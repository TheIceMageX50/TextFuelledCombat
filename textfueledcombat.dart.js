// Generated by dart2js, the Dart to JavaScript compiler.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
(function($) {
function dart() {
  this.x = 0;
  delete this.x;
}
var A = new dart;
var B = new dart;
var C = new dart;
var D = new dart;
var E = new dart;
var F = new dart;
var G = new dart;
var H = new dart;
var J = new dart;
var K = new dart;
var L = new dart;
var M = new dart;
var N = new dart;
var O = new dart;
var P = new dart;
var Q = new dart;
var R = new dart;
var S = new dart;
var T = new dart;
var U = new dart;
var V = new dart;
var W = new dart;
var X = new dart;
var Y = new dart;
var Z = new dart;
function Isolate() {}
init();

$ = Isolate.$isolateProperties;
var $$ = Object.create(null);

// Native classes
init.mangledNames = {get$Arcade: "Arcade", get$_PIXI$__tilePattern: "_PIXI$__tilePattern", get$_PIXI$_height: "_PIXI$_height", get$_PIXI$_text: "_PIXI$_text", get$_PIXI$_width: "_PIXI$_width", get$_Phaser$_add: "_Phaser$_add", get$_Phaser$_bounds: "_Phaser$_bounds", get$_Phaser$_buffer: "_Phaser$_buffer", get$_Phaser$_currentBounds: "_Phaser$_currentBounds", get$_Phaser$_dirty: "_Phaser$_dirty", get$_Phaser$_duration: "_Phaser$_duration", get$_Phaser$_keys: "_Phaser$_keys", get$_Phaser$_parent: "_Phaser$_parent", get$_Phaser$_position: "_Phaser$_position", get$_UID: "_UID", get$__hit: "__hit", get$__isDown: "__isDown", get$__isOver: "__isOver", get$__mouseIsDown: "__mouseIsDown", get$__stage: "__stage", get$__tilePattern: "__tilePattern", get$__touchData: "__touchData", get$_a: "_a", get$_align: "_align", get$_anchor: "_anchor", get$_anims: "_anims", get$_args: "_args", get$_attachmentTime: "_attachmentTime", get$_backgroundColor: "_backgroundColor", get$_binary: "_binary", get$_bindings: "_bindings", get$_bitmapDatas: "_bitmapDatas", get$_bitmapFont: "_bitmapFont", get$_bounds: "_bounds", get$_cache: "_cache", get$_cacheAsBitmap: "_cacheAsBitmap", get$_cacheIsDirty: "_cacheIsDirty", get$_cacheMap: "_cacheMap", get$_cachedSprite: "_cachedSprite", get$_canvas: "_canvas", get$_canvases: "_canvases", get$_capture: "_capture", get$_chainedTweens: "_chainedTweens", get$_charCount: "_charCount", get$_check: "_check", get$_checkOrientation: "_checkOrientation", get$_checkResize: "_checkResize", get$_clearCache: "_clearCache", get$_clearWorld: "_clearWorld", get$_codeMuted: "_codeMuted", get$_codePaused: "_codePaused", get$_colorBuffer: "_colorBuffer", get$_column: "_column", get$_context: "_context", get$_counter: "_counter", get$_cr: "_cr", get$_created: "_created", get$_crop: "_crop", get$_currentBounds: "_currentBounds", get$_currentFrame: "_currentFrame", get$_currentGraphics: "_currentGraphics", get$_currentId: "_currentId", get$_currentPath: "_currentPath", get$_definedSize: "_definedSize", get$_delayTime: "_delayTime", get$_diameter: "_diameter", get$_diff: "_diff", get$_dirty: "_dirty", get$_dragPhase: "_dragPhase", get$_dragPoint: "_dragPoint", get$_draggedPointerID: "_draggedPointerID", get$_dx: "_dx", get$_dy: "_dy", get$_easingFunction: "_easingFunction", get$_edge: "_edge", get$_explode: "_explode", get$_fileIndex: "_fileIndex", get$_fileList: "_fileList", get$_filterArea: "_filterArea", get$_filterBlock: "_filterBlock", get$_filters: "_filters", get$_font: "_font", get$_fontSize: "_fontSize", get$_fontWeight: "_fontWeight", get$_frame: "_frame", get$_frameData: "_frameData", get$_frameDiff: "_frameDiff", get$_frameIndex: "_frameIndex", get$_frameName: "_frameName", get$_frameNames: "_frameNames", get$_frameSkip: "_frameSkip", get$_frames: "_frames", get$_fullScreenChange: "_fullScreenChange", get$_glFilterTexture: "_glFilterTexture", get$_glTextures: "_glTextures", get$_graphicsData: "_graphicsData", get$_hasLoaded: "_hasLoaded", get$_hasUpdateAnimation: "_hasUpdateAnimation", get$_height: "_height", get$_hiddenVar: "_hiddenVar", get$_highestInputPriorityID: "_highestInputPriorityID", get$_highestRenderObject: "_highestRenderObject", get$_highestRenderOrderID: "_highestRenderOrderID", get$_history: "_history", get$_holdSent: "_holdSent", get$_i: "_i", get$_images: "_images", get$_indexBuffer: "_indexBuffer", get$_interactive: "_interactive", get$_interactiveEventsAdded: "_interactiveEventsAdded", get$_interpolationFunction: "_interpolationFunction", get$_isMask: "_isMask", get$_isOnce: "_isOnce", get$_isPaused: "_isPaused", get$_isSetTimeOut: "_isSetTimeOut", get$_iterations: "_iterations", get$_json: "_json", get$_justResumed: "_justResumed", get$_k: "_k", get$_lastChild: "_lastChild", get$_len: "_len", get$_lineSpacing: "_lineSpacing", get$_listener: "_listener", get$_localPoint: "_localPoint", get$_manager: "_manager", get$_marked: "_marked", get$_mask: "_mask", get$_maxParticleScale: "_maxParticleScale", get$_mc: "_mc", get$_minParticleScale: "_minParticleScale", get$_muteVolume: "_muteVolume", get$_muted: "_muted", get$_newTick: "_newTick", get$_nextDrop: "_nextDrop", get$_nextOffsetCheck: "_nextOffsetCheck", get$_nextParentCheck: "_nextParentCheck", get$_now: "_now", get$_object: "_object", get$_oldPosition: "_oldPosition", get$_onBoot: "_onBoot", get$_onChange: "_onChange", get$_onDecodedEventDispatched: "_onDecodedEventDispatched", get$_onDownFrameID: "_onDownFrameID", get$_onDownFrameName: "_onDownFrameName", get$_onKeyDown: "_onKeyDown", get$_onKeyPress: "_onKeyPress", get$_onKeyUp: "_onKeyUp", get$_onLoop: "_onLoop", get$_onMouseDown: "_onMouseDown", get$_onMouseMove: "_onMouseMove", get$_onMouseOut: "_onMouseOut", get$_onMouseOver: "_onMouseOver", get$_onMouseUp: "_onMouseUp", get$_onMouseUpGlobal: "_onMouseUpGlobal", get$_onMouseWheel: "_onMouseWheel", get$_onOutFrameID: "_onOutFrameID", get$_onOutFrameName: "_onOutFrameName", get$_onOverFrameID: "_onOverFrameID", get$_onOverFrameName: "_onOverFrameName", get$_onStartCallbackFired: "_onStartCallbackFired", get$_onUpFrameID: "_onUpFrameID", get$_onUpFrameName: "_onUpFrameName", get$_onUpdateCallback: "_onUpdateCallback", get$_onUpdateCallbackContext: "_onUpdateCallbackContext", get$_outOfBoundsFired: "_outOfBoundsFired", get$_outputFrames: "_outputFrames", get$_packIndex: "_packIndex", get$_packList: "_packList", get$_parent: "_parent", get$_parentBounds: "_parentBounds", get$_pauseStartTime: "_pauseStartTime", get$_pauseStarted: "_pauseStarted", get$_pauseTotal: "_pauseTotal", get$_paused: "_paused", get$_pausedTime: "_pausedTime", get$_pendingState: "_pendingState", get$_pendingStateKey: "_pendingStateKey", get$_physics: "_physics", get$_playing: "_playing", get$_pointerData: "_pointerData", get$_pointerLockChange: "_pointerLockChange", get$_points: "_points", get$_pollCounter: "_pollCounter", get$_pool: "_pool", get$_powerOf2: "_powerOf2", get$_prevParams: "_prevParams", get$_priority: "_priority", get$_progressChunk: "_progressChunk", get$_quantity: "_quantity", get$_radius: "_radius", get$_ready: "_ready", get$_repeat: "_repeat", get$_requiresUpdate: "_requiresUpdate", get$_reset: "_reset", get$_results: "_results", get$_reversed: "_reversed", get$_rotationCache: "_rotationCache", get$_s: "_s", get$_scaleMode: "_scaleMode", get$_scroll: "_scroll", get$_setHandCursor: "_setHandCursor", get$_shouldPropagate: "_shouldPropagate", get$_signal: "_signal", get$_sortProperty: "_sortProperty", get$_sound: "_sound", get$_sounds: "_sounds", get$_sr: "_sr", get$_stage: "_stage", get$_startHeight: "_startHeight", get$_startTime: "_startTime", get$_started: "_started", get$_stateReset: "_stateReset", get$_style: "_style", get$_targetPosition: "_targetPosition", get$_temp: "_temp", get$_tempA: "_tempA", get$_tempB: "_tempB", get$_tempG: "_tempG", get$_tempLoop: "_tempLoop", get$_tempMarker: "_tempMarker", get$_tempPoint: "_tempPoint", get$_tempPosition: "_tempPosition", get$_tempR: "_tempR", get$_tempVolume: "_tempVolume", get$_text: "_text", get$_textHeight: "_textHeight", get$_textWidth: "_textWidth", get$_textures: "_textures", get$_tilemaps: "_tilemaps", get$_timeLastFrame: "_timeLastFrame", get$_timeLastSecond: "_timeLastSecond", get$_timeNextFrame: "_timeNextFrame", get$_timeOutID: "_timeOutID", get$_timer: "_timer", get$_timers: "_timers", get$_tint: "_tint", get$_tweens: "_tweens", get$_unlockSource: "_unlockSource", get$_updateAnimation: "_updateAnimation", get$_updateAnimationCallback: "_updateAnimationCallback", get$_urlMap: "_urlMap", get$_urlResolver: "_urlResolver", get$_urlTemp: "_urlTemp", get$_uvBuffer: "_uvBuffer", get$_uvs: "_uvs", get$_valuesEnd: "_valuesEnd", get$_valuesStart: "_valuesStart", get$_valuesStartRepeat: "_valuesStartRepeat", get$_vertexBuffer: "_vertexBuffer", get$_volume: "_volume", get$_wasEnabled: "_wasEnabled", get$_webGL: "_webGL", get$_width: "_width", get$_worldAlpha: "_worldAlpha", get$_worldTransform: "_worldTransform", get$_x: "_x", get$_xhr: "_xhr", get$_xml: "_xml", get$_y: "_y", get$_yoyo: "_yoyo", get$a: "a", get$aPositionCoord: "aPositionCoord", get$aRotation: "aRotation", get$aScale: "aScale", get$aTextureCoord: "aTextureCoord", get$aVertexPosition: "aVertexPosition", get$acceleration: "acceleration", get$active: "active", get$activePointer: "activePointer", get$add: "add", get$addToStage: "addToStage", get$advancedTiming: "advancedTiming", get$ajaxRequest: "ajaxRequest", get$align: "align", get$alive: "alive", get$allowHorizontalDrag: "allowHorizontalDrag", get$allowMultiple: "allowMultiple", get$allowVerticalDrag: "allowVerticalDrag", get$alpha: "alpha", get$alphaData: "alphaData", get$altKey: "altKey", get$anchor: "anchor", get$android: "android", get$angle: "angle", get$angularDrag: "angularDrag", get$angularVelocity: "angularVelocity", get$animation: "animation", get$animationSpeed: "animationSpeed", get$animationToMixTime: "animationToMixTime", get$animations: "animations", get$antialias: "antialias", get$any: "any", get$arcade: "arcade", get$area: "area", get$args: "args", get$arora: "arora", get$array: "array", get$aspectRatio: "aspectRatio", get$assetURLs: "assetURLs", get$atLimit: "atLimit", get$atlas: "atlas", get$attachment: "attachment", get$attachmentLoader: "attachmentLoader", get$attachmentName: "attachmentName", get$attachmentNames: "attachmentNames", get$attachments: "attachments", get$attribState: "attribState", get$attributes: "attributes", get$audioData: "audioData", get$autoAlpha: "autoAlpha", get$autoCull: "autoCull", get$autoDestroy: "autoDestroy", get$autoScale: "autoScale", get$autoUpperCase: "autoUpperCase", get$autoplay: "autoplay", get$autoplayKey: "autoplayKey", get$b: "b", get$backgroundColor: "backgroundColor", get$backgroundColorSplit: "backgroundColorSplit", get$backgroundColorString: "backgroundColorString", get$baseTexture: "baseTexture", get$baseURL: "baseURL", get$baseUrl: "baseUrl", get$blendMode: "blendMode", get$blendModeManager: "blendModeManager", get$blendModes: "blendModes", get$blocked: "blocked", get$blue: "blue", get$blurXFilter: "blurXFilter", get$blurYFilter: "blurYFilter", get$bodies: "bodies", get$body: "body", get$bone: "bone", get$boneData: "boneData", get$boneIndex: "boneIndex", get$bones: "bones", get$bottom: "bottom", get$bottomLeft: "bottomLeft", get$bottomMiddle: "bottomMiddle", get$bottomRight: "bottomRight", get$bounce: "bounce", get$bounds: "bounds", get$boundsCustom: "boundsCustom", get$boundsFluid: "boundsFluid", get$boundsFull: "boundsFull", get$boundsNone: "boundsNone", get$boundsPadding: "boundsPadding", get$boundsRect: "boundsRect", get$boundsSprite: "boundsSprite", get$box2d: "box2d", get$bringToTop: "bringToTop", get$buffer: "buffer", get$button: "button", get$buttonMode: "buttonMode", get$c: "c", get$cache: "cache", get$cachedTint: "cachedTint", get$callback: "callback", get$callbackContext: "callbackContext", get$callbacks: "callbacks", get$camerOffset: "camerOffset", get$camera: "camera", get$cameraOffset: "cameraOffset", get$cancelFullscreen: "cancelFullscreen", get$canvas: "canvas", get$canvasBuffer: "canvasBuffer", get$capture: "capture", get$center: "center", get$centerX: "centerX", get$centerY: "centerY", get$ch: "ch", get$channels: "channels", get$charCode: "charCode", get$characterHeight: "characterHeight", get$characterPerRow: "characterPerRow", get$characterSpacingX: "characterSpacingX", get$characterSpacingY: "characterSpacingY", get$characterWidth: "characterWidth", get$chars: "chars", get$checkOffsetInterval: "checkOffsetInterval", get$checkWorldBounds: "checkWorldBounds", get$checked: "checked", get$children: "children", get$chipmunk: "chipmunk", get$chrome: "chrome", get$chromeOS: "chromeOS", get$circle: "circle", get$classType: "classType", get$clearBeforeRender: "clearBeforeRender", get$clearDirty: "clearDirty", get$click: "click", get$clientX: "clientX", get$clientY: "clientY", get$cls: "cls", get$cocoonJS: "cocoonJS", get$collideDown: "collideDown", get$collideIndexes: "collideIndexes", get$collideLeft: "collideLeft", get$collideRight: "collideRight", get$collideUp: "collideUp", get$collideWorldBounds: "collideWorldBounds", get$collides: "collides", get$collision: "collision", get$collisionCallback: "collisionCallback", get$color: "color", get$colorArray: "colorArray", get$colorAttribute: "colorAttribute", get$colorBuffer: "colorBuffer", get$colors: "colors", get$columnWidth: "columnWidth", get$columns: "columns", get$complexPrimativeShader: "complexPrimativeShader", get$config: "config", get$connectToMaster: "connectToMaster", get$consumePointerEvent: "consumePointerEvent", get$content: "content", get$context: "context", get$contextLost: "contextLost", get$cos: "cos", get$count: "count", get$creator: "creator", get$crop: "crop", get$cropRect: "cropRect", get$crossOrigin: "crossOrigin", get$crossorigin: "crossorigin", get$crosswalk: "crosswalk", get$css3D: "css3D", get$ctrlKey: "ctrlKey", get$ctx: "ctx", get$current: "current", get$currentAlpha: "currentAlpha", get$currentAnim: "currentAnim", get$currentBaseTexture: "currentBaseTexture", get$currentBatchSize: "currentBatchSize", get$currentBlendMode: "currentBlendMode", get$currentColor: "currentColor", get$currentCursorStyle: "currentCursorStyle", get$currentFrame: "currentFrame", get$currentImageId: "currentImageId", get$currentLayer: "currentLayer", get$currentLoop: "currentLoop", get$currentMarker: "currentMarker", get$currentPointers: "currentPointers", get$currentRenderOrderID: "currentRenderOrderID", get$currentShader: "currentShader", get$currentSprite: "currentSprite", get$currentSpriteName: "currentSpriteName", get$currentTime: "currentTime", get$currentX: "currentX", get$currentY: "currentY", get$cursor: "cursor", get$curves: "curves", get$customHeight: "customHeight", get$customOffsetX: "customOffsetX", get$customOffsetY: "customOffsetY", get$customSpacingX: "customSpacingX", get$customSpacingY: "customSpacingY", get$customWidth: "customWidth", get$cw: "cw", get$d: "d", get$data: "data", get$deadzone: "deadzone", get$debug: "debug", get$debugAlpha: "debugAlpha", get$debugCallbackColor: "debugCallbackColor", get$debugColor: "debugColor", get$debugFill: "debugFill", get$debugFillColor: "debugFillColor", get$debugMap: "debugMap", get$defaultCursor: "defaultCursor", get$defaultMix: "defaultMix", get$defaultShader: "defaultShader", get$defaultSkin: "defaultSkin", get$delay: "delay", get$deltaCap: "deltaCap", get$desktop: "desktop", get$device: "device", get$dh: "dh", get$dimensions: "dimensions", get$dirty: "dirty", get$disableTextureUpload: "disableTextureUpload", get$disableVisibilityChange: "disableVisibilityChange", get$disabled: "disabled", get$displayObject: "displayObject", get$distance: "distance", get$doubleTapRate: "doubleTapRate", get$down: "down", get$downDuration: "downDuration", get$drag: "drag", get$dragFromCenter: "dragFromCenter", get$dragOffset: "dragOffset", get$draggable: "draggable", get$drawCoords: "drawCoords", get$drawCount: "drawCount", get$drawOrder: "drawOrder", get$drawing: "drawing", get$dropShadow: "dropShadow", get$dropShadowAngle: "dropShadowAngle", get$dropShadowColor: "dropShadowColor", get$dropShadowDistance: "dropShadowDistance", get$duration: "duration", get$durationMS: "durationMS", get$dw: "dw", get$dx: "dx", get$dy: "dy", get$ejecta: "ejecta", get$elapsed: "elapsed", get$emitX: "emitX", get$emitY: "emitY", get$emitters: "emitters", get$enableBody: "enableBody", get$enableBodyDebug: "enableBodyDebug", get$enabled: "enabled", get$end: "end", get$enterFullScreen: "enterFullScreen", get$enterIncorrectOrientation: "enterIncorrectOrientation", get$enterLandscape: "enterLandscape", get$enterPortrait: "enterPortrait", get$epiphany: "epiphany", get$event: "event", get$events: "events", get$exists: "exists", get$expired: "expired", get$externalNode: "externalNode", get$faceBottom: "faceBottom", get$faceLeft: "faceLeft", get$faceRight: "faceRight", get$faceTop: "faceTop", get$fastShader: "fastShader", get$fastSpriteBatch: "fastSpriteBatch", get$file: "file", get$fileSystem: "fileSystem", get$fill: "fill", get$fillAlpha: "fillAlpha", get$fillColor: "fillColor", get$filling: "filling", get$filterArea: "filterArea", get$filterManager: "filterManager", get$filterPasses: "filterPasses", get$filterStack: "filterStack", get$firefox: "firefox", get$firstgid: "firstgid", get$fixedToCamera: "fixedToCamera", get$fixedWidth: "fixedWidth", get$flipX: "flipX", get$flipY: "flipY", get$font: "font", get$fontName: "fontName", get$fontSet: "fontSet", get$fontSize: "fontSize", get$forceLandscape: "forceLandscape", get$forceOut: "forceOut", get$forcePortrait: "forcePortrait", get$forceSetTimeOut: "forceSetTimeOut", get$format: "format", get$fps: "fps", get$fpsMax: "fpsMax", get$fpsMin: "fpsMin", get$fragmentSrc: "fragmentSrc", get$frame: "frame", get$frameBuffer: "frameBuffer", get$frames: "frames", get$freezeFrames: "freezeFrames", get$frequency: "frequency", get$fullScreenScaleMode: "fullScreenScaleMode", get$fullScreenTarget: "fullScreenTarget", get$fullscreen: "fullscreen", get$fullscreenKeyboard: "fullscreenKeyboard", get$g: "g", get$ga: "ga", get$gainNode: "gainNode", get$game: "game", get$getUserMedia: "getUserMedia", get$gl: "gl", get$glIndicies: "glIndicies", get$glPoints: "glPoints", get$global: "global", get$grabData: "grabData", get$gravity: "gravity", get$green: "green", get$grid: "grid", get$h: "h", get$halfHeight: "halfHeight", get$halfWidth: "halfWidth", get$hasLoaded: "hasLoaded", get$hasPostRender: "hasPostRender", get$hasPostUpdate: "hasPostUpdate", get$hasPreUpdate: "hasPreUpdate", get$hasRender: "hasRender", get$hasUpdate: "hasUpdate", get$health: "health", get$height: "height", get$heightInPixels: "heightInPixels", get$hitArea: "hitArea", get$hitCanvas: "hitCanvas", get$hitContext: "hitContext", get$holdRate: "holdRate", get$iOS: "iOS", get$iPad: "iPad", get$iPhone: "iPhone", get$iPhone4: "iPhone4", get$id: "id", get$identifier: "identifier", get$ie: "ie", get$ieVersion: "ieVersion", get$ignoreDestroy: "ignoreDestroy", get$image: "image", get$imageData: "imageData", get$imageUrl: "imageUrl", get$images: "images", get$immovable: "immovable", get$incorrectOrientation: "incorrectOrientation", get$index: "index", get$indexBuffer: "indexBuffer", get$indexes: "indexes", get$indices: "indices", get$input: "input", get$interactionDOMElement: "interactionDOMElement", get$interactionManager: "interactionManager", get$interactiveChildren: "interactiveChildren", get$interactiveItems: "interactiveItems", get$isBooted: "isBooted", get$isCocoonJS: "isCocoonJS", get$isDown: "isDown", get$isDragged: "isDragged", get$isFinished: "isFinished", get$isFullScreen: "isFullScreen", get$isLandscape: "isLandscape", get$isLoaded: "isLoaded", get$isLoading: "isLoading", get$isMouse: "isMouse", get$isOut: "isOut", get$isOver: "isOver", get$isPlaying: "isPlaying", get$isPortrait: "isPortrait", get$isRunning: "isRunning", get$isTiling: "isTiling", get$isUp: "isUp", get$json: "json", get$justPressedRate: "justPressedRate", get$justReleasedRate: "justReleasedRate", get$kernings: "kernings", get$key: "key", get$keyCode: "keyCode", get$keyboard: "keyboard", get$killOnComplete: "killOnComplete", get$l: "l", get$last: "last", get$lastIndex: "lastIndex", get$lastIndexCount: "lastIndexCount", get$lastTime: "lastTime", get$layer: "layer", get$layers: "layers", get$leaveFullScreen: "leaveFullScreen", get$leaveIncorrectOrientation: "leaveIncorrectOrientation", get$left: "left", get$length: "length", get$level: "level", get$lifespan: "lifespan", get$line: "line", get$lineAlpha: "lineAlpha", get$lineColor: "lineColor", get$lineHeight: "lineHeight", get$lineWidth: "lineWidth", get$lines: "lines", get$linux: "linux", get$listeners: "listeners", get$littleEndian: "littleEndian", get$load: "load", get$loadCount: "loadCount", get$loaded: "loaded", get$loader: "loader", get$localStorage: "localStorage", get$locked: "locked", get$loop: "loop", get$loopCount: "loopCount", get$m00: "m00", get$m01: "m01", get$m10: "m10", get$m11: "m11", get$m4a: "m4a", get$macOS: "macOS", get$magFilter: "magFilter", get$make: "make", get$manager: "manager", get$map: "map", get$margin: "margin", get$markers: "markers", get$maskManager: "maskManager", get$maskPosition: "maskPosition", get$maskStack: "maskStack", get$masterGain: "masterGain", get$masterGainNode: "masterGainNode", get$math: "math", get$matrix: "matrix", get$maxAttibs: "maxAttibs", get$maxHeight: "maxHeight", get$maxIterations: "maxIterations", get$maxLevels: "maxLevels", get$maxObjects: "maxObjects", get$maxParticleAlpha: "maxParticleAlpha", get$maxParticleScale: "maxParticleScale", get$maxParticleSpeed: "maxParticleSpeed", get$maxParticles: "maxParticles", get$maxPointers: "maxPointers", get$maxRotation: "maxRotation", get$maxSize: "maxSize", get$maxVelocity: "maxVelocity", get$maxWidth: "maxWidth", get$maxX: "maxX", get$maxY: "maxY", get$memorize: "memorize", get$midori: "midori", get$minFilter: "minFilter", get$minHeight: "minHeight", get$minParticleAlpha: "minParticleAlpha", get$minParticleScale: "minParticleScale", get$minParticleSpeed: "minParticleSpeed", get$minPriorityID: "minPriorityID", get$minRotation: "minRotation", get$minWidth: "minWidth", get$mixDuration: "mixDuration", get$mixTime: "mixTime", get$mobileSafari: "mobileSafari", get$mode: "mode", get$mouse: "mouse", get$mouseDownCallback: "mouseDownCallback", get$mouseMoveCallback: "mouseMoveCallback", get$mouseOut: "mouseOut", get$mouseOutCallback: "mouseOutCallback", get$mouseOverCallback: "mouseOverCallback", get$mousePointer: "mousePointer", get$mouseUpCallback: "mouseUpCallback", get$mouseWheelCallback: "mouseWheelCallback", get$mousedown: "mousedown", get$mousemove: "mousemove", get$mouseout: "mouseout", get$mouseover: "mouseover", get$mouseoverEnabled: "mouseoverEnabled", get$mouseup: "mouseup", get$mouseupoutside: "mouseupoutside", get$moveCallback: "moveCallback", get$moveCallbacks: "moveCallbacks", get$movementX: "movementX", get$movementY: "movementY", get$moves: "moves", get$mp3: "mp3", get$msMax: "msMax", get$msMin: "msMin", get$msSinceLastClick: "msSinceLastClick", get$mspointer: "mspointer", get$multiInputOverride: "multiInputOverride", get$multiLine: "multiLine", get$multiplier: "multiplier", get$name: "name", get$needToRecalculate: "needToRecalculate", get$needsUpdate: "needsUpdate", get$net: "net", get$nextTick: "nextTick", get$ninja: "ninja", get$noAudio: "noAudio", get$noFrame: "noFrame", get$nodes: "nodes", get$none: "none", get$now: "now", get$numIndices: "numIndices", get$numVerts: "numVerts", get$objects: "objects", get$offset: "offset", get$offsetVector: "offsetVector", get$offsetX: "offsetX", get$offsetY: "offsetY", get$ogg: "ogg", get$on: "on", get$onAddedToGroup: "onAddedToGroup", get$onAnimationComplete: "onAnimationComplete", get$onAnimationLoop: "onAnimationLoop", get$onAnimationStart: "onAnimationStart", get$onBlur: "onBlur", get$onComplete: "onComplete", get$onCreateCallback: "onCreateCallback", get$onDecoded: "onDecoded", get$onDestroy: "onDestroy", get$onDown: "onDown", get$onDownCallback: "onDownCallback", get$onDownSound: "onDownSound", get$onDownSoundMarker: "onDownSoundMarker", get$onDragStart: "onDragStart", get$onDragStop: "onDragStop", get$onEnterBounds: "onEnterBounds", get$onFadeComplete: "onFadeComplete", get$onFileComplete: "onFileComplete", get$onFileError: "onFileError", get$onFileStart: "onFileStart", get$onFocus: "onFocus", get$onHold: "onHold", get$onHoldCallback: "onHoldCallback", get$onInitCallback: "onInitCallback", get$onInputDown: "onInputDown", get$onInputOut: "onInputOut", get$onInputOver: "onInputOver", get$onInputUp: "onInputUp", get$onKilled: "onKilled", get$onLoadComplete: "onLoadComplete", get$onLoadRenderCallback: "onLoadRenderCallback", get$onLoadStart: "onLoadStart", get$onLoadUpdateCallback: "onLoadUpdateCallback", get$onLoaded: "onLoaded", get$onLoop: "onLoop", get$onMarkerComplete: "onMarkerComplete", get$onMute: "onMute", get$onOutOfBounds: "onOutOfBounds", get$onOutSound: "onOutSound", get$onOutSoundMarker: "onOutSoundMarker", get$onOverMouseOnly: "onOverMouseOnly", get$onOverSound: "onOverSound", get$onOverSoundMarker: "onOverSoundMarker", get$onPackComplete: "onPackComplete", get$onPause: "onPause", get$onPauseUpdateCallback: "onPauseUpdateCallback", get$onPausedCallback: "onPausedCallback", get$onPlay: "onPlay", get$onPreRenderCallback: "onPreRenderCallback", get$onPreloadCallback: "onPreloadCallback", get$onPressCallback: "onPressCallback", get$onProgress: "onProgress", get$onRemovedFromGroup: "onRemovedFromGroup", get$onRenderCallback: "onRenderCallback", get$onResize: "onResize", get$onResizeCallback: "onResizeCallback", get$onResume: "onResume", get$onResumedCallback: "onResumedCallback", get$onRevived: "onRevived", get$onShutDownCallback: "onShutDownCallback", get$onSoundDecode: "onSoundDecode", get$onSoundUnlock: "onSoundUnlock", get$onStart: "onStart", get$onStop: "onStop", get$onTap: "onTap", get$onTouchCancelListener: "onTouchCancelListener", get$onTouchEndListener: "onTouchEndListener", get$onTouchEnterListener: "onTouchEnterListener", get$onTouchLeaveListener: "onTouchLeaveListener", get$onTouchMoveListener: "onTouchMoveListener", get$onTouchStartListener: "onTouchStartListener", get$onUp: "onUp", get$onUpCallback: "onUpCallback", get$onUpSound: "onUpSound", get$onUpSoundMarker: "onUpSoundMarker", get$onUpdate: "onUpdate", get$onUpdateCallback: "onUpdateCallback", get$opera: "opera", get$options: "options", get$opus: "opus", get$orientation: "orientation", get$originalEvent: "originalEvent", get$originalHeight: "originalHeight", get$originalWidth: "originalWidth", get$outOfBoundsKill: "outOfBoundsKill", get$override: "override", get$p2: "p2", get$padding: "padding", get$pads: "pads", get$page: "page", get$pageAlignHorizontally: "pageAlignHorizontally", get$pageAlignVertically: "pageAlignVertically", get$pageX: "pageX", get$pageY: "pageY", get$pages: "pages", get$params: "params", get$parent: "parent", get$parentIsWindow: "parentIsWindow", get$parentNode: "parentNode", get$parentScaleFactor: "parentScaleFactor", get$particleAnchor: "particleAnchor", get$particleBringToTop: "particleBringToTop", get$particleClass: "particleClass", get$particleDrag: "particleDrag", get$particleSendToBack: "particleSendToBack", get$particles: "particles", get$passes: "passes", get$pauseDuration: "pauseDuration", get$paused: "paused", get$pausedPosition: "pausedPosition", get$pausedTime: "pausedTime", get$pendingDelete: "pendingDelete", get$pendingPlayback: "pendingPlayback", get$pendingStep: "pendingStep", get$persist: "persist", get$phase: "phase", get$physics: "physics", get$physicsBodyType: "physicsBodyType", get$physicsConfig: "physicsConfig", get$physicsElapsed: "physicsElapsed", get$pivot: "pivot", get$pixelPerfectAlpha: "pixelPerfectAlpha", get$pixelPerfectClick: "pixelPerfectClick", get$pixelPerfectOver: "pixelPerfectOver", get$pixelRatio: "pixelRatio", get$pixels: "pixels", get$plugins: "plugins", get$pointerId: "pointerId", get$pointerLock: "pointerLock", get$pointers: "pointers", get$points: "points", get$pollRate: "pollRate", get$pool: "pool", get$position: "position", get$positionCustom: "positionCustom", get$positionDown: "positionDown", get$positionFluid: "positionFluid", get$positionFull: "positionFull", get$positionNone: "positionNone", get$positionUp: "positionUp", get$preloadSprite: "preloadSprite", get$premultipliedAlpha: "premultipliedAlpha", get$preserveDrawingBuffer: "preserveDrawingBuffer", get$pressEvent: "pressEvent", get$prevX: "prevX", get$prevY: "prevY", get$preventDefault: "preventDefault", get$preventingRecalculate: "preventingRecalculate", get$previous: "previous", get$previousLoop: "previousLoop", get$previousTapTime: "previousTapTime", get$previousTime: "previousTime", get$primitiveShader: "primitiveShader", get$priorityID: "priorityID", get$program: "program", get$progress: "progress", get$progressFloat: "progressFloat", get$projection: "projection", get$projectionVector: "projectionVector", get$properties: "properties", get$queue: "queue", get$quirksMode: "quirksMode", get$r: "r", get$radius: "radius", get$raf: "raf", get$ratioH: "ratioH", get$ratioV: "ratioV", get$rawMovementX: "rawMovementX", get$rawMovementY: "rawMovementY", get$rayStepRate: "rayStepRate", get$recordLimit: "recordLimit", get$recordPointerHistory: "recordPointerHistory", get$recordRate: "recordRate", get$red: "red", get$refresh: "refresh", get$refreshTexture: "refreshTexture", get$regionHeight: "regionHeight", get$regionOffsetX: "regionOffsetX", get$regionOffsetY: "regionOffsetY", get$regionOriginalHeight: "regionOriginalHeight", get$regionOriginalWidth: "regionOriginalWidth", get$regionWidth: "regionWidth", get$regions: "regions", get$render: "render", get$renderBuffer: "renderBuffer", get$renderOrderID: "renderOrderID", get$renderSession: "renderSession", get$renderShadow: "renderShadow", get$renderType: "renderType", get$renderable: "renderable", get$renderer: "renderer", get$rendererObject: "rendererObject", get$repeatCount: "repeatCount", get$repeats: "repeats", get$requestFullscreen: "requestFullscreen", get$resetLocked: "resetLocked", get$reverse: "reverse", get$rgba: "rgba", get$right: "right", get$rnd: "rnd", get$rotate: "rotate", get$rotation: "rotation", get$rotationDirection: "rotationDirection", get$roundPixels: "roundPixels", get$roundPx: "roundPx", get$rows: "rows", get$running: "running", get$s: "s", get$s0: "s0", get$s1: "s1", get$s2: "s2", get$safari: "safari", get$safeRemove: "safeRemove", get$scale: "scale", get$scaleCustom: "scaleCustom", get$scaleData: "scaleData", get$scaleFactor: "scaleFactor", get$scaleFactorInversed: "scaleFactorInversed", get$scaleFluid: "scaleFluid", get$scaleFluidInversed: "scaleFluidInversed", get$scaleFull: "scaleFull", get$scaleLayer: "scaleLayer", get$scaleMode: "scaleMode", get$scaleModel: "scaleModel", get$scaleNone: "scaleNone", get$scaleX: "scaleX", get$scaleY: "scaleY", get$scanned: "scanned", get$scope: "scope", get$screenView: "screenView", get$screenX: "screenX", get$screenY: "screenY", get$scrollFactorX: "scrollFactorX", get$scrollFactorY: "scrollFactorY", get$shader: "shader", get$shaderManager: "shaderManager", get$shaderMap: "shaderMap", get$shaders: "shaders", get$shadowBlur: "shadowBlur", get$shadowColor: "shadowColor", get$shadowOffsetX: "shadowOffsetX", get$shadowOffsetY: "shadowOffsetY", get$shiftKey: "shiftKey", get$silk: "silk", get$sin: "sin", get$size: "size", get$skeleton: "skeleton", get$skeletonData: "skeletonData", get$skin: "skin", get$skins: "skins", get$slotContainers: "slotContainers", get$slotIndex: "slotIndex", get$slots: "slots", get$smoothProperty: "smoothProperty", get$snapOffset: "snapOffset", get$snapOffsetX: "snapOffsetX", get$snapOffsetY: "snapOffsetY", get$snapOnDrag: "snapOnDrag", get$snapOnRelease: "snapOnRelease", get$snapX: "snapX", get$snapY: "snapY", get$sound: "sound", get$sounds: "sounds", get$source: "source", get$sourceAspectRatio: "sourceAspectRatio", get$sourceHeight: "sourceHeight", get$sourceSizeH: "sourceSizeH", get$sourceSizeW: "sourceSizeW", get$sourceWidth: "sourceWidth", get$speed: "speed", get$splits: "splits", get$sprite: "sprite", get$spriteBatch: "spriteBatch", get$spriteSourceSizeH: "spriteSourceSizeH", get$spriteSourceSizeW: "spriteSourceSizeW", get$spriteSourceSizeX: "spriteSourceSizeX", get$spriteSourceSizeY: "spriteSourceSizeY", get$sprites: "sprites", get$stage: "stage", get$stamp: "stamp", get$start: "start", get$startTime: "startTime", get$startX: "startX", get$startY: "startY", get$state: "state", get$stateData: "stateData", get$states: "states", get$stencilManager: "stencilManager", get$stencilStack: "stencilStack", get$stepCount: "stepCount", get$stepping: "stepping", get$stop: "stop", get$stopOnGameOut: "stopOnGameOut", get$stopTime: "stopTime", get$stripShader: "stripShader", get$stroke: "stroke", get$strokeThickness: "strokeThickness", get$style: "style", get$subHeight: "subHeight", get$subWidth: "subWidth", get$support32bit: "support32bit", get$tap: "tap", get$tapRate: "tapRate", get$target: "target", get$targetObject: "targetObject", get$tempAttribState: "tempAttribState", get$tempPoint: "tempPoint", get$text: "text", get$texture: "texture", get$textureBuffer: "textureBuffer", get$textureCount: "textureCount", get$textureFrame: "textureFrame", get$textureLoader: "textureLoader", get$texturePool: "texturePool", get$textureThing: "textureThing", get$textures: "textures", get$th: "th", get$tick: "tick", get$tileColor: "tileColor", get$tileHeight: "tileHeight", get$tileMargin: "tileMargin", get$tilePadding: "tilePadding", get$tilePosition: "tilePosition", get$tileProperties: "tileProperties", get$tileScale: "tileScale", get$tileScaleOffset: "tileScaleOffset", get$tileSpacing: "tileSpacing", get$tileWidth: "tileWidth", get$tiles: "tiles", get$tilesets: "tilesets", get$tilingTexture: "tilingTexture", get$time: "time", get$timeCap: "timeCap", get$timeDown: "timeDown", get$timeOut: "timeOut", get$timeOver: "timeOver", get$timeToCall: "timeToCall", get$timeUp: "timeUp", get$timelines: "timelines", get$timer: "timer", get$tint: "tint", get$tintCache: "tintCache", get$tintColor: "tintColor", get$tintedTexture: "tintedTexture", get$tl: "tl", get$topLeft: "topLeft", get$topMiddle: "topMiddle", get$topRight: "topRight", get$total: "total", get$totalDuration: "totalDuration", get$totalTouches: "totalTouches", get$touch: "touch", get$touchCancelCallback: "touchCancelCallback", get$touchEndCallback: "touchEndCallback", get$touchEnterCallback: "touchEnterCallback", get$touchLeaveCallback: "touchLeaveCallback", get$touchLocked: "touchLocked", get$touchMoveCallback: "touchMoveCallback", get$touchStartCallback: "touchStartCallback", get$touchend: "touchend", get$touchendoutside: "touchendoutside", get$touching: "touching", get$touchmove: "touchmove", get$touchs: "touchs", get$touchstart: "touchstart", get$trackParentInterval: "trackParentInterval", get$translationMatrix: "translationMatrix", get$transparent: "transparent", get$trident: "trident", get$tridentVersion: "tridentVersion", get$trim: "trim", get$trimmed: "trimmed", get$tw: "tw", get$tweens: "tweens", get$tx: "tx", get$ty: "ty", get$type: "type", get$typedArray: "typedArray", get$u: "u", get$u2: "u2", get$uMatrix: "uMatrix", get$uSampler: "uSampler", get$uWrap: "uWrap", get$uniforms: "uniforms", get$up: "up", get$update: "update", get$updateFrame: "updateFrame", get$updateIfVisible: "updateIfVisible", get$url: "url", get$useHandCursor: "useHandCursor", get$usingAudioTag: "usingAudioTag", get$usingWebAudio: "usingWebAudio", get$uuid: "uuid", get$uvArray: "uvArray", get$uvBuffer: "uvBuffer", get$uvs: "uvs", get$v: "v", get$v2: "v2", get$vWrap: "vWrap", get$valid: "valid", get$value: "value", get$velocity: "velocity", get$version: "version", get$vertSize: "vertSize", get$vertexArray: "vertexArray", get$vertexBuffer: "vertexBuffer", get$vertexSrc: "vertexSrc", get$vertices: "vertices", get$verticies: "verticies", get$vibration: "vibration", get$view: "view", get$visible: "visible", get$volume: "volume", get$wav: "wav", get$webApp: "webApp", get$webAudio: "webAudio", get$webGL: "webGL", get$webm: "webm", get$wheelDelta: "wheelDelta", get$width: "width", get$widthInPixels: "widthInPixels", get$windows: "windows", get$windowsPhone: "windowsPhone", get$withinGame: "withinGame", get$wordWrap: "wordWrap", get$wordWrapWidth: "wordWrapWidth", get$worker: "worker", get$world: "world", get$worldRotation: "worldRotation", get$worldScaleX: "worldScaleX", get$worldScaleY: "worldScaleY", get$worldX: "worldX", get$worldY: "worldY", get$wrap: "wrap", get$x: "x", get$x0: "x0", get$x1: "x1", get$x2: "x2", get$x3: "x3", get$xAdvance: "xAdvance", get$xOffset: "xOffset", get$y: "y", get$y0: "y0", get$y1: "y1", get$y2: "y2", get$y3: "y3", get$yOffset: "yOffset", get$z: "z"};
init.mangledGlobalNames = {AUTO: "AUTO", AUTO_PREVENT_DEFAULT: "AUTO_PREVENT_DEFAULT", AnimCache: "AnimCache", AtlasReader_replaceReg: "replaceReg", AtlasReader_splitReg: "splitReg", Atlas_Format: "Format", Atlas_TextureFilter: "TextureFilter", Atlas_TextureWrap: "TextureWrap", AttachmentType: "AttachmentType", BITMAPDATA: "BITMAPDATA", BITMAPTEXT: "BITMAPTEXT", BUTTON: "BUTTON", Backs__param_s: "_param_s", BaseTextureCache: "BaseTextureCache", BaseTextureCacheIdGenerator: "BaseTextureCacheIdGenerator", BitmapText__charCodeReg: "_charCodeReg", BitmapText__numReg: "_numReg", BitmapText_fonts: "fonts", BlendModes_ADD: "ADD", BlendModes_COLOR: "COLOR", BlendModes_COLOR_BURN: "COLOR_BURN", BlendModes_COLOR_DODGE: "COLOR_DODGE", BlendModes_DARKEN: "DARKEN", BlendModes_DIFFERENCE: "DIFFERENCE", BlendModes_EXCLUSION: "EXCLUSION", BlendModes_HARD_LIGHT: "HARD_LIGHT", BlendModes_HUE: "HUE", BlendModes_LIGHTEN: "LIGHTEN", BlendModes_LUMINOSITY: "LUMINOSITY", BlendModes_MULTIPLY: "MULTIPLY", BlendModes_NONE: "NONE", BlendModes_NORMAL: "NORMAL", BlendModes_OVERLAY: "OVERLAY", BlendModes_SATURATION: "SATURATION", BlendModes_SCREEN: "SCREEN", BlendModes_SOFT_LIGHT: "SOFT_LIGHT", Bone_yDown: "yDown", CANVAS: "CANVAS", CANVAS_FILTER: "CANVAS_FILTER", CANVAS_RENDERER: "CANVAS_RENDERER", Cache_BINARY: "BINARY", Cache_BITMAPDATA: "BITMAPDATA", Cache_BITMAPFONT: "BITMAPFONT", Cache_CANVAS: "CANVAS", Cache_IMAGE: "IMAGE", Cache_JSON: "JSON", Cache_PHYSICS: "PHYSICS", Cache_SOUND: "SOUND", Cache_TEXT: "TEXT", Cache_TEXTURE: "TEXTURE", Cache_TILEMAP: "TILEMAP", Cache_XML: "XML", Camera_FOLLOW_LOCKON: "FOLLOW_LOCKON", Camera_FOLLOW_PLATFORMER: "FOLLOW_PLATFORMER", Camera_FOLLOW_TOPDOWN: "FOLLOW_TOPDOWN", Camera_FOLLOW_TOPDOWN_TIGHT: "FOLLOW_TOPDOWN_TIGHT", CanvasTinter_cacheStepsPerColorChannel: "cacheStepsPerColorChannel", CanvasTinter_canUseMultiply: "canUseMultiply", CanvasTinter_canvas: "canvas", CanvasTinter_convertTintToImage: "convertTintToImage", CanvasTinter_tintMethod: "tintMethod", DEG_TO_RAD: "DEG_TO_RAD", DOWN: "DOWN", Device_LITTLE_ENDIAN: "LITTLE_ENDIAN", ELLIPSE: "ELLIPSE", EMITTER: "EMITTER", Easing_Back: "Back", Easing_Bounce: "Bounce", Easing_Circ: "Circ", Easing_Cubic: "Cubic", Easing_Default: "Default", Easing_Elastic: "Elastic", Easing_Exponential: "Exponential", Easing_Linear: "Linear", Easing_Quadratic: "Quadratic", Easing_Quartic: "Quartic", Easing_Quintic: "Quintic", Easing_Sinusoidal: "Sinusoidal", EmptyRectangle: "EmptyRectangle", FrameCache: "FrameCache", GAMES: "GAMES", GRAPHICS: "GRAPHICS", GROUP: "GROUP", Graphics_CIRC: "CIRC", Graphics_ELIP: "ELIP", Graphics_POLY: "POLY", Graphics_RECT: "RECT", Graphics_RREC: "RREC", Group_RETURN_CHILD: "RETURN_CHILD", Group_RETURN_NONE: "RETURN_NONE", Group_RETURN_TOTAL: "RETURN_TOTAL", Group_SORT_ASCENDING: "SORT_ASCENDING", Group_SORT_DESCENDING: "SORT_DESCENDING", HEADLESS: "HEADLESS", IMAGE: "IMAGE", INTERACTION_FREQUENCY: "INTERACTION_FREQUENCY", IdentityMatrix: "IdentityMatrix", Input_MOUSE_OVERRIDES_TOUCH: "MOUSE_OVERRIDES_TOUCH", Input_MOUSE_TOUCH_COMBINE: "MOUSE_TOUCH_COMBINE", Input_TOUCH_OVERRIDES_MOUSE: "TOUCH_OVERRIDES_MOUSE", Keyboard_A: "A", Keyboard_ALT: "ALT", Keyboard_B: "B", Keyboard_BACKSPACE: "BACKSPACE", Keyboard_BACKWARD_SLASH: "BACKWARD_SLASH", Keyboard_C: "C", Keyboard_CAPS_LOCK: "CAPS_LOCK", Keyboard_CLEAR: "CLEAR", Keyboard_CLOSED_BRACKET: "CLOSED_BRACKET", Keyboard_COLON: "COLON", Keyboard_CONTROL: "CONTROL", Keyboard_D: "D", Keyboard_DELETE: "DELETE", Keyboard_DOWN: "DOWN", Keyboard_E: "E", Keyboard_EIGHT: "EIGHT", Keyboard_END: "END", Keyboard_ENTER: "ENTER", Keyboard_EQUALS: "EQUALS", Keyboard_ESC: "ESC", Keyboard_F: "F", Keyboard_F1: "F1", Keyboard_F10: "F10", Keyboard_F11: "F11", Keyboard_F12: "F12", Keyboard_F13: "F13", Keyboard_F14: "F14", Keyboard_F15: "F15", Keyboard_F2: "F2", Keyboard_F3: "F3", Keyboard_F4: "F4", Keyboard_F5: "F5", Keyboard_F6: "F6", Keyboard_F7: "F7", Keyboard_F8: "F8", Keyboard_F9: "F9", Keyboard_FIVE: "FIVE", Keyboard_FOUR: "FOUR", Keyboard_G: "G", Keyboard_H: "H", Keyboard_HELP: "HELP", Keyboard_HOME: "HOME", Keyboard_I: "I", Keyboard_INSERT: "INSERT", Keyboard_J: "J", Keyboard_K: "K", Keyboard_L: "L", Keyboard_LEFT: "LEFT", Keyboard_M: "M", Keyboard_MINUS: "MINUS", Keyboard_N: "N", Keyboard_NINE: "NINE", Keyboard_NUMPAD_0: "NUMPAD_0", Keyboard_NUMPAD_1: "NUMPAD_1", Keyboard_NUMPAD_2: "NUMPAD_2", Keyboard_NUMPAD_3: "NUMPAD_3", Keyboard_NUMPAD_4: "NUMPAD_4", Keyboard_NUMPAD_5: "NUMPAD_5", Keyboard_NUMPAD_6: "NUMPAD_6", Keyboard_NUMPAD_7: "NUMPAD_7", Keyboard_NUMPAD_8: "NUMPAD_8", Keyboard_NUMPAD_9: "NUMPAD_9", Keyboard_NUMPAD_ADD: "NUMPAD_ADD", Keyboard_NUMPAD_DECIMAL: "NUMPAD_DECIMAL", Keyboard_NUMPAD_DIVIDE: "NUMPAD_DIVIDE", Keyboard_NUMPAD_ENTER: "NUMPAD_ENTER", Keyboard_NUMPAD_MULTIPLY: "NUMPAD_MULTIPLY", Keyboard_NUMPAD_SUBTRACT: "NUMPAD_SUBTRACT", Keyboard_NUM_LOCK: "NUM_LOCK", Keyboard_O: "O", Keyboard_ONE: "ONE", Keyboard_OPEN_BRACKET: "OPEN_BRACKET", Keyboard_P: "P", Keyboard_PAGE_DOWN: "PAGE_DOWN", Keyboard_PAGE_UP: "PAGE_UP", Keyboard_PLUS: "PLUS", Keyboard_Q: "Q", Keyboard_QUESTION_MARK: "QUESTION_MARK", Keyboard_QUOTES: "QUOTES", Keyboard_R: "R", Keyboard_RIGHT: "RIGHT", Keyboard_S: "S", Keyboard_SEVEN: "SEVEN", Keyboard_SHIFT: "SHIFT", Keyboard_SIX: "SIX", Keyboard_SPACEBAR: "SPACEBAR", Keyboard_T: "T", Keyboard_TAB: "TAB", Keyboard_THREE: "THREE", Keyboard_TILDE: "TILDE", Keyboard_TWO: "TWO", Keyboard_U: "U", Keyboard_UNDERSCORE: "UNDERSCORE", Keyboard_UP: "UP", Keyboard_V: "V", Keyboard_W: "W", Keyboard_X: "X", Keyboard_Y: "Y", Keyboard_Z: "Z", Keyboard_ZERO: "ZERO", LEFT: "LEFT", Loader_Format: "Format", Loader_PHYSICS_LIME_CORONA_JSON: "PHYSICS_LIME_CORONA_JSON", Loader_PHYSICS_PHASER_JSON: "PHYSICS_PHASER_JSON", Loader_TEXTURE_ATLAS_JSON_ARRAY: "TEXTURE_ATLAS_JSON_ARRAY", Loader_TEXTURE_ATLAS_JSON_HASH: "TEXTURE_ATLAS_JSON_HASH", Loader_TEXTURE_ATLAS_XML_STARLING: "TEXTURE_ATLAS_XML_STARLING", Loader_baseReg: "baseReg", Loader_resultReg: "resultReg", Loader_resultSplit: "resultSplit", Math_PI: "PI", Math_PI2: "PI2", Math_SQRT1_2: "SQRT1_2", Math_SQRT2: "SQRT2", Math__degreeToRadiansFactor: "_degreeToRadiansFactor", Math__radianToDegreesFactor: "_radianToDegreesFactor", Math_random: "random", Matrix2: "Matrix2", Mouse_LEFT_BUTTON: "LEFT_BUTTON", Mouse_MIDDLE_BUTTON: "MIDDLE_BUTTON", Mouse_NO_BUTTON: "NO_BUTTON", Mouse_RIGHT_BUTTON: "RIGHT_BUTTON", Mouse_WHEEL_DOWN: "WHEEL_DOWN", Mouse_WHEEL_UP: "WHEEL_UP", NONE: "NONE", POINTER: "POINTER", POLYGON: "POLYGON", Particles_ID: "ID", Physics_ARCADE: "ARCADE", Physics_BOX2D: "BOX2D", Physics_CHIPMUNK: "CHIPMUNK", Physics_NINJA: "NINJA", Physics_P2JS: "P2JS", PixiShader_defaultVertexSrc: "defaultVertexSrc", QuadTree__empty: "_empty", RAD_TO_DEG: "RAD_TO_DEG", RENDERTEXTURE: "RENDERTEXTURE", RETROFONT: "RETROFONT", RIGHT: "RIGHT", ROPE: "ROPE", RandomDataGenerator_UUID: "UUID", RenderTexture_tempMatrix: "tempMatrix", RetroFont_ALIGN_CENTER: "ALIGN_CENTER", RetroFont_ALIGN_LEFT: "ALIGN_LEFT", RetroFont_ALIGN_RIGHT: "ALIGN_RIGHT", RetroFont_TEXT_SET1: "TEXT_SET1", RetroFont_TEXT_SET10: "TEXT_SET10", RetroFont_TEXT_SET11: "TEXT_SET11", RetroFont_TEXT_SET2: "TEXT_SET2", RetroFont_TEXT_SET3: "TEXT_SET3", RetroFont_TEXT_SET4: "TEXT_SET4", RetroFont_TEXT_SET5: "TEXT_SET5", RetroFont_TEXT_SET6: "TEXT_SET6", RetroFont_TEXT_SET7: "TEXT_SET7", RetroFont_TEXT_SET8: "TEXT_SET8", RetroFont_TEXT_SET9: "TEXT_SET9", SPRITE: "SPRITE", SPRITEBATCH: "SPRITEBATCH", ScaleManager_EXACT_FIT: "EXACT_FIT", ScaleManager_NO_SCALE: "NO_SCALE", ScaleManager_RESIZE: "RESIZE", ScaleManager_SHOW_ALL: "SHOW_ALL", TEXT: "TEXT", TILEMAP: "TILEMAP", TILEMAPLAYER: "TILEMAPLAYER", TILESPRITE: "TILESPRITE", Text_heightCache: "heightCache", Text_linesReg: "linesReg", Text_splitReg: "splitReg", TextureCache: "TextureCache", TextureCacheIdGenerator: "TextureCacheIdGenerator", Texture_frameUpdates: "frameUpdates", Tilemap_CSV: "CSV", Tilemap_EAST: "EAST", Tilemap_Format: "Format", Tilemap_NORTH: "NORTH", Tilemap_SOUTH: "SOUTH", Tilemap_TILED_JSON: "TILED_JSON", Tilemap_WEST: "WEST", Timer_HALF: "HALF", Timer_MINUTE: "MINUTE", Timer_QUARTER: "QUARTER", Timer_SECOND: "SECOND", UP: "UP", VERSION: "VERSION", VERSION0: "VERSION", WEBGL: "WEBGL", WEBGL_FILTER: "WEBGL_FILTER", WEBGL_RENDERER: "WEBGL_RENDERER", WebGLGraphics_graphicsDataPool: "graphicsDataPool", WebGLGraphics_last: "last", _UID: "_UID", blendModesCanvas: "blendModesCanvas", blendModesWebGL: "blendModesWebGL", defaultRenderer: "defaultRenderer", glContexts: "glContexts", requestAnimFrame: "requestAnimFrame", scaleModes_DEFAULT: "DEFAULT", scaleModes_LINEAR: "LINEAR", scaleModes_NEAREST: "NEAREST", texturesToDestroy: "texturesToDestroy", texturesToUpdate: "texturesToUpdate"};
(function(reflectionData) {
  "use strict";
  function map(x) {
    x = Object.create(null);
    x.x = 0;
    delete x.x;
    return x;
  }
  function processStatics(descriptor) {
    for (var property in descriptor) {
      if (!hasOwnProperty.call(descriptor, property))
        continue;
      if (property === "^")
        continue;
      var element = descriptor[property];
      var firstChar = property.substring(0, 1);
      var previousProperty;
      if (firstChar === "+") {
        mangledGlobalNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
        if (element && element.length)
          init.typeInformation[previousProperty] = element;
      } else if (firstChar === "@") {
        property = property.substring(1);
        $[property]["@"] = element;
      } else if (firstChar === "*") {
        globalObject[previousProperty].$defaultValues = element;
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods) {
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        }
        optionalMethods[property] = previousProperty;
      } else if (typeof element === "function") {
        globalObject[previousProperty = property] = element;
        functions.push(property);
        init.globalFunctions[property] = element;
      } else if (element.constructor === Array) {
        addStubs(globalObject, element, property, true, descriptor, functions);
      } else {
        previousProperty = property;
        var newDesc = {};
        var previousProp;
        for (var prop in element) {
          if (!hasOwnProperty.call(element, prop))
            continue;
          firstChar = prop.substring(0, 1);
          if (prop === "static") {
            processStatics(init.statics[property] = element[prop]);
          } else if (firstChar === "+") {
            mangledNames[previousProp] = prop.substring(1);
            var flag = element[prop];
            if (flag > 0)
              element[previousProp].$reflectable = flag;
          } else if (firstChar === "@" && prop !== "@") {
            newDesc[prop.substring(1)]["@"] = element[prop];
          } else if (firstChar === "*") {
            newDesc[previousProp].$defaultValues = element[prop];
            var optionalMethods = newDesc.$methodsWithOptionalArguments;
            if (!optionalMethods) {
              newDesc.$methodsWithOptionalArguments = optionalMethods = {};
            }
            optionalMethods[prop] = previousProp;
          } else {
            var elem = element[prop];
            if (prop !== "^" && elem != null && elem.constructor === Array && prop !== "<>") {
              addStubs(newDesc, elem, prop, false, element, []);
            } else {
              newDesc[previousProp = prop] = elem;
            }
          }
        }
        $$[property] = [globalObject, newDesc];
        classes.push(property);
      }
    }
  }
  function addStubs(descriptor, array, name, isStatic, originalDescriptor, functions) {
    var f, funcs = [originalDescriptor[name] = descriptor[name] = f = array[0]];
    f.$stubName = name;
    functions.push(name);
    for (var index = 0; index < array.length; index += 2) {
      f = array[index + 1];
      if (typeof f != "function")
        break;
      f.$stubName = array[index + 2];
      funcs.push(f);
      if (f.$stubName) {
        originalDescriptor[f.$stubName] = descriptor[f.$stubName] = f;
        functions.push(f.$stubName);
      }
    }
    for (var i = 0; i < funcs.length; index++, i++) {
      funcs[i].$callName = array[index + 1];
    }
    var getterStubName = array[++index];
    array = array.slice(++index);
    var requiredParameterInfo = array[0];
    var requiredParameterCount = requiredParameterInfo >> 1;
    var isAccessor = (requiredParameterInfo & 1) === 1;
    var isSetter = requiredParameterInfo === 3;
    var isGetter = requiredParameterInfo === 1;
    var optionalParameterInfo = array[1];
    var optionalParameterCount = optionalParameterInfo >> 1;
    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
    var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
    var functionTypeIndex = array[2];
    var unmangledNameIndex = 3 * optionalParameterCount + 2 * requiredParameterCount + 3;
    var isReflectable = array.length > unmangledNameIndex;
    if (getterStubName) {
      f = tearOff(funcs, array, isStatic, name, isIntercepted);
      descriptor[name].$getter = f;
      f.$getterStub = true;
      if (isStatic)
        init.globalFunctions[name] = f;
      originalDescriptor[getterStubName] = descriptor[getterStubName] = f;
      funcs.push(f);
      if (getterStubName)
        functions.push(getterStubName);
      f.$stubName = getterStubName;
      f.$callName = null;
      if (isIntercepted)
        init.interceptedNames[getterStubName] = true;
    }
    if (isReflectable) {
      for (var i = 0; i < funcs.length; i++) {
        funcs[i].$reflectable = 1;
        funcs[i].$reflectionInfo = array;
      }
      var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;
      var unmangledName = array[unmangledNameIndex];
      var reflectionName = unmangledName;
      if (getterStubName)
        mangledNames[getterStubName] = reflectionName;
      if (isSetter) {
        reflectionName += "=";
      } else if (!isGetter) {
        reflectionName += ":" + requiredParameterCount + ":" + optionalParameterCount;
      }
      mangledNames[name] = reflectionName;
      funcs[0].$reflectionName = reflectionName;
      funcs[0].$metadataIndex = unmangledNameIndex + 1;
      if (optionalParameterCount)
        descriptor[unmangledName + "*"] = funcs[0];
    }
  }
  function tearOffGetterNoCsp(funcs, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
  }
  function tearOffGetterCsp(funcs, reflectionInfo, name, isIntercepted) {
    var cache = null;
    return isIntercepted ? function(x) {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [x], name);
      return new cache(this, funcs[0], x, name);
    } : function() {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [], name);
      return new cache(this, funcs[0], null, name);
    };
  }
  function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
    var cache;
    return isStatic ? function() {
      if (cache === void 0)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
      return cache;
    } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
  }
  var functionCounter = 0;
  var tearOffGetter = typeof dart_precompiled == "function" ? tearOffGetterCsp : tearOffGetterNoCsp;
  if (!init.libraries)
    init.libraries = [];
  if (!init.mangledNames)
    init.mangledNames = map();
  if (!init.mangledGlobalNames)
    init.mangledGlobalNames = map();
  if (!init.statics)
    init.statics = map();
  if (!init.typeInformation)
    init.typeInformation = map();
  if (!init.globalFunctions)
    init.globalFunctions = map();
  if (!init.interceptedNames)
    init.interceptedNames = map();
  var libraries = init.libraries;
  var mangledNames = init.mangledNames;
  var mangledGlobalNames = init.mangledGlobalNames;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var length = reflectionData.length;
  for (var i = 0; i < length; i++) {
    var data = reflectionData[i];
    var name = data[0];
    var uri = data[1];
    var metadata = data[2];
    var globalObject = data[3];
    var descriptor = data[4];
    var isRoot = !!data[5];
    var fields = descriptor && descriptor["^"];
    if (fields instanceof Array)
      fields = fields[0];
    var classes = [];
    var functions = [];
    processStatics(descriptor);
    libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
  }
})([
["Arcade", "package:play_phaser/arcade.dart", , O, {
  "^": "",
  Arcade0: {
    "^": "Object;game@,gravity@,bounds@,checkCollision<,maxObjects@,maxLevels@,OVERLAP_BIAS,TILE_BIAS,forceX,quadTree,_overlap,_maxOverlap,_velocity1,_velocity2,_newVelocity1,_newVelocity2,_average,_mapData,_result,_total,_angle,_Arcade$_dx,_Arcade$_dy,_velocityDelta,_drag,_potentials,skipQuadTree",
    quadTree$2: function(arg0, arg1) {
      return this.quadTree.call$2(arg0, arg1);
    },
    setBounds$4: function(x, y, width, height) {
      this.bounds.setTo$4(x, y, width, height);
    },
    setBoundsToWorld$0: function() {
      this.bounds.setTo$4(J.get$x$x(this.game.get$world().get$bounds()), J.get$y$x(this.game.get$world().get$bounds()), J.get$width$x(this.game.get$world().get$bounds()), J.get$height$x(this.game.get$world().get$bounds()));
    },
    enable$2: function(_, object, children) {
      var t1, i, t2, t3, i0, t4;
      t1 = J.getInterceptor(object);
      if (!!t1.$isList) {
        i = t1.get$length(object);
        for (t2 = children === true; t3 = J.getInterceptor$n(i), i0 = t3.$sub(i, 1), t3.$ge(i, 0); i = i0)
          if (!!J.getInterceptor(t1.$index(object, i0)).$isGroup)
            this.enable$2(0, J.get$children$x(t1.$index(object, i0)), children);
          else {
            t3 = t1.$index(object, i0);
            t4 = J.getInterceptor$x(t3);
            if (t4.get$body(t3) == null)
              t4.set$body(t3, O.Body$(t3));
            if (t2 && J.$gt$n(J.get$length$asx(J.get$children$x(t1.$index(object, i0))), 0))
              this.enable$2(0, t1.$index(object, i0), true);
          }
      } else if (!!t1.$isGroup)
        this.enable$2(0, object.Phaser$Group$children, children);
      else {
        if (t1.get$body(object) == null)
          t1.set$body(object, O.Body$(object));
        if (children === true && J.$gt$n(J.get$length$asx(t1.get$children(object)), 0))
          this.enable$2(0, t1.get$children(object), true);
      }
    },
    enable$1: function($receiver, object) {
      return this.enable$2($receiver, object, true);
    },
    enableBody$1: [function(object) {
      var t1 = J.getInterceptor$x(object);
      if (t1.get$body(object) == null)
        t1.set$body(object, O.Body$(object));
    }, "call$1", "get$enableBody", 2, 0, 612],
    updateMotion$1: function(body) {
      var t1, t2;
      t1 = J.$sub$n(this.computeVelocity$6(0, body, body.Arcade$Body0$angularVelocity, body.angularAcceleration, body.Arcade$Body0$angularDrag, body.maxAngular), body.Arcade$Body0$angularVelocity);
      this._velocityDelta = t1;
      t1 = J.$add$ns(body.Arcade$Body0$angularVelocity, t1);
      body.Arcade$Body0$angularVelocity = t1;
      body.rotation = J.$add$ns(body.rotation, J.$mul$ns(t1, this.game.get$time().get$physicsElapsed()));
      t1 = body.Arcade$Body0$velocity;
      t2 = J.getInterceptor$x(t1);
      t2.set$x(t1, this.computeVelocity$6(1, body, t2.get$x(t1), J.get$x$x(body.Arcade$Body0$acceleration), J.get$x$x(body.Arcade$Body0$drag), J.get$x$x(body.Arcade$Body0$maxVelocity)));
      t1 = body.Arcade$Body0$velocity;
      t2 = J.getInterceptor$x(t1);
      t2.set$y(t1, this.computeVelocity$6(2, body, t2.get$y(t1), J.get$y$x(body.Arcade$Body0$acceleration), J.get$y$x(body.Arcade$Body0$drag), J.get$y$x(body.Arcade$Body0$maxVelocity)));
    },
    computeVelocity$6: function(axis, body, velocity, acceleration, drag, max) {
      var t1, t2;
      if (axis === 1 && body.allowGravity)
        velocity = J.$add$ns(velocity, J.$mul$ns(J.$add$ns(this.gravity.x, J.get$x$x(body.Arcade$Body0$gravity)), this.game.get$time().get$physicsElapsed()));
      else if (axis === 2 && body.allowGravity)
        velocity = J.$add$ns(velocity, J.$mul$ns(J.$add$ns(this.gravity.y, J.get$y$x(body.Arcade$Body0$gravity)), this.game.get$time().get$physicsElapsed()));
      t1 = J.getInterceptor(acceleration);
      if (!t1.$eq(acceleration, 0))
        velocity = J.$add$ns(velocity, t1.$mul(acceleration, this.game.get$time().get$physicsElapsed()));
      else {
        t1 = J.getInterceptor(drag);
        if (!t1.$eq(drag, 0)) {
          t1 = t1.$mul(drag, this.game.get$time().get$physicsElapsed());
          this._drag = t1;
          t2 = J.getInterceptor$n(velocity);
          if (J.$gt$n(t2.$sub(velocity, t1), 0))
            velocity = t2.$sub(velocity, this._drag);
          else
            velocity = J.$lt$n(t2.$add(velocity, this._drag), 0) ? t2.$add(velocity, this._drag) : 0;
        }
      }
      t1 = J.getInterceptor$n(velocity);
      if (t1.$gt(velocity, max))
        velocity = max;
      else {
        t2 = J.getInterceptor$n(max);
        if (t1.$lt(velocity, t2.$negate(max)))
          velocity = t2.$negate(max);
      }
      return velocity;
    },
    intersects$2: function(_, body1, body2) {
      var t1, t2;
      t1 = body1.get$right(body1);
      t2 = body2.get$position(body2);
      t1.$le(0, t2.get$x(t2));
      t1 = body1.get$bottom(body1);
      t2 = body2.get$position(body2);
      t1.$le(0, t2.get$y(t2));
      t1 = body1.get$position(body1);
      t1.get$x(t1).$ge(0, body2.get$right(body2));
      t1 = body1.get$position(body1);
      t1.get$y(t1).$ge(0, body2.get$bottom(body2));
      return true;
    },
    Arcade$1: function(game) {
      var t1, t2, t3, t4, t5, t6, t7, t8;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.gravity = t1;
      this.bounds = new R.Rectangle1(0, 0, J.get$width$x(this.game.get$world()), J.get$height$x(this.game.get$world()), 0, 0, 0, 0);
      t1 = R.CollisionInfo$(false, false, false, false);
      t1.up = true;
      t1.down = true;
      t1.left = true;
      t1.right = true;
      this.checkCollision = t1;
      this.maxObjects = 10;
      this.maxLevels = 4;
      this.OVERLAP_BIAS = 4;
      this.TILE_BIAS = 16;
      this.forceX = false;
      t1 = J.get$x$x(this.game.get$world().get$bounds());
      t2 = J.get$y$x(this.game.get$world().get$bounds());
      t3 = J.get$width$x(this.game.get$world().get$bounds());
      t4 = J.get$height$x(this.game.get$world().get$bounds());
      t5 = this.maxObjects;
      t6 = this.maxLevels;
      t7 = H.setRuntimeTypeInfo([], [R.Body]);
      t8 = Array(4);
      t8.fixed$length = init;
      t8 = new R.QuadTree(10, 4, 0, null, t7, H.setRuntimeTypeInfo(t8, [R.QuadTree]));
      t8.reset$7(0, J.toInt$0$n(t1), J.toInt$0$n(t2), J.toInt$0$n(t3), J.toInt$0$n(t4), t5, t6, null);
      this.quadTree = t8;
      this._overlap = 0;
      this._maxOverlap = 0;
      this._velocity1 = 0;
      this._velocity2 = 0;
      this._newVelocity1 = 0;
      this._newVelocity2 = 0;
      this._average = 0;
      this._mapData = [];
      this._result = false;
      this._total = 0;
      this._angle = 0;
      this._Arcade$_dx = 0;
      this._Arcade$_dy = 0;
      this.setBoundsToWorld$0();
    },
    static: {Arcade$: function(game) {
        var t1 = new O.Arcade0(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);
        t1.Arcade$1(game);
        return t1;
      }}
  },
  "+Arcade": 0,
  Body0: {
    "^": "Body;sprite@,game:Arcade$Body0$game@-613,type:Arcade$Body0$type*-614,enable,offset*,position:Arcade$Body0$position*-615,prev,allowRotation,rotation@,preRotation,sourceWidth@,sourceHeight@,width:Arcade$Body0$width*-616,height:Arcade$Body0$height*-616,halfWidth@-616,halfHeight@-616,center@,velocity:Arcade$Body0$velocity@-615,newVelocity,deltaMax,acceleration:Arcade$Body0$acceleration*-615,drag:Arcade$Body0$drag@-615,allowGravity,gravity:Arcade$Body0$gravity@-615,bounce:Arcade$Body0$bounce@-615,maxVelocity:Arcade$Body0$maxVelocity@-615,angularVelocity:Arcade$Body0$angularVelocity@-616,angularAcceleration,angularDrag:Arcade$Body0$angularDrag@-616,maxAngular,mass@,angle:Arcade$Body0$angle*-616,speed:Arcade$Body0$speed@-616,facing,immovable:Arcade$Body0$immovable@-617,moves:Arcade$Body0$moves@-617,customSeparateX,customSeparateY,overlapX,overlapY,embedded,collideWorldBounds:Arcade$Body0$collideWorldBounds@-617,checkCollision<,touching:Arcade$Body0$touching@-618,wasTouching,blocked:Arcade$Body0$blocked@-618,tilePadding:Arcade$Body0$tilePadding@-615,safeRemove:Arcade$Body0$safeRemove@-617,skipQuadTree,phase:Arcade$Body0$phase@-614,_Arcade$_reset,_sx,_sy,_Arcade$_dx,_Arcade$_dy,game-613,position-615,tilePadding-615,Phaser$Body$width-616,Phaser$Body$height-616,velocity-615,acceleration-615,maxVelocity-615,collideWorldBounds-617,bounce-12,type-614,angularVelocity-616,gravity-615,drag-12,angularDrag-616,immovable-617,Phaser$Body$x-616,Phaser$Body$y-616,speed-616,blocked-618,angle-616,moves-617,phase-614,_reset-617,safeRemove-617,touching-618,Phaser$Rectangle1$x-616,Phaser$Rectangle1$y-616,Phaser$Rectangle1$width-616,Phaser$Rectangle1$height-616,x-616,y-616,width-616,height-616",
    addToWorld$0: [function() {
    }, "call$0", "get$addToWorld", 0, 0, 54, "addToWorld"],
    removeFromWorld$0: [function() {
    }, "call$0", "get$removeFromWorld", 0, 0, 54, "removeFromWorld"],
    sprite$3: function(arg0, arg1, arg2) {
      return this.sprite.call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.sprite.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.sprite.call$4(arg0, arg1, arg2, arg3);
    },
    enable$2: function($receiver, arg0, arg1) {
      return this.enable.call$2(arg0, arg1);
    },
    enable$1: function($receiver, arg0) {
      return this.enable.call$1(arg0);
    },
    enable$3: function($receiver, arg0, arg1, arg2) {
      return this.enable.call$3(arg0, arg1, arg2);
    },
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    angle$0: function($receiver) {
      return this.Arcade$Body0$angle.call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.Arcade$Body0$angle.call$2(arg0, arg1);
    },
    get$bottom: [function(_) {
      return J.$add$ns(J.get$y$x(this.Arcade$Body0$position), this.Arcade$Body0$height);
    }, null, null, 1, 0, 619, "bottom"],
    get$right: [function(_) {
      return J.$add$ns(J.get$x$x(this.Arcade$Body0$position), this.Arcade$Body0$width);
    }, null, null, 1, 0, 619, "right"],
    get$x: [function(_) {
      return J.get$x$x(this.Arcade$Body0$position);
    }, null, null, 1, 0, 619, "x"],
    set$x: [function(_, value) {
      J.set$x$x(this.Arcade$Body0$position, value);
    }, null, null, 3, 0, 620, 138, [], "x"],
    get$y: [function(_) {
      return J.get$y$x(this.Arcade$Body0$position);
    }, null, null, 1, 0, 619, "y"],
    set$y: [function(_, value) {
      J.set$y$x(this.Arcade$Body0$position, value);
    }, null, null, 3, 0, 620, 138, [], "y"],
    render$3: [function(context, color, filled) {
      var t1 = J.getInterceptor$x(context);
      if (filled === true) {
        t1.set$fillStyle(context, color);
        t1.fillRect$4(context, J.$sub$n(J.get$x$x(this.Arcade$Body0$position), J.get$x$x(this.Arcade$Body0$game.get$camera())), J.$sub$n(J.get$y$x(this.Arcade$Body0$position), J.get$y$x(this.Arcade$Body0$game.get$camera())), this.Arcade$Body0$width, this.Arcade$Body0$height);
      } else {
        t1.set$strokeStyle(context, color);
        t1.strokeRect$4(context, J.$sub$n(J.get$x$x(this.Arcade$Body0$position), J.get$x$x(this.Arcade$Body0$game.get$camera())), J.$sub$n(J.get$y$x(this.Arcade$Body0$position), J.get$y$x(this.Arcade$Body0$game.get$camera())), this.Arcade$Body0$width, this.Arcade$Body0$height);
      }
    }, function(context) {
      return this.render$3(context, "rgba(0,255,0,0.4)", true);
    }, "render$1", function(context, color) {
      return this.render$3(context, color, true);
    }, "render$2", "call$3", "call$1", "call$2", "get$render", 2, 4, 621, 622, 78, 142, [], 152, [], 623, []],
    renderBodyInfo$1: function(debug) {
      debug.line$1(["x: " + J.toStringAsFixed$1$n(J.get$x$x(this.Arcade$Body0$position), 2), "y: " + J.toStringAsFixed$1$n(J.get$y$x(this.Arcade$Body0$position), 2), C.JSString_methods.$add("width: ", J.toString$0(this.Arcade$Body0$width)), C.JSString_methods.$add("height: ", J.toString$0(this.Arcade$Body0$height))]);
      debug.line$1(["velocity x: " + J.toStringAsFixed$1$n(J.get$x$x(this.Arcade$Body0$velocity), 2), "y: " + J.toStringAsFixed$1$n(J.get$y$x(this.Arcade$Body0$velocity), 2), "deltaX: " + J.toStringAsFixed$1$n(this._Arcade$_dx, 2), "deltaY: " + J.toStringAsFixed$1$n(this._Arcade$_dy, 2)]);
      debug.line$1(["acceleration x: " + J.toStringAsFixed$1$n(J.get$x$x(this.Arcade$Body0$acceleration), 2), "y: " + J.toStringAsFixed$1$n(J.get$y$x(this.Arcade$Body0$acceleration), 2), "speed: " + J.toStringAsFixed$1$n(this.Arcade$Body0$speed, 2), "angle: " + J.toStringAsFixed$1$n(this.Arcade$Body0$angle, 2)]);
      debug.line$1([C.JSString_methods.$add("gravity x: ", J.toString$0(J.get$x$x(this.Arcade$Body0$gravity))), C.JSString_methods.$add("y: ", J.toString$0(J.get$y$x(this.Arcade$Body0$gravity))), "bounce x: " + J.toStringAsFixed$1$n(J.get$x$x(this.Arcade$Body0$bounce), 2), "y: " + J.toStringAsFixed$1$n(J.get$y$x(this.Arcade$Body0$bounce), 2)]);
      debug.line$1([C.JSString_methods.$add("touching left: ", J.toString$0(J.get$left$x(this.Arcade$Body0$touching))), C.JSString_methods.$add("right: ", J.toString$0(J.get$right$x(this.Arcade$Body0$touching))), C.JSString_methods.$add("up: ", J.toString$0(this.Arcade$Body0$touching.get$up())), C.JSString_methods.$add("down: ", J.toString$0(this.Arcade$Body0$touching.get$down()))]);
      debug.line$1([C.JSString_methods.$add("blocked left: ", J.toString$0(J.get$left$x(this.Arcade$Body0$blocked))), C.JSString_methods.$add("right: ", J.toString$0(J.get$right$x(this.Arcade$Body0$blocked))), C.JSString_methods.$add("up: ", J.toString$0(this.Arcade$Body0$blocked.get$up())), C.JSString_methods.$add("down: ", J.toString$0(this.Arcade$Body0$blocked.get$down()))]);
    },
    updateBounds$0: function() {
      var asx, asy;
      asx = J.abs$0$n(J.get$x$x(J.get$scale$x(this.sprite)));
      asy = J.abs$0$n(J.get$y$x(J.get$scale$x(this.sprite)));
      if (!J.$eq(asx, this._sx) || !J.$eq(asy, this._sy)) {
        this.Arcade$Body0$width = J.$mul$ns(this.sourceWidth, asx);
        this.Arcade$Body0$height = J.$mul$ns(this.sourceHeight, asy);
        this.halfWidth = J.floor$0$n(J.$div$n(this.Arcade$Body0$width, 2));
        this.halfHeight = J.floor$0$n(J.$div$n(this.Arcade$Body0$height, 2));
        this._sx = asx;
        this._sy = asy;
        this.center.setTo$2(J.$add$ns(J.get$x$x(this.Arcade$Body0$position), this.halfWidth), J.$add$ns(J.get$y$x(this.Arcade$Body0$position), this.halfHeight));
        this._Arcade$_reset = true;
      }
    },
    preUpdate$0: [function() {
      var t1, t2;
      if (!this.enable)
        return;
      this.Arcade$Body0$phase = 1;
      this.wasTouching.none = this.Arcade$Body0$touching.get$none();
      this.wasTouching.up = this.Arcade$Body0$touching.get$up();
      this.wasTouching.down = this.Arcade$Body0$touching.get$down();
      this.wasTouching.left = J.get$left$x(this.Arcade$Body0$touching);
      this.wasTouching.right = J.get$right$x(this.Arcade$Body0$touching);
      this.Arcade$Body0$touching.set$none(true);
      this.Arcade$Body0$touching.set$up(false);
      this.Arcade$Body0$touching.set$down(false);
      J.set$left$x(this.Arcade$Body0$touching, false);
      J.set$right$x(this.Arcade$Body0$touching, false);
      this.Arcade$Body0$blocked.set$up(false);
      this.Arcade$Body0$blocked.set$down(false);
      J.set$left$x(this.Arcade$Body0$blocked, false);
      J.set$right$x(this.Arcade$Body0$blocked, false);
      this.embedded = false;
      this.updateBounds$0();
      J.set$x$x(this.Arcade$Body0$position, J.$add$ns(J.$sub$n(J.get$x$x(this.sprite.get$world()), J.$mul$ns(J.get$x$x(this.sprite.get$anchor()), this.Arcade$Body0$width)), J.get$x$x(this.offset)));
      J.set$y$x(this.Arcade$Body0$position, J.$add$ns(J.$sub$n(J.get$y$x(this.sprite.get$world()), J.$mul$ns(J.get$y$x(this.sprite.get$anchor()), this.Arcade$Body0$height)), J.get$y$x(this.offset)));
      t1 = J.get$angle$x(this.sprite);
      this.rotation = t1;
      this.preRotation = t1;
      if (this._Arcade$_reset || this.sprite.get$fresh()) {
        this.prev.x = J.get$x$x(this.Arcade$Body0$position);
        this.prev.y = J.get$y$x(this.Arcade$Body0$position);
      }
      if (this.Arcade$Body0$moves === true) {
        this.Arcade$Body0$game.get$physics().get$arcade().updateMotion$1(this);
        this.newVelocity.set$2(J.$mul$ns(J.get$x$x(this.Arcade$Body0$velocity), this.Arcade$Body0$game.get$time().get$physicsElapsed()), J.$mul$ns(J.get$y$x(this.Arcade$Body0$velocity), this.Arcade$Body0$game.get$time().get$physicsElapsed()));
        t1 = this.Arcade$Body0$position;
        t2 = J.getInterceptor$x(t1);
        t2.set$x(t1, J.$add$ns(t2.get$x(t1), this.newVelocity.x));
        t1 = this.Arcade$Body0$position;
        t2 = J.getInterceptor$x(t1);
        t2.set$y(t1, J.$add$ns(t2.get$y(t1), this.newVelocity.y));
        if (!J.$eq(J.get$x$x(this.Arcade$Body0$position), this.prev.x) || !J.$eq(J.get$y$x(this.Arcade$Body0$position), this.prev.y)) {
          this.Arcade$Body0$speed = Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(J.get$x$x(this.Arcade$Body0$velocity), J.get$x$x(this.Arcade$Body0$velocity)), J.$mul$ns(J.get$y$x(this.Arcade$Body0$velocity), J.get$y$x(this.Arcade$Body0$velocity)))));
          t1 = J.get$y$x(this.Arcade$Body0$velocity);
          t2 = J.get$x$x(this.Arcade$Body0$velocity);
          this.Arcade$Body0$angle = Math.atan2(H.checkNum(t1), H.checkNum(t2));
        }
        if (this.Arcade$Body0$collideWorldBounds === true) {
          if (J.$lt$n(J.get$x$x(this.Arcade$Body0$position), J.get$x$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds())) && this.Arcade$Body0$game.get$physics().get$arcade().get$checkCollision().left === true) {
            J.set$x$x(this.Arcade$Body0$position, J.get$x$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds()));
            t1 = this.Arcade$Body0$velocity;
            t2 = J.getInterceptor$x(t1);
            t2.set$x(t1, J.$mul$ns(t2.get$x(t1), J.$negate$n(J.get$x$x(this.Arcade$Body0$bounce))));
            J.set$left$x(this.Arcade$Body0$blocked, true);
          } else if (J.$gt$n(J.$add$ns(J.get$x$x(this.Arcade$Body0$position), this.Arcade$Body0$width), J.get$right$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds())) && this.Arcade$Body0$game.get$physics().get$arcade().get$checkCollision().right === true) {
            J.set$x$x(this.Arcade$Body0$position, J.$sub$n(J.get$right$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds()), this.Arcade$Body0$width));
            t1 = this.Arcade$Body0$velocity;
            t2 = J.getInterceptor$x(t1);
            t2.set$x(t1, J.$mul$ns(t2.get$x(t1), J.$negate$n(J.get$x$x(this.Arcade$Body0$bounce))));
            J.set$right$x(this.Arcade$Body0$blocked, true);
          }
          if (J.$lt$n(J.get$y$x(this.Arcade$Body0$position), J.get$y$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds())) && this.Arcade$Body0$game.get$physics().get$arcade().get$checkCollision().up === true) {
            J.set$y$x(this.Arcade$Body0$position, J.get$y$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds()));
            t1 = this.Arcade$Body0$velocity;
            t2 = J.getInterceptor$x(t1);
            t2.set$y(t1, J.$mul$ns(t2.get$y(t1), J.$negate$n(J.get$y$x(this.Arcade$Body0$bounce))));
            this.Arcade$Body0$blocked.set$up(true);
          } else if (J.$gt$n(J.$add$ns(J.get$y$x(this.Arcade$Body0$position), this.Arcade$Body0$height), J.get$bottom$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds())) && this.Arcade$Body0$game.get$physics().get$arcade().get$checkCollision().down === true) {
            J.set$y$x(this.Arcade$Body0$position, J.$sub$n(J.get$bottom$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds()), this.Arcade$Body0$height));
            t1 = this.Arcade$Body0$velocity;
            t2 = J.getInterceptor$x(t1);
            t2.set$y(t1, J.$mul$ns(t2.get$y(t1), J.$negate$n(J.get$y$x(this.Arcade$Body0$bounce))));
            this.Arcade$Body0$blocked.set$down(true);
          }
        }
      }
      this._Arcade$_dx = J.$sub$n(J.get$x$x(this.Arcade$Body0$position), this.prev.x);
      this._Arcade$_dy = J.$sub$n(J.get$y$x(this.Arcade$Body0$position), this.prev.y);
      this._Arcade$_reset = false;
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    postUpdate$0: [function() {
      var t1, t2;
      if (!this.enable)
        return;
      if (J.$eq(this.Arcade$Body0$phase, 2))
        return;
      this.Arcade$Body0$phase = 2;
      if (J.$lt$n(J.$sub$n(J.get$x$x(this.Arcade$Body0$position), this.prev.x), 0))
        this.facing = 1;
      else if (J.$gt$n(J.$sub$n(J.get$x$x(this.Arcade$Body0$position), this.prev.x), 0))
        this.facing = 2;
      if (J.$lt$n(J.$sub$n(J.get$y$x(this.Arcade$Body0$position), this.prev.y), 0))
        this.facing = 3;
      else if (J.$gt$n(J.$sub$n(J.get$y$x(this.Arcade$Body0$position), this.prev.y), 0))
        this.facing = 4;
      if (this.Arcade$Body0$moves === true) {
        this._Arcade$_dx = J.$sub$n(J.get$x$x(this.Arcade$Body0$position), this.prev.x);
        this._Arcade$_dy = J.$sub$n(J.get$y$x(this.Arcade$Body0$position), this.prev.y);
        if (!J.$eq(this.deltaMax.x, 0) && !J.$eq(this._Arcade$_dx, 0))
          if (J.$lt$n(this._Arcade$_dx, 0) && J.$lt$n(this._Arcade$_dx, J.$negate$n(this.deltaMax.x)))
            this._Arcade$_dx = J.$negate$n(this.deltaMax.x);
          else if (J.$gt$n(this._Arcade$_dx, 0) && J.$gt$n(this._Arcade$_dx, this.deltaMax.x))
            this._Arcade$_dx = this.deltaMax.x;
        if (!J.$eq(this.deltaMax.y, 0) && !J.$eq(this._Arcade$_dy, 0))
          if (J.$lt$n(this._Arcade$_dy, 0) && J.$lt$n(this._Arcade$_dy, J.$negate$n(this.deltaMax.y)))
            this._Arcade$_dy = J.$negate$n(this.deltaMax.y);
          else if (J.$gt$n(this._Arcade$_dy, 0) && J.$gt$n(this._Arcade$_dy, this.deltaMax.y))
            this._Arcade$_dy = this.deltaMax.y;
        t1 = this.sprite;
        t2 = J.getInterceptor$x(t1);
        t2.set$x(t1, J.$add$ns(t2.get$x(t1), this._Arcade$_dx));
        t1 = this.sprite;
        t2 = J.getInterceptor$x(t1);
        t2.set$y(t1, J.$add$ns(t2.get$y(t1), this._Arcade$_dy));
      }
      this.center.setTo$2(J.$add$ns(J.get$x$x(this.Arcade$Body0$position), this.halfWidth), J.$add$ns(J.get$y$x(this.Arcade$Body0$position), this.halfHeight));
      if (this.allowRotation) {
        t1 = this.sprite;
        t2 = J.getInterceptor$x(t1);
        t2.set$angle(t1, J.$add$ns(t2.get$angle(t1), J.$sub$n(this.rotation, this.preRotation)));
      }
      this.prev.x = J.get$x$x(this.Arcade$Body0$position);
      this.prev.y = J.get$y$x(this.Arcade$Body0$position);
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    moveLeft$1: [function(speed) {
      var t1, t2;
      t1 = this.Arcade$Body0$velocity;
      t2 = J.getInterceptor$x(t1);
      t2.set$x(t1, J.$sub$n(t2.get$x(t1), P.max(speed, J.get$x$x(this.Arcade$Body0$maxVelocity))));
    }, "call$1", "get$moveLeft", 2, 0, 620, 624, [], "moveLeft"],
    moveRight$1: [function(speed) {
      var t1, t2;
      t1 = this.Arcade$Body0$velocity;
      t2 = J.getInterceptor$x(t1);
      t2.set$x(t1, J.$add$ns(t2.get$x(t1), P.max(speed, J.get$x$x(this.Arcade$Body0$maxVelocity))));
    }, "call$1", "get$moveRight", 2, 0, 620, 624, [], "moveRight"],
    moveUp$1: [function(speed) {
      var t1, t2;
      t1 = this.Arcade$Body0$velocity;
      t2 = J.getInterceptor$x(t1);
      t2.set$y(t1, J.$sub$n(t2.get$y(t1), P.max(speed, J.get$y$x(this.Arcade$Body0$maxVelocity))));
    }, "call$1", "get$moveUp", 2, 0, 620, 624, [], "moveUp"],
    moveDown$1: [function(speed) {
      var t1, t2;
      t1 = this.Arcade$Body0$velocity;
      t2 = J.getInterceptor$x(t1);
      t2.set$y(t1, J.$add$ns(t2.get$y(t1), P.max(speed, J.get$y$x(this.Arcade$Body0$maxVelocity))));
    }, "call$1", "get$moveDown", 2, 0, 620, 624, [], "moveDown"],
    destroy$0: [function() {
      J.set$body$x(this.sprite, null);
      this.sprite = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    checkWorldBounds$0: [function() {
      var t1, t2;
      if (J.$lt$n(J.get$x$x(this.Arcade$Body0$position), J.get$x$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds())) && this.Arcade$Body0$game.get$physics().get$arcade().get$checkCollision().left === true) {
        J.set$x$x(this.Arcade$Body0$position, J.get$x$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds()));
        t1 = this.Arcade$Body0$velocity;
        t2 = J.getInterceptor$x(t1);
        t2.set$x(t1, J.$mul$ns(t2.get$x(t1), J.$negate$n(J.get$x$x(this.Arcade$Body0$bounce))));
        J.set$left$x(this.Arcade$Body0$blocked, true);
      } else if (J.$gt$n(J.$add$ns(J.get$x$x(this.Arcade$Body0$position), this.Arcade$Body0$width), J.get$right$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds())) && this.Arcade$Body0$game.get$physics().get$arcade().get$checkCollision().right === true) {
        J.set$x$x(this.Arcade$Body0$position, J.$sub$n(J.get$right$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds()), this.Arcade$Body0$width));
        t1 = this.Arcade$Body0$velocity;
        t2 = J.getInterceptor$x(t1);
        t2.set$x(t1, J.$mul$ns(t2.get$x(t1), J.$negate$n(J.get$x$x(this.Arcade$Body0$bounce))));
        J.set$right$x(this.Arcade$Body0$blocked, true);
      }
      if (J.$lt$n(J.get$y$x(this.Arcade$Body0$position), J.get$y$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds())) && this.Arcade$Body0$game.get$physics().get$arcade().get$checkCollision().up === true) {
        J.set$y$x(this.Arcade$Body0$position, J.get$y$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds()));
        t1 = this.Arcade$Body0$velocity;
        t2 = J.getInterceptor$x(t1);
        t2.set$y(t1, J.$mul$ns(t2.get$y(t1), J.$negate$n(J.get$y$x(this.Arcade$Body0$bounce))));
        this.Arcade$Body0$blocked.set$up(true);
      } else if (J.$gt$n(J.$add$ns(J.get$y$x(this.Arcade$Body0$position), this.Arcade$Body0$height), J.get$bottom$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds())) && this.Arcade$Body0$game.get$physics().get$arcade().get$checkCollision().down === true) {
        J.set$y$x(this.Arcade$Body0$position, J.$sub$n(J.get$bottom$x(this.Arcade$Body0$game.get$physics().get$arcade().get$bounds()), this.Arcade$Body0$height));
        t1 = this.Arcade$Body0$velocity;
        t2 = J.getInterceptor$x(t1);
        t2.set$y(t1, J.$mul$ns(t2.get$y(t1), J.$negate$n(J.get$y$x(this.Arcade$Body0$bounce))));
        this.Arcade$Body0$blocked.set$down(true);
      }
    }, "call$0", "get$checkWorldBounds", 0, 0, 54],
    setSize$4: [function(width, height, offsetX, offsetY) {
      if (offsetX == null)
        offsetX = J.get$x$x(this.offset);
      if (offsetY == null)
        offsetY = J.get$y$x(this.offset);
      this.sourceWidth = width;
      this.sourceHeight = height;
      this.Arcade$Body0$width = J.$mul$ns(width, this._sx);
      this.Arcade$Body0$height = J.$mul$ns(this.sourceHeight, this._sy);
      this.halfWidth = J.floor$0$n(J.$div$n(this.Arcade$Body0$width, 2));
      this.halfHeight = J.floor$0$n(J.$div$n(this.Arcade$Body0$height, 2));
      this.offset.setTo$2(offsetX, offsetY);
      this.center.setTo$2(J.$add$ns(J.get$x$x(this.Arcade$Body0$position), this.halfWidth), J.$add$ns(J.get$y$x(this.Arcade$Body0$position), this.halfHeight));
    }, function(width, height) {
      return this.setSize$4(width, height, null, null);
    }, "setSize$2", function(width, height, offsetX) {
      return this.setSize$4(width, height, offsetX, null);
    }, "setSize$3", "call$4", "call$2", "call$3", "get$setSize", 4, 4, 625, 12, 12, 31, [], 52, [], 626, [], 627, [], "setSize"],
    reset$4: [function(_, x, y, a1, a2) {
      var t1;
      this.Arcade$Body0$velocity.set$1(0);
      this.Arcade$Body0$acceleration.set$1(0);
      this.Arcade$Body0$angularVelocity = 0;
      this.angularAcceleration = 0;
      J.set$x$x(this.Arcade$Body0$position, J.$add$ns(J.$sub$n(x, J.$mul$ns(J.get$x$x(this.sprite.get$anchor()), this.Arcade$Body0$width)), J.get$x$x(this.offset)));
      J.set$y$x(this.Arcade$Body0$position, J.$add$ns(J.$sub$n(y, J.$mul$ns(J.get$y$x(this.sprite.get$anchor()), this.Arcade$Body0$height)), J.get$y$x(this.offset)));
      this.prev.x = J.get$x$x(this.Arcade$Body0$position);
      this.prev.y = J.get$y$x(this.Arcade$Body0$position);
      t1 = J.get$angle$x(this.sprite);
      this.rotation = t1;
      this.preRotation = t1;
      this._sx = J.get$x$x(J.get$scale$x(this.sprite));
      this._sy = J.get$y$x(J.get$scale$x(this.sprite));
      this.center.setTo$2(J.$add$ns(J.get$x$x(this.Arcade$Body0$position), this.halfWidth), J.$add$ns(J.get$y$x(this.Arcade$Body0$position), this.halfHeight));
    }, function($receiver, x, y, a1) {
      return this.reset$4($receiver, x, y, a1, null);
    }, "reset$3", function($receiver, x, y) {
      return this.reset$4($receiver, x, y, null, null);
    }, "reset$2", "call$4", "call$3", "call$2", "get$reset", 4, 4, 628, 12, 12, 9, [], 10, [], 445, [], 446, [], "reset"],
    hitTest$2: function(x, y) {
      return this.contains$2(0, x, y);
    },
    deltaX$0: [function(_) {
      return J.$sub$n(J.get$x$x(this.Arcade$Body0$position), this.prev.x);
    }, "call$0", "get$deltaX", 0, 0, 619],
    deltaY$0: [function(_) {
      return J.$sub$n(J.get$y$x(this.Arcade$Body0$position), this.prev.y);
    }, "call$0", "get$deltaY", 0, 0, 619],
    deltaZ$0: [function(_) {
      return J.$sub$n(this.rotation, this.preRotation);
    }, "call$0", "get$deltaZ", 0, 0, 619],
    Body$1: function(sprite) {
      var t1, t2, t3;
      this.Arcade$Body0$game = this.sprite.get$game();
      this.Arcade$Body0$type = 0;
      this.enable = true;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.offset = t1;
      t1 = J.get$x$x(this.sprite);
      t2 = J.get$y$x(this.sprite);
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      this.Arcade$Body0$position = t3;
      t3 = t3.x;
      t2 = J.get$y$x(this.Arcade$Body0$position);
      t1 = new R.Point(null, null);
      t1.x = t3;
      t1.y = t2;
      this.prev = t1;
      this.allowRotation = true;
      this.rotation = this.sprite.get$rotation();
      this.preRotation = this.sprite.get$rotation();
      this.sourceWidth = J.get$width$x(this.sprite.get$texture().get$frame());
      this.sourceHeight = J.get$height$x(this.sprite.get$texture().get$frame());
      this.Arcade$Body0$width = J.get$width$x(this.sprite);
      this.Arcade$Body0$height = J.get$height$x(this.sprite);
      this.halfWidth = J.abs$0$n(J.$div$n(J.get$width$x(this.sprite), 2));
      this.halfHeight = J.abs$0$n(J.$div$n(J.get$height$x(this.sprite), 2));
      t1 = J.$add$ns(J.get$x$x(this.sprite), this.halfWidth);
      t2 = J.$add$ns(J.get$y$x(this.sprite), this.halfHeight);
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      this.center = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.Arcade$Body0$velocity = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.newVelocity = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.deltaMax = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.Arcade$Body0$acceleration = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.Arcade$Body0$drag = t3;
      this.allowGravity = true;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.Arcade$Body0$gravity = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.Arcade$Body0$bounce = t3;
      t3 = new R.Point(null, null);
      t3.x = 10000;
      t3.y = 10000;
      this.Arcade$Body0$maxVelocity = t3;
      this.Arcade$Body0$angularVelocity = 0;
      this.angularAcceleration = 0;
      this.Arcade$Body0$angularDrag = 0;
      this.maxAngular = 1000;
      this.mass = 1;
      this.Arcade$Body0$angle = 0;
      this.Arcade$Body0$speed = 0;
      this.facing = 0;
      this.Arcade$Body0$immovable = false;
      this.Arcade$Body0$moves = true;
      this.customSeparateX = false;
      this.customSeparateY = false;
      this.overlapX = 0;
      this.overlapY = 0;
      this.embedded = false;
      this.Arcade$Body0$collideWorldBounds = false;
      t3 = R.CollisionInfo$(false, false, false, false);
      t3.none = false;
      t3.any = true;
      t3.up = true;
      t3.down = true;
      t3.left = true;
      t3.right = true;
      this.checkCollision = t3;
      t3 = R.CollisionInfo$(false, false, false, false);
      t3.none = true;
      t3.up = false;
      t3.down = false;
      t3.left = false;
      t3.right = false;
      this.Arcade$Body0$touching = t3;
      t3 = R.CollisionInfo$(false, false, false, false);
      t3.none = true;
      t3.up = false;
      t3.down = false;
      t3.left = false;
      t3.right = false;
      this.wasTouching = t3;
      t3 = R.CollisionInfo$(false, false, false, false);
      t3.up = false;
      t3.down = false;
      t3.left = false;
      t3.right = false;
      this.Arcade$Body0$blocked = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.Arcade$Body0$tilePadding = t3;
      this.Arcade$Body0$phase = 0;
      this._Arcade$_reset = true;
      this._sx = J.get$x$x(J.get$scale$x(this.sprite));
      this._sy = J.get$y$x(J.get$scale$x(this.sprite));
      this._Arcade$_dx = 0;
      this._Arcade$_dy = 0;
    },
    static: {Body$: function(sprite) {
        var t1 = new O.Body0(sprite, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, 0, 0, 0);
        t1.Body$1(sprite);
        return t1;
      }}
  },
  "+Body": 0
}],
["Ninja", "package:play_phaser/ninja.dart", , E, {
  "^": "",
  AABB: {
    "^": "Shape1;body:Ninja0$AABB$body*,Ninja0$AABB$system,pos:Ninja0$AABB$pos<,oldpos:Ninja0$AABB$oldpos<,_Ninja0$_width:Ninja0$AABB$_Ninja0$_width<,_Ninja0$_height:Ninja0$AABB$_Ninja0$_height<,Ninja0$AABB$oH,Ninja0$AABB$oV,velocity:Ninja0$AABB$velocity@,Ninja0$AABB$aabbTileProjections,body,system,pos,oldpos,_Ninja0$_width,_Ninja0$_height,oH,oV,velocity,aabbTileProjections",
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.Ninja0$AABB$body.call$3(arg0, arg1, arg2);
    },
    get$xw: function() {
      return J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_width, 2));
    },
    get$yw: function() {
      return J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_height, 2));
    },
    get$width: function(_) {
      return this.Ninja0$AABB$_Ninja0$_width;
    },
    get$height: function(_) {
      return this.Ninja0$AABB$_Ninja0$_height;
    },
    integrate$0: function() {
      var t1, px, py;
      t1 = this.Ninja0$AABB$pos;
      px = t1.x;
      py = t1.y;
      t1.x = J.$add$ns(px, J.$sub$n(J.$mul$ns(this.Ninja0$AABB$body.get$drag(), this.Ninja0$AABB$pos.x), J.$mul$ns(this.Ninja0$AABB$body.get$drag(), this.Ninja0$AABB$oldpos.x)));
      t1 = this.Ninja0$AABB$pos;
      t1.y = J.$add$ns(t1.y, J.$add$ns(J.$sub$n(J.$mul$ns(this.Ninja0$AABB$body.get$drag(), this.Ninja0$AABB$pos.y), J.$mul$ns(this.Ninja0$AABB$body.get$drag(), this.Ninja0$AABB$oldpos.y)), this.Ninja0$AABB$system.gravity * this.Ninja0$AABB$body.get$gravityScale()));
      this.Ninja0$AABB$velocity.set$2(J.$sub$n(this.Ninja0$AABB$pos.x, px), J.$sub$n(this.Ninja0$AABB$pos.y, py));
      this.Ninja0$AABB$oldpos.set$2(px, py);
    },
    reportCollisionVsWorld$4: function(px, py, dx, dy) {
      var p, o, vx, vy, t1, t2, dp, t3, nx, ny, tx, ty, fx, fy, b, bx, by;
      p = this.Ninja0$AABB$pos;
      o = this.Ninja0$AABB$oldpos;
      vx = J.$sub$n(p.x, o.x);
      vy = J.$sub$n(p.y, o.y);
      t1 = J.getInterceptor$ns(vx);
      t2 = J.getInterceptor$ns(vy);
      dp = J.$add$ns(t1.$mul(vx, dx), t2.$mul(vy, dy));
      t3 = J.getInterceptor$ns(dp);
      nx = t3.$mul(dp, dx);
      ny = t3.$mul(dp, dy);
      tx = t1.$sub(vx, nx);
      ty = t2.$sub(vy, ny);
      if (t3.$lt(dp, 0)) {
        fx = J.$mul$ns(tx, this.Ninja0$AABB$body.get$friction());
        fy = J.$mul$ns(ty, this.Ninja0$AABB$body.get$friction());
        t1 = this.Ninja0$AABB$body.get$bounce();
        if (typeof t1 !== "number")
          return H.iae(t1);
        b = 1 + t1;
        bx = J.$mul$ns(nx, b);
        by = J.$mul$ns(ny, b);
        t1 = J.getInterceptor(dx);
        if (t1.$eq(dx, 1))
          J.set$left$x(this.Ninja0$AABB$body.get$touching(), true);
        else if (t1.$eq(dx, -1))
          J.set$right$x(this.Ninja0$AABB$body.get$touching(), true);
        t1 = J.getInterceptor(dy);
        if (t1.$eq(dy, 1))
          this.Ninja0$AABB$body.get$touching().set$up(true);
        else if (t1.$eq(dy, -1))
          this.Ninja0$AABB$body.get$touching().set$down(true);
      } else {
        bx = 0;
        by = 0;
        fx = 0;
        fy = 0;
      }
      p.x = J.$add$ns(p.x, px);
      p.y = J.$add$ns(p.y, py);
      o.x = J.$add$ns(o.x, J.$add$ns(J.$add$ns(px, bx), fx));
      o.y = J.$add$ns(o.y, J.$add$ns(J.$add$ns(py, by), fy));
    },
    reverse$0: [function() {
      var vx, vy;
      vx = J.$sub$n(this.Ninja0$AABB$pos.x, this.Ninja0$AABB$oldpos.x);
      vy = J.$sub$n(this.Ninja0$AABB$pos.y, this.Ninja0$AABB$oldpos.y);
      if (J.$lt$n(this.Ninja0$AABB$oldpos.x, this.Ninja0$AABB$pos.x))
        this.Ninja0$AABB$oldpos.x = J.$add$ns(this.Ninja0$AABB$pos.x, vx);
      else if (J.$gt$n(this.Ninja0$AABB$oldpos.x, this.Ninja0$AABB$pos.x))
        this.Ninja0$AABB$oldpos.x = J.$sub$n(this.Ninja0$AABB$pos.x, vx);
      if (J.$lt$n(this.Ninja0$AABB$oldpos.y, this.Ninja0$AABB$pos.y))
        this.Ninja0$AABB$oldpos.y = J.$add$ns(this.Ninja0$AABB$pos.y, vy);
      else if (J.$gt$n(this.Ninja0$AABB$oldpos.y, this.Ninja0$AABB$pos.y))
        this.Ninja0$AABB$oldpos.y = J.$sub$n(this.Ninja0$AABB$pos.y, vy);
    }, "call$0", "get$reverse", 0, 0, 54],
    collideWorldBounds$0: [function() {
      var dx, t1, t2, dy;
      dx = J.$sub$n(this.Ninja0$AABB$system.bounds.Phaser$Rectangle1$x, J.$sub$n(this.Ninja0$AABB$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_width, 2))));
      if (typeof dx !== "number")
        return H.iae(dx);
      if (0 < dx)
        this.reportCollisionVsWorld$4(dx, 0, 1, 0);
      else {
        t1 = J.$add$ns(this.Ninja0$AABB$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_width, 2)));
        t2 = this.Ninja0$AABB$system.bounds;
        dx = J.$sub$n(t1, J.$add$ns(t2.Phaser$Rectangle1$x, t2.Phaser$Rectangle1$width));
        if (typeof dx !== "number")
          return H.iae(dx);
        if (0 < dx)
          this.reportCollisionVsWorld$4(-dx, 0, -1, 0);
      }
      dy = J.$sub$n(this.Ninja0$AABB$system.bounds.Phaser$Rectangle1$y, J.$sub$n(this.Ninja0$AABB$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_height, 2))));
      if (typeof dy !== "number")
        return H.iae(dy);
      if (0 < dy)
        this.reportCollisionVsWorld$4(0, dy, 0, 1);
      else {
        t1 = J.$add$ns(this.Ninja0$AABB$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_height, 2)));
        t2 = this.Ninja0$AABB$system.bounds;
        dy = J.$sub$n(t1, J.$add$ns(t2.Phaser$Rectangle1$y, t2.Phaser$Rectangle1$height));
        if (typeof dy !== "number")
          return H.iae(dy);
        if (0 < dy)
          this.reportCollisionVsWorld$4(0, -dy, 0, -1);
      }
    }, "call$0", "get$collideWorldBounds", 0, 0, 54],
    projAABB_Full$3: [function(x, y, obj) {
      var t1, t2, l;
      t1 = J.getInterceptor$ns(x);
      t2 = J.getInterceptor$ns(y);
      l = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(x, x), t2.$mul(y, y))));
      obj.reportCollisionVsWorld$4(x, y, t1.$div(x, l), t2.$div(y, l));
      return 1;
    }, "call$3", "get$projAABB_Full", 6, 0, 629, 9, [], 10, [], 630, []],
    projAABB_Half$4: [function(x, y, obj, t) {
      var sx, sy, t1, t2, ox, oy, dp, lenN, lenP;
      sx = t.get$signx();
      sy = t.get$signy();
      t1 = obj.get$pos().x;
      t2 = obj.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      ox = J.$sub$n(J.$sub$n(t1, sx * t2), t.get$pos().x);
      t2 = obj.get$pos().y;
      t1 = obj.get$yw();
      if (typeof t1 !== "number")
        return H.iae(t1);
      oy = J.$sub$n(J.$sub$n(t2, sy * t1), t.get$pos().y);
      dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
      t1 = J.getInterceptor$n(dp);
      if (t1.$lt(dp, 0)) {
        t2 = t1.$negate(dp);
        if (typeof t2 !== "number")
          return H.iae(t2);
        sx *= t2;
        t1 = t1.$negate(dp);
        if (typeof t1 !== "number")
          return H.iae(t1);
        sy *= t1;
        lenN = Math.sqrt(H.checkNum(sx * sx + sy * sy));
        t1 = J.getInterceptor$ns(x);
        t2 = J.getInterceptor$ns(y);
        lenP = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(x, x), t2.$mul(y, y))));
        if (lenP < lenN) {
          obj.reportCollisionVsWorld$4(x, y, t1.$div(x, lenP), t2.$div(y, lenP));
          return 1;
        } else {
          obj.reportCollisionVsWorld$4(sx, sy, t.get$signx(), t.get$signy());
          return 2;
        }
      }
      return 0;
    }, "call$4", "get$projAABB_Half", 8, 0, 631, 9, [], 10, [], 630, [], 423, []],
    projAABB_45Deg$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, ox, oy, sx, sy, dp, lenN, lenP;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = obj.get$pos().x;
      t2 = obj.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      ox = J.$sub$n(J.$sub$n(t1, signx * t2), t.get$pos().x);
      t2 = obj.get$pos().y;
      t1 = obj.get$yw();
      if (typeof t1 !== "number")
        return H.iae(t1);
      oy = J.$sub$n(J.$sub$n(t2, signy * t1), t.get$pos().y);
      sx = t.get$sx();
      sy = t.get$sy();
      dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
      t1 = J.getInterceptor$n(dp);
      if (t1.$lt(dp, 0)) {
        t2 = t1.$negate(dp);
        if (typeof t2 !== "number")
          return H.iae(t2);
        sx *= t2;
        t1 = t1.$negate(dp);
        if (typeof t1 !== "number")
          return H.iae(t1);
        sy *= t1;
        lenN = Math.sqrt(H.checkNum(sx * sx + sy * sy));
        t1 = J.getInterceptor$ns(x);
        t2 = J.getInterceptor$ns(y);
        lenP = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(x, x), t2.$mul(y, y))));
        if (lenP < lenN) {
          obj.reportCollisionVsWorld$4(x, y, t1.$div(x, lenP), t2.$div(y, lenP));
          return 1;
        } else {
          obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
          return 2;
        }
      }
      return 0;
    }, "call$4", "get$projAABB_45Deg", 8, 0, 631, 9, [], 10, [], 630, [], 423, []],
    projAABB_22DegS$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, py, penY, t3, t4, ox, oy, sx, sy, dp, lenN, lenP, aY;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = obj.get$pos().y;
      t2 = obj.get$yw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      py = J.$sub$n(t1, signy * t2);
      penY = J.$sub$n(t.get$pos().y, py);
      t1 = J.getInterceptor$ns(penY);
      t2 = t1.$mul(penY, signy);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (0 < t2) {
        t2 = obj.get$pos().x;
        t3 = obj.get$xw();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t3 = J.$sub$n(t2, signx * t3);
        t2 = t.get$pos().x;
        t4 = t.get$xw();
        if (typeof t4 !== "number")
          return H.iae(t4);
        ox = J.$sub$n(t3, J.$add$ns(t2, signx * t4));
        t4 = obj.get$pos().y;
        t2 = obj.get$yw();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = J.$sub$n(t4, signy * t2);
        t4 = t.get$pos().y;
        t3 = t.get$yw();
        if (typeof t3 !== "number")
          return H.iae(t3);
        oy = J.$sub$n(t2, J.$sub$n(t4, signy * t3));
        sx = t.get$sx();
        sy = t.get$sy();
        dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
        t2 = J.getInterceptor$n(dp);
        if (t2.$lt(dp, 0)) {
          t3 = t2.$negate(dp);
          if (typeof t3 !== "number")
            return H.iae(t3);
          sx *= t3;
          t2 = t2.$negate(dp);
          if (typeof t2 !== "number")
            return H.iae(t2);
          sy *= t2;
          lenN = Math.sqrt(H.checkNum(sx * sx + sy * sy));
          t2 = J.getInterceptor$ns(x);
          t3 = J.getInterceptor$ns(y);
          lenP = Math.sqrt(H.checkNum(J.$add$ns(t2.$mul(x, x), t3.$mul(y, y))));
          aY = t1.abs$0(penY);
          if (lenP < lenN)
            if (J.$lt$n(aY, lenP)) {
              obj.reportCollisionVsWorld$4(0, penY, 0, t1.$div(penY, aY));
              return 2;
            } else {
              obj.reportCollisionVsWorld$4(x, y, t2.$div(x, lenP), t3.$div(y, lenP));
              return 1;
            }
          else if (J.$lt$n(aY, lenN)) {
            obj.reportCollisionVsWorld$4(0, penY, 0, t1.$div(penY, aY));
            return 2;
          } else {
            obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
            return 2;
          }
        }
      }
      return 0;
    }, "call$4", "get$projAABB_22DegS", 8, 0, 631, 9, [], 10, [], 630, [], 423, []],
    projAABB_22DegB$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, t3, ox, oy, sx, sy, dp, lenN, lenP;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = obj.get$pos().x;
      t2 = obj.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = J.$sub$n(t1, signx * t2);
      t1 = t.get$pos().x;
      t3 = t.get$xw();
      if (typeof t3 !== "number")
        return H.iae(t3);
      ox = J.$sub$n(t2, J.$sub$n(t1, signx * t3));
      t3 = obj.get$pos().y;
      t1 = obj.get$yw();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = J.$sub$n(t3, signy * t1);
      t3 = t.get$pos().y;
      t2 = t.get$yw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      oy = J.$sub$n(t1, J.$add$ns(t3, signy * t2));
      sx = t.get$sx();
      sy = t.get$sy();
      dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
      t1 = J.getInterceptor$n(dp);
      if (t1.$lt(dp, 0)) {
        t2 = t1.$negate(dp);
        if (typeof t2 !== "number")
          return H.iae(t2);
        sx *= t2;
        t1 = t1.$negate(dp);
        if (typeof t1 !== "number")
          return H.iae(t1);
        sy *= t1;
        lenN = Math.sqrt(H.checkNum(sx * sx + sy * sy));
        t1 = J.getInterceptor$ns(x);
        t2 = J.getInterceptor$ns(y);
        lenP = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(x, x), t2.$mul(y, y))));
        if (lenP < lenN) {
          obj.reportCollisionVsWorld$4(x, y, t1.$div(x, lenP), t2.$div(y, lenP));
          return 1;
        } else {
          obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
          return 2;
        }
      }
      return 0;
    }, "call$4", "get$projAABB_22DegB", 8, 0, 631, 9, [], 10, [], 630, [], 423, []],
    projAABB_67DegS$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, px, penX, t3, t4, ox, oy, sx, sy, dp, lenN, lenP, aX;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = obj.get$pos().x;
      t2 = obj.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      px = J.$sub$n(t1, signx * t2);
      penX = J.$sub$n(t.get$pos().x, px);
      t1 = J.getInterceptor$ns(penX);
      t2 = t1.$mul(penX, signx);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (0 < t2) {
        t2 = obj.get$pos().x;
        t3 = obj.get$xw();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t3 = J.$sub$n(t2, signx * t3);
        t2 = t.get$pos().x;
        t4 = t.get$xw();
        if (typeof t4 !== "number")
          return H.iae(t4);
        ox = J.$sub$n(t3, J.$sub$n(t2, signx * t4));
        t4 = obj.get$pos().y;
        t2 = obj.get$yw();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = J.$sub$n(t4, signy * t2);
        t4 = t.get$pos().y;
        t3 = t.get$yw();
        if (typeof t3 !== "number")
          return H.iae(t3);
        oy = J.$sub$n(t2, J.$add$ns(t4, signy * t3));
        sx = t.get$sx();
        sy = t.get$sy();
        dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
        t2 = J.getInterceptor$n(dp);
        if (t2.$lt(dp, 0)) {
          t3 = t2.$negate(dp);
          if (typeof t3 !== "number")
            return H.iae(t3);
          sx *= t3;
          t2 = t2.$negate(dp);
          if (typeof t2 !== "number")
            return H.iae(t2);
          sy *= t2;
          lenN = Math.sqrt(H.checkNum(sx * sx + sy * sy));
          t2 = J.getInterceptor$ns(x);
          t3 = J.getInterceptor$ns(y);
          lenP = Math.sqrt(H.checkNum(J.$add$ns(t2.$mul(x, x), t3.$mul(y, y))));
          aX = t1.abs$0(penX);
          if (lenP < lenN)
            if (J.$lt$n(aX, lenP)) {
              obj.reportCollisionVsWorld$4(penX, 0, t1.$div(penX, aX), 0);
              return 2;
            } else {
              obj.reportCollisionVsWorld$4(x, y, t2.$div(x, lenP), t3.$div(y, lenP));
              return 1;
            }
          else if (J.$lt$n(aX, lenN)) {
            obj.reportCollisionVsWorld$4(penX, 0, t1.$div(penX, aX), 0);
            return 2;
          } else {
            obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
            return 2;
          }
        }
      }
      return 0;
    }, "call$4", "get$projAABB_67DegS", 8, 0, 631, 9, [], 10, [], 630, [], 423, []],
    projAABB_67DegB$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, t3, ox, oy, sx, sy, dp, lenN, lenP;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = obj.get$pos().x;
      t2 = obj.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = J.$sub$n(t1, signx * t2);
      t1 = t.get$pos().x;
      t3 = t.get$xw();
      if (typeof t3 !== "number")
        return H.iae(t3);
      ox = J.$sub$n(t2, J.$add$ns(t1, signx * t3));
      t3 = obj.get$pos().y;
      t1 = obj.get$yw();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = J.$sub$n(t3, signy * t1);
      t3 = t.get$pos().y;
      t2 = t.get$yw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      oy = J.$sub$n(t1, J.$sub$n(t3, signy * t2));
      sx = t.get$sx();
      sy = t.get$sy();
      dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
      t1 = J.getInterceptor$n(dp);
      if (t1.$lt(dp, 0)) {
        t2 = t1.$negate(dp);
        if (typeof t2 !== "number")
          return H.iae(t2);
        sx *= t2;
        t1 = t1.$negate(dp);
        if (typeof t1 !== "number")
          return H.iae(t1);
        sy *= t1;
        lenN = Math.sqrt(H.checkNum(sx * sx + sy * sy));
        t1 = J.getInterceptor$ns(x);
        t2 = J.getInterceptor$ns(y);
        lenP = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(x, x), t2.$mul(y, y))));
        if (lenP < lenN) {
          obj.reportCollisionVsWorld$4(x, y, t1.$div(x, lenP), t2.$div(y, lenP));
          return 1;
        } else {
          obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
          return 2;
        }
      }
      return 0;
    }, "call$4", "get$projAABB_67DegB", 8, 0, 631, 9, [], 10, [], 630, [], 423, []],
    projAABB_Convex$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, t3, ox, oy, len, twid, pen, lenP;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = obj.get$pos().x;
      t2 = obj.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = J.$sub$n(t1, signx * t2);
      t1 = t.get$pos().x;
      t3 = t.get$xw();
      if (typeof t3 !== "number")
        return H.iae(t3);
      ox = J.$sub$n(t2, J.$sub$n(t1, signx * t3));
      t3 = obj.get$pos().y;
      t1 = obj.get$yw();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = J.$sub$n(t3, signy * t1);
      t3 = t.get$pos().y;
      t2 = t.get$yw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      oy = J.$sub$n(t1, J.$sub$n(t3, signy * t2));
      t2 = J.getInterceptor$ns(oy);
      len = Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(ox, ox), t2.$mul(oy, oy))));
      twid = J.$mul$ns(t.get$xw(), 2);
      pen = Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(twid, twid), 0))) - len;
      if (typeof ox !== "number")
        return H.iae(ox);
      if (!(signx * ox < 0)) {
        if (typeof oy !== "number")
          return H.iae(oy);
        t1 = signy * oy < 0;
      } else
        t1 = true;
      if (t1) {
        t1 = J.getInterceptor$ns(x);
        t2 = J.getInterceptor$ns(y);
        lenP = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(x, x), t2.$mul(y, y))));
        obj.reportCollisionVsWorld$4(x, y, t1.$div(x, lenP), t2.$div(y, lenP));
        return 1;
      } else if (0 < pen) {
        ox /= len;
        oy = t2.$div(oy, len);
        obj.reportCollisionVsWorld$4(ox * pen, J.$mul$ns(oy, pen), ox, oy);
        return 2;
      }
      return 0;
    }, "call$4", "get$projAABB_Convex", 8, 0, 631, 9, [], 10, [], 630, [], 423, []],
    projAABB_Concave$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, t3, ox, oy, twid, rad, len, pen, t4, lenP;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = t.get$pos().x;
      t2 = t.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = J.$add$ns(t1, signx * t2);
      t1 = obj.get$pos().x;
      t3 = obj.get$xw();
      if (typeof t3 !== "number")
        return H.iae(t3);
      ox = J.$sub$n(t2, J.$sub$n(t1, signx * t3));
      t3 = t.get$pos().y;
      t1 = t.get$yw();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = J.$add$ns(t3, signy * t1);
      t3 = obj.get$pos().y;
      t2 = obj.get$yw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      oy = J.$sub$n(t1, J.$sub$n(t3, signy * t2));
      twid = J.$mul$ns(t.get$xw(), 2);
      rad = Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(twid, twid), 0)));
      t2 = J.getInterceptor$ns(ox);
      t3 = J.getInterceptor$ns(oy);
      len = Math.sqrt(H.checkNum(J.$add$ns(t2.$mul(ox, ox), t3.$mul(oy, oy))));
      pen = len - rad;
      if (0 < pen) {
        t1 = J.getInterceptor$ns(x);
        t4 = J.getInterceptor$ns(y);
        lenP = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(x, x), t4.$mul(y, y))));
        if (lenP < pen) {
          obj.reportCollisionVsWorld$4(x, y, t1.$div(x, lenP), t4.$div(y, lenP));
          return 1;
        } else {
          ox = t2.$div(ox, len);
          oy = t3.$div(oy, len);
          obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
          return 2;
        }
      }
      return 0;
    }, "call$4", "get$projAABB_Concave", 8, 0, 631, 9, [], 10, [], 630, [], 423, []],
    destroy$0: function() {
      this.Ninja0$AABB$body = null;
      this.Ninja0$AABB$system = null;
    },
    render$5: [function(context, xOffset, yOffset, color, filled) {
      var left, $top, t1;
      left = J.$sub$n(J.$sub$n(this.Ninja0$AABB$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_width, 2))), xOffset);
      $top = J.$sub$n(J.$sub$n(this.Ninja0$AABB$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_height, 2))), yOffset);
      t1 = J.getInterceptor$x(context);
      if (filled === true) {
        t1.set$fillStyle(context, color);
        t1.fillRect$4(context, left, $top, this.Ninja0$AABB$_Ninja0$_width, this.Ninja0$AABB$_Ninja0$_height);
      } else {
        t1.set$strokeStyle(context, color);
        t1.strokeRect$4(context, left, $top, this.Ninja0$AABB$_Ninja0$_width, this.Ninja0$AABB$_Ninja0$_height);
      }
    }, "call$5", "get$render", 10, 0, 632, 142, [], 336, [], 337, [], 152, [], 623, []],
    AABB$5: function(body, x, y, width, height) {
      var t1;
      this.Ninja0$AABB$body = body;
      this.Ninja0$AABB$system = body.system;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.Ninja0$AABB$pos = t1;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.Ninja0$AABB$oldpos = t1;
      this.Ninja0$AABB$_Ninja0$_width = width;
      this.Ninja0$AABB$_Ninja0$_height = height;
      this.Ninja0$AABB$oH = 0;
      this.Ninja0$AABB$oV = 0;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.Ninja0$AABB$velocity = t1;
      t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      this.Ninja0$AABB$aabbTileProjections = t1;
      t1.$indexSet(0, 1, this.get$projAABB_Full());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 2, this.get$projAABB_45Deg());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 6, this.get$projAABB_Concave());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 10, this.get$projAABB_Convex());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 14, this.get$projAABB_22DegS());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 18, this.get$projAABB_22DegB());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 22, this.get$projAABB_67DegS());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 26, this.get$projAABB_67DegB());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 30, this.get$projAABB_Half());
    },
    static: {"^": "AABB_COL_NONE,AABB_COL_AXIS,AABB_COL_OTHER"}
  },
  "+AABB": 0,
  Body2: {
    "^": "Body;sprite@,game:Ninja0$Body2$game@-613,type:Ninja0$Body2$type*-614,system,aabb<,tile,circle@,shape,drag:Ninja0$Body2$drag@-616,friction<,gravityScale<,bounce:Ninja0$Body2$bounce@-616,velocity:Ninja0$Body2$velocity@-615,facing,immovable:Ninja0$Body2$immovable@-617,collideWorldBounds:Ninja0$Body2$collideWorldBounds@-617,checkCollision<,touching:Ninja0$Body2$touching@-618,wasTouching,maxSpeed,game-613,position-615,tilePadding-615,Phaser$Body$width-616,Phaser$Body$height-616,velocity-615,acceleration-615,maxVelocity-615,collideWorldBounds-617,bounce-12,type-614,angularVelocity-616,gravity-615,drag-12,angularDrag-616,immovable-617,Phaser$Body$x-616,Phaser$Body$y-616,speed-616,blocked-618,angle-616,moves-617,phase-614,_reset-617,safeRemove-617,touching-618,Phaser$Rectangle1$x-616,Phaser$Rectangle1$y-616,Phaser$Rectangle1$width-616,Phaser$Rectangle1$height-616,x-616,y-616,width-616,height-616",
    sprite$3: function(arg0, arg1, arg2) {
      return this.sprite.call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.sprite.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.sprite.call$4(arg0, arg1, arg2, arg3);
    },
    circle$4: function(arg0, arg1, arg2, arg3) {
      return this.circle.call$4(arg0, arg1, arg2, arg3);
    },
    preUpdate$0: [function() {
      this.wasTouching.none = this.Ninja0$Body2$touching.get$none();
      this.wasTouching.up = this.Ninja0$Body2$touching.get$up();
      this.wasTouching.down = this.Ninja0$Body2$touching.get$down();
      this.wasTouching.left = J.get$left$x(this.Ninja0$Body2$touching);
      this.wasTouching.right = J.get$right$x(this.Ninja0$Body2$touching);
      this.Ninja0$Body2$touching.set$none(true);
      this.Ninja0$Body2$touching.set$up(false);
      this.Ninja0$Body2$touching.set$down(false);
      J.set$left$x(this.Ninja0$Body2$touching, false);
      J.set$right$x(this.Ninja0$Body2$touching, false);
      this.shape.integrate$0();
      if (this.Ninja0$Body2$collideWorldBounds === true)
        this.shape.collideWorldBounds$0();
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    setSize$4: [function(width, height, offsetX, offsetY) {
      throw H.wrapException(P.Exception_Exception("Do not use it!"));
    }, function(width, height) {
      return this.setSize$4(width, height, null, null);
    }, "setSize$2", function(width, height, offsetX) {
      return this.setSize$4(width, height, offsetX, null);
    }, "setSize$3", "call$4", "call$2", "call$3", "get$setSize", 4, 4, 625, 12, 12, 31, [], 52, [], 626, [], 627, [], "setSize"],
    removeFromWorld$0: [function() {
      throw H.wrapException(P.Exception_Exception("Do not use it!"));
    }, "call$0", "get$removeFromWorld", 0, 0, 54, "removeFromWorld"],
    addToWorld$0: [function() {
      throw H.wrapException(P.Exception_Exception("Do not use it!"));
    }, "call$0", "get$addToWorld", 0, 0, 54, "addToWorld"],
    updateBounds$0: function() {
      throw H.wrapException(P.Exception_Exception("Do not use it!"));
    },
    postUpdate$0: [function() {
      var t1, t2, t3;
      t1 = this.sprite;
      if (t1 != null) {
        t1 = J.$eq(J.get$type$x(t1), 5);
        t2 = this.sprite;
        t3 = this.shape;
        if (t1) {
          J.set$x$x(t2, J.$sub$n(t3.get$pos().x, this.shape.get$xw()));
          J.set$y$x(this.sprite, J.$sub$n(this.shape.get$pos().y, this.shape.get$yw()));
        } else {
          J.set$x$x(t2, t3.get$pos().x);
          J.set$y$x(this.sprite, this.shape.get$pos().y);
        }
      }
      if (J.$lt$n(J.get$x$x(this.Ninja0$Body2$velocity), 0))
        this.facing = 1;
      else if (J.$gt$n(J.get$x$x(this.Ninja0$Body2$velocity), 0))
        this.facing = 2;
      if (J.$lt$n(J.get$y$x(this.Ninja0$Body2$velocity), 0))
        this.facing = 3;
      else if (J.$gt$n(J.get$y$x(this.Ninja0$Body2$velocity), 0))
        this.facing = 4;
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    moveTo$2: function(_, speed, angle) {
      var magnitude, t1;
      magnitude = J.$mul$ns(speed, this.Ninja0$Body2$game.get$time().get$physicsElapsed());
      angle = J.$mul$ns(angle, 0.017453292519943295);
      t1 = J.getInterceptor$ns(magnitude);
      this.shape.get$pos().x = J.$add$ns(this.shape.get$oldpos().x, t1.$mul(magnitude, Math.cos(H.checkNum(angle))));
      this.shape.get$pos().y = J.$add$ns(this.shape.get$oldpos().y, t1.$mul(magnitude, Math.sin(H.checkNum(angle))));
    },
    moveLeft$1: [function(speed) {
      var fx, t1, t2, t3;
      fx = J.$mul$ns(J.$negate$n(speed), this.Ninja0$Body2$game.get$time().get$physicsElapsed());
      t1 = this.shape.get$pos();
      t2 = this.shape.get$oldpos().x;
      t3 = this.maxSpeed;
      t1.x = J.$add$ns(t2, P.min(t3, P.max(-t3, J.$add$ns(J.$sub$n(this.shape.get$pos().x, this.shape.get$oldpos().x), fx))));
    }, "call$1", "get$moveLeft", 2, 0, 620, 624, [], "moveLeft"],
    moveRight$1: [function(speed) {
      var fx, t1, t2, t3;
      fx = J.$mul$ns(speed, this.Ninja0$Body2$game.get$time().get$physicsElapsed());
      t1 = this.shape.get$pos();
      t2 = this.shape.get$oldpos().x;
      t3 = this.maxSpeed;
      t1.x = J.$add$ns(t2, P.min(t3, P.max(-t3, J.$add$ns(J.$sub$n(this.shape.get$pos().x, this.shape.get$oldpos().x), fx))));
    }, "call$1", "get$moveRight", 2, 0, 620, 624, [], "moveRight"],
    moveUp$1: [function(speed) {
      var fx, t1, t2, t3;
      fx = J.$mul$ns(J.$negate$n(speed), this.Ninja0$Body2$game.get$time().get$physicsElapsed());
      t1 = this.shape.get$pos();
      t2 = this.shape.get$oldpos().y;
      t3 = this.maxSpeed;
      t1.y = J.$add$ns(t2, P.min(t3, P.max(-t3, J.$add$ns(J.$sub$n(this.shape.get$pos().y, this.shape.get$oldpos().y), fx))));
    }, "call$1", "get$moveUp", 2, 0, 620, 624, [], "moveUp"],
    moveDown$1: [function(speed) {
      var fx, t1, t2, t3;
      fx = J.$mul$ns(speed, this.Ninja0$Body2$game.get$time().get$physicsElapsed());
      t1 = this.shape.get$pos();
      t2 = this.shape.get$oldpos().y;
      t3 = this.maxSpeed;
      t1.y = J.$add$ns(t2, P.min(t3, P.max(-t3, J.$add$ns(J.$sub$n(this.shape.get$pos().y, this.shape.get$oldpos().y), fx))));
    }, "call$1", "get$moveDown", 2, 0, 620, 624, [], "moveDown"],
    reset$4: [function(_, x, y, a1, a2) {
      var t1, t2;
      this.Ninja0$Body2$velocity.set$1(0);
      this.shape.get$pos().x = J.get$x$x(this.sprite);
      this.shape.get$pos().y = J.get$y$x(this.sprite);
      t1 = this.shape.get$oldpos();
      t2 = this.shape.get$pos();
      t1.setTo$2(t2.x, t2.y);
    }, function($receiver, x, y, a1) {
      return this.reset$4($receiver, x, y, a1, null);
    }, "reset$3", function($receiver, x, y) {
      return this.reset$4($receiver, x, y, null, null);
    }, "reset$2", "call$4", "call$3", "call$2", "get$reset", 4, 4, 628, 12, 12, 9, [], 10, [], 445, [], 446, [], "reset"],
    renderBodyInfo$1: function(debug) {
      var t1, t2, t3, t4;
      t1 = "x: " + J.toStringAsFixed$1$n(this.shape.get$pos().x, 2);
      t2 = "y: " + J.toStringAsFixed$1$n(this.shape.get$pos().y, 2);
      t3 = this.shape;
      t3 = C.JSString_methods.$add("width: ", J.toString$0(t3.get$width(t3)));
      t4 = this.shape;
      debug.line$1([t1, t2, t3, C.JSString_methods.$add("height: ", J.toString$0(t4.get$height(t4)))]);
      debug.line$1(["velocity x: " + J.toStringAsFixed$1$n(J.get$x$x(this.Ninja0$Body2$velocity), 2), "y: " + J.toStringAsFixed$1$n(J.get$y$x(this.Ninja0$Body2$velocity), 2), "deltaX: " + J.toStringAsFixed$1$n(this.shape.get$pos().x, 2), "deltaY: " + J.toStringAsFixed$1$n(this.shape.get$pos().y, 2)]);
      debug.line$1(["acceleration x: " + J.toStringAsFixed$1$n(J.get$x$x(this.acceleration), 2), "y: " + J.toStringAsFixed$1$n(J.get$y$x(this.acceleration), 2), "speed: " + C.JSDouble_methods.toStringAsFixed$1(Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(this.shape.get$velocity().x, this.shape.get$velocity().x), J.$mul$ns(this.shape.get$velocity().y, this.shape.get$velocity().y)))), 2), "angle: " + C.JSDouble_methods.toStringAsFixed$1(this.get$angle(this), 2)]);
      debug.line$1([C.JSString_methods.$add("gravity x: ", J.toString$0(J.get$x$x(this.gravity))), C.JSString_methods.$add("y: ", J.toString$0(J.get$y$x(this.gravity))), "bounce: " + J.toStringAsFixed$1$n(this.Ninja0$Body2$bounce, 2)]);
      debug.line$1([C.JSString_methods.$add("touching left: ", J.toString$0(J.get$left$x(this.Ninja0$Body2$touching))), C.JSString_methods.$add("right: ", J.toString$0(J.get$right$x(this.Ninja0$Body2$touching))), C.JSString_methods.$add("up: ", J.toString$0(this.Ninja0$Body2$touching.get$up())), C.JSString_methods.$add("down: ", J.toString$0(this.Ninja0$Body2$touching.get$down()))]);
      debug.line$1([C.JSString_methods.$add("blocked left: ", J.toString$0(J.get$left$x(this.blocked))), C.JSString_methods.$add("right: ", J.toString$0(J.get$right$x(this.blocked))), C.JSString_methods.$add("up: ", J.toString$0(this.blocked.get$up())), C.JSString_methods.$add("down: ", J.toString$0(this.blocked.get$down()))]);
    },
    deltaX$0: [function(_) {
      return J.$sub$n(this.shape.get$pos().x, this.shape.get$oldpos().x);
    }, "call$0", "get$deltaX", 0, 0, 54],
    deltaY$0: [function(_) {
      return J.$sub$n(this.shape.get$pos().y, this.shape.get$oldpos().y);
    }, "call$0", "get$deltaY", 0, 0, 54],
    destroy$0: [function() {
      this.sprite = null;
      this.system = null;
      this.aabb = null;
      this.tile = null;
      this.circle = null;
      this.shape.destroy$0();
      this.shape = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    get$x: [function(_) {
      return this.shape.get$pos().x;
    }, null, null, 1, 0, 619, "x"],
    set$x: [function(_, value) {
      this.shape.get$pos().x = value;
    }, null, null, 3, 0, 620, 138, [], "x"],
    get$y: [function(_) {
      return this.shape.get$pos().y;
    }, null, null, 1, 0, 619, "y"],
    set$y: [function(_, value) {
      this.shape.get$pos().y = value;
    }, null, null, 3, 0, 620, 138, [], "y"],
    get$width: [function(_) {
      var t1 = this.shape;
      return t1.get$width(t1);
    }, null, null, 1, 0, 619, "width"],
    get$height: [function(_) {
      var t1 = this.shape;
      return t1.get$height(t1);
    }, null, null, 1, 0, 619, "height"],
    get$bottom: [function(_) {
      return J.$add$ns(this.shape.get$pos().y, this.shape.get$yw());
    }, null, null, 1, 0, 619, "bottom"],
    get$right: [function(_) {
      return J.$add$ns(this.shape.get$pos().x, this.shape.get$xw());
    }, null, null, 1, 0, 619, "right"],
    get$speed: [function() {
      return Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(this.shape.get$velocity().x, this.shape.get$velocity().x), J.$mul$ns(this.shape.get$velocity().y, this.shape.get$velocity().y))));
    }, null, null, 1, 0, 619, "speed"],
    get$angle: [function(_) {
      var t1, t2;
      t1 = this.shape.get$velocity().y;
      t2 = this.shape.get$velocity().x;
      return Math.atan2(H.checkNum(t1), H.checkNum(t2));
    }, null, null, 1, 0, 619, "angle"],
    angle$0: function($receiver) {
      return this.get$angle(this).call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.get$angle(this).call$2(arg0, arg1);
    },
    render$3: [function(context, color, filled) {
      if (filled == null)
        filled = true;
      if (this.aabb != null || this.circle != null)
        this.shape.render$5(context, J.get$x$x(this.Ninja0$Body2$game.get$camera()), J.get$y$x(this.Ninja0$Body2$game.get$camera()), color, filled);
    }, function(context) {
      return this.render$3(context, "rgba(0,255,0,0.4)", true);
    }, "render$1", function(context, color) {
      return this.render$3(context, color, true);
    }, "render$2", "call$3", "call$1", "call$2", "get$render", 2, 4, 633, 622, 78, 142, [], 152, [], 623, []],
    Body$9: function(system, sprite, type, id, radius, x, y, width, height) {
      var t1;
      this.sprite = sprite;
      this.Ninja0$Body2$game = system.game;
      this.Ninja0$Body2$type = 2;
      this.system = system;
      this.aabb = null;
      this.tile = null;
      this.circle = null;
      this.shape = null;
      this.Ninja0$Body2$drag = 1;
      this.friction = 0.05;
      this.gravityScale = 1;
      this.Ninja0$Body2$bounce = 0.3;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.Ninja0$Body2$velocity = t1;
      this.facing = 0;
      this.Ninja0$Body2$immovable = false;
      this.Ninja0$Body2$collideWorldBounds = true;
      this.checkCollision = R.CollisionInfo$(true, true, true, true);
      this.Ninja0$Body2$touching = R.CollisionInfo$(false, false, false, false);
      this.wasTouching = R.CollisionInfo$(false, false, false, false);
      this.maxSpeed = 8;
      if (sprite != null) {
        t1 = J.getInterceptor$x(sprite);
        x = t1.get$x(sprite);
        y = t1.get$y(sprite);
        width = t1.get$width(sprite);
        height = t1.get$height(sprite);
        if (J.$eq(J.get$x$x(sprite.get$anchor()), 0))
          x = J.$add$ns(x, J.$mul$ns(t1.get$width(sprite), 0.5));
        if (J.$eq(J.get$y$x(sprite.get$anchor()), 0))
          y = J.$add$ns(y, J.$mul$ns(t1.get$height(sprite), 0.5));
      }
      t1 = J.getInterceptor(type);
      if (t1.$eq(type, 1)) {
        t1 = new E.AABB(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.AABB$5(this, x, y, width, height);
        this.aabb = t1;
        this.shape = t1;
      } else if (t1.$eq(type, 2)) {
        t1 = new E.Circle1(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Circle$4(this, x, y, radius);
        this.circle = t1;
        this.shape = t1;
      } else if (t1.$eq(type, 3)) {
        t1 = new E.Tile1(null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Tile$6(this, x, y, width, height, id);
        this.tile = t1;
        this.shape = t1;
      }
    }
  },
  "+Body": 0,
  Circle1: {
    "^": "Shape1;body:Ninja0$Circle1$body*,Ninja0$Circle1$system,pos:Ninja0$Circle1$pos<,oldpos:Ninja0$Circle1$oldpos<,_Ninja0$_width:Ninja0$Circle1$_Ninja0$_width<,_Ninja0$_height:Ninja0$Circle1$_Ninja0$_height<,Ninja0$Circle1$oH,Ninja0$Circle1$oV,velocity:Ninja0$Circle1$velocity@,circleTileProjections,radius@,body,system,pos,oldpos,_Ninja0$_width,_Ninja0$_height,oH,oV,velocity,aabbTileProjections",
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.Ninja0$Circle1$body.call$3(arg0, arg1, arg2);
    },
    get$xw: function() {
      return this.radius;
    },
    get$yw: function() {
      return this.radius;
    },
    get$width: function(_) {
      return this.Ninja0$Circle1$_Ninja0$_width;
    },
    get$height: function(_) {
      return this.Ninja0$Circle1$_Ninja0$_height;
    },
    integrate$0: function() {
      var t1, px, py;
      t1 = this.Ninja0$Circle1$pos;
      px = t1.x;
      py = t1.y;
      t1.x = J.$add$ns(px, J.$sub$n(J.$mul$ns(this.Ninja0$Circle1$body.get$drag(), this.Ninja0$Circle1$pos.x), J.$mul$ns(this.Ninja0$Circle1$body.get$drag(), this.Ninja0$Circle1$oldpos.x)));
      t1 = this.Ninja0$Circle1$pos;
      t1.y = J.$add$ns(t1.y, J.$add$ns(J.$sub$n(J.$mul$ns(this.Ninja0$Circle1$body.get$drag(), this.Ninja0$Circle1$pos.y), J.$mul$ns(this.Ninja0$Circle1$body.get$drag(), this.Ninja0$Circle1$oldpos.y)), this.Ninja0$Circle1$system.gravity * this.Ninja0$Circle1$body.get$gravityScale()));
      this.Ninja0$Circle1$velocity.set$2(J.$sub$n(this.Ninja0$Circle1$pos.x, px), J.$sub$n(this.Ninja0$Circle1$pos.y, py));
      this.Ninja0$Circle1$oldpos.set$2(px, py);
    },
    reportCollisionVsWorld$4: function(px, py, dx, dy) {
      var p, o, vx, vy, t1, t2, dp, t3, nx, ny, tx, ty, fx, fy, b, bx, by;
      p = this.Ninja0$Circle1$pos;
      o = this.Ninja0$Circle1$oldpos;
      vx = J.$sub$n(p.x, o.x);
      vy = J.$sub$n(p.y, o.y);
      t1 = J.getInterceptor$ns(vx);
      t2 = J.getInterceptor$ns(vy);
      dp = J.$add$ns(t1.$mul(vx, dx), t2.$mul(vy, dy));
      t3 = J.getInterceptor$ns(dp);
      nx = t3.$mul(dp, dx);
      ny = t3.$mul(dp, dy);
      tx = t1.$sub(vx, nx);
      ty = t2.$sub(vy, ny);
      if (t3.$lt(dp, 0)) {
        fx = J.$mul$ns(tx, this.Ninja0$Circle1$body.get$friction());
        fy = J.$mul$ns(ty, this.Ninja0$Circle1$body.get$friction());
        t1 = this.Ninja0$Circle1$body.get$bounce();
        if (typeof t1 !== "number")
          return H.iae(t1);
        b = 1 + t1;
        bx = J.$mul$ns(nx, b);
        by = J.$mul$ns(ny, b);
        t1 = J.getInterceptor(dx);
        if (t1.$eq(dx, 1))
          J.set$left$x(this.Ninja0$Circle1$body.get$touching(), true);
        else if (t1.$eq(dx, -1))
          J.set$right$x(this.Ninja0$Circle1$body.get$touching(), true);
        t1 = J.getInterceptor(dy);
        if (t1.$eq(dy, 1))
          this.Ninja0$Circle1$body.get$touching().set$up(true);
        else if (t1.$eq(dy, -1))
          this.Ninja0$Circle1$body.get$touching().set$down(true);
      } else {
        bx = 0;
        by = 0;
        fx = 0;
        fy = 0;
      }
      p.x = J.$add$ns(p.x, px);
      p.y = J.$add$ns(p.y, py);
      o.x = J.$add$ns(o.x, J.$add$ns(J.$add$ns(px, bx), fx));
      o.y = J.$add$ns(o.y, J.$add$ns(J.$add$ns(py, by), fy));
    },
    collideWorldBounds$0: [function() {
      var dx, t1, t2, dy;
      dx = J.$sub$n(this.Ninja0$Circle1$system.bounds.Phaser$Rectangle1$x, J.$sub$n(this.Ninja0$Circle1$pos.x, this.radius));
      if (typeof dx !== "number")
        return H.iae(dx);
      if (0 < dx)
        this.reportCollisionVsWorld$4(dx, 0, 1, 0);
      else {
        t1 = J.$add$ns(this.Ninja0$Circle1$pos.x, this.radius);
        t2 = this.Ninja0$Circle1$system.bounds;
        dx = J.$sub$n(t1, J.$add$ns(t2.Phaser$Rectangle1$x, t2.Phaser$Rectangle1$width));
        if (typeof dx !== "number")
          return H.iae(dx);
        if (0 < dx)
          this.reportCollisionVsWorld$4(-dx, 0, -1, 0);
      }
      dy = J.$sub$n(this.Ninja0$Circle1$system.bounds.Phaser$Rectangle1$y, J.$sub$n(this.Ninja0$Circle1$pos.y, this.radius));
      if (typeof dy !== "number")
        return H.iae(dy);
      if (0 < dy)
        this.reportCollisionVsWorld$4(0, dy, 0, 1);
      else {
        t1 = J.$add$ns(this.Ninja0$Circle1$pos.y, this.radius);
        t2 = this.Ninja0$Circle1$system.bounds;
        dy = J.$sub$n(t1, J.$add$ns(t2.Phaser$Rectangle1$y, t2.Phaser$Rectangle1$height));
        if (typeof dy !== "number")
          return H.iae(dy);
        if (0 < dy)
          this.reportCollisionVsWorld$4(0, -dy, 0, -1);
      }
    }, "call$0", "get$collideWorldBounds", 0, 0, 54],
    projCircle_Full$6: [function(x, y, oH, oV, obj, t) {
      var t1, t2, vx, vy, dx, dy, t3, t4, len, pen;
      t1 = J.getInterceptor(oH);
      if (t1.$eq(oH, 0))
        if (J.$eq(oV, 0)) {
          t1 = J.getInterceptor$n(x);
          if (t1.$lt(x, y))
            if (J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0)) {
              obj.reportCollisionVsWorld$4(t1.$negate(x), 0, -1, 0);
              return 1;
            } else {
              obj.reportCollisionVsWorld$4(x, 0, 1, 0);
              return 1;
            }
          else if (J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0)) {
            obj.reportCollisionVsWorld$4(0, J.$negate$n(y), 0, -1);
            return 1;
          } else {
            obj.reportCollisionVsWorld$4(0, y, 0, 1);
            return 1;
          }
        } else {
          obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
          return 1;
        }
      else {
        t2 = J.getInterceptor(oV);
        if (t2.$eq(oV, 0)) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          vx = J.$add$ns(t.get$pos().x, t1.$mul(oH, t.get$xw()));
          vy = J.$add$ns(t.get$pos().y, t2.$mul(oV, t.get$yw()));
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t3 = J.getInterceptor$ns(dx);
          t4 = J.getInterceptor$ns(dy);
          len = Math.sqrt(H.checkNum(J.$add$ns(t3.$mul(dx, dx), t4.$mul(dy, dy))));
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = t1.$div(oH, 1.4142135623730951);
              dy = t2.$div(oV, 1.4142135623730951);
            } else {
              dx = t3.$div(dx, len);
              dy = t4.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_Full", 12, 0, 634, 9, [], 10, [], 635, [], 636, [], 630, [], 423, []],
    projCircle_45Deg$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, sx, sy, t1, t2, ox, oy, dp, x0, lenP, y0, t3, len, pen, vx, vy, dx, dy;
      signx = t.get$signx();
      signy = t.get$signy();
      if (J.$eq(oH, 0))
        if (J.$eq(oV, 0)) {
          sx = t.get$sx();
          sy = t.get$sy();
          t1 = obj.get$pos().x;
          t2 = obj.get$radius();
          if (typeof t2 !== "number")
            return H.iae(t2);
          ox = J.$sub$n(J.$sub$n(t1, sx * t2), t.get$pos().x);
          t2 = obj.get$pos().y;
          t1 = obj.get$radius();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(J.$sub$n(t2, sy * t1), t.get$pos().y);
          dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
          t1 = J.getInterceptor$n(dp);
          if (t1.$lt(dp, 0)) {
            t2 = t1.$negate(dp);
            if (typeof t2 !== "number")
              return H.iae(t2);
            sx *= t2;
            t1 = t1.$negate(dp);
            if (typeof t1 !== "number")
              return H.iae(t1);
            sy *= t1;
            t1 = J.getInterceptor$n(x);
            if (t1.$lt(x, y)) {
              x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t1.$mul(x, -1) : x;
              lenP = x;
              x = x0;
              y = 0;
            } else {
              y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
              lenP = y;
              y = y0;
              x = 0;
            }
            if (J.$lt$n(lenP, Math.sqrt(H.checkNum(sx * sx + sy * sy)))) {
              obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
              return 1;
            } else {
              obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
              return 2;
            }
          }
        } else {
          if (typeof oV !== "number")
            return H.iae(oV);
          if (signy * oV < 0) {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          } else {
            sx = t.get$sx();
            sy = t.get$sy();
            t1 = obj.get$pos().x;
            t2 = t.get$pos().x;
            t3 = t.get$xw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
            t3 = obj.get$pos().y;
            t2 = t.get$pos().y;
            t1 = t.get$yw();
            if (typeof t1 !== "number")
              return H.iae(t1);
            oy = J.$sub$n(t3, J.$add$ns(t2, oV * t1));
            t1 = J.getInterceptor$ns(ox);
            t2 = J.getInterceptor$ns(oy);
            t3 = J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (0 < t3) {
              len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy))));
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                ox = t1.$div(ox, len);
                oy = t2.$div(oy, len);
                obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                return 2;
              }
            } else {
              dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
              pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                obj.reportCollisionVsWorld$4(sx * pen, sy * pen, sx, sy);
                return 2;
              }
            }
          }
        }
      else if (J.$eq(oV, 0)) {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (signx * oH < 0) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          sx = t.get$sx();
          sy = t.get$sy();
          t1 = obj.get$pos().x;
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$add$ns(t2, oH * t3));
          t3 = obj.get$pos().y;
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          t1 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          if (J.$lt$n(J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy), 0)) {
            len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy))));
            pen = J.$sub$n(obj.get$radius(), len);
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              ox = t1.$div(ox, len);
              oy = t2.$div(oy, len);
              obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
              return 2;
            }
          } else {
            dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
            pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              obj.reportCollisionVsWorld$4(sx * pen, sy * pen, sx, sy);
              return 2;
            }
          }
        }
      } else {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (typeof oV !== "number")
          return H.iae(oV);
        if (0 < signx * oH + signy * oV)
          return 0;
        else {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          vx = J.$add$ns(t1, oH * t2);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          vy = J.$add$ns(t2, oV * t1);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t1 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy))));
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH / 1.4142135623730951;
              dy = oV / 1.4142135623730951;
            } else {
              dx = t1.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_45Deg", 12, 0, 634, 9, [], 10, [], 635, [], 636, [], 630, [], 423, []],
    projCircle_Concave$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, t1, t2, ox, oy, twid, trad, len, t3, pen, x0, lenP, y0, vx, vy, dx, dy;
      signx = t.get$signx();
      signy = t.get$signy();
      if (J.$eq(oH, 0))
        if (J.$eq(oV, 0)) {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          ox = J.$sub$n(J.$add$ns(t1, signx * t2), obj.get$pos().x);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(J.$add$ns(t2, signy * t1), obj.get$pos().y);
          twid = J.$mul$ns(t.get$xw(), 2);
          trad = Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(twid, twid), 0)));
          t1 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy))));
          t3 = obj.get$radius();
          if (typeof t3 !== "number")
            return H.iae(t3);
          pen = len + t3 - trad;
          if (0 < pen) {
            t3 = J.getInterceptor$n(x);
            if (t3.$lt(x, y)) {
              x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t3.$mul(x, -1) : x;
              lenP = x;
              x = x0;
              y = 0;
            } else {
              y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
              lenP = y;
              y = y0;
              x = 0;
            }
            if (J.$lt$n(lenP, pen)) {
              obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
              return 1;
            } else {
              ox = t1.$div(ox, len);
              oy = t2.$div(oy, len);
              obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
              return 2;
            }
          } else
            return 0;
        } else {
          if (typeof oV !== "number")
            return H.iae(oV);
          if (signy * oV < 0) {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          } else {
            t1 = t.get$pos().x;
            t2 = t.get$xw();
            if (typeof t2 !== "number")
              return H.iae(t2);
            vx = J.$sub$n(t1, signx * t2);
            t2 = t.get$pos().y;
            t1 = t.get$yw();
            if (typeof t1 !== "number")
              return H.iae(t1);
            vy = J.$add$ns(t2, oV * t1);
            dx = J.$sub$n(obj.get$pos().x, vx);
            dy = J.$sub$n(obj.get$pos().y, vy);
            t1 = J.getInterceptor$ns(dx);
            t2 = J.getInterceptor$ns(dy);
            len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy))));
            pen = J.$sub$n(obj.get$radius(), len);
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              if (len === 0) {
                dy = oV;
                dx = 0;
              } else {
                dx = t1.$div(dx, len);
                dy = t2.$div(dy, len);
              }
              obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
              return 2;
            }
          }
        }
      else if (J.$eq(oV, 0)) {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (signx * oH < 0) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          vx = J.$add$ns(t1, oH * t2);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          vy = J.$sub$n(t2, signy * t1);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t1 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy))));
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH;
              dy = 0;
            } else {
              dx = t1.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      } else {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (typeof oV !== "number")
          return H.iae(oV);
        if (0 < signx * oH + signy * oV)
          return 0;
        else {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          vx = J.$add$ns(t1, oH * t2);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          vy = J.$add$ns(t2, oV * t1);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t1 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy))));
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH / 1.4142135623730951;
              dy = oV / 1.4142135623730951;
            } else {
              dx = t1.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_Concave", 12, 0, 634, 9, [], 10, [], 635, [], 636, [], 630, [], 423, []],
    projCircle_Convex$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, t1, t2, t3, ox, oy, twid, trad, len, pen, x0, lenP, y0, vx, vy, dx, dy;
      signx = t.get$signx();
      signy = t.get$signy();
      if (J.$eq(oH, 0))
        if (J.$eq(oV, 0)) {
          t1 = obj.get$pos().x;
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
          t3 = obj.get$pos().y;
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          twid = J.$mul$ns(t.get$xw(), 2);
          trad = Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(twid, twid), 0)));
          t1 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy))));
          t3 = obj.get$radius();
          if (typeof t3 !== "number")
            return H.iae(t3);
          pen = trad + t3 - len;
          if (0 < pen) {
            t3 = J.getInterceptor$n(x);
            if (t3.$lt(x, y)) {
              x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t3.$mul(x, -1) : x;
              lenP = x;
              x = x0;
              y = 0;
            } else {
              y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
              lenP = y;
              y = y0;
              x = 0;
            }
            if (J.$lt$n(lenP, pen)) {
              obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
              return 1;
            } else {
              ox = t1.$div(ox, len);
              oy = t2.$div(oy, len);
              obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
              return 2;
            }
          }
        } else {
          if (typeof oV !== "number")
            return H.iae(oV);
          if (signy * oV < 0) {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          } else {
            t1 = obj.get$pos().x;
            t2 = t.get$pos().x;
            t3 = t.get$xw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
            t3 = obj.get$pos().y;
            t2 = t.get$pos().y;
            t1 = t.get$yw();
            if (typeof t1 !== "number")
              return H.iae(t1);
            oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
            twid = J.$mul$ns(t.get$xw(), 2);
            trad = Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(twid, twid), 0)));
            t1 = J.getInterceptor$ns(ox);
            t2 = J.getInterceptor$ns(oy);
            len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy))));
            t3 = obj.get$radius();
            if (typeof t3 !== "number")
              return H.iae(t3);
            pen = trad + t3 - len;
            if (0 < pen) {
              ox = t1.$div(ox, len);
              oy = t2.$div(oy, len);
              obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
              return 2;
            }
          }
        }
      else if (J.$eq(oV, 0)) {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (signx * oH < 0) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          t1 = obj.get$pos().x;
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
          t3 = obj.get$pos().y;
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          twid = J.$mul$ns(t.get$xw(), 2);
          trad = Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(twid, twid), 0)));
          t1 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy))));
          t3 = obj.get$radius();
          if (typeof t3 !== "number")
            return H.iae(t3);
          pen = trad + t3 - len;
          if (0 < pen) {
            ox = t1.$div(ox, len);
            oy = t2.$div(oy, len);
            obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
            return 2;
          }
        }
      } else {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (typeof oV !== "number")
          return H.iae(oV);
        if (0 < signx * oH + signy * oV) {
          t1 = obj.get$pos().x;
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
          t3 = obj.get$pos().y;
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          twid = J.$mul$ns(t.get$xw(), 2);
          trad = Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(twid, twid), 0)));
          t1 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy))));
          t3 = obj.get$radius();
          if (typeof t3 !== "number")
            return H.iae(t3);
          pen = trad + t3 - len;
          if (0 < pen) {
            ox = t1.$div(ox, len);
            oy = t2.$div(oy, len);
            obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
            return 2;
          }
        } else {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          vx = J.$add$ns(t1, oH * t2);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          vy = J.$add$ns(t2, oV * t1);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t1 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy))));
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH / 1.4142135623730951;
              dy = oV / 1.4142135623730951;
            } else {
              dx = t1.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_Convex", 12, 0, 634, 9, [], 10, [], 635, [], 636, [], 630, [], 423, []],
    projCircle_Half$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, t1, t2, celldp, r, ox, oy, dp, sx, sy, lenN, lenP, dx, dy, t3, len, pen, vx, vy, t4;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = J.getInterceptor$ns(oH);
      t2 = J.getInterceptor$ns(oV);
      celldp = J.$add$ns(t1.$mul(oH, signx), t2.$mul(oV, signy));
      if (typeof celldp !== "number")
        return H.iae(celldp);
      if (0 < celldp)
        return 0;
      else if (t1.$eq(oH, 0))
        if (t2.$eq(oV, 0)) {
          r = obj.get$radius();
          t1 = obj.get$pos().x;
          if (typeof r !== "number")
            return H.iae(r);
          ox = J.$sub$n(J.$sub$n(t1, signx * r), t.get$pos().x);
          oy = J.$sub$n(J.$sub$n(obj.get$pos().y, signy * r), t.get$pos().y);
          dp = J.$add$ns(J.$mul$ns(ox, signx), J.$mul$ns(oy, signy));
          t1 = J.getInterceptor$n(dp);
          if (t1.$lt(dp, 0)) {
            t2 = t1.$negate(dp);
            if (typeof t2 !== "number")
              return H.iae(t2);
            sx = signx * t2;
            t1 = t1.$negate(dp);
            if (typeof t1 !== "number")
              return H.iae(t1);
            sy = signy * t1;
            lenN = Math.sqrt(H.checkNum(sx * sx + sy * sy));
            t1 = J.getInterceptor$ns(x);
            t2 = J.getInterceptor$ns(y);
            lenP = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(x, x), t2.$mul(y, y))));
            if (lenP < lenN) {
              obj.reportCollisionVsWorld$4(x, y, t1.$div(x, lenP), t2.$div(y, lenP));
              return 1;
            } else {
              obj.reportCollisionVsWorld$4(sx, sy, t.get$signx(), t.get$signy());
              return 2;
            }
          }
        } else if (celldp === 0) {
          dx = J.$sub$n(obj.get$pos().x, t.get$pos().x);
          t1 = J.getInterceptor$ns(dx);
          if (J.$lt$n(t1.$mul(dx, signx), 0)) {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          } else {
            dy = J.$sub$n(obj.get$pos().y, J.$add$ns(t.get$pos().y, t2.$mul(oV, t.get$yw())));
            t3 = J.getInterceptor$ns(dy);
            len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(dx, dx), t3.$mul(dy, dy))));
            pen = J.$sub$n(obj.get$radius(), len);
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              if (len === 0) {
                dx = signx / 1.4142135623730951;
                dy = t2.$div(oV, 1.4142135623730951);
              } else {
                dx = t1.$div(dx, len);
                dy = t3.$div(dy, len);
              }
              obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
              return 2;
            }
          }
        } else {
          obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
          return 1;
        }
      else if (t2.$eq(oV, 0))
        if (celldp === 0) {
          dy = J.$sub$n(obj.get$pos().y, t.get$pos().y);
          t3 = J.getInterceptor$ns(dy);
          if (J.$lt$n(t3.$mul(dy, signy), 0)) {
            obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
            return 1;
          } else {
            dx = J.$sub$n(obj.get$pos().x, J.$add$ns(t.get$pos().x, t1.$mul(oH, t.get$xw())));
            t1 = J.getInterceptor$ns(dx);
            len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(dx, dx), t3.$mul(dy, dy))));
            pen = J.$sub$n(obj.get$radius(), len);
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              if (len === 0) {
                dx = signx / 1.4142135623730951;
                dy = t2.$div(oV, 1.4142135623730951);
              } else {
                dx = t1.$div(dx, len);
                dy = t3.$div(dy, len);
              }
              obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
              return 2;
            }
          }
        } else {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        }
      else {
        vx = J.$add$ns(t.get$pos().x, t1.$mul(oH, t.get$xw()));
        vy = J.$add$ns(t.get$pos().y, t2.$mul(oV, t.get$yw()));
        dx = J.$sub$n(obj.get$pos().x, vx);
        dy = J.$sub$n(obj.get$pos().y, vy);
        t3 = J.getInterceptor$ns(dx);
        t4 = J.getInterceptor$ns(dy);
        len = Math.sqrt(H.checkNum(J.$add$ns(t3.$mul(dx, dx), t4.$mul(dy, dy))));
        pen = J.$sub$n(obj.get$radius(), len);
        if (typeof pen !== "number")
          return H.iae(pen);
        if (0 < pen) {
          if (len === 0) {
            dx = t1.$div(oH, 1.4142135623730951);
            dy = t2.$div(oV, 1.4142135623730951);
          } else {
            dx = t3.$div(dx, len);
            dy = t4.$div(dy, len);
          }
          obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
          return 2;
        }
      }
      return 0;
    }, "call$6", "get$projCircle_Half", 12, 0, 634, 9, [], 10, [], 635, [], 636, [], 630, [], 423, []],
    projCircle_22DegS$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, t1, sx, sy, r, t2, t3, ox, oy, t4, len, pen, dp, lenN, x0, lenP, y0, vx, vy, dx, dy;
      signx = t.get$signx();
      signy = t.get$signy();
      if (typeof oV !== "number")
        return H.iae(oV);
      if (0 < signy * oV)
        return 0;
      else {
        t1 = J.getInterceptor(oH);
        if (t1.$eq(oH, 0))
          if (oV === 0) {
            sx = t.get$sx();
            sy = t.get$sy();
            r = obj.get$radius();
            t1 = obj.get$pos().x;
            t2 = t.get$pos().x;
            t3 = t.get$xw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
            oy = J.$sub$n(obj.get$pos().y, t.get$pos().y);
            t3 = J.getInterceptor$ns(ox);
            t2 = J.getInterceptor$ns(oy);
            t1 = J.$mul$ns(J.$mul$ns(J.$add$ns(t3.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy);
            if (typeof t1 !== "number")
              return H.iae(t1);
            t4 = J.getInterceptor$ns(r);
            if (0 < t1) {
              len = Math.sqrt(H.checkNum(J.$add$ns(t3.$mul(ox, ox), t2.$mul(oy, oy))));
              pen = t4.$sub(r, len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                ox = t3.$div(ox, len);
                oy = t2.$div(oy, len);
                obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                return 2;
              }
            } else {
              ox = t3.$sub(ox, t4.$mul(r, sx));
              oy = t2.$sub(oy, t4.$mul(r, sy));
              dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
              t1 = J.getInterceptor$n(dp);
              if (t1.$lt(dp, 0)) {
                t2 = t1.$negate(dp);
                if (typeof t2 !== "number")
                  return H.iae(t2);
                sx *= t2;
                t1 = t1.$negate(dp);
                if (typeof t1 !== "number")
                  return H.iae(t1);
                sy *= t1;
                lenN = Math.sqrt(H.checkNum(sx * sx + sy * sy));
                t1 = J.getInterceptor$n(x);
                if (t1.$lt(x, y)) {
                  x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t1.$mul(x, -1) : x;
                  lenP = x;
                  x = x0;
                  y = 0;
                } else {
                  y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
                  lenP = y;
                  y = y0;
                  x = 0;
                }
                if (J.$lt$n(lenP, lenN)) {
                  obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
                  return 1;
                } else {
                  obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
                  return 2;
                }
              }
            }
          } else {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          }
        else if (oV === 0) {
          if (typeof oH !== "number")
            return H.iae(oH);
          if (signx * oH < 0) {
            t1 = t.get$pos().x;
            t2 = t.get$xw();
            if (typeof t2 !== "number")
              return H.iae(t2);
            vx = J.$sub$n(t1, signx * t2);
            vy = t.get$pos().y;
            dx = J.$sub$n(obj.get$pos().x, vx);
            dy = J.$sub$n(obj.get$pos().y, vy);
            t1 = J.getInterceptor$ns(dy);
            if (J.$lt$n(t1.$mul(dy, signy), 0)) {
              obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
              return 1;
            } else {
              t2 = J.getInterceptor$ns(dx);
              len = Math.sqrt(H.checkNum(J.$add$ns(t2.$mul(dx, dx), t1.$mul(dy, dy))));
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                if (len === 0) {
                  dx = oH / 1.4142135623730951;
                  dy = oV / 1.4142135623730951;
                } else {
                  dx = t2.$div(dx, len);
                  dy = t1.$div(dy, len);
                }
                obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
                return 2;
              }
            }
          } else {
            sx = t.get$sx();
            sy = t.get$sy();
            t1 = obj.get$pos().x;
            t2 = t.get$pos().x;
            t3 = t.get$xw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            ox = J.$sub$n(t1, J.$add$ns(t2, oH * t3));
            t3 = obj.get$pos().y;
            t2 = t.get$pos().y;
            t1 = t.get$yw();
            if (typeof t1 !== "number")
              return H.iae(t1);
            oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
            t1 = J.getInterceptor$ns(ox);
            t2 = J.getInterceptor$ns(oy);
            if (J.$lt$n(J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy), 0)) {
              len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy))));
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                ox = t1.$div(ox, len);
                oy = t2.$div(oy, len);
                obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                return 2;
              }
            } else {
              dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
              pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                obj.reportCollisionVsWorld$4(sx * pen, sy * pen, sx, sy);
                return 2;
              }
            }
          }
        } else {
          vx = J.$add$ns(t.get$pos().x, t1.$mul(oH, t.get$xw()));
          t2 = t.get$pos().y;
          t3 = t.get$yw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          vy = J.$add$ns(t2, oV * t3);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t3 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          len = Math.sqrt(H.checkNum(J.$add$ns(t3.$mul(dx, dx), t2.$mul(dy, dy))));
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = t1.$div(oH, 1.4142135623730951);
              dy = oV / 1.4142135623730951;
            } else {
              dx = t3.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_22DegS", 12, 0, 634, 9, [], 10, [], 635, [], 636, [], 630, [], 423, []],
    projCircle_22DegB$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, sx, sy, r, t1, t2, t3, ox, oy, dp, lenN, x0, lenP, y0, len, pen, slen, vx, vy, dx, dy;
      signx = t.get$signx();
      signy = t.get$signy();
      if (J.$eq(oH, 0))
        if (J.$eq(oV, 0)) {
          sx = t.get$sx();
          sy = t.get$sy();
          r = obj.get$radius();
          t1 = obj.get$pos().x;
          if (typeof r !== "number")
            return H.iae(r);
          t1 = J.$sub$n(t1, sx * r);
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
          t3 = J.$sub$n(obj.get$pos().y, sy * r);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$add$ns(t2, signy * t1));
          dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
          t1 = J.getInterceptor$n(dp);
          if (t1.$lt(dp, 0)) {
            t2 = t1.$negate(dp);
            if (typeof t2 !== "number")
              return H.iae(t2);
            sx *= t2;
            t1 = t1.$negate(dp);
            if (typeof t1 !== "number")
              return H.iae(t1);
            sy *= t1;
            lenN = Math.sqrt(H.checkNum(sx * sx + sy * sy));
            t1 = J.getInterceptor$n(x);
            if (t1.$lt(x, y)) {
              x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t1.$mul(x, -1) : x;
              lenP = x;
              x = x0;
              y = 0;
            } else {
              y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
              lenP = y;
              y = y0;
              x = 0;
            }
            if (J.$lt$n(lenP, lenN)) {
              obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
              return 1;
            } else {
              obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
              return 2;
            }
          }
        } else {
          if (typeof oV !== "number")
            return H.iae(oV);
          if (signy * oV < 0) {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          } else {
            sx = t.get$sx();
            sy = t.get$sy();
            t1 = obj.get$pos().x;
            t2 = t.get$pos().x;
            t3 = t.get$xw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
            t3 = obj.get$pos().y;
            t2 = t.get$pos().y;
            t1 = t.get$yw();
            if (typeof t1 !== "number")
              return H.iae(t1);
            oy = J.$sub$n(t3, J.$add$ns(t2, signy * t1));
            t1 = J.getInterceptor$ns(ox);
            t2 = J.getInterceptor$ns(oy);
            t3 = J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (0 < t3) {
              len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy))));
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                ox = t1.$div(ox, len);
                oy = t2.$div(oy, len);
                obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                return 2;
              }
            } else {
              dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
              pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                obj.reportCollisionVsWorld$4(sx * pen, sy * pen, sx, sy);
                return 2;
              }
            }
          }
        }
      else if (J.$eq(oV, 0)) {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (signx * oH < 0) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          t1 = obj.get$pos().x;
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$add$ns(t2, signx * t3));
          oy = J.$sub$n(obj.get$pos().y, t.get$pos().y);
          t1 = J.getInterceptor$ns(oy);
          if (J.$lt$n(t1.$mul(oy, signy), 0)) {
            obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
            return 1;
          } else {
            sx = t.get$sx();
            sy = t.get$sy();
            t2 = J.getInterceptor$ns(ox);
            if (J.$lt$n(J.$mul$ns(J.$mul$ns(J.$add$ns(t2.$mul(ox, -sy), t1.$mul(oy, sx)), signx), signy), 0)) {
              len = Math.sqrt(H.checkNum(J.$add$ns(t2.$mul(ox, ox), t1.$mul(oy, oy))));
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                ox = t2.$div(ox, len);
                oy = t1.$div(oy, len);
                obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                return 2;
              }
            } else {
              dp = J.$add$ns(t2.$mul(ox, sx), t1.$mul(oy, sy));
              pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                obj.reportCollisionVsWorld$4(sx * pen, sy * pen, t.get$sx(), t.get$sy());
                return 2;
              }
            }
          }
        }
      } else {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (typeof oV !== "number")
          return H.iae(oV);
        if (0 < signx * oH + signy * oV) {
          slen = Math.sqrt(H.checkNum(5));
          sx = signx / slen;
          sy = signy * 2 / slen;
          r = obj.get$radius();
          t1 = obj.get$pos().x;
          if (typeof r !== "number")
            return H.iae(r);
          t1 = J.$sub$n(t1, sx * r);
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
          t3 = J.$sub$n(obj.get$pos().y, sy * r);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$add$ns(t2, signy * t1));
          dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
          if (J.$lt$n(dp, 0)) {
            if (typeof dp !== "number")
              return H.iae(dp);
            obj.reportCollisionVsWorld$4(-sx * dp, -sy * dp, t.get$sx(), t.get$sy());
            return 2;
          }
          return 0;
        } else {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          vx = J.$add$ns(t1, oH * t2);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          vy = J.$add$ns(t2, oV * t1);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t1 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy))));
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH / 1.4142135623730951;
              dy = oV / 1.4142135623730951;
            } else {
              dx = t1.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_22DegB", 12, 0, 634, 9, [], 10, [], 635, [], 636, [], 630, [], 423, []],
    projCircle_67DegS$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, sx, sy, r, ox, t1, t2, t3, oy, len, pen, dp, lenN, x0, lenP, y0, vx, vy, dx, dy;
      signx = t.get$signx();
      signy = t.get$signy();
      if (typeof oH !== "number")
        return H.iae(oH);
      if (0 < signx * oH)
        return 0;
      else if (oH === 0)
        if (J.$eq(oV, 0)) {
          sx = t.get$sx();
          sy = t.get$sy();
          r = obj.get$radius();
          ox = J.$sub$n(obj.get$pos().x, t.get$pos().x);
          t1 = obj.get$pos().y;
          t2 = t.get$pos().y;
          t3 = t.get$yw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          oy = J.$sub$n(t1, J.$sub$n(t2, signy * t3));
          t3 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          t1 = J.getInterceptor$ns(r);
          if (J.$lt$n(J.$mul$ns(J.$mul$ns(J.$add$ns(t3.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy), 0)) {
            len = Math.sqrt(H.checkNum(J.$add$ns(t3.$mul(ox, ox), t2.$mul(oy, oy))));
            pen = t1.$sub(r, len);
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              ox = t3.$div(ox, len);
              oy = t2.$div(oy, len);
              obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
              return 2;
            }
          } else {
            ox = t3.$sub(ox, t1.$mul(r, sx));
            oy = t2.$sub(oy, t1.$mul(r, sy));
            dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
            t1 = J.getInterceptor$n(dp);
            if (t1.$lt(dp, 0)) {
              t2 = t1.$negate(dp);
              if (typeof t2 !== "number")
                return H.iae(t2);
              sx *= t2;
              t1 = t1.$negate(dp);
              if (typeof t1 !== "number")
                return H.iae(t1);
              sy *= t1;
              lenN = Math.sqrt(H.checkNum(sx * sx + sy * sy));
              t1 = J.getInterceptor$n(x);
              if (t1.$lt(x, y)) {
                x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t1.$mul(x, -1) : x;
                lenP = x;
                x = x0;
                y = 0;
              } else {
                y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
                lenP = y;
                y = y0;
                x = 0;
              }
              if (J.$lt$n(lenP, lenN)) {
                obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
                return 1;
              } else {
                obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
                return 2;
              }
            }
          }
        } else {
          if (typeof oV !== "number")
            return H.iae(oV);
          if (signy * oV < 0) {
            vx = t.get$pos().x;
            t1 = t.get$pos().y;
            t2 = t.get$yw();
            if (typeof t2 !== "number")
              return H.iae(t2);
            vy = J.$sub$n(t1, signy * t2);
            dx = J.$sub$n(obj.get$pos().x, vx);
            dy = J.$sub$n(obj.get$pos().y, vy);
            t1 = J.getInterceptor$ns(dx);
            if (J.$lt$n(t1.$mul(dx, signx), 0)) {
              obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
              return 1;
            } else {
              t2 = J.getInterceptor$ns(dy);
              len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy))));
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                if (len === 0) {
                  dx = oH / 1.4142135623730951;
                  dy = oV / 1.4142135623730951;
                } else {
                  dx = t1.$div(dx, len);
                  dy = t2.$div(dy, len);
                }
                obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
                return 2;
              }
            }
          } else {
            sx = t.get$sx();
            sy = t.get$sy();
            t1 = obj.get$pos().x;
            t2 = t.get$pos().x;
            t3 = t.get$xw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
            t3 = obj.get$pos().y;
            t2 = t.get$pos().y;
            t1 = t.get$yw();
            if (typeof t1 !== "number")
              return H.iae(t1);
            oy = J.$sub$n(t3, J.$add$ns(t2, oV * t1));
            t1 = J.getInterceptor$ns(ox);
            t2 = J.getInterceptor$ns(oy);
            t3 = J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (0 < t3) {
              len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy))));
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                ox = t1.$div(ox, len);
                oy = t2.$div(oy, len);
                obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                return 2;
              }
            } else {
              dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
              pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                obj.reportCollisionVsWorld$4(sx * pen, sy * pen, t.get$sx(), t.get$sy());
                return 2;
              }
            }
          }
        }
      else {
        t1 = J.getInterceptor(oV);
        if (t1.$eq(oV, 0)) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          vx = J.$add$ns(t2, oH * t3);
          vy = J.$add$ns(t.get$pos().y, t1.$mul(oV, t.get$yw()));
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t3 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          len = Math.sqrt(H.checkNum(J.$add$ns(t3.$mul(dx, dx), t2.$mul(dy, dy))));
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH / 1.4142135623730951;
              dy = t1.$div(oV, 1.4142135623730951);
            } else {
              dx = t3.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_67DegS", 12, 0, 634, 9, [], 10, [], 635, [], 636, [], 630, [], 423, []],
    projCircle_67DegB$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, sx, sy, r, t1, t2, t3, ox, oy, dp, lenN, x0, lenP, y0, len, pen, slen, vx, vy, dx, dy;
      signx = t.get$signx();
      signy = t.get$signy();
      if (J.$eq(oH, 0))
        if (J.$eq(oV, 0)) {
          sx = t.get$sx();
          sy = t.get$sy();
          r = obj.get$radius();
          t1 = obj.get$pos().x;
          if (typeof r !== "number")
            return H.iae(r);
          t1 = J.$sub$n(t1, sx * r);
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$add$ns(t2, signx * t3));
          t3 = J.$sub$n(obj.get$pos().y, sy * r);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
          t1 = J.getInterceptor$n(dp);
          if (t1.$lt(dp, 0)) {
            t2 = t1.$negate(dp);
            if (typeof t2 !== "number")
              return H.iae(t2);
            sx *= t2;
            t1 = t1.$negate(dp);
            if (typeof t1 !== "number")
              return H.iae(t1);
            sy *= t1;
            lenN = Math.sqrt(H.checkNum(sx * sx + sy * sy));
            t1 = J.getInterceptor$n(x);
            if (t1.$lt(x, y)) {
              x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t1.$mul(x, -1) : x;
              lenP = x;
              x = x0;
              y = 0;
            } else {
              y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
              lenP = y;
              y = y0;
              x = 0;
            }
            if (J.$lt$n(lenP, lenN)) {
              obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
              return 1;
            } else {
              obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
              return 2;
            }
          }
        } else {
          if (typeof oV !== "number")
            return H.iae(oV);
          if (signy * oV < 0) {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          } else {
            ox = J.$sub$n(obj.get$pos().x, t.get$pos().x);
            t1 = obj.get$pos().y;
            t2 = t.get$pos().y;
            t3 = t.get$yw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            oy = J.$sub$n(t1, J.$add$ns(t2, signy * t3));
            t1 = J.getInterceptor$ns(ox);
            if (J.$lt$n(t1.$mul(ox, signx), 0)) {
              obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
              return 1;
            } else {
              sx = t.get$sx();
              sy = t.get$sy();
              t2 = J.getInterceptor$ns(oy);
              t3 = J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy);
              if (typeof t3 !== "number")
                return H.iae(t3);
              if (0 < t3) {
                len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy))));
                pen = J.$sub$n(obj.get$radius(), len);
                if (typeof pen !== "number")
                  return H.iae(pen);
                if (0 < pen) {
                  ox = t1.$div(ox, len);
                  oy = t2.$div(oy, len);
                  obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                  return 2;
                }
              } else {
                dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
                pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
                if (typeof pen !== "number")
                  return H.iae(pen);
                if (0 < pen) {
                  obj.reportCollisionVsWorld$4(sx * pen, sy * pen, sx, sy);
                  return 2;
                }
              }
            }
          }
        }
      else if (J.$eq(oV, 0)) {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (signx * oH < 0) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          slen = Math.sqrt(H.checkNum(5));
          sx = signx * 2 / slen;
          sy = signy / slen;
          t1 = obj.get$pos().x;
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$add$ns(t2, signx * t3));
          t3 = obj.get$pos().y;
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          t1 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          if (J.$lt$n(J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy), 0)) {
            len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy))));
            pen = J.$sub$n(obj.get$radius(), len);
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              ox = t1.$div(ox, len);
              oy = t2.$div(oy, len);
              obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
              return 2;
            }
          } else {
            dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
            pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              obj.reportCollisionVsWorld$4(sx * pen, sy * pen, t.get$sx(), t.get$sy());
              return 2;
            }
          }
        }
      } else {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (typeof oV !== "number")
          return H.iae(oV);
        if (0 < signx * oH + signy * oV) {
          sx = t.get$sx();
          sy = t.get$sy();
          r = obj.get$radius();
          t1 = obj.get$pos().x;
          if (typeof r !== "number")
            return H.iae(r);
          t1 = J.$sub$n(t1, sx * r);
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$add$ns(t2, signx * t3));
          t3 = J.$sub$n(obj.get$pos().y, sy * r);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
          if (J.$lt$n(dp, 0)) {
            if (typeof dp !== "number")
              return H.iae(dp);
            obj.reportCollisionVsWorld$4(-sx * dp, -sy * dp, t.get$sx(), t.get$sy());
            return 2;
          }
          return 0;
        } else {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          vx = J.$add$ns(t1, oH * t2);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          vy = J.$add$ns(t2, oV * t1);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t1 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          len = Math.sqrt(H.checkNum(J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy))));
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH / 1.4142135623730951;
              dy = oV / 1.4142135623730951;
            } else {
              dx = t1.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_67DegB", 12, 0, 634, 9, [], 10, [], 635, [], 636, [], 630, [], 423, []],
    destroy$0: function() {
      this.Ninja0$Circle1$body = null;
      this.Ninja0$Circle1$system = null;
    },
    render$5: [function(context, xOffset, yOffset, color, filled) {
      var x, y, t1;
      x = J.$sub$n(this.Ninja0$Circle1$pos.x, xOffset);
      y = J.$sub$n(this.Ninja0$Circle1$pos.y, yOffset);
      t1 = J.getInterceptor$x(context);
      t1.beginPath$0(context);
      t1.arc$6(context, x, y, this.radius, 0, 6.283185307179586, false);
      if (filled === true) {
        t1.set$fillStyle(context, color);
        t1.fill$0(context);
      } else {
        t1.set$strokeStyle(context, color);
        t1.stroke$0(context);
      }
    }, "call$5", "get$render", 10, 0, 632, 142, [], 336, [], 337, [], 152, [], 623, []],
    Circle$4: function(body, x, y, radius) {
      var t1;
      this.Ninja0$Circle1$body = body;
      this.Ninja0$Circle1$system = body.system;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.Ninja0$Circle1$pos = t1;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.Ninja0$Circle1$oldpos = t1;
      this.radius = radius;
      t1 = radius * 2;
      this.Ninja0$Circle1$_Ninja0$_width = t1;
      this.Ninja0$Circle1$_Ninja0$_height = t1;
      this.Ninja0$Circle1$oH = 0;
      this.Ninja0$Circle1$oV = 0;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.Ninja0$Circle1$velocity = t1;
      t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      this.circleTileProjections = t1;
      t1.$indexSet(0, 1, this.get$projCircle_Full());
      this.circleTileProjections.$indexSet(0, 2, this.get$projCircle_45Deg());
      this.circleTileProjections.$indexSet(0, 6, this.get$projCircle_Concave());
      this.circleTileProjections.$indexSet(0, 10, this.get$projCircle_Convex());
      this.circleTileProjections.$indexSet(0, 14, this.get$projCircle_22DegS());
      this.circleTileProjections.$indexSet(0, 18, this.get$projCircle_22DegB());
      this.circleTileProjections.$indexSet(0, 22, this.get$projCircle_67DegS());
      this.circleTileProjections.$indexSet(0, 26, this.get$projCircle_67DegB());
      this.circleTileProjections.$indexSet(0, 30, this.get$projCircle_Half());
    },
    static: {"^": "Circle_COL_NONE,Circle_COL_AXIS,Circle_COL_OTHER"}
  },
  "+Circle": 0,
  Ninja: {
    "^": "Object;game@,time@,gravity@,bounds@,maxObjects@,maxLevels@,quadTree,_Ninja0$_result,_Ninja0$_total",
    quadTree$2: function(arg0, arg1) {
      return this.quadTree.call$2(arg0, arg1);
    },
    enableAABB$2: function(object, children) {
      this.enable$5(0, object, 1, 0, 0, children);
    },
    enableAABB$1: function(object) {
      return this.enableAABB$2(object, true);
    },
    enable$5: function(_, object, type, id, radius, children) {
      var t1, i, t2, i0, t3, t4;
      t1 = J.getInterceptor(object);
      if (!!t1.$isList) {
        i = t1.get$length(object);
        for (; t2 = J.getInterceptor$n(i), i0 = t2.$sub(i, 1), t2.$gt(i, 0); i = i0)
          if (!!J.getInterceptor(t1.$index(object, i0)).$isGroup)
            this.enable$5(0, J.get$children$x(t1.$index(object, i0)), type, id, radius, children);
          else {
            t2 = t1.$index(object, i0);
            t3 = J.getInterceptor$x(t2);
            if (t3.get$body(t2) == null) {
              t4 = new E.Body2(null, null, 2, null, null, null, null, null, null, null, null, null, null, 0, null, true, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, 0, 0, 0);
              t4.Body$9(this, t2, type, id, radius, 0, 0, 0, 0);
              t3.set$body(t2, t4);
              t2.get$anchor().set$1(0.5);
            }
            if (children && !!J.getInterceptor(t1.$index(object, i0)).$isDisplayObjectContainer && J.$gt$n(J.get$length$asx(J.get$children$x(t1.$index(object, i0))), 0))
              this.enable$5(0, t1.$index(object, i0), type, id, radius, true);
          }
      } else if (!!t1.$isGroup)
        this.enable$5(0, object.Phaser$Group$children, type, id, radius, children);
      else {
        if (t1.get$body(object) == null) {
          t2 = new E.Body2(null, null, 2, null, null, null, null, null, null, null, null, null, null, 0, null, true, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, 0, 0, 0);
          t2.Body$9(this, object, type, id, radius, 0, 0, 0, 0);
          t1.set$body(object, t2);
          object.get$anchor().set$1(0.5);
        }
        if (children && !!t1.$isDisplayObjectContainer && J.$gt$n(J.get$length$asx(t1.get$children(object)), 0))
          this.enable$5(0, t1.get$children(object), type, id, radius, true);
      }
    },
    enable$2: function($receiver, object, type) {
      return this.enable$5($receiver, object, type, 1, 0, true);
    },
    enable$1: function($receiver, object) {
      return this.enable$5($receiver, object, 1, 1, 0, true);
    },
    enable$3: function($receiver, object, type, id) {
      return this.enable$5($receiver, object, type, id, 0, true);
    },
    enableBody$4: [function(object, type, id, radius) {
      var t1, t2;
      t1 = J.getInterceptor$x(object);
      if (t1.get$body(object) == null) {
        t2 = new E.Body2(null, null, 2, null, null, null, null, null, null, null, null, null, null, 0, null, true, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, 0, 0, 0);
        t2.Body$9(this, object, type, id, radius, 0, 0, 0, 0);
        t1.set$body(object, t2);
        object.get$anchor().set$1(0.5);
      }
    }, function(object) {
      return this.enableBody$4(object, 1, 1, 0);
    }, "enableBody$1", function(object, type) {
      return this.enableBody$4(object, type, 1, 0);
    }, "enableBody$2", function(object, type, id) {
      return this.enableBody$4(object, type, id, 0);
    }, "enableBody$3", "call$4", "call$1", "call$2", "call$3", "get$enableBody", 2, 6, 637, 433, 433, 49],
    setBounds$4: function(x, y, width, height) {
      this.bounds.setTo$4(x, y, width, height);
    },
    setBoundsToWorld$0: function() {
      this.bounds.setTo$4(J.get$x$x(this.game.get$world().get$bounds()), J.get$y$x(this.game.get$world().get$bounds()), J.get$width$x(this.game.get$world().get$bounds()), J.get$height$x(this.game.get$world().get$bounds()));
    },
    Ninja$1: function(game) {
      var t1, t2, t3, t4, t5, t6, t7, t8;
      this.game = game;
      this.time = game.get$time();
      this.gravity = 0.2;
      this.bounds = new R.Rectangle1(0, 0, J.get$width$x(game.get$world()), J.get$height$x(game.get$world()), 0, 0, 0, 0);
      this.maxObjects = 10;
      this.maxLevels = 4;
      t1 = J.get$x$x(this.game.get$world().get$bounds());
      t2 = J.get$y$x(this.game.get$world().get$bounds());
      t3 = J.get$width$x(this.game.get$world().get$bounds());
      t4 = J.get$height$x(this.game.get$world().get$bounds());
      t5 = this.maxObjects;
      t6 = this.maxLevels;
      t7 = H.setRuntimeTypeInfo([], [R.Body]);
      t8 = Array(4);
      t8.fixed$length = init;
      t8 = new R.QuadTree(10, 4, 0, null, t7, H.setRuntimeTypeInfo(t8, [R.QuadTree]));
      t8.reset$7(0, J.toInt$0$n(t1), J.toInt$0$n(t2), J.toInt$0$n(t3), J.toInt$0$n(t4), t5, t6, null);
      this.quadTree = t8;
      this.setBoundsToWorld$0();
    }
  },
  Shape1: {
    "^": "Object;body*,pos<,_Ninja0$_width<,_Ninja0$_height<,velocity@",
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.body.call$3(arg0, arg1, arg2);
    },
    get$xw: function() {
      return J.abs$0$n(J.$div$n(this.get$width(this), 2));
    },
    get$yw: function() {
      return J.abs$0$n(J.$div$n(this.get$height(this), 2));
    },
    get$width: function(_) {
      return this.get$_Ninja0$_width();
    },
    get$height: function(_) {
      return this.get$_Ninja0$_height();
    }
  },
  "+Shape": 0,
  Tile1: {
    "^": "Shape1;body:Ninja0$Tile1$body*,Ninja0$Tile1$system,pos:Ninja0$Tile1$pos<,oldpos:Ninja0$Tile1$oldpos<,_Ninja0$_width:Ninja0$Tile1$_Ninja0$_width<,_Ninja0$_height:Ninja0$Tile1$_Ninja0$_height<,Ninja0$Tile1$oH,Ninja0$Tile1$oV,velocity:Ninja0$Tile1$velocity@,Ninja0$Tile1$aabbTileProjections,signx<,signy<,sx<,sy<,id*,type*,body,system,pos,oldpos,_Ninja0$_width,_Ninja0$_height,oH,oV,velocity,aabbTileProjections",
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.Ninja0$Tile1$body.call$3(arg0, arg1, arg2);
    },
    get$xw: function() {
      return J.abs$0$n(J.$div$n(this.Ninja0$Tile1$_Ninja0$_width, 2));
    },
    get$yw: function() {
      return J.abs$0$n(J.$div$n(this.Ninja0$Tile1$_Ninja0$_height, 2));
    },
    get$width: function(_) {
      return this.Ninja0$Tile1$_Ninja0$_width;
    },
    get$height: function(_) {
      return this.Ninja0$Tile1$_Ninja0$_height;
    },
    render$5: [function(context, xOffset, yOffset, color, filled) {
      throw H.wrapException(P.Expando$("Never call!", null));
    }, "call$5", "get$render", 10, 0, 632, 142, [], 336, [], 337, [], 152, [], 623, []],
    integrate$0: function() {
      var t1, px, py;
      t1 = this.Ninja0$Tile1$pos;
      px = t1.x;
      py = t1.y;
      t1.x = J.$add$ns(px, J.$sub$n(J.$mul$ns(this.Ninja0$Tile1$body.get$drag(), this.Ninja0$Tile1$pos.x), J.$mul$ns(this.Ninja0$Tile1$body.get$drag(), this.Ninja0$Tile1$oldpos.x)));
      t1 = this.Ninja0$Tile1$pos;
      t1.y = J.$add$ns(t1.y, J.$add$ns(J.$sub$n(J.$mul$ns(this.Ninja0$Tile1$body.get$drag(), this.Ninja0$Tile1$pos.y), J.$mul$ns(this.Ninja0$Tile1$body.get$drag(), this.Ninja0$Tile1$oldpos.y)), this.Ninja0$Tile1$system.gravity * this.Ninja0$Tile1$body.get$gravityScale()));
      this.Ninja0$Tile1$velocity.set$2(J.$sub$n(this.Ninja0$Tile1$pos.x, px), J.$sub$n(this.Ninja0$Tile1$pos.y, py));
      this.Ninja0$Tile1$oldpos.set$2(px, py);
    },
    collideWorldBounds$0: [function() {
      var dx, t1, t2, dy;
      dx = J.$sub$n(this.Ninja0$Tile1$system.bounds.Phaser$Rectangle1$x, J.$sub$n(this.Ninja0$Tile1$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$Tile1$_Ninja0$_width, 2))));
      if (typeof dx !== "number")
        return H.iae(dx);
      if (0 < dx)
        this.reportCollisionVsWorld$4(dx, 0, 1, 0);
      else {
        t1 = J.$add$ns(this.Ninja0$Tile1$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$Tile1$_Ninja0$_width, 2)));
        t2 = this.Ninja0$Tile1$system.bounds;
        dx = J.$sub$n(t1, J.$add$ns(t2.Phaser$Rectangle1$x, t2.Phaser$Rectangle1$width));
        if (typeof dx !== "number")
          return H.iae(dx);
        if (0 < dx)
          this.reportCollisionVsWorld$4(-dx, 0, -1, 0);
      }
      dy = J.$sub$n(this.Ninja0$Tile1$system.bounds.Phaser$Rectangle1$y, J.$sub$n(this.Ninja0$Tile1$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$Tile1$_Ninja0$_height, 2))));
      if (typeof dy !== "number")
        return H.iae(dy);
      if (0 < dy)
        this.reportCollisionVsWorld$4(0, dy, 0, 1);
      else {
        t1 = J.$add$ns(this.Ninja0$Tile1$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$Tile1$_Ninja0$_height, 2)));
        t2 = this.Ninja0$Tile1$system.bounds;
        dy = J.$sub$n(t1, J.$add$ns(t2.Phaser$Rectangle1$y, t2.Phaser$Rectangle1$height));
        if (typeof dy !== "number")
          return H.iae(dy);
        if (0 < dy)
          this.reportCollisionVsWorld$4(0, -dy, 0, -1);
      }
    }, "call$0", "get$collideWorldBounds", 0, 0, 54],
    reportCollisionVsWorld$4: function(px, py, dx, dy) {
      var p, o, vx, vy, t1, t2, dp, t3, nx, ny, tx, ty, fx, fy, b, bx, by;
      p = this.Ninja0$Tile1$pos;
      o = this.Ninja0$Tile1$oldpos;
      vx = J.$sub$n(p.x, o.x);
      vy = J.$sub$n(p.y, o.y);
      t1 = J.getInterceptor$ns(vx);
      t2 = J.getInterceptor$ns(vy);
      dp = J.$add$ns(t1.$mul(vx, dx), t2.$mul(vy, dy));
      t3 = J.getInterceptor$ns(dp);
      nx = t3.$mul(dp, dx);
      ny = t3.$mul(dp, dy);
      tx = t1.$sub(vx, nx);
      ty = t2.$sub(vy, ny);
      if (t3.$lt(dp, 0)) {
        fx = J.$mul$ns(tx, this.Ninja0$Tile1$body.get$friction());
        fy = J.$mul$ns(ty, this.Ninja0$Tile1$body.get$friction());
        t1 = this.Ninja0$Tile1$body.get$bounce();
        if (typeof t1 !== "number")
          return H.iae(t1);
        b = 1 + t1;
        bx = J.$mul$ns(nx, b);
        by = J.$mul$ns(ny, b);
        t1 = J.getInterceptor(dx);
        if (t1.$eq(dx, 1))
          J.set$left$x(this.Ninja0$Tile1$body.get$touching(), true);
        else if (t1.$eq(dx, -1))
          J.set$right$x(this.Ninja0$Tile1$body.get$touching(), true);
        t1 = J.getInterceptor(dy);
        if (t1.$eq(dy, 1))
          this.Ninja0$Tile1$body.get$touching().set$up(true);
        else if (t1.$eq(dy, -1))
          this.Ninja0$Tile1$body.get$touching().set$down(true);
      } else {
        bx = 0;
        by = 0;
        fx = 0;
        fy = 0;
      }
      p.x = J.$add$ns(p.x, px);
      p.y = J.$add$ns(p.y, py);
      o.x = J.$add$ns(o.x, J.$add$ns(J.$add$ns(px, bx), fx));
      o.y = J.$add$ns(o.y, J.$add$ns(J.$add$ns(py, by), fy));
    },
    clear$0: function(_) {
      this.id = 0;
      this.updateType$0();
    },
    destroy$0: function() {
      this.Ninja0$Tile1$body = null;
      this.Ninja0$Tile1$system = null;
    },
    updateType$0: function() {
      var t1, slen;
      t1 = this.id;
      if (t1 === 0) {
        this.type = 0;
        this.signx = 0;
        this.signy = 0;
        this.sx = 0;
        this.sy = 0;
        return true;
      }
      if (typeof t1 !== "number")
        return t1.$lt();
      if (t1 < 2) {
        this.type = 1;
        this.signx = 0;
        this.signy = 0;
        this.sx = 0;
        this.sy = 0;
      } else if (t1 < 6) {
        this.type = 2;
        if (t1 === 2) {
          this.signx = 1;
          this.signy = -1;
          this.sx = 0.7071067811865475;
          this.sy = -0.7071067811865475;
        } else if (t1 === 3) {
          this.signx = -1;
          this.signy = -1;
          this.sx = -0.7071067811865475;
          this.sy = -0.7071067811865475;
        } else if (t1 === 4) {
          this.signx = -1;
          this.signy = 1;
          this.sx = -0.7071067811865475;
          this.sy = 0.7071067811865475;
        } else if (t1 === 5) {
          this.signx = 1;
          this.signy = 1;
          this.sx = 0.7071067811865475;
          this.sy = 0.7071067811865475;
        } else
          return false;
      } else if (t1 < 10) {
        this.type = 6;
        if (t1 === 6) {
          this.signx = 1;
          this.signy = -1;
          this.sx = 0;
          this.sy = 0;
        } else if (t1 === 7) {
          this.signx = -1;
          this.signy = -1;
          this.sx = 0;
          this.sy = 0;
        } else if (t1 === 8) {
          this.signx = -1;
          this.signy = 1;
          this.sx = 0;
          this.sy = 0;
        } else if (t1 === 9) {
          this.signx = 1;
          this.signy = 1;
          this.sx = 0;
          this.sy = 0;
        } else
          return false;
      } else if (t1 < 14) {
        this.type = 10;
        if (t1 === 10) {
          this.signx = 1;
          this.signy = -1;
          this.sx = 0;
          this.sy = 0;
        } else if (t1 === 11) {
          this.signx = -1;
          this.signy = -1;
          this.sx = 0;
          this.sy = 0;
        } else if (t1 === 12) {
          this.signx = -1;
          this.signy = 1;
          this.sx = 0;
          this.sy = 0;
        } else if (t1 === 13) {
          this.signx = 1;
          this.signy = 1;
          this.sx = 0;
          this.sy = 0;
        } else
          return false;
      } else if (t1 < 18) {
        this.type = 14;
        if (t1 === 14) {
          this.signx = 1;
          this.signy = -1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else if (t1 === 15) {
          this.signx = -1;
          this.signy = -1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else if (t1 === 16) {
          this.signx = -1;
          this.signy = 1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else if (t1 === 17) {
          this.signx = 1;
          this.signy = 1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else
          return false;
      } else if (t1 < 22) {
        this.type = 18;
        if (t1 === 18) {
          this.signx = 1;
          this.signy = -1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else if (t1 === 19) {
          this.signx = -1;
          this.signy = -1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else if (t1 === 20) {
          this.signx = -1;
          this.signy = 1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else if (t1 === 21) {
          this.signx = 1;
          this.signy = 1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else
          return false;
      } else if (t1 < 26) {
        this.type = 22;
        if (t1 === 22) {
          this.signx = 1;
          this.signy = -1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else if (t1 === 23) {
          this.signx = -1;
          this.signy = -1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else if (t1 === 24) {
          this.signx = -1;
          this.signy = 1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else if (t1 === 25) {
          this.signx = 1;
          this.signy = 1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else
          return false;
      } else if (t1 < 30) {
        this.type = 26;
        if (t1 === 26) {
          this.signx = 1;
          this.signy = -1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else if (t1 === 27) {
          this.signx = -1;
          this.signy = -1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else if (t1 === 28) {
          this.signx = -1;
          this.signy = 1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else if (t1 === 29) {
          this.signx = 1;
          this.signy = 1;
          slen = Math.sqrt(H.checkNum(5));
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else
          return false;
      } else {
        this.type = 30;
        if (t1 === 30) {
          this.signx = 0;
          this.signy = -1;
          this.sx = 0;
          this.sy = -1;
        } else if (t1 === 32) {
          this.signx = 0;
          this.signy = 1;
          this.sx = 0;
          this.sy = 1;
        } else if (t1 === 33) {
          this.signx = 1;
          this.signy = 0;
          this.sx = 1;
          this.sy = 0;
        } else if (t1 === 31) {
          this.signx = -1;
          this.signy = 0;
          this.sx = -1;
          this.sy = 0;
        } else
          return false;
      }
    },
    get$x: function(_) {
      return J.$sub$n(this.Ninja0$Tile1$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$Tile1$_Ninja0$_width, 2)));
    },
    set$x: function(_, value) {
      this.Ninja0$Tile1$pos.x = value;
    },
    get$y: function(_) {
      return J.$sub$n(this.Ninja0$Tile1$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$Tile1$_Ninja0$_height, 2)));
    },
    set$y: function(_, value) {
      this.Ninja0$Tile1$pos.y = value;
    },
    get$bottom: function(_) {
      return J.$add$ns(this.Ninja0$Tile1$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$Tile1$_Ninja0$_height, 2)));
    },
    get$right: function(_) {
      return J.$add$ns(this.Ninja0$Tile1$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$Tile1$_Ninja0$_width, 2)));
    },
    Tile$6: function(body, x, y, width, height, type) {
      var t1;
      this.Ninja0$Tile1$body = body;
      this.Ninja0$Tile1$system = body.system;
      this.id = type;
      this.type = 0;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.Ninja0$Tile1$pos = t1;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.Ninja0$Tile1$oldpos = t1;
      if (type > 1 && type < 30)
        height = width;
      this.Ninja0$Tile1$_Ninja0$_width = width;
      this.Ninja0$Tile1$_Ninja0$_height = height;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.Ninja0$Tile1$velocity = t1;
      this.signx = 0;
      this.signy = 0;
      this.sx = 0;
      this.sy = 0;
      body.gravityScale = 0;
      this.Ninja0$Tile1$body.set$collideWorldBounds(false);
      t1 = this.id;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 > 0)
        if (t1 === 0) {
          this.id = 0;
          this.updateType$0();
        } else {
          this.id = t1;
          this.updateType$0();
        }
    },
    static: {"^": "Tile_EMPTY,Tile_FULL,Tile_SLOPE_45DEGpn,Tile_SLOPE_45DEGnn,Tile_SLOPE_45DEGnp,Tile_SLOPE_45DEGpp,Tile_CONCAVEpn,Tile_CONCAVEnn,Tile_CONCAVEnp,Tile_CONCAVEpp,Tile_CONVEXpn,Tile_CONVEXnn,Tile_CONVEXnp,Tile_CONVEXpp,Tile_SLOPE_22DEGpnS,Tile_SLOPE_22DEGnnS,Tile_SLOPE_22DEGnpS,Tile_SLOPE_22DEGppS,Tile_SLOPE_22DEGpnB,Tile_SLOPE_22DEGnnB,Tile_SLOPE_22DEGnpB,Tile_SLOPE_22DEGppB,Tile_SLOPE_67DEGpnS,Tile_SLOPE_67DEGnnS,Tile_SLOPE_67DEGnpS,Tile_SLOPE_67DEGppS,Tile_SLOPE_67DEGpnB,Tile_SLOPE_67DEGnnB,Tile_SLOPE_67DEGnpB,Tile_SLOPE_67DEGppB,Tile_HALFd,Tile_HALFr,Tile_HALFu,Tile_HALFl,Tile_TYPE_EMPTY,Tile_TYPE_FULL,Tile_TYPE_45DEG,Tile_TYPE_CONCAVE,Tile_TYPE_CONVEX,Tile_TYPE_22DEGs,Tile_TYPE_22DEGb,Tile_TYPE_67DEGs,Tile_TYPE_67DEGb,Tile_TYPE_HALF"}
  },
  "+Tile": 0
}],
["P2", "package:play_phaser/p2.dart", , L, {
  "^": "",
  Body1: {
    "^": "Body;game:P20$Body1$game@-613,system,sprite@,type:P20$Body1$type*-614,offset*,data*,velocity:P20$Body1$velocity@-638,force>,gravity:P20$Body1$gravity@-615,onBeginContact<,onEndContact<,collidesWith,removeNextStep,debugBody,_collideWorldBounds,_bodyCallbacks,_groupCallbacks,height:P20$Body1$height*-616,tilePadding:P20$Body1$tilePadding@-615,game-613,position-615,tilePadding-615,Phaser$Body$width-616,Phaser$Body$height-616,velocity-615,acceleration-615,maxVelocity-615,collideWorldBounds-617,bounce-12,type-614,angularVelocity-616,gravity-615,drag-12,angularDrag-616,immovable-617,Phaser$Body$x-616,Phaser$Body$y-616,speed-616,blocked-618,angle-616,moves-617,phase-614,_reset-617,safeRemove-617,touching-618,Phaser$Rectangle1$x-616,Phaser$Rectangle1$y-616,Phaser$Rectangle1$width-616,Phaser$Rectangle1$height-616,x-616,y-616,width-616,height-616",
    sprite$3: function(arg0, arg1, arg2) {
      return this.sprite.call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.sprite.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.sprite.call$4(arg0, arg1, arg2, arg3);
    },
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    setSize$4: [function(x, y, width, height) {
      throw H.wrapException(P.Exception_Exception("Should not be called in P2!"));
    }, "call$4", "get$setSize", 8, 0, 350, 9, [], 10, [], 31, [], 52, [], "setSize"],
    get$allowSleep: function() {
      return this.data.get$allowSleep();
    },
    get$angle: [function(_) {
      return R.Math_wrapAngle(J.$mul$ns(J.get$angle$x(this.data), 57.29577951308232), false);
    }, null, null, 1, 0, 619, "angle"],
    angle$0: function($receiver) {
      return this.get$angle(this).call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.get$angle(this).call$2(arg0, arg1);
    },
    set$angle: [function(_, value) {
      J.set$angle$x(this.data, R.Math_wrapAngle(value, false) * 0.017453292519943295);
    }, null, null, 3, 0, 620, 138, [], "angle"],
    set$angularDamping: function(value) {
      this.data.set$angularDamping(value);
    },
    get$angularForce: function() {
      return this.data.get$angularForce();
    },
    get$angularVelocity: [function() {
      return this.data.get$angularVelocity();
    }, null, null, 1, 0, 619, "angularVelocity"],
    set$angularVelocity: [function(value) {
      this.data.set$angularVelocity(value);
    }, null, null, 3, 0, 620, 138, [], "angularVelocity"],
    set$damping: function(value) {
      this.data.set$damping(value);
    },
    get$fixedRotation: function() {
      return this.data.get$fixedRotation();
    },
    get$mass: function() {
      return this.data.get$mass();
    },
    set$mass: function(value) {
      if (value !== this.data.get$mass()) {
        this.data.set$mass(value);
        this.data.updateMassProperties$0();
      }
    },
    get$rotation: function() {
      return J.get$angle$x(this.data);
    },
    set$rotation: function(value) {
      J.set$angle$x(this.data, value);
    },
    get$sleepSpeedLimit: function() {
      return this.data.get$sleepSpeedLimit();
    },
    get$x: [function(_) {
      return this.system.mpxi$1(J.get$position$x(this.data).x);
    }, null, null, 1, 0, 619, "x"],
    set$x: [function(_, value) {
      J.get$position$x(this.data).x = this.system.pxmi$1(value);
    }, null, null, 3, 0, 620, 138, [], "x"],
    get$y: [function(_) {
      return this.system.mpxi$1(J.get$position$x(this.data).y);
    }, null, null, 1, 0, 619, "y"],
    set$y: [function(_, value) {
      J.get$position$x(this.data).y = this.system.pxmi$1(value);
    }, null, null, 3, 0, 620, 138, [], "y"],
    get$id: function(_) {
      return J.get$id$x(this.data);
    },
    get$debug: function() {
      return this.debugBody != null;
    },
    debug$0: function() {
      return this.get$debug().call$0();
    },
    set$debug: function(value) {
      var t1, t2, t3, t4, t5, t6, t7;
      t1 = value === true;
      if (t1 && this.debugBody == null) {
        t1 = this.P20$Body1$game;
        t2 = this.data;
        t3 = new R.Point(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new R.Point(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = new M.Point0(null, null);
        t6.x = 1;
        t6.y = 1;
        t7 = new M.Point0(null, null);
        t7.x = 0;
        t7.y = 0;
        t7 = new L.BodyDebug(null, null, null, null, null, null, "group", false, false, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, t3, null, t4, null, [], false, 0, 0, t5, t6, t7, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t7.Group$6(t1, null, "group", false, false, 0, null);
        t7.BodyDebug$6$alpha$debugPolygons$lineWidth$pixelsPerLengthUnit(t1, t2, 0.5, false, 1, 20);
        this.debugBody = t7;
      } else if (!t1 && this.debugBody != null) {
        this.debugBody.destroy$0();
        this.debugBody = null;
      }
    },
    get$collideWorldBounds: [function() {
      return this._collideWorldBounds;
    }, null, null, 1, 0, 247, "collideWorldBounds"],
    set$collideWorldBounds: [function(value) {
      var t1 = value === true;
      if (t1 && this._collideWorldBounds !== true) {
        this._collideWorldBounds = true;
        this.updateCollisionMask$0();
      } else if (!t1 && this._collideWorldBounds === true) {
        this._collideWorldBounds = false;
        this.updateCollisionMask$0();
      }
    }, null, null, 3, 0, 639, 138, [], "collideWorldBounds"],
    getCollisionMask$0: function() {
      var t1 = {};
      t1.mask_0 = 0;
      if (this._collideWorldBounds === true)
        t1.mask_0 = this.P20$Body1$game.get$physics().get$p2().get$boundsCollisionGroup().mask;
      this.collidesWith.forEach$1(0, new L.Body_getCollisionMask_closure(t1));
      return t1.mask_0;
    },
    updateCollisionMask$1: function(shape) {
      var mask, i, t1;
      mask = this.getCollisionMask$0();
      for (i = this.data.get$shapes().length - 1; i >= 0; --i) {
        t1 = this.data.get$shapes();
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].set$collisionMask(mask);
      }
    },
    updateCollisionMask$0: function() {
      return this.updateCollisionMask$1(null);
    },
    collides$3: [function(group, callback, shape) {
      var i, t1, mask;
      for (i = 0; C.JSInt_methods.$lt(i, group.get$length(group)); ++i)
        if (!this.collidesWith.contains$1(0, group.$index(0, i))) {
          this.collidesWith.add$1(0, group.$index(0, i));
          t1 = group.$index(0, i);
          this._groupCallbacks.$indexSet(0, t1.get$mask(t1), callback);
        }
      mask = this.getCollisionMask$0();
      shape.set$collisionMask(mask);
    }, function(group) {
      return this.collides$3(group, null, null);
    }, "collides$1", function(group, callback) {
      return this.collides$3(group, callback, null);
    }, "collides$2", "call$3", "call$1", "call$2", "get$collides", 2, 4, 640, 12, 12],
    applyDamping$1: [function(dt) {
      this.data.applyDamping$1(dt);
    }, "call$1", "get$applyDamping", 2, 0, 620],
    setZeroForce$0: function() {
      this.data.setZeroForce$0();
    },
    reverse$1: [function(speed) {
      var magnitude, angle, t1, t2;
      magnitude = this.system.pxmi$1(speed.$negate(0));
      angle = J.$add$ns(J.get$angle$x(this.data), 1.5707963267948966);
      t1 = J.get$force$x(this.data);
      t2 = J.getInterceptor$ns(magnitude);
      t1.x = J.$sub$n(t1.x, t2.$mul(magnitude, Math.cos(H.checkNum(angle))));
      t1 = J.get$force$x(this.data);
      t1.y = J.$sub$n(t1.y, t2.$mul(magnitude, Math.sin(H.checkNum(angle))));
    }, "call$1", "get$reverse", 2, 0, 102],
    moveLeft$1: [function(speed) {
      this.data.get$velocity().x = this.system.pxmi$1(J.$negate$n(speed));
    }, "call$1", "get$moveLeft", 2, 0, 102, 624, [], "moveLeft"],
    moveRight$1: [function(speed) {
      this.data.get$velocity().x = this.system.pxmi$1(speed);
    }, "call$1", "get$moveRight", 2, 0, 102, 624, [], "moveRight"],
    moveUp$1: [function(speed) {
      this.data.get$velocity().y = this.system.pxmi$1(J.$negate$n(speed));
    }, "call$1", "get$moveUp", 2, 0, 102, 624, [], "moveUp"],
    moveDown$1: [function(speed) {
      this.data.get$velocity().y = this.system.pxmi$1(speed);
    }, "call$1", "get$moveDown", 2, 0, 102, 624, [], "moveDown"],
    preUpdate$0: [function() {
      if (this.removeNextStep === true) {
        this.removeFromWorld$0();
        this.removeNextStep = false;
      }
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    postUpdate$0: [function() {
      J.set$x$x(this.sprite, this.system.mpxi$1(J.get$position$x(this.data).x));
      J.set$y$x(this.sprite, this.system.mpxi$1(J.get$position$x(this.data).y));
      if (!this.data.get$fixedRotation())
        this.sprite.set$rotation(J.get$angle$x(this.data));
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    reset$4: [function(_, x, y, resetDamping, resetMass) {
      if (resetDamping == null)
        resetDamping = false;
      if (resetMass == null)
        resetMass = false;
      this.data.setZeroForce$0();
      this.data.get$velocity().x = 0;
      this.data.get$velocity().y = 0;
      this.data.set$angularVelocity(0);
      if (resetDamping === true) {
        this.data.set$damping(0);
        this.data.set$angularDamping(0);
      }
      if (resetMass === true)
        this.set$mass(1);
      J.get$position$x(this.data).x = this.system.pxmi$1(x);
      J.get$position$x(this.data).y = this.system.pxmi$1(y);
    }, function($receiver, x, y, resetDamping) {
      return this.reset$4($receiver, x, y, resetDamping, false);
    }, "reset$3", function($receiver, x, y) {
      return this.reset$4($receiver, x, y, false, false);
    }, "reset$2", "call$4", "call$3", "call$2", "get$reset", 4, 4, 628, 19, 19, 9, [], 10, [], 641, [], 642, [], "reset"],
    addToWorld$0: [function() {
      var i, t1;
      if (this.P20$Body1$game.get$physics().get$p2().get$toRemove() != null)
        for (i = 0; i < this.P20$Body1$game.get$physics().get$p2().get$toRemove().length; ++i) {
          t1 = this.P20$Body1$game.get$physics().get$p2().get$toRemove();
          if (i >= t1.length)
            return H.ioore(t1, i);
          if (t1[i] === this)
            J.removeAt$1$ax(this.P20$Body1$game.get$physics().get$p2().get$toRemove(), i);
        }
      if (!J.$eq(this.data.get$world(), this.P20$Body1$game.get$physics().get$p2()))
        this.P20$Body1$game.get$physics().get$p2().addBody$1(this);
    }, "call$0", "get$addToWorld", 0, 0, 54, "addToWorld"],
    removeFromWorld$0: [function() {
      if (J.$eq(this.data.get$world(), this.P20$Body1$game.get$physics().get$p2()))
        this.P20$Body1$game.get$physics().get$p2().removeBodyNextStep$1(this);
    }, "call$0", "get$removeFromWorld", 0, 0, 54, "removeFromWorld"],
    destroy$0: [function() {
      this.removeFromWorld$0();
      this.clearShapes$0();
      this._bodyCallbacks = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._groupCallbacks = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      var t1 = this.debugBody;
      if (t1 != null)
        t1.destroy$0();
      this.debugBody = null;
      J.set$body$x(this.sprite, null);
      this.sprite = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    clearShapes$0: function() {
      var i, i0, t1, t2;
      i = this.data.get$shapes().length;
      for (; i0 = i - 1, i > 0; i = i0) {
        t1 = this.data;
        t2 = t1.get$shapes();
        if (i0 < 0 || i0 >= t2.length)
          return H.ioore(t2, i0);
        t1.removeShape$1(t2[i0]);
      }
      this.shapeChanged$0();
    },
    addShape$4: function(shape, offsetX, offsetY, rotation) {
      var t1, t2, t3, t4;
      if (offsetY == null)
        offsetY = 0;
      if (rotation == null)
        rotation = 0;
      t1 = this.data;
      t2 = this.system.pxmi$1(offsetX);
      t3 = this.system.pxmi$1(offsetY);
      t4 = new A.vec2(0, 0);
      t4.x = t2;
      t4.y = t3;
      t1.addShape$3(shape, t4, rotation);
      this.shapeChanged$0();
      return shape;
    },
    addShape$1: function(shape) {
      return this.addShape$4(shape, 0, 0, 0);
    },
    addShape$3: function(shape, offsetX, offsetY) {
      return this.addShape$4(shape, offsetX, offsetY, 0);
    },
    removeShape$1: function(shape) {
      var result = this.data.removeShape$1(shape);
      this.shapeChanged$0();
      return result;
    },
    shapeChanged$0: function() {
      var t1 = this.debugBody;
      if (t1 != null)
        t1.draw$0();
    },
    Body$5: function(game, sprite, x, y, mass) {
      var t1, t2, t3;
      this.P20$Body1$game = game;
      t1 = game.get$physics().get$p2();
      this.system = t1;
      this.sprite = sprite;
      this.P20$Body1$type = 1;
      t2 = new R.Point(null, null);
      t2.x = 0;
      t2.y = 0;
      this.offset = t2;
      t1 = t1.pxmi$1(x);
      t2 = this.system.pxmi$1(y);
      t3 = new A.vec2(0, 0);
      t3.x = t1;
      t3.y = t2;
      t3 = A.Body$0(0, 0.1, 0, 0, 0.1, false, null, mass, t3, null, null);
      this.data = t3;
      t3.parent = this;
      t3 = new L.InversePointProxy(this.system, this.data.get$velocity(), null, null);
      t3.set$x(0, 0);
      t3.set$y(0, 0);
      this.P20$Body1$velocity = t3;
      t3 = new L.InversePointProxy(this.system, J.get$force$x(this.data), null, null);
      t3.set$x(0, 0);
      t3.set$y(0, 0);
      this.force = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.P20$Body1$gravity = t3;
      this.onBeginContact = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onEndContact = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.collidesWith = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
      this.removeNextStep = false;
      this.debugBody = null;
      this._collideWorldBounds = true;
      this._bodyCallbacks = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._groupCallbacks = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      if (sprite != null) {
        this.clearShapes$0();
        t1 = J.getInterceptor$x(sprite);
        t2 = t1.get$width(sprite);
        t1 = t1.get$height(sprite);
        t3 = sprite.get$rotation();
        this.addShape$4(A.Rectangle$0(this.system.pxm$1(t2), this.system.pxm$1(t1)), 0, 0, t3);
        if (sprite.get$exists() === true)
          this.P20$Body1$game.get$physics().get$p2().addBody$1(this);
      }
    },
    $isBody1: true,
    static: {"^": "Body_DYNAMIC,Body_STATIC,Body_KINEMATIC"}
  },
  "+Body": 0,
  Body_getCollisionMask_closure: {
    "^": "Closure:643;box_0",
    call$1: function(c) {
      var t1, t2, t3;
      t1 = this.box_0;
      t2 = t1.mask_0;
      t3 = J.get$mask$x(c);
      if (typeof t3 !== "number")
        return H.iae(t3);
      t1.mask_0 = (t2 | t3) >>> 0;
    }
  },
  BodyDebug: {
    "^": "Group;game:P20$BodyDebug$game@-613,body*,canvas*,ppu,debugPolygons,game-613,name-644,addToStage-617,enableBody-617,physicsBodyType-616,z-614,type-614,alive-617,exists-617,ignoreDestroy-617,_Phaser$_dirty-617,cursor-12,cameraOffset-615,_sortProperty-644,enableBodyDebug-617,_cache-645,creator-646,renderOrderID-614,Phaser$Group$children-647,autoCull-617,events-648,_anchor-615,_Phaser$_currentBounds-649,Phaser$Group$position-615,onDestroy-650,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.body.call$3(arg0, arg1, arg2);
    },
    update$0: [function() {
      J.set$x$x(this.Phaser$Group$position, J.$mul$ns(J.get$x$x(J.get$position$x(this.body)), this.ppu));
      J.set$y$x(this.Phaser$Group$position, J.$mul$ns(J.get$y$x(J.get$position$x(this.body)), this.ppu));
      this.rotation = J.get$angle$x(this.body);
    }, "call$0", "get$update", 0, 0, 54, "update"],
    draw$0: function() {
      var obj, sprite, red, green, blue, color, lw, l, t1, t2, t3, t4, t5, i, v, vrot, verts, _j, t6, child, offset, angle, t7, t8, lineWidth, color0, t9, t10, t11, out, _ref1, j, t12, xd;
      obj = this.body;
      sprite = this.canvas;
      sprite.clear$0(0);
      red = C.C__JSRandom.nextInt$1(256);
      green = C.C__JSRandom.nextInt$1(256);
      blue = C.C__JSRandom.nextInt$1(256);
      red = C.JSNumber_methods.toInt$0(Math.floor((red + 765) / 4));
      green = C.JSNumber_methods.toInt$0(Math.floor((green + 765) / 4));
      blue = C.JSNumber_methods.toInt$0(Math.floor((blue + 765) / 4));
      color = H.Primitives_parseInt(this.componentToHex$1(red) + this.componentToHex$1(green) + this.componentToHex$1(blue), 16, null);
      lw = this.canvas.lineWidth;
      if (!!J.getInterceptor(obj).$isBody3 && obj.shapes.length !== 0) {
        l = obj.get$shapes().length;
        for (t1 = sprite._graphicsData, t2 = J.getInterceptor$asx(t1), t3 = lw == null, t4 = color == null, t5 = J.getInterceptor$ns(lw), i = 0, v = null, vrot = null, verts = null, _j = null; i !== l;) {
          t6 = obj.get$shapes();
          if (i >= t6.length)
            return H.ioore(t6, i);
          child = t6[i];
          t6 = obj.get$shapeOffsets();
          if (i >= t6.length)
            return H.ioore(t6, i);
          offset = t6[i];
          t6 = obj.get$shapeAngles();
          if (i >= t6.length)
            return H.ioore(t6, i);
          angle = t6[i];
          if (angle == null)
            angle = 0;
          t6 = J.getInterceptor(child);
          if (!!t6.$isCircle2) {
            t6 = J.$mul$ns(offset.x, this.ppu);
            t7 = J.$mul$ns(offset.y, this.ppu);
            t8 = J.$mul$ns(child.radius, this.ppu);
            lineWidth = t3 ? 1 : lw;
            color0 = t4 ? 16777215 : color;
            sprite.lineStyle$3(lineWidth, 0, 1);
            sprite.filling = true;
            sprite.fillColor = color0;
            sprite.fillAlpha = 1;
            t9 = J.getInterceptor$n(t8);
            sprite.drawCircle$3(t6, t7, t9.$negate(t8));
            sprite.filling = false;
            sprite.fillColor = null;
            sprite.fillAlpha = 1;
            sprite.moveTo$2(0, t6, t7);
            t10 = J.getInterceptor$n(angle);
            t11 = t10.$negate(angle);
            if (typeof t11 !== "number")
              H.throwExpression(P.ArgumentError$(t11));
            t6 = J.$add$ns(t6, t9.$mul(t8, Math.cos(t11)));
            t10 = t10.$negate(angle);
            if (typeof t10 !== "number")
              H.throwExpression(P.ArgumentError$(t10));
            t7 = J.$add$ns(t7, t9.$mul(t8, Math.sin(t10)));
            J.addAll$1$ax(J.get$points$x(sprite._currentPath), [t6, t7]);
            sprite._dirty = true;
          } else if (!!t6.$isConvex) {
            verts = [];
            out = new A.vec2(0, 0);
            out.x = 0;
            out.y = 0;
            t6 = child.vertices;
            _ref1 = t6.length;
            _j = 0;
            j = 0;
            while (true) {
              if (!(_j < _ref1))
                break;
              if (j < 0 || j >= t6.length)
                return H.ioore(t6, j);
              v = t6[j];
              A.vec2_rotate(out, v, angle);
              t7 = J.$mul$ns(J.$add$ns(out.x, offset.x), this.ppu);
              t8 = J.$mul$ns(J.$negate$n(J.$add$ns(out.y, offset.y)), this.ppu);
              t9 = new A.vec2(0, 0);
              t9.x = t7;
              t9.y = t8;
              verts.push(t9);
              ++_j;
              j = _j;
            }
            this.drawConvex$8(sprite, verts, child.triangles, 16711680, color, lw, this.debugPolygons, [J.$mul$ns(offset.x, this.ppu), J.$mul$ns(J.$negate$n(offset.y), this.ppu)]);
            vrot = out;
          } else if (!!t6.$isPlane) {
            t6 = J.$mul$ns(offset.x, this.ppu);
            t7 = J.$mul$ns(J.$negate$n(offset.y), this.ppu);
            t8 = t5.$mul(lw, 5);
            t5.$mul(lw, 10);
            t5.$mul(lw, 10);
            t9 = this.ppu;
            if (typeof t9 !== "number")
              return t9.$mul();
            color0 = t4 ? 16777215 : color;
            sprite.lineStyle$3(t8, 16711680, 11);
            sprite.filling = true;
            sprite.fillColor = color0;
            sprite.fillAlpha = 1;
            t8 = J.getInterceptor$n(t7);
            sprite.moveTo$2(0, t6, t8.$negate(t7));
            t9 = typeof angle !== "number";
            if (t9)
              H.throwExpression(P.ArgumentError$(angle));
            t10 = Math.cos(angle);
            t11 = J.get$width$x(this.P20$BodyDebug$game);
            if (typeof t11 !== "number")
              return H.iae(t11);
            t12 = J.getInterceptor$ns(t6);
            xd = t12.$add(t6, t10 * t11);
            if (t9)
              H.throwExpression(P.ArgumentError$(angle));
            t10 = Math.sin(angle);
            t11 = J.get$height$x(this.P20$BodyDebug$game);
            if (typeof t11 !== "number")
              return H.iae(t11);
            t11 = J.$negate$n(t8.$add(t7, t10 * t11));
            J.addAll$1$ax(J.get$points$x(sprite._currentPath), [xd, t11]);
            sprite._dirty = true;
            sprite.moveTo$2(0, t6, t8.$negate(t7));
            if (t9)
              H.throwExpression(P.ArgumentError$(angle));
            t10 = Math.cos(angle);
            t11 = J.$negate$n(J.get$width$x(this.P20$BodyDebug$game));
            if (typeof t11 !== "number")
              return H.iae(t11);
            xd = t12.$add(t6, t10 * t11);
            if (t9)
              H.throwExpression(P.ArgumentError$(angle));
            t6 = Math.sin(angle);
            t9 = J.$negate$n(J.get$height$x(this.P20$BodyDebug$game));
            if (typeof t9 !== "number")
              return H.iae(t9);
            t9 = J.$negate$n(t8.$add(t7, t6 * t9));
            J.addAll$1$ax(J.get$points$x(sprite._currentPath), [xd, t9]);
            sprite._dirty = true;
          } else if (!!t6.$isRectangle2) {
            t6 = J.$mul$ns(offset.x, this.ppu);
            t7 = J.$mul$ns(J.$negate$n(offset.y), this.ppu);
            t8 = J.$mul$ns(child.width, this.ppu);
            t9 = J.$mul$ns(child.height, this.ppu);
            lineWidth = t3 ? 1 : lw;
            sprite.lineStyle$3(lineWidth, 16711680, 1);
            sprite.filling = true;
            sprite.fillColor = color;
            sprite.fillAlpha = 1;
            t6 = J.$sub$n(t6, J.$div$n(t8, 2));
            t7 = J.$sub$n(t7, J.$div$n(t9, 2));
            if (J.$eq(J.get$length$asx(J.get$points$x(sprite._currentPath)), 0))
              if (J.$gt$n(t2.get$length(t1), 0))
                t2.removeLast$0(t1);
            t10 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, $.Graphics_POLY);
            t10.lineWidth = sprite.lineWidth;
            t10.lineColor = sprite.lineColor;
            t10.lineAlpha = sprite.lineAlpha;
            t10.fillColor = sprite.fillColor;
            t10.fillAlpha = sprite.fillAlpha;
            t10.fill = sprite.filling;
            t10.points = [t6, t7, t8, t9];
            t10.type = $.Graphics_RECT;
            sprite._currentPath = t10;
            t2.add$1(t1, t10);
            sprite._dirty = true;
          }
          ++i;
        }
      }
    },
    drawConvex$8: function(g, verts, triangles, color, fillColor, lineWidth, debug, offset) {
      var i, t1, v, x, y, t2, colors, v0, i0, v1, x0, y0, x1, y1, t3;
      if (lineWidth == null)
        lineWidth = 1;
      if (debug !== true) {
        g.lineStyle$3(lineWidth, color, 1);
        g.filling = true;
        g.fillColor = fillColor;
        g.fillAlpha = 1;
        for (i = 0; t1 = verts.length, i !== t1;) {
          if (i >= t1)
            return H.ioore(verts, i);
          v = verts[i];
          x = v.x;
          y = v.y;
          t1 = J.getInterceptor$n(y);
          if (i === 0)
            g.moveTo$2(0, x, t1.$negate(y));
          else {
            t1 = t1.$negate(y);
            J.addAll$1$ax(J.get$points$x(g._currentPath), [x, t1]);
            g._dirty = true;
          }
          ++i;
        }
        g.filling = false;
        g.fillColor = null;
        g.fillAlpha = 1;
        if (t1 > 2) {
          t1 = verts[t1 - 1];
          g.moveTo$2(0, t1.x, J.$negate$n(t1.y));
          if (0 >= verts.length)
            return H.ioore(verts, 0);
          t1 = verts[0];
          t2 = t1.x;
          t1 = J.$negate$n(t1.y);
          J.addAll$1$ax(J.get$points$x(g._currentPath), [t2, t1]);
          g._dirty = true;
          return g;
        }
      } else {
        colors = [16711680, 65280, 255];
        for (t1 = J.getInterceptor$ns(lineWidth), i = 0; t2 = verts.length, i !== t2 + 1; i = i0) {
          v0 = verts[C.JSInt_methods.$mod(i, t2)];
          i0 = i + 1;
          v1 = verts[C.JSInt_methods.$mod(i0, t2)];
          x0 = v0.x;
          y0 = v0.y;
          x1 = v1.x;
          y1 = v1.y;
          g.lineStyle$3(lineWidth, colors[C.JSInt_methods.$mod(i, 3)], 1);
          t2 = J.getInterceptor$n(y0);
          g.moveTo$2(0, x0, t2.$negate(y0));
          t3 = J.$negate$n(y1);
          J.addAll$1$ax(J.get$points$x(g._currentPath), [x1, t3]);
          g._dirty = true;
          g.drawCircle$3(x0, t2.$negate(y0), t1.$mul(lineWidth, 2));
        }
        g.lineStyle$3(lineWidth, 0, 1);
        return g.drawCircle$3(C.JSArray_methods.get$x(offset), C.JSArray_methods.get$y(offset), t1.$mul(lineWidth, 2));
      }
    },
    componentToHex$1: function(c) {
      var hex = C.JSInt_methods.toRadixString$1(c, 16);
      if (hex.length === 2)
        return hex;
      else
        return hex + "0";
    },
    BodyDebug$6$alpha$debugPolygons$lineWidth$pixelsPerLengthUnit: function(game, body, alpha, debugPolygons, lineWidth, pixelsPerLengthUnit) {
      var t1;
      this.P20$BodyDebug$game = game;
      this.body = body;
      this.debugPolygons = debugPolygons;
      this.ppu = pixelsPerLengthUnit;
      this.ppu = -1 * pixelsPerLengthUnit;
      t1 = R.Graphics$(game, 0, 0);
      this.canvas = t1;
      t1.alpha = alpha;
      this.add$1(0, t1);
      this.draw$0();
    },
    $asGroup: function() {
      return [null];
    },
    $asGroup: function() {
      return [null];
    }
  },
  CollisionGroup: {
    "^": "Object;mask*"
  },
  InversePointProxy: {
    "^": "Point;world@,destination>,x-616,y-616",
    get$x: [function(_) {
      return this.world.mpxi$1(J.get$x$x(this.destination));
    }, null, null, 1, 0, 54, "x"],
    set$x: [function(_, value) {
      J.set$x$x(this.destination, this.world.pxmi$1(value));
    }, null, null, 3, 0, 102, 138, [], "x"],
    get$y: [function(_) {
      return this.world.mpxi$1(J.get$y$x(this.destination));
    }, null, null, 1, 0, 619, "y"],
    set$y: [function(_, value) {
      J.set$y$x(this.destination, this.world.pxmi$1(value));
    }, null, null, 3, 0, 620, 138, [], "y"]
  },
  Walls: {
    "^": "Object;left*,right*,top*,bottom*"
  },
  P2: {
    "^": "Object;game@,world@,frameRate,useElapsedTime,paused*,materials,gravity@,onBodyAdded,onBodyRemoved,onSpringAdded,onSpringRemoved,onConstraintAdded,onConstraintRemoved,onContactMaterialAdded,onContactMaterialRemoved,postBroadphaseCallback,onBeginContact<,onEndContact<,collisionGroups,nothingCollisionGroup,boundsCollisionGroup<,everythingCollisionGroup,boundsCollidesWith,_toRemove,_collisionGroupID,impactCallback,walls",
    get$friction: function() {
      return this.world.get$defaultContactMaterial().friction;
    },
    set$restitution: function(value) {
      this.world.get$defaultContactMaterial().restitution = value;
    },
    get$applyDamping: function() {
      return this.world.get$applyDamping();
    },
    applyDamping$1: function(arg0) {
      return this.get$applyDamping().call$1(arg0);
    },
    get$time: function() {
      return this.world.get$time();
    },
    get$total: function(_) {
      return J.get$length$asx(this.world.get$bodies());
    },
    paused$0: function($receiver) {
      return this.paused.call$0();
    },
    get$toRemove: function() {
      return this._toRemove;
    },
    removeBodyNextStep$1: function(body) {
      this._toRemove.push(body);
    },
    preUpdate$0: function() {
      var i, i0, t1;
      i = this._toRemove.length;
      for (; i0 = i - 1, i > 0; i = i0) {
        t1 = this._toRemove;
        if (i0 < 0 || i0 >= t1.length)
          return H.ioore(t1, i0);
        t1 = t1[i0];
        if (J.$eq(t1.data.get$world(), this.world)) {
          this.world.removeBody$1(t1.data);
          this.onBodyRemoved.dispatch$1(t1);
        }
      }
      J.set$length$asx(this._toRemove, 0);
    },
    enable$3: function(_, object, debug, children) {
      var t1, i, t2, i0;
      if (debug == null)
        debug = false;
      t1 = J.getInterceptor(object);
      if (!!t1.$isList) {
        i = t1.get$length(object);
        for (; t2 = J.getInterceptor$n(i), i0 = t2.$sub(i, 1), t2.$gt(i, 0); i = i0)
          if (!!J.getInterceptor(t1.$index(object, i0)).$isGroup)
            this.enable$3(0, J.get$children$x(t1.$index(object, i0)), debug, children);
          else {
            this.enableBody$2(t1.$index(object, i0), debug);
            if (children && J.$gt$n(J.get$length$asx(J.get$children$x(t1.$index(object, i0))), 0))
              this.enable$3(0, t1.$index(object, i0), debug, true);
          }
      } else if (!!t1.$isGroup)
        this.enable$3(0, object.Phaser$Group$children, debug, children);
      else {
        this.enableBody$2(object, debug);
        if (children && J.$gt$n(J.get$length$asx(t1.get$children(object)), 0))
          this.enable$3(0, t1.get$children(object), debug, true);
      }
    },
    enable$2: function($receiver, object, debug) {
      return this.enable$3($receiver, object, debug, true);
    },
    enable$1: function($receiver, object) {
      return this.enable$3($receiver, object, false, true);
    },
    enableBody$2: [function(object, debug) {
      var t1, body, t2, t3, t4, t5, t6, t7, t8, t9;
      t1 = J.getInterceptor$x(object);
      if (t1.get$body(object) == null) {
        body = new L.Body1(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, 0, 0, 0);
        body.Body$5(this.game, object, t1.get$x(object), t1.get$y(object), 1);
        t2 = debug === true;
        if (t2 && body.debugBody == null) {
          t2 = body.P20$Body1$game;
          t3 = body.data;
          t4 = new R.Point(null, null);
          t4.x = 0;
          t4.y = 0;
          t5 = new R.Point(null, null);
          t5.x = 0;
          t5.y = 0;
          t6 = new M.Point0(null, null);
          t6.x = 0;
          t6.y = 0;
          t7 = new M.Point0(null, null);
          t7.x = 1;
          t7.y = 1;
          t8 = new M.Point0(null, null);
          t8.x = 0;
          t8.y = 0;
          t9 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
          t4 = new L.BodyDebug(null, null, null, null, null, null, "group", false, false, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, t4, null, t5, null, [], false, 0, 0, t6, t7, t8, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t9, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
          t4.Group$6(t2, null, "group", false, false, 0, null);
          t4.BodyDebug$6$alpha$debugPolygons$lineWidth$pixelsPerLengthUnit(t2, t3, 0.5, false, 1, 20);
          body.debugBody = t4;
        } else if (!t2 && body.debugBody != null) {
          body.debugBody.destroy$0();
          body.debugBody = null;
        }
        t1.set$body(object, body);
        object.get$anchor().set$1(0.5);
      }
    }, "call$2", "get$enableBody", 4, 0, 664],
    beginContactHandler$1: [function($event) {
      var t1 = J.getInterceptor$asx($event);
      this.onBeginContact.dispatch$1([t1.$index($event, "bodyA"), t1.$index($event, "bodyB"), t1.$index($event, "shapeA"), t1.$index($event, "shapeB"), t1.$index($event, "contactEquations")]);
      if (J.get$parent$x(t1.$index($event, "bodyA")) != null)
        J.get$parent$x(t1.$index($event, "bodyA")).get$onBeginContact().dispatch$1([J.get$parent$x(t1.$index($event, "bodyB")), t1.$index($event, "shapeA"), t1.$index($event, "shapeB"), t1.$index($event, "contactEquations")]);
      if (J.get$parent$x(t1.$index($event, "bodyB")) != null)
        J.get$parent$x(t1.$index($event, "bodyB")).get$onBeginContact().dispatch$1([J.get$parent$x(t1.$index($event, "bodyA")), t1.$index($event, "shapeB"), t1.$index($event, "shapeA"), t1.$index($event, "contactEquations")]);
    }, "call$1", "get$beginContactHandler", 2, 0, 665, 666, []],
    endContactHandler$1: [function($event) {
      var t1 = J.getInterceptor$asx($event);
      this.onEndContact.dispatch$1([t1.$index($event, "bodyA"), t1.$index($event, "bodyB"), t1.$index($event, "shapeA"), t1.$index($event, "shapeB")]);
      if (J.get$parent$x(t1.$index($event, "bodyA")) != null)
        J.get$parent$x(t1.$index($event, "bodyA")).get$onEndContact().dispatch$1([J.get$parent$x(t1.$index($event, "bodyB")), t1.$index($event, "shapeA"), t1.$index($event, "shapeB")]);
      if (J.get$parent$x(t1.$index($event, "bodyB")) != null)
        J.get$parent$x(t1.$index($event, "bodyB")).get$onEndContact().dispatch$1([J.get$parent$x(t1.$index($event, "bodyA")), t1.$index($event, "shapeB"), t1.$index($event, "shapeA")]);
    }, "call$1", "get$endContactHandler", 2, 0, 665, 666, []],
    setBoundsToWorld$5: function(left, right, $top, bottom, setCollisionGroup) {
      this.setBounds$9(J.get$x$x(this.game.get$world().get$bounds()), J.get$y$x(this.game.get$world().get$bounds()), J.get$width$x(this.game.get$world().get$bounds()), J.get$height$x(this.game.get$world().get$bounds()), left, right, $top, bottom, setCollisionGroup);
    },
    setBoundsToWorld$0: function() {
      return this.setBoundsToWorld$5(true, true, true, true, true);
    },
    setBounds$9: function(x, y, width, height, left, right, $top, bottom, setCollisionGroup) {
      var t1, t2, t3, t4;
      t1 = this.walls.left;
      if (t1 != null)
        this.world.removeBody$1(t1);
      t1 = this.walls.right;
      if (t1 != null)
        this.world.removeBody$1(t1);
      t1 = this.walls.top;
      if (t1 != null)
        this.world.removeBody$1(t1);
      t1 = this.walls.bottom;
      if (t1 != null)
        this.world.removeBody$1(t1);
      if (left) {
        t1 = this.walls;
        t2 = J.$mul$ns(x, -0.05);
        t3 = J.$mul$ns(y, -0.05);
        t4 = new A.vec2(0, 0);
        t4.x = t2;
        t4.y = t3;
        t1.left = A.Body$0(1.5707963267948966, 0.1, 0, 0, 0.1, false, null, 0, t4, null, null);
        t4 = this.walls.left;
        t1 = new A.Plane(null, null, null, null, null, null, null, null);
        t1.Shape$1(4);
        t4.addShape$1(t1);
        if (setCollisionGroup) {
          t1 = this.walls.left.get$shapes();
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1[0].set$collisionGroup(this.boundsCollisionGroup.mask);
        }
        this.world.addBody$1(this.walls.left);
      }
      if (right) {
        t1 = this.walls;
        t2 = J.$mul$ns(J.$add$ns(x, width), -0.05);
        t3 = J.$mul$ns(y, -0.05);
        t4 = new A.vec2(0, 0);
        t4.x = t2;
        t4.y = t3;
        t1.right = A.Body$0(-1.5707963267948966, 0.1, 0, 0, 0.1, false, null, 0, t4, null, null);
        t4 = this.walls.right;
        t1 = new A.Plane(null, null, null, null, null, null, null, null);
        t1.Shape$1(4);
        t4.addShape$1(t1);
        if (setCollisionGroup) {
          t1 = this.walls.right.get$shapes();
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1[0].set$collisionGroup(this.boundsCollisionGroup.mask);
        }
        this.world.addBody$1(this.walls.right);
      }
      if ($top) {
        t1 = this.walls;
        t2 = J.$mul$ns(x, -0.05);
        t3 = J.$mul$ns(y, -0.05);
        t4 = new A.vec2(0, 0);
        t4.x = t2;
        t4.y = t3;
        t1.top = A.Body$0(-3.141592653589793, 0.1, 0, 0, 0.1, false, null, 0, t4, null, null);
        t4 = this.walls.top;
        t1 = new A.Plane(null, null, null, null, null, null, null, null);
        t1.Shape$1(4);
        t4.addShape$1(t1);
        if (setCollisionGroup) {
          t1 = this.walls.top.shapes;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1[0].set$collisionGroup(this.boundsCollisionGroup.mask);
        }
        this.world.addBody$1(this.walls.top);
      }
      if (bottom) {
        t1 = this.walls;
        t2 = J.$mul$ns(x, -0.05);
        t3 = J.$mul$ns(J.$add$ns(y, height), -0.05);
        t4 = new A.vec2(0, 0);
        t4.x = t2;
        t4.y = t3;
        t1.bottom = A.Body$0(0, 0.1, 0, 0, 0.1, false, null, 0, t4, null, null);
        t4 = this.walls.bottom;
        t1 = new A.Plane(null, null, null, null, null, null, null, null);
        t1.Shape$1(4);
        t4.addShape$1(t1);
        if (setCollisionGroup) {
          t1 = this.walls.bottom.shapes;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1[0].set$collisionGroup(this.boundsCollisionGroup.mask);
        }
        this.world.addBody$1(this.walls.bottom);
      }
    },
    setBounds$4: function(x, y, width, height) {
      return this.setBounds$9(x, y, width, height, true, true, true, true, true);
    },
    pause$0: function(_) {
      this.paused = true;
    },
    resume$0: function() {
      this.paused = false;
    },
    update$0: [function() {
      var t1, t2;
      if (this.paused)
        return;
      t1 = this.useElapsedTime;
      t2 = this.world;
      if (t1)
        J.step$1$x(t2, this.game.get$time().get$physicsElapsed());
      else
        J.step$1$x(t2, this.frameRate);
    }, "call$0", "get$update", 0, 0, 54],
    clear$0: function(_) {
      J.clear$0$ax(this.world);
      this.world.off$2("beginContact", this.get$beginContactHandler());
      this.world.off$2("endContact", this.get$endContactHandler());
      this.postBroadphaseCallback = null;
      this.impactCallback = null;
      this.collisionGroups = [];
      this._toRemove = [];
      this._collisionGroupID = 2;
      this.boundsCollidesWith = [];
    },
    destroy$0: function() {
      this.clear$0(0);
      this.game = null;
    },
    addBody$1: function(body) {
      var t1 = J.getInterceptor$x(body);
      if (t1.get$data(body).get$world() != null)
        return false;
      else {
        this.world.addBody$1(t1.get$data(body));
        this.onBodyAdded.dispatch$1(body);
        return true;
      }
    },
    removeBody$1: function(body) {
      var t1 = J.getInterceptor$x(body);
      if (J.$eq(t1.get$data(body).get$world(), this.world)) {
        this.world.removeBody$1(t1.get$data(body));
        this.onBodyRemoved.dispatch$1(body);
      }
      return body;
    },
    hitTest$4: function(worldPoint, bodies, precision, filterStatic) {
      var t1, t2, physicsPosition, query, i, i0;
      if (bodies == null)
        bodies = this.world.get$bodies();
      if (precision == null)
        precision = 5;
      t1 = J.getInterceptor$x(worldPoint);
      t2 = J.$mul$ns(t1.get$x(worldPoint), -0.05);
      t1 = J.$mul$ns(t1.get$y(worldPoint), -0.05);
      physicsPosition = new A.vec2(0, 0);
      physicsPosition.x = t2;
      physicsPosition.y = t1;
      query = [];
      t1 = J.getInterceptor$asx(bodies);
      i = t1.get$length(bodies);
      for (; t2 = J.getInterceptor$n(i), i0 = t2.$sub(i, 1), t2.$gt(i, 0); i = i0) {
        if (!!J.getInterceptor(t1.$index(bodies, i0)).$isBody1)
          t2 = !(filterStatic && J.get$type$x(H.interceptedTypeCast(t1.$index(bodies, i0), "$isBody1").data) === 2);
        else
          t2 = false;
        if (t2)
          query.push(H.interceptedTypeCast(t1.$index(bodies, i0), "$isBody1").data);
        else {
          if (!!J.getInterceptor(t1.$index(bodies, i0)).$isBody3)
            if (J.get$parent$x(t1.$index(bodies, i0)) != null)
              t2 = !(filterStatic && J.$eq(J.get$type$x(t1.$index(bodies, i0)), 2));
            else
              t2 = false;
          else
            t2 = false;
          if (t2)
            query.push(t1.$index(bodies, i0));
          else {
            if (!!J.getInterceptor(t1.$index(bodies, i0)).$isSprite)
              t2 = !(filterStatic && J.get$type$x(H.interceptedTypeCast(H.interceptedTypeCast(t1.$index(bodies, i0), "$isSprite").body, "$isBody1").data) === 2);
            else
              t2 = false;
            if (t2)
              query.push(H.interceptedTypeCast(H.interceptedTypeCast(t1.$index(bodies, i0), "$isSprite").body, "$isBody1").data);
          }
        }
      }
      return this.world.hitTest$3(physicsPosition, query, precision);
    },
    hitTest$3: function(worldPoint, bodies, precision) {
      return this.hitTest$4(worldPoint, bodies, precision, false);
    },
    hitTest$2: function(worldPoint, bodies) {
      return this.hitTest$4(worldPoint, bodies, 5, false);
    },
    pxm$1: function(v) {
      return J.$mul$ns(v, 0.05);
    },
    mpxi$1: function(v) {
      return J.$mul$ns(v, -20);
    },
    pxmi$1: function(v) {
      return J.$mul$ns(v, -0.05);
    },
    P2$7$broadphase$doProfiling$fake$gravity$islandSplit$solver: function(game, broadphase, doProfiling, fake, gravity, islandSplit, solver) {
      var t1, t2, t3;
      this.game = game;
      t1 = J.getInterceptor$asx(gravity);
      t2 = J.toDouble$0$n(t1.$index(gravity, 0));
      t1 = J.toDouble$0$n(t1.$index(gravity, 1));
      t3 = new A.vec2(0, 0);
      t3.x = t2;
      t3.y = t1;
      t3 = A.World$(broadphase, doProfiling, fake, t3, islandSplit, solver);
      this.world = t3;
      this.frameRate = 0.016666666666666666;
      this.useElapsedTime = false;
      this.paused = false;
      this.materials = [];
      t3 = new L.InversePointProxy(this, t3.gravity, null, null);
      t3.set$x(0, 0);
      t3.set$y(0, 0);
      this.gravity = t3;
      this.walls = new L.Walls(null, null, null, null);
      this.onBodyAdded = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onBodyRemoved = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onSpringAdded = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onSpringRemoved = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onConstraintAdded = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onConstraintRemoved = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onContactMaterialAdded = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onContactMaterialRemoved = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.postBroadphaseCallback = null;
      this.onBeginContact = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onEndContact = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      J.on$2$x(this.world, "beginContact", this.get$beginContactHandler());
      J.on$2$x(this.world, "endContact", this.get$endContactHandler());
      this.collisionGroups = [];
      t3 = new L.CollisionGroup(null);
      t3.mask = 1;
      this.nothingCollisionGroup = t3;
      t3 = new L.CollisionGroup(null);
      t3.mask = 2;
      this.boundsCollisionGroup = t3;
      t3 = new L.CollisionGroup(null);
      t3.mask = 2147483647;
      this.everythingCollisionGroup = t3;
      this.boundsCollidesWith = [];
      this._toRemove = [];
      this._collisionGroupID = 2;
      this.setBoundsToWorld$5(true, true, true, true, false);
    }
  }
}],
["PIXI", "package:play_pixi/pixi.dart", , M, {
  "^": "",
  determineMatrixArrayType: [function() {
    return C.Type_Art;
  }, "call$0", "determineMatrixArrayType$closure", 0, 0, 53, "determineMatrixArrayType"],
  binarySearch: [function(values, target, step) {
    var t1, high, current, low, low0;
    t1 = J.getInterceptor$asx(values);
    high = J.floor$0$n(J.$div$n(t1.get$length(values), step)) - 2;
    if (high === 0)
      return step;
    current = C.JSInt_methods._shrOtherPositive$1(high, 1);
    for (low = 0; true;) {
      low0 = current + 1;
      if (typeof step !== "number")
        return H.iae(step);
      if (J.$le$n(t1.$index(values, low0 * step), target))
        low = low0;
      else
        high = current;
      if (low === high)
        return (low + 1) * step;
      current = C.JSInt_methods._shrOtherPositive$1(low + high, 1);
    }
  }, "call$3", "binarySearch$closure", 6, 0, 95, 96, [], 97, [], 98, [], "binarySearch"],
  linearSearch: [function(values, target, step) {
    var t1, last, i;
    t1 = J.getInterceptor$asx(values);
    last = J.$sub$n(t1.get$length(values), step);
    if (typeof last !== "number")
      return H.iae(last);
    i = 0;
    while (i <= last) {
      if (J.$gt$n(t1.$index(values, i), target))
        return i;
      if (typeof step !== "number")
        return H.iae(step);
      i += step;
    }
    return -1;
  }, "call$3", "linearSearch$closure", 6, 0, 95, 96, [], 97, [], 98, [], "linearSearch"],
  CompileVertexShader: [function(gl, shaderSrc) {
    return M._CompileShader(gl, shaderSrc, 35633);
  }, "call$2", "CompileVertexShader$closure", 4, 0, 180, 160, [], 181, [], "CompileVertexShader"],
  CompileFragmentShader: [function(gl, shaderSrc) {
    return M._CompileShader(gl, shaderSrc, 35632);
  }, "call$2", "CompileFragmentShader$closure", 4, 0, 180, 160, [], 181, [], "CompileFragmentShader"],
  _CompileShader: [function(gl, shaderSrc, shaderType) {
    var src, t1, shader;
    src = J.join$1$ax(shaderSrc, "\n");
    t1 = J.getInterceptor$x(gl);
    shader = t1.createShader$1(gl, shaderType);
    t1.shaderSource$2(gl, shader, src);
    t1.compileShader$1(gl, shader);
    if (t1.getShaderParameter$2(gl, shader, 35713) == null) {
      window;
      t1 = t1.getShaderInfoLog$1(gl, shader);
      if (typeof console != "undefined")
        console.log(t1);
      return;
    }
    return shader;
  }, "call$3", "_CompileShader$closure", 6, 0, 182, 160, [], 181, [], 183, [], "_CompileShader"],
  compileProgram: [function(gl, vertexSrc, fragmentSrc) {
    var fragmentShader, vertexShader, t1, shaderProgram;
    fragmentShader = M._CompileShader(gl, fragmentSrc, 35632);
    vertexShader = M._CompileShader(gl, vertexSrc, 35633);
    t1 = J.getInterceptor$x(gl);
    shaderProgram = t1.createProgram$0(gl);
    t1.attachShader$2(gl, shaderProgram, vertexShader);
    t1.attachShader$2(gl, shaderProgram, fragmentShader);
    t1.linkProgram$1(gl, shaderProgram);
    if (t1.getProgramParameter$2(gl, shaderProgram, 35714) == null) {
      window;
      if (typeof console != "undefined")
        console.log("Could not initialise shaders");
    }
    return shaderProgram;
  }, "call$3", "compileProgram$closure", 6, 0, 184, 160, [], 185, [], 186, [], "compileProgram"],
  createWebGLTexture: [function(texture, gl) {
    var t1;
    if (texture.get$hasLoaded() === true) {
      t1 = J.getInterceptor$x(gl);
      J.$indexSet$ax(texture.get$_glTextures(), gl, t1.createTexture$0(gl));
      t1.bindTexture$2(gl, 3553, J.$index$asx(texture.get$_glTextures(), gl));
      t1.pixelStorei$2(gl, 37441, texture.get$premultipliedAlpha() === true ? 1 : 0);
      t1.texImage2D$6(gl, 3553, 0, 6408, 6408, 5121, J.get$source$x(texture));
      t1.texParameteri$3(gl, 3553, 10240, J.$eq(texture.get$scaleMode(), C.scaleModes_1) ? 9729 : 9728);
      t1.texParameteri$3(gl, 3553, 10241, J.$eq(texture.get$scaleMode(), C.scaleModes_1) ? 9729 : 9728);
      if (texture.get$_powerOf2() !== true) {
        t1.texParameteri$3(gl, 3553, 10242, 33071);
        t1.texParameteri$3(gl, 3553, 10243, 33071);
      } else {
        t1.texParameteri$3(gl, 3553, 10242, 10497);
        t1.texParameteri$3(gl, 3553, 10243, 10497);
      }
      t1.bindTexture$2(gl, 3553, null);
      J.$indexSet$ax(texture.get$_dirty(), gl, false);
    }
    return J.$index$asx(texture.get$_glTextures(), gl);
  }, "call$2", "createWebGLTexture$closure", 4, 0, 190, 68, [], 160, [], "createWebGLTexture"],
  updateWebGLTexture: [function(texture, gl) {
    var t1;
    if (J.$index$asx(texture.get$_glTextures(), gl) != null) {
      t1 = J.getInterceptor$x(gl);
      t1.bindTexture$2(gl, 3553, J.$index$asx(texture.get$_glTextures(), gl));
      t1.pixelStorei$2(gl, 37441, texture.get$premultipliedAlpha() === true ? 1 : 0);
      t1.texImage2D$6(gl, 3553, 0, 6408, 6408, 5121, J.get$source$x(texture));
      t1.texParameteri$3(gl, 3553, 10240, J.$eq(texture.get$scaleMode(), C.scaleModes_1) ? 9729 : 9728);
      t1.texParameteri$3(gl, 3553, 10241, J.$eq(texture.get$scaleMode(), C.scaleModes_1) ? 9729 : 9728);
      if (texture.get$_powerOf2() !== true) {
        t1.texParameteri$3(gl, 3553, 10242, 33071);
        t1.texParameteri$3(gl, 3553, 10243, 33071);
      } else {
        t1.texParameteri$3(gl, 3553, 10242, 10497);
        t1.texParameteri$3(gl, 3553, 10243, 10497);
      }
      J.$indexSet$ax(texture.get$_dirty(), gl, false);
    }
  }, "call$2", "updateWebGLTexture$closure", 4, 0, 190, 68, [], 160, [], "updateWebGLTexture"],
  autoDetectRenderer: [function(width, height, view, transparent, antialias) {
    if (J.getContext3d$0$x(W.CanvasElement_CanvasElement(null, null)) != null)
      return M.WebGLRenderer$(width, height, view, transparent, antialias, false);
    else
      return M.CanvasRenderer$(width, height, view, transparent, false);
  }, function(width) {
    return M.autoDetectRenderer(width, 600, null, false, false);
  }, null, function(width, height) {
    return M.autoDetectRenderer(width, height, null, false, false);
  }, null, function() {
    return M.autoDetectRenderer(800, 600, null, false, false);
  }, null, function(width, height, view) {
    return M.autoDetectRenderer(width, height, view, false, false);
  }, null, function(width, height, view, transparent) {
    return M.autoDetectRenderer(width, height, view, transparent, false);
  }, null, "call$5", "call$1", "call$2", "call$0", "call$3", "call$4", "autoDetectRenderer$closure", 0, 10, 224, 144, 145, 12, 19, 19, 31, [], 52, [], 146, [], 147, [], 148, [], "autoDetectRenderer"],
  hex2rgb: [function(hex) {
    var t1 = J.getInterceptor$n(hex);
    return [(t1.$shr(hex, 16) & 255) / 255, (t1.$shr(hex, 8) & 255) / 255, t1.$and(hex, 255) / 255];
  }, "call$1", "hex2rgb$closure", 2, 0, 242, 243, [], "hex2rgb"],
  rgb2hex: [function(rgb) {
    var t1, t2, t3;
    t1 = J.getInterceptor$asx(rgb);
    t2 = J.floor$0$n(J.$mul$ns(t1.$index(rgb, 0), 255));
    if (typeof t2 !== "number")
      return t2.$shl();
    t3 = J.floor$0$n(J.$mul$ns(t1.$index(rgb, 1), 255));
    if (typeof t3 !== "number")
      return t3.$shl();
    t1 = J.$mul$ns(t1.$index(rgb, 2), 255);
    if (typeof t1 !== "number")
      return H.iae(t1);
    return (t2 << 16 >>> 0) + (t3 << 8 >>> 0) + t1;
  }, "call$1", "rgb2hex$closure", 2, 0, 244, 245, [], "rgb2hex"],
  AjaxRequest: [function() {
    return new XMLHttpRequest();
  }, "call$0", "AjaxRequest$closure", 0, 0, 246, "AjaxRequest"],
  canUseNewCanvasBlendModes: [function() {
    var canvas, context, t1;
    canvas = H.interceptedTypeCast(document.createElement("canvas", null), "$isCanvasElement");
    canvas.width = 1;
    canvas.height = 1;
    context = J.getContext$1$x(canvas, "2d");
    t1 = J.getInterceptor$x(context);
    t1.set$fillStyle(context, "#000");
    t1.fillRect$4(context, 0, 0, 1, 1);
    t1.set$globalCompositeOperation(context, "multiply");
    t1.set$fillStyle(context, "#fff");
    t1.fillRect$4(context, 0, 0, 1, 1);
    t1 = J.get$data$x(t1.getImageData$4(context, 0, 0, 1, 1));
    if (0 >= t1.length)
      return H.ioore(t1, 0);
    return t1[0] === 0;
  }, "call$0", "canUseNewCanvasBlendModes$closure", 0, 0, 247, "canUseNewCanvasBlendModes"],
  getNextPowerOfTwo: [function(number) {
    var t1, result;
    t1 = J.getInterceptor$n(number);
    if (t1.$gt(number, 0) && t1.$and(number, t1.$sub(number, 1)) === 0)
      return number;
    else {
      if (typeof number !== "number")
        return H.iae(number);
      result = 1;
      for (; result < number;)
        result = result << 1 >>> 0;
      return result;
    }
  }, "call$1", "getNextPowerOfTwo$closure", 2, 0, 248, 249, [], "getNextPowerOfTwo"],
  Circle: {
    "^": "Shape;x*-616,y*-616,radius@-616",
    clone$0: [function(_) {
      return new M.Circle(this.get$x(this), this.get$y(this), this.get$radius());
    }, "call$0", "get$clone", 0, 0, 667, "clone"],
    contains$2: [function(_, x, y) {
      var dx, dy, r2;
      if (J.$le$n(this.get$radius(), 0))
        return false;
      dx = J.$sub$n(this.get$x(this), x);
      dy = J.$sub$n(this.get$y(this), y);
      r2 = J.$mul$ns(this.get$radius(), this.get$radius());
      return J.$le$n(J.$add$ns(J.$mul$ns(dx, dx), J.$mul$ns(dy, dy)), r2);
    }, "call$2", "get$contains", 4, 0, 668, 9, [], 10, [], "contains"],
    getBounds$0: [function() {
      var t1, t2, t3, t4;
      t1 = J.$sub$n(this.get$x(this), this.get$radius());
      t2 = J.$sub$n(this.get$y(this), this.get$radius());
      t3 = this.get$radius();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = this.get$radius();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return new M.Rectangle0(t1, t2, 2 * t3, 2 * t4);
    }, "call$0", "get$getBounds", 0, 0, 669, "getBounds"],
    static: {Circle$0: [function(x, y, radius) {
        return new M.Circle(x, y, radius);
      }, null, null, 0, 6, 48, 49, 49, 49, 9, [], 10, [], 50, [], "new Circle"]}
  },
  "+Circle": [653],
  Ellipse: {
    "^": "Shape;x*-616,y*-616,width*-616,height*-616",
    clone$0: [function(_) {
      return new M.Ellipse(this.get$x(this), this.get$y(this), this.get$width(this), this.get$height(this));
    }, "call$0", "get$clone", 0, 0, 670, "clone"],
    contains$2: [function(_, x, y) {
      var normx, normy;
      if (J.$le$n(this.get$width(this), 0) || J.$le$n(this.get$height(this), 0))
        return false;
      normx = J.$div$n(J.$sub$n(x, this.get$x(this)), this.get$width(this));
      normy = J.$div$n(J.$sub$n(y, this.get$y(this)), this.get$height(this));
      return J.$le$n(J.$add$ns(J.$mul$ns(normx, normx), J.$mul$ns(normy, normy)), 1);
    }, "call$2", "get$contains", 4, 0, 668, 9, [], 10, [], "contains"],
    getBounds$0: [function() {
      return new M.Rectangle0(J.$sub$n(this.get$x(this), this.get$width(this)), J.$sub$n(this.get$y(this), this.get$height(this)), this.get$width(this), this.get$height(this));
    }, "call$0", "get$getBounds", 0, 0, 669, "getBounds"],
    static: {Ellipse$: [function(x, y, width, height) {
        return new M.Ellipse(x, y, width, height);
      }, null, null, 0, 8, 51, 49, 49, 49, 49, 9, [], 10, [], 31, [], 52, [], "new Ellipse"]}
  },
  "+Ellipse": [653],
  Matrix: {
    "^": "Object;a*-671,b@-671,c@-671,d@-671,tx@-671,ty@-671,array@-672",
    $index: [function(_, i) {
      return J.$index$asx(this.array, i);
    }, "call$1", "get$[]", 2, 0, 577, 424, [], "[]"],
    toArray$1: [function(transpose) {
      var array, t1, t2;
      array = this.array;
      t1 = J.getInterceptor$ax(array);
      t2 = this.a;
      if (transpose === true) {
        t1.$indexSet(array, 0, t2);
        t1.$indexSet(array, 1, this.c);
        t1.$indexSet(array, 2, 0);
        t1.$indexSet(array, 3, this.b);
        t1.$indexSet(array, 4, this.d);
        t1.$indexSet(array, 5, 0);
        t1.$indexSet(array, 6, this.tx);
        t1.$indexSet(array, 7, this.ty);
        t1.$indexSet(array, 8, 1);
      } else {
        t1.$indexSet(array, 0, t2);
        t1.$indexSet(array, 1, this.b);
        t1.$indexSet(array, 2, this.tx);
        t1.$indexSet(array, 3, this.c);
        t1.$indexSet(array, 4, this.d);
        t1.$indexSet(array, 5, this.ty);
        t1.$indexSet(array, 6, 0);
        t1.$indexSet(array, 7, 0);
        t1.$indexSet(array, 8, 1);
      }
      return array;
    }, "call$1", "get$toArray", 2, 0, 673, 46, [], "toArray"],
    Matrix$fromArray$1: function(array) {
      var t1 = J.getInterceptor$asx(array);
      this.a = t1.$index(array, 0);
      this.b = t1.$index(array, 1);
      this.c = t1.$index(array, 3);
      this.d = t1.$index(array, 4);
      this.tx = t1.$index(array, 2);
      this.ty = t1.$index(array, 5);
    },
    static: {Matrix$: [function() {
        return new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9)));
      }, null, null, 0, 0, 54, "new Matrix"], Matrix$fromArray: [function(array) {
        var t1 = new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9)));
        t1.Matrix$fromArray$1(array);
        return t1;
      }, null, null, 2, 0, 55, 47, [], "new Matrix$fromArray"]}
  },
  "+Matrix": [674],
  Point0: {
    "^": "Object;x*-616,y*-616",
    clone$0: [function(_) {
      var t1, t2, t3;
      t1 = this.get$x(this);
      t2 = this.get$y(this);
      t3 = new M.Point0(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, "call$0", "get$clone", 0, 0, 54, "clone"],
    set$2: [function(x, y) {
      this.set$x(0, x);
      this.set$y(0, y == null ? this.get$x(this) : y);
    }, function(x) {
      return this.set$2(x, null);
    }, "set$1", function() {
      return this.set$2(0, null);
    }, "set$0", "call$2", "call$1", "call$0", "get$set", 0, 4, 56, 49, 12, 9, [], 10, [], "set"],
    static: {Point$: [function(x, y) {
        var t1 = new M.Point0(null, null);
        t1.x = x;
        t1.y = y;
        return t1;
      }, null, null, 0, 4, 56, 49, 49, 9, [], 10, [], "new Point"]}
  },
  "+Point": [674],
  Polygon: {
    "^": "Shape;points*-675",
    clone$0: [function(_) {
      var points, i, t1;
      points = [];
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.points);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        points.push(J.clone$0$x(J.$index$asx(this.points, i)));
        ++i;
      }
      return M.Polygon$(points);
    }, "call$0", "get$clone", 0, 0, 54, "clone"],
    contains$2: [function(_, x, y) {
      var j, t1, t2, inside, i, t3, xi, yi, xj, yj, i0;
      j = J.$sub$n(J.get$length$asx(this.points), 1);
      t1 = J.getInterceptor$n(y);
      t2 = J.getInterceptor$n(x);
      inside = false;
      i = 0;
      while (true) {
        t3 = J.get$length$asx(this.points);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        xi = J.get$x$x(J.$index$asx(this.points, i));
        yi = J.get$y$x(J.$index$asx(this.points, i));
        xj = J.get$x$x(J.$index$asx(this.points, j));
        yj = J.get$y$x(J.$index$asx(this.points, j));
        t3 = J.getInterceptor$n(yj);
        if (J.$gt$n(yi, y) !== t3.$gt(yj, y) && t2.$lt(x, J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(xj, xi), t1.$sub(y, yi)), t3.$sub(yj, yi)), xi)))
          inside = !inside;
        i0 = i + 1;
        j = i;
        i = i0;
      }
      return inside;
    }, "call$2", "get$contains", 4, 0, 149, 9, [], 10, [], "contains"],
    Polygon$1: function(points) {
      var t1, t2, p, il, i, t3, t4;
      t1 = J.getInterceptor$asx(points);
      t2 = t1.$index(points, 0);
      if (typeof t2 === "number") {
        p = [];
        il = t1.get$length(points);
        if (typeof il !== "number")
          return H.iae(il);
        i = 0;
        for (; i < il; i += 2) {
          t2 = t1.$index(points, i);
          t3 = t1.$index(points, i + 1);
          t4 = new M.Point0(null, null);
          t4.x = t2;
          t4.y = t3;
          p.push(t4);
        }
        points = p;
      }
      this.points = points;
    },
    static: {Polygon$: [function(points) {
        var t1 = new M.Polygon(null);
        t1.Polygon$1(points);
        return t1;
      }, null, null, 2, 0, 55, 57, [], "new Polygon"]}
  },
  "+Polygon": [653],
  Rectangle0: {
    "^": "Shape;x*-616,y*-616,width*-616,height*-616",
    clone$0: [function(_) {
      return new M.Rectangle0(this.get$x(this), this.get$y(this), this.get$width(this), this.get$height(this));
    }, "call$0", "get$clone", 0, 0, 669, "clone"],
    contains$2: [function(_, x, y) {
      var x1, t1, y1;
      if (J.$le$n(this.get$width(this), 0) || J.$le$n(this.get$height(this), 0))
        return false;
      x1 = this.get$x(this);
      t1 = J.getInterceptor$n(x);
      if (t1.$ge(x, x1) && t1.$le(x, J.$add$ns(x1, this.get$width(this)))) {
        y1 = this.get$y(this);
        t1 = J.getInterceptor$n(y);
        if (t1.$ge(y, y1) && t1.$le(y, J.$add$ns(y1, this.get$height(this))))
          return true;
      }
      return false;
    }, "call$2", "get$contains", 4, 0, 668, 9, [], 10, [], "contains"],
    static: {Rectangle$1: [function(x, y, width, height) {
        return new M.Rectangle0(x, y, width, height);
      }, null, null, 0, 8, 51, 49, 49, 49, 49, 9, [], 10, [], 31, [], 52, [], "new Rectangle"]}
  },
  "+Rectangle": [653],
  Shape: {
    "^": "Object;",
    static: {Shape$: [function() {
        return new M.Shape();
      }, null, null, 0, 0, 58, "new Shape"]}
  },
  "+Shape": [674],
  DisplayInterface: {
    "^": "Object;hitArea@-653",
    static: {DisplayInterface$: [function() {
        return new M.DisplayInterface(null);
      }, null, null, 0, 0, 59, "new DisplayInterface"]}
  },
  "+DisplayInterface": [674],
  DisplayObject: {
    "^": "Object;position*-652,scale*-652,pivot@-652,rotation@-616,alpha*-616,visible@-617,hitArea@-653,buttonMode@-617,renderable@-617,_parent@-654,__hit@-617,__isOver@-617,__mouseIsDown@-617,__isDown@-617,_dirty@-617,click*-655,mousemove@-655,mousedown@-655,mouseout@-655,mouseover@-655,mouseup@-655,mouseupoutside@-655,touchmove@-655,touchstart@-655,touchend@-655,tap@-655,touchendoutside@-655,__touchData@-656,_stage@-657,_worldAlpha@-616,_interactive@-617,defaultCursor@-644,_worldTransform@-658,_sr@-616,_cr@-616,filterArea@-659,_bounds@-659,_currentBounds@-659,_mask@-660,_cacheAsBitmap@-617,_cachedSprite@-661,_cacheIsDirty@-617,_filterBlock@-662,_filters@-663,_rotationCache@-616",
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    get$parent: [function(_) {
      return this._parent;
    }, null, null, 1, 0, 59, "parent"],
    click$1: function($receiver, arg0) {
      return this.click.call$1(arg0);
    },
    mousemove$1: function(arg0) {
      return this.mousemove.call$1(arg0);
    },
    mousedown$1: function(arg0) {
      return this.mousedown.call$1(arg0);
    },
    mouseout$1: function(arg0) {
      return this.mouseout.call$1(arg0);
    },
    mouseover$1: function(arg0) {
      return this.mouseover.call$1(arg0);
    },
    mouseup$1: function(arg0) {
      return this.mouseup.call$1(arg0);
    },
    mouseupoutside$1: function(arg0) {
      return this.mouseupoutside.call$1(arg0);
    },
    touchmove$1: function(arg0) {
      return this.touchmove.call$1(arg0);
    },
    touchstart$1: function(arg0) {
      return this.touchstart.call$1(arg0);
    },
    touchend$1: function(arg0) {
      return this.touchend.call$1(arg0);
    },
    tap$1: function(arg0) {
      return this.tap.call$1(arg0);
    },
    touchendoutside$1: function(arg0) {
      return this.touchendoutside.call$1(arg0);
    },
    get$stage: [function() {
      return this._stage;
    }, null, null, 1, 0, 676, "stage"],
    get$worldAlpha: [function() {
      return this._worldAlpha;
    }, null, null, 1, 0, 619, "worldAlpha"],
    get$interactive: [function() {
      return this._interactive;
    }, null, null, 1, 0, 247, "interactive"],
    set$interactive: [function(value) {
      var t1;
      this._interactive = value;
      t1 = this._stage;
      if (t1 != null)
        t1.set$_dirty(true);
    }, null, null, 3, 0, 102, 138, [], "interactive"],
    get$worldTransform: [function() {
      return this.get$_worldTransform();
    }, null, null, 1, 0, 677, "worldTransform"],
    get$mask: [function(_) {
      return this._mask;
    }, null, null, 1, 0, 678, "mask"],
    set$mask: [function(_, value) {
      var t1 = this._mask;
      if (t1 != null)
        t1.set$_isMask(false);
      this._mask = value;
      if (value != null)
        value.set$_isMask(true);
    }, null, null, 3, 0, 679, 138, [], "mask"],
    get$cacheAsBitmap: [function() {
      return this._cacheAsBitmap;
    }, null, null, 1, 0, 247, "cacheAsBitmap"],
    set$cacheAsBitmap: [function(value) {
      if (J.$eq(this._cacheAsBitmap, value))
        return;
      if (value === true)
        this._generateCachedSprite$0();
      else
        this._destroyCachedSprite$0();
      this._cacheAsBitmap = value;
    }, null, null, 3, 0, 639, 138, [], "cacheAsBitmap"],
    get$worldVisible: [function() {
      var item = this;
      do {
        if (item.get$visible() !== true)
          return false;
        item = item.get$_parent();
      } while (item != null);
      return true;
    }, null, null, 1, 0, 247, "worldVisible"],
    get$filters: [function() {
      return this._filters;
    }, null, null, 1, 0, 680, "filters"],
    set$filters: [function(value) {
      var passes, t1, i, t2, filterPasses, j, t3;
      if (value != null) {
        passes = [];
        t1 = J.getInterceptor$asx(value);
        i = 0;
        while (true) {
          t2 = t1.get$length(value);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          filterPasses = t1.$index(value, i).get$passes();
          t2 = J.getInterceptor$asx(filterPasses);
          j = 0;
          while (true) {
            t3 = t2.get$length(filterPasses);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(j < t3))
              break;
            passes.push(t2.$index(filterPasses, j));
            ++j;
          }
          ++i;
        }
        J.set$target$x(this._filterBlock, this);
        this._filterBlock.set$filterPasses(passes);
      }
      this._filters = value;
    }, null, null, 3, 0, 681, 138, [], "filters"],
    updateTransform$0: [function() {
      var t1, $parent, parentTransform, worldTransform, px, py, a00, a01, a10, a11, a02, a12, b00, b01, b10, b11, t2;
      if (!J.$eq(this.rotation, this._rotationCache)) {
        t1 = this.rotation;
        this._rotationCache = t1;
        this._sr = Math.sin(H.checkNum(t1));
        this._cr = Math.cos(H.checkNum(this.rotation));
      }
      $parent = this._parent;
      parentTransform = $parent.get$_worldTransform();
      worldTransform = this.get$_worldTransform();
      px = J.get$x$x(this.pivot);
      py = J.get$y$x(this.pivot);
      a00 = J.$mul$ns(this._cr, J.get$x$x(this.get$scale(this)));
      a01 = J.$mul$ns(J.$negate$n(this._sr), J.get$y$x(this.get$scale(this)));
      a10 = J.$mul$ns(this._sr, J.get$x$x(this.get$scale(this)));
      a11 = J.$mul$ns(this._cr, J.get$y$x(this.get$scale(this)));
      a02 = J.$sub$n(J.$sub$n(J.get$x$x(this.get$position(this)), J.$mul$ns(a00, px)), J.$mul$ns(py, a01));
      a12 = J.$sub$n(J.$sub$n(J.get$y$x(this.get$position(this)), J.$mul$ns(a11, py)), J.$mul$ns(px, a10));
      b00 = J.get$a$x(parentTransform);
      b01 = parentTransform.get$b();
      b10 = parentTransform.get$c();
      b11 = parentTransform.get$d();
      t1 = J.getInterceptor$ns(b00);
      t2 = J.getInterceptor$ns(b01);
      J.set$a$x(worldTransform, J.$add$ns(t1.$mul(b00, a00), t2.$mul(b01, a10)));
      worldTransform.set$b(J.$add$ns(t1.$mul(b00, a01), t2.$mul(b01, a11)));
      worldTransform.set$tx(J.$add$ns(J.$add$ns(t1.$mul(b00, a02), t2.$mul(b01, a12)), parentTransform.get$tx()));
      t2 = J.getInterceptor$ns(b10);
      t1 = J.getInterceptor$ns(b11);
      worldTransform.set$c(J.$add$ns(t2.$mul(b10, a00), t1.$mul(b11, a10)));
      worldTransform.set$d(J.$add$ns(t2.$mul(b10, a01), t1.$mul(b11, a11)));
      worldTransform.set$ty(J.$add$ns(J.$add$ns(t2.$mul(b10, a02), t1.$mul(b11, a12)), parentTransform.get$ty()));
      this._worldAlpha = J.$mul$ns(this.alpha, $parent.get$_worldAlpha());
    }, "call$0", "get$updateTransform", 0, 0, 17, "updateTransform"],
    getBounds$1: [function(matrix) {
      return $.get$EmptyRectangle();
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 682, 12, 580, [], "getBounds"],
    getLocalBounds$0: [function() {
      return this.getBounds$1($.get$IdentityMatrix());
    }, "call$0", "get$getLocalBounds", 0, 0, 669, "getLocalBounds"],
    _setStageReference$1: [function(stage) {
      this._stage = stage;
      if (this._interactive === true)
        stage.set$_dirty(true);
    }, "call$1", "get$_setStageReference", 2, 0, 131, 132, [], "_setStageReference"],
    generateTexture$1: [function(renderer) {
      var bounds, t1, renderTexture, t2, t3;
      bounds = this.getLocalBounds$0();
      t1 = J.getInterceptor$x(bounds);
      renderTexture = M.RenderTexture$0(J.floor$0$n(t1.get$width(bounds)), J.floor$0$n(t1.get$height(bounds)), renderer, C.scaleModes_0);
      t2 = J.$negate$n(t1.get$x(bounds));
      t1 = J.$negate$n(t1.get$y(bounds));
      t3 = new M.Point0(null, null);
      t3.x = t2;
      t3.y = t1;
      renderTexture.render$2(this, t3);
      return renderTexture;
    }, "call$1", "get$generateTexture", 2, 0, 683, 213, [], "generateTexture"],
    updateCache$0: [function() {
      this._generateCachedSprite$0();
    }, "call$0", "get$updateCache", 0, 0, 54, "updateCache"],
    _renderCachedSprite$1: [function(renderSession) {
      var t1, t2;
      this._cachedSprite.set$_worldAlpha(this._worldAlpha);
      t1 = renderSession.get$gl();
      t2 = this._cachedSprite;
      if (t1 != null)
        t2._renderWebGL$1(renderSession);
      else
        t2._renderCanvas$1(renderSession);
    }, "call$1", "get$_renderCachedSprite", 2, 0, 684, 166, [], "_renderCachedSprite"],
    _generateCachedSprite$0: [function() {
      var bounds, t1, t2, renderTexture, t3, t4, tempFilters, texture;
      this._cacheAsBitmap = false;
      bounds = this.getLocalBounds$0();
      t1 = this._cachedSprite;
      t2 = J.getInterceptor$x(bounds);
      if (t1 == null) {
        renderTexture = M.RenderTexture$0(J.floor$0$n(t2.get$width(bounds)), J.floor$0$n(t2.get$height(bounds)), null, C.scaleModes_0);
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t4 = new M.Sprite0(t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t4.texture = renderTexture;
        t4._setupTexture$0();
        this._cachedSprite = t4;
        t4._worldTransform = this.get$_worldTransform();
      } else
        H.interceptedTypeCast(t1.get$texture(), "$isRenderTexture0").resize$2(0, J.floor$0$n(t2.get$width(bounds)), J.floor$0$n(t2.get$height(bounds)));
      tempFilters = this._filters;
      this._filters = null;
      this._cachedSprite.set$filters(tempFilters);
      texture = H.interceptedTypeCast(this._cachedSprite.get$texture(), "$isRenderTexture0");
      t1 = J.getInterceptor$x(bounds);
      t2 = J.$negate$n(t1.get$x(bounds));
      t3 = J.$negate$n(t1.get$y(bounds));
      t4 = new M.Point0(null, null);
      t4.x = t2;
      t4.y = t3;
      texture.render$3(this, t4, false);
      J.set$x$x(this._cachedSprite.get$anchor(), J.$negate$n(J.$div$n(t1.get$x(bounds), t1.get$width(bounds))));
      J.set$y$x(this._cachedSprite.get$anchor(), J.$negate$n(J.$div$n(t1.get$y(bounds), t1.get$height(bounds))));
      this._filters = tempFilters;
      this._cacheAsBitmap = true;
    }, "call$0", "get$_generateCachedSprite", 0, 0, 17, "_generateCachedSprite"],
    _destroyCachedSprite$0: [function() {
      var t1 = this._cachedSprite;
      if (t1 == null)
        return;
      t1.get$texture().destroy$1(true);
      this._cachedSprite = null;
    }, "call$0", "get$_destroyCachedSprite", 0, 0, 17, "_destroyCachedSprite"],
    _renderWebGL$1: [function(renderSession) {
    }, "call$1", "get$_renderWebGL", 2, 0, 685, 166, [], "_renderWebGL"],
    _renderCanvas$1: [function(renderSession) {
    }, "call$1", "get$_renderCanvas", 2, 0, 596, 166, [], "_renderCanvas"],
    get$x: [function(_) {
      return J.get$x$x(this.get$position(this));
    }, null, null, 1, 0, 619, "x"],
    set$x: [function(_, value) {
      J.set$x$x(this.get$position(this), value);
    }, null, null, 3, 0, 6, 138, [], "x"],
    get$y: [function(_) {
      return J.get$y$x(this.get$position(this));
    }, null, null, 1, 0, 619, "y"],
    set$y: [function(_, value) {
      J.set$y$x(this.get$position(this), value);
    }, null, null, 3, 0, 6, 138, [], "y"],
    $isDisplayObject: true,
    static: {DisplayObject$: [function() {
        var t1, t2, t3;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        return new M.DisplayObject(t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
      }, null, null, 0, 0, 60, "new DisplayObject"]}
  },
  "+DisplayObject": [674, 654],
  DisplayObjectContainer: {
    "^": "DisplayObject;children>-651,interactiveChildren@-617,_PIXI$_width@-616,_PIXI$_height@-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    get$width: [function(_) {
      return J.$mul$ns(J.get$x$x(this.get$scale(this)), J.get$width$x(this.getLocalBounds$0()));
    }, null, null, 1, 0, 619, "width"],
    set$width: [function(_, value) {
      var width = J.get$width$x(this.getLocalBounds$0());
      if (!J.$eq(width, 0))
        J.set$x$x(this.get$scale(this), J.$div$n(value, width));
      else
        J.set$x$x(this.get$scale(this), 1);
      this.set$_PIXI$_width(value);
    }, null, null, 3, 0, 620, 138, [], "width"],
    get$height: [function(_) {
      return J.$mul$ns(J.get$y$x(this.get$scale(this)), J.get$height$x(this.getLocalBounds$0()));
    }, null, null, 1, 0, 619, "height"],
    set$height: [function(_, value) {
      var height = J.get$height$x(this.getLocalBounds$0());
      if (!J.$eq(height, 0))
        J.set$y$x(this.get$scale(this), J.$div$n(value, height));
      else
        J.set$y$x(this.get$scale(this), 1);
      this.set$_PIXI$_height(value);
    }, null, null, 3, 0, 620, 138, [], "height"],
    addChild$1: [function(child) {
      return this.addChildAt$2(child, J.get$length$asx(this.get$children(this)));
    }, "call$1", "get$addChild", 2, 0, 686, 687, [], "addChild"],
    addChildAt$2: [function(child, index) {
      var t1;
      H.interceptedTypeCast(child, "$isDisplayObject");
      t1 = J.getInterceptor$n(index);
      if (t1.$ge(index, 0) && t1.$le(index, J.get$length$asx(this.get$children(this)))) {
        t1 = child._parent;
        if (t1 != null) {
          H.interceptedTypeCast(t1, "$isDisplayObjectContainer");
          t1.removeChildAt$1(J.indexOf$1$asx(t1.get$children(t1), child));
        }
        child._parent = this;
        J.insert$2$ax(this.get$children(this), index, child);
        t1 = this._stage;
        if (t1 != null)
          child._setStageReference$1(t1);
        return child;
      } else
        throw H.wrapException(P.Exception_Exception(H.S(child) + "  The index " + H.S(index) + " supplied is out of bounds " + H.S(J.get$length$asx(this.get$children(this)))));
    }, "call$2", "get$addChildAt", 4, 0, 688, 687, [], 281, [], "addChildAt"],
    swapChildren$2: [function(child, child2) {
      var index1, index2;
      if (J.$eq(child, child2))
        return false;
      index1 = J.indexOf$1$asx(this.get$children(this), child);
      index2 = J.indexOf$1$asx(this.get$children(this), child2);
      if (J.$lt$n(index1, 0) || J.$lt$n(index2, 0))
        throw H.wrapException(P.Exception_Exception("swapChildren: Both the supplied DisplayObjects must be a child of the caller."));
      J.$indexSet$ax(this.get$children(this), index1, child2);
      J.$indexSet$ax(this.get$children(this), index2, child);
      return true;
    }, "call$2", "get$swapChildren", 4, 0, 689, 687, [], 690, [], "swapChildren"],
    getChildAt$1: [function(index) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$ge(index, 0) && t1.$lt(index, J.get$length$asx(this.get$children(this))))
        return J.$index$asx(this.get$children(this), index);
      else
        throw H.wrapException(P.Exception_Exception("Supplied index does not exist in the child list, or the supplied DisplayObject must be a child of the caller"));
    }, "call$1", "get$getChildAt", 2, 0, 691, 281, [], "getChildAt"],
    removeChild$1: [function(child) {
      return this.removeChildAt$1(J.indexOf$1$asx(this.get$children(this), child));
    }, "call$1", "get$removeChild", 2, 0, 686, 687, [], "removeChild"],
    removeChildAt$1: [function(index) {
      var child = this.getChildAt$1(index);
      if (this._stage != null && !!J.getInterceptor(child).$isDisplayObjectContainer)
        child._removeStageReference$0();
      child.set$_parent(null);
      J.removeAt$1$ax(this.get$children(this), index);
      return child;
    }, "call$1", "get$removeChildAt", 2, 0, 691, 281, [], "removeChildAt"],
    removeChildren$2: [function(begin, end) {
      var range, t1, removed, child;
      if (end == null)
        end = J.get$length$asx(this.get$children(this));
      range = J.$sub$n(end, begin);
      t1 = J.getInterceptor$n(range);
      if (t1.$gt(range, 0) && t1.$le(range, end)) {
        removed = J.getRange$2$ax(this.get$children(this), begin, range);
        J.removeRange$2$ax(this.get$children(this), begin, range);
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(removed, removed.get$length(removed), 0, null), [H.getRuntimeTypeArgument(removed, "ListIterable", 0)]); t1.moveNext$0();) {
          child = t1.__internal$_current;
          child.set$_stage(null);
          child.set$_parent(null);
        }
        return removed;
      } else
        throw H.wrapException(P.Exception_Exception("Range Error, numeric values are outside the acceptable range"));
    }, function(begin) {
      return this.removeChildren$2(begin, null);
    }, "removeChildren$1", function() {
      return this.removeChildren$2(0, null);
    }, "removeChildren$0", "call$2", "call$1", "call$0", "get$removeChildren", 0, 4, 692, 49, 12, 693, [], 694, [], "removeChildren"],
    updateTransform$0: [function() {
      var j, i;
      if (this.visible !== true)
        return;
      M.DisplayObject.prototype.updateTransform$0.call(this);
      if (this._cacheAsBitmap === true)
        return;
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i).updateTransform$0();
    }, "call$0", "get$updateTransform", 0, 0, 54, "updateTransform"],
    getBounds$1: [function(matrix) {
      var matrixCache, j, minX, minY, maxX, maxY, childBounds, childMaxX, childMaxY, childVisible, i, child, t1, bounds;
      if (J.$eq(J.get$length$asx(this.get$children(this)), 0))
        return $.get$EmptyRectangle();
      if (matrix != null) {
        matrixCache = this.get$_worldTransform();
        this.set$_worldTransform(matrix);
        this.updateTransform$0();
        this.set$_worldTransform(matrixCache);
      }
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      minX = 1 / 0;
      minY = 1 / 0;
      maxX = -1 / 0;
      maxY = -1 / 0;
      childBounds = null;
      childMaxX = null;
      childMaxY = null;
      childVisible = false;
      i = 0;
      for (; i < j; ++i) {
        child = J.$index$asx(this.get$children(this), i);
        if (child.get$visible() !== true)
          continue;
        childBounds = child.getBounds$1(matrix);
        t1 = J.getInterceptor$x(childBounds);
        minX = J.$lt$n(minX, t1.get$x(childBounds)) ? minX : t1.get$x(childBounds);
        minY = J.$lt$n(minY, t1.get$y(childBounds)) ? minY : t1.get$y(childBounds);
        childMaxX = J.$add$ns(t1.get$width(childBounds), t1.get$x(childBounds));
        childMaxY = J.$add$ns(t1.get$height(childBounds), t1.get$y(childBounds));
        maxX = J.$gt$n(maxX, childMaxX) ? maxX : childMaxX;
        maxY = J.$gt$n(maxY, childMaxY) ? maxY : childMaxY;
        childVisible = true;
      }
      if (!childVisible)
        return $.get$EmptyRectangle();
      bounds = this._bounds;
      t1 = J.getInterceptor$x(bounds);
      t1.set$x(bounds, minX);
      t1.set$y(bounds, minY);
      t1.set$width(bounds, J.$sub$n(maxX, minX));
      t1.set$height(bounds, J.$sub$n(maxY, minY));
      return bounds;
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 682, 12, 580, [], "getBounds"],
    getLocalBounds$0: [function() {
      var matrixCache, j, i, bounds;
      matrixCache = this.get$_worldTransform();
      this.set$_worldTransform($.get$IdentityMatrix());
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i).updateTransform$0();
      bounds = this.getBounds$0();
      this.set$_worldTransform(matrixCache);
      return bounds;
    }, "call$0", "get$getLocalBounds", 0, 0, 669, "getLocalBounds"],
    _setStageReference$1: [function(stage) {
      var j, i;
      this._stage = stage;
      if (this._interactive === true)
        stage.set$_dirty(true);
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._setStageReference$1(stage);
    }, "call$1", "get$_setStageReference", 2, 0, 695, 132, [], "_setStageReference"],
    _removeStageReference$0: [function() {
      var j, i;
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._removeStageReference$0();
      if (this._interactive === true)
        this._stage.set$_dirty(true);
      this._stage = null;
    }, "call$0", "get$_removeStageReference", 0, 0, 17, "_removeStageReference"],
    _renderWebGL$1: [function(renderSession) {
      var j, i;
      if (this.visible !== true || J.$le$n(this.alpha, 0))
        return;
      if (this._cacheAsBitmap === true) {
        this._renderCachedSprite$1(renderSession);
        return;
      }
      if (this._mask != null || this._filters != null) {
        if (this._filters != null) {
          J.flush$0$x(renderSession.get$spriteBatch());
          renderSession.get$filterManager().pushFilter$1(this._filterBlock);
        }
        if (this._mask != null) {
          J.stop$0$x(renderSession.get$spriteBatch());
          renderSession.get$maskManager().pushMask$2(this._mask, renderSession);
          J.start$0$x(renderSession.get$spriteBatch());
        }
        j = J.get$length$asx(this.get$children(this));
        if (typeof j !== "number")
          return H.iae(j);
        i = 0;
        for (; i < j; ++i)
          J.$index$asx(this.get$children(this), i)._renderWebGL$1(renderSession);
        J.stop$0$x(renderSession.get$spriteBatch());
        if (this._mask != null)
          renderSession.get$maskManager().popMask$2(this._mask, renderSession);
        if (this._filters != null)
          renderSession.get$filterManager().popFilter$0();
        J.start$0$x(renderSession.get$spriteBatch());
      } else {
        j = J.get$length$asx(this.get$children(this));
        if (typeof j !== "number")
          return H.iae(j);
        i = 0;
        for (; i < j; ++i)
          J.$index$asx(this.get$children(this), i)._renderWebGL$1(renderSession);
      }
    }, "call$1", "get$_renderWebGL", 2, 0, 685, 166, [], "_renderWebGL"],
    _renderCanvas$1: [function(renderSession) {
      var j, i;
      if (J.$eq(this.visible, false) || J.$eq(this.alpha, 0))
        return;
      if (this._cacheAsBitmap === true) {
        this._renderCachedSprite$1(renderSession);
        return;
      }
      if (this._mask != null)
        renderSession.get$maskManager().pushMask$2(this._mask, J.get$context$x(renderSession));
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._renderCanvas$1(renderSession);
      if (this._mask != null)
        renderSession.get$maskManager().popMask$1(J.get$context$x(renderSession));
    }, "call$1", "get$_renderCanvas", 2, 0, 685, 166, [], "_renderCanvas"],
    $isDisplayObjectContainer: true,
    static: {DisplayObjectContainer$: [function() {
        var t1, t2, t3;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        return new M.DisplayObjectContainer([], false, 0, 0, t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
      }, null, null, 0, 0, 61, "new DisplayObjectContainer"]}
  },
  "+DisplayObjectContainer": [696],
  MovieClip: {
    "^": "Sprite0;textures@-697,animationSpeed@-616,loop*-617,onComplete*-0,_currentFrame@-616,_playing@-617,anchor-652,texture-698,updateFrame-617,PIXI$Sprite0$_PIXI$_width-616,PIXI$Sprite0$_PIXI$_height-616,_uvs-699,tintedTexture-700,buffer-701,tint-614,cachedTint-614,blendMode-702,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    loop$0: function($receiver) {
      return this.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return this.loop.call$3(arg0, arg1, arg2);
    },
    onComplete$0: function($receiver) {
      return this.onComplete.call$0();
    },
    get$currentFrame: [function() {
      return this._currentFrame;
    }, null, null, 1, 0, 619, "currentFrame"],
    get$playing: [function() {
      return this._playing;
    }, null, null, 1, 0, 247, "playing"],
    get$totalFrames: [function() {
      return J.get$length$asx(this.textures);
    }, null, null, 1, 0, 412, "totalFrames"],
    stop$0: [function(_) {
      this._playing = false;
    }, "call$0", "get$stop", 0, 0, 54, "stop"],
    play$0: [function(_) {
      this._playing = true;
    }, "call$0", "get$play", 0, 0, 54, "play"],
    gotoAndStop$1: [function(frameNumber) {
      var round, t1, t2, t3;
      this._playing = false;
      this._currentFrame = frameNumber;
      round = J.ceil$0$n(frameNumber);
      t1 = this.textures;
      t2 = J.getInterceptor$asx(t1);
      t3 = t2.get$length(t1);
      if (typeof t3 !== "number")
        return H.iae(t3);
      this.texture = t2.$index(t1, C.JSInt_methods.$mod(round, t3));
      this.cachedTint = 16777215;
    }, "call$1", "get$gotoAndStop", 2, 0, 99, 703, [], "gotoAndStop"],
    gotoAndPlay$1: [function(frameNumber) {
      this._currentFrame = frameNumber;
      this._playing = true;
    }, "call$1", "get$gotoAndPlay", 2, 0, 99, 703, [], "gotoAndPlay"],
    updateTransform$0: [function() {
      var t1, round, t2, t3;
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
      if (this._playing !== true)
        return;
      t1 = J.$add$ns(this._currentFrame, this.animationSpeed);
      this._currentFrame = t1;
      round = J.ceil$0$n(t1);
      this._currentFrame = J.$mod$n(this._currentFrame, J.get$length$asx(this.textures));
      if (this.loop !== true) {
        t1 = J.get$length$asx(this.textures);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = round < t1;
      } else
        t1 = true;
      if (t1) {
        t1 = this.textures;
        t2 = J.getInterceptor$asx(t1);
        t3 = t2.get$length(t1);
        if (typeof t3 !== "number")
          return H.iae(t3);
        this.texture = t2.$index(t1, C.JSInt_methods.$mod(round, t3));
        this.cachedTint = 16777215;
      } else {
        t1 = J.get$length$asx(this.textures);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (round >= t1) {
          t1 = J.$sub$n(J.get$length$asx(this.textures), 1);
          this._playing = false;
          this._currentFrame = t1;
          round = J.ceil$0$n(t1);
          t1 = this.textures;
          t2 = J.getInterceptor$asx(t1);
          t3 = t2.get$length(t1);
          if (typeof t3 !== "number")
            return H.iae(t3);
          this.texture = t2.$index(t1, C.JSInt_methods.$mod(round, t3));
          this.cachedTint = 16777215;
          if (this.onComplete != null)
            this.onComplete$0(0);
        }
      }
    }, "call$0", "get$updateTransform", 0, 0, 54, "updateTransform"],
    static: {MovieClip$: [function(textures) {
        var t1, t2, t3, t4, t5;
        t1 = J.$index$asx(textures, 0);
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = new M.MovieClip(null, 1, true, null, 0, false, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t5.texture = t1;
        t5._setupTexture$0();
        t5.textures = textures;
        return t5;
      }, null, null, 2, 0, 62, 63, [], "new MovieClip"], MovieClip_fromFrames: [function($frames) {
        var textures, t1, i, t2, texture, t3, t4, t5;
        textures = [];
        t1 = J.getInterceptor$asx($frames);
        i = 0;
        while (true) {
          t2 = t1.get$length($frames);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t2 = t1.$index($frames, i);
          texture = J.$index$asx($.get$TextureCache(), t2);
          if (texture == null)
            H.throwExpression(P.Exception_Exception("The frameId \"" + H.S(t2) + "\" does not exist in the texture cache"));
          textures.push(texture);
          ++i;
        }
        if (0 >= textures.length)
          return H.ioore(textures, 0);
        t1 = textures[0];
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = new M.MovieClip(null, 1, true, null, 0, false, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t5.texture = t1;
        t5._setupTexture$0();
        t5.textures = textures;
        return t5;
      }, "call$1", "MovieClip_fromFrames$closure", 2, 0, 64, 65, [], "fromFrames"], MovieClip_fromImages: [function(images) {
        var textures, t1, i, t2, t3, t4, t5;
        textures = [];
        t1 = J.getInterceptor$asx(images);
        i = 0;
        while (true) {
          t2 = t1.get$length(images);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          textures.push(M.Texture_fromImage(t1.$index(images, i), null, null));
          ++i;
        }
        if (0 >= textures.length)
          return H.ioore(textures, 0);
        t1 = textures[0];
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = new M.MovieClip(null, 1, true, null, 0, false, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t5.texture = t1;
        t5._setupTexture$0();
        t5.textures = textures;
        return t5;
      }, "call$1", "MovieClip_fromImages$closure", 2, 0, 64, 66, [], "fromImages"]}
  },
  "+MovieClip": [661],
  Sprite0: {
    "^": "DisplayObjectContainer;anchor@-652,texture@-698,updateFrame@-617,_PIXI$_width:PIXI$Sprite0$_PIXI$_width@-616,_PIXI$_height:PIXI$Sprite0$_PIXI$_height@-616,_uvs@-699,tintedTexture@-700,buffer*-701,tint@-614,cachedTint@-614,blendMode@-702,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    get$width: [function(_) {
      return J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.get$texture().get$frame()));
    }, null, null, 1, 0, 619, "width"],
    set$width: [function(_, value) {
      J.set$x$x(this.scale, J.$div$n(value, J.get$width$x(this.get$texture().get$frame())));
      this.set$_PIXI$_width(value);
    }, null, null, 3, 0, 620, 138, [], "width"],
    get$height: [function(_) {
      return J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.get$texture().get$frame()));
    }, null, null, 1, 0, 619, "height"],
    set$height: [function(_, value) {
      J.set$y$x(this.scale, J.$div$n(value, J.get$height$x(this.get$texture().get$frame())));
      this.set$_PIXI$_height(value);
    }, null, null, 3, 0, 620, 138, [], "height"],
    _setupTexture$0: [function() {
      if (this.get$texture().get$baseTexture().get$hasLoaded() === true)
        this._onTextureUpdate$1(null);
      else
        J.addEventListener$2$x(this.get$texture(), "update", this.get$_onTextureUpdate());
    }, "call$0", "get$_setupTexture", 0, 0, 17, "_setupTexture"],
    setTexture$1: [function(texture) {
      this.set$texture(texture);
      this.cachedTint = 16777215;
    }, "call$1", "get$setTexture", 2, 0, 704, 68, [], "setTexture"],
    _onTextureUpdate$1: [function(e) {
      if (!J.$eq(this.get$_PIXI$_width(), 0))
        J.set$x$x(this.scale, J.$div$n(this.get$_PIXI$_width(), J.get$width$x(this.get$texture().get$frame())));
      if (!J.$eq(this.get$_PIXI$_height(), 0))
        J.set$y$x(this.scale, J.$div$n(this.get$_PIXI$_height(), J.get$height$x(this.get$texture().get$frame())));
    }, "call$1", "get$_onTextureUpdate", 2, 0, 705, 356, [], "_onTextureUpdate"],
    getBounds$1: [function(matrix) {
      var width, height, t1, t2, w0, w1, h0, h1, worldTransform, a, b, c, d, tx, ty, x1, t3, t4, y1, x2, y2, x3, y3, x4, y4, minX, t5, minY, t6, t7, t8, maxX, maxY, bounds;
      width = J.get$width$x(this.get$texture().get$frame());
      height = J.get$height$x(this.get$texture().get$frame());
      t1 = J.get$x$x(this.get$anchor());
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = J.getInterceptor$ns(width);
      w0 = t2.$mul(width, 1 - t1);
      w1 = t2.$mul(width, J.$negate$n(J.get$x$x(this.get$anchor())));
      t2 = J.get$y$x(this.get$anchor());
      if (typeof t2 !== "number")
        return H.iae(t2);
      t1 = J.getInterceptor$ns(height);
      h0 = t1.$mul(height, 1 - t2);
      h1 = t1.$mul(height, J.$negate$n(J.get$y$x(this.get$anchor())));
      worldTransform = matrix == null ? this._worldTransform : matrix;
      a = J.get$a$x(worldTransform);
      b = worldTransform.get$c();
      c = worldTransform.get$b();
      d = worldTransform.get$d();
      tx = worldTransform.get$tx();
      ty = worldTransform.get$ty();
      t1 = J.getInterceptor$ns(a);
      t2 = J.getInterceptor$ns(c);
      x1 = J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h1)), tx);
      t3 = J.getInterceptor$ns(d);
      t4 = J.getInterceptor$ns(b);
      y1 = J.$add$ns(J.$add$ns(t3.$mul(d, h1), t4.$mul(b, w1)), ty);
      x2 = J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h1)), tx);
      y2 = J.$add$ns(J.$add$ns(t3.$mul(d, h1), t4.$mul(b, w0)), ty);
      x3 = J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h0)), tx);
      y3 = J.$add$ns(J.$add$ns(t3.$mul(d, h0), t4.$mul(b, w0)), ty);
      x4 = J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h0)), tx);
      y4 = J.$add$ns(J.$add$ns(t3.$mul(d, h0), t4.$mul(b, w1)), ty);
      t1 = J.getInterceptor$n(x1);
      minX = t1.$lt(x1, 1 / 0) ? x1 : 1 / 0;
      t2 = J.getInterceptor$n(x2);
      if (t2.$lt(x2, minX))
        minX = x2;
      t3 = J.getInterceptor$n(x3);
      if (t3.$lt(x3, minX))
        minX = x3;
      t4 = J.getInterceptor$n(x4);
      if (t4.$lt(x4, minX))
        minX = x4;
      t5 = J.getInterceptor$n(y1);
      minY = t5.$lt(y1, 1 / 0) ? y1 : 1 / 0;
      t6 = J.getInterceptor$n(y2);
      if (t6.$lt(y2, minY))
        minY = y2;
      t7 = J.getInterceptor$n(y3);
      if (t7.$lt(y3, minY))
        minY = y3;
      t8 = J.getInterceptor$n(y4);
      if (t8.$lt(y4, minY))
        minY = y4;
      maxX = t1.$gt(x1, -1 / 0) ? x1 : -1 / 0;
      if (t2.$gt(x2, maxX))
        maxX = x2;
      if (t3.$gt(x3, maxX))
        maxX = x3;
      if (t4.$gt(x4, maxX))
        maxX = x4;
      maxY = t5.$gt(y1, -1 / 0) ? y1 : -1 / 0;
      if (t6.$gt(y2, maxY))
        maxY = y2;
      if (t7.$gt(y3, maxY))
        maxY = y3;
      if (t8.$gt(y4, maxY))
        maxY = y4;
      bounds = this._bounds;
      t1 = J.getInterceptor$x(bounds);
      t1.set$x(bounds, minX);
      t1.set$width(bounds, J.$sub$n(maxX, minX));
      t1.set$y(bounds, minY);
      t1.set$height(bounds, J.$sub$n(maxY, minY));
      this._currentBounds = bounds;
      return bounds;
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 682, 12, 580, [], "getBounds"],
    _renderWebGL$1: [function(renderSession) {
      var spriteBatch, t1, j, i;
      if (this.visible !== true || J.$le$n(this.alpha, 0))
        return;
      if (this._mask != null || this._filters != null) {
        spriteBatch = renderSession.get$spriteBatch();
        if (this._filters != null) {
          J.flush$0$x(spriteBatch);
          renderSession.get$filterManager().pushFilter$1(this._filterBlock);
        }
        if (this._mask != null) {
          t1 = J.getInterceptor$x(spriteBatch);
          t1.stop$0(spriteBatch);
          renderSession.get$maskManager().pushMask$2(this._mask, renderSession);
          t1.start$0(spriteBatch);
        }
        spriteBatch.render$1(this);
        j = J.get$length$asx(this.get$children(this));
        if (typeof j !== "number")
          return H.iae(j);
        i = 0;
        for (; i < j; ++i)
          J.$index$asx(this.get$children(this), i)._renderWebGL$1(renderSession);
        t1 = J.getInterceptor$x(spriteBatch);
        t1.stop$0(spriteBatch);
        if (this._mask != null)
          renderSession.get$maskManager().popMask$2(this._mask, renderSession);
        if (this._filters != null)
          renderSession.get$filterManager().popFilter$0();
        t1.start$0(spriteBatch);
      } else {
        renderSession.get$spriteBatch().render$1(this);
        j = J.get$length$asx(this.get$children(this));
        if (typeof j !== "number")
          return H.iae(j);
        i = 0;
        for (; i < j; ++i)
          J.$index$asx(this.get$children(this), i)._renderWebGL$1(renderSession);
      }
    }, "call$1", "get$_renderWebGL", 2, 0, 685, 166, [], "_renderWebGL"],
    _renderCanvas$1: [function(renderSession) {
      var t1, t2, t3, t4, t5, t6, t7, dx, dy, j, i;
      if (J.$eq(this.visible, false) || J.$eq(this.alpha, 0))
        return;
      if (!J.$eq(this.blendMode, renderSession.get$currentBlendMode())) {
        renderSession.set$currentBlendMode(this.blendMode);
        J.set$globalCompositeOperation$x(J.get$context$x(renderSession), J.$index$asx($.blendModesCanvas, renderSession.get$currentBlendMode()));
      }
      if (this._mask != null)
        renderSession.get$maskManager().pushMask$2(this._mask, J.get$context$x(renderSession));
      if (this.get$texture().get$valid() === true) {
        t1 = J.getInterceptor$x(renderSession);
        J.set$globalAlpha$x(t1.get$context(renderSession), this._worldAlpha);
        if (renderSession.get$roundPixels() != null)
          J.setTransform$6$x(t1.get$context(renderSession), J.get$a$x(this._worldTransform), this._worldTransform.get$c(), this._worldTransform.get$b(), this._worldTransform.get$d(), J.floor$0$n(this._worldTransform.get$tx()), J.floor$0$n(this._worldTransform.get$ty()));
        else {
          t2 = t1.get$context(renderSession);
          t3 = J.get$a$x(this._worldTransform);
          t4 = this._worldTransform.get$c();
          t5 = this._worldTransform.get$b();
          t6 = this._worldTransform.get$d();
          t7 = this._worldTransform.get$tx() == null ? 0 : this._worldTransform.get$tx();
          J.setTransform$6$x(t2, t3, t4, t5, t6, t7, this._worldTransform.get$ty() == null ? 0 : this._worldTransform.get$ty());
        }
        if (!J.$eq(renderSession.get$scaleMode(), this.get$texture().get$baseTexture().get$scaleMode())) {
          renderSession.set$scaleMode(this.get$texture().get$baseTexture().get$scaleMode());
          J.set$imageSmoothingEnabled$x(t1.get$context(renderSession), J.$eq(renderSession.get$scaleMode(), C.scaleModes_1));
        }
        dx = J.get$trim$s(this.get$texture()) != null ? J.$sub$n(J.get$x$x(J.get$trim$s(this.get$texture())), J.$mul$ns(J.get$x$x(this.get$anchor()), J.get$width$x(J.get$trim$s(this.get$texture())))) : J.$mul$ns(J.get$x$x(this.get$anchor()), J.$negate$n(J.get$width$x(this.get$texture().get$frame())));
        dy = J.get$trim$s(this.get$texture()) != null ? J.$sub$n(J.get$y$x(J.get$trim$s(this.get$texture())), J.$mul$ns(J.get$y$x(this.get$anchor()), J.get$height$x(J.get$trim$s(this.get$texture())))) : J.$mul$ns(J.get$y$x(this.get$anchor()), J.$negate$n(J.get$height$x(this.get$texture().get$frame())));
        if (!J.$eq(this.tint, 16777215)) {
          if (!J.$eq(this.cachedTint, this.tint)) {
            t2 = this.tint;
            this.cachedTint = t2;
            this.tintedTexture = M.CanvasTinter_getTintedTexture(this, t2);
          }
          J.drawImageScaledFromSource$9$x(t1.get$context(renderSession), this.tintedTexture, 0, 0, J.get$width$x(this.get$texture().get$crop()), J.get$height$x(this.get$texture().get$crop()), dx, dy, J.get$width$x(this.get$texture().get$crop()), J.get$height$x(this.get$texture().get$crop()));
        } else
          J.drawImageScaledFromSource$9$x(t1.get$context(renderSession), J.get$source$x(this.get$texture().get$baseTexture()), J.get$x$x(this.get$texture().get$crop()), J.get$y$x(this.get$texture().get$crop()), J.get$width$x(this.get$texture().get$crop()), J.get$height$x(this.get$texture().get$crop()), dx, dy, J.get$width$x(this.get$texture().get$crop()), J.get$height$x(this.get$texture().get$crop()));
      }
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._renderCanvas$1(renderSession);
      if (this._mask != null)
        renderSession.get$maskManager().popMask$1(J.get$context$x(renderSession));
    }, "call$1", "get$_renderCanvas", 2, 0, 685, 166, [], "_renderCanvas"],
    $isSprite0: true,
    static: {Sprite$_: [function() {
        var t1, t2, t3, t4;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t4 = new M.Sprite0(t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t4.renderable = true;
        return t4;
      }, null, null, 0, 0, 54, "new Sprite$_"], Sprite$0: [function(texture) {
        var t1, t2, t3, t4;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t4 = new M.Sprite0(t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t4.texture = texture;
        t4._setupTexture$0();
        return t4;
      }, null, null, 2, 0, 67, 68, [], "new Sprite"], Sprite_fromFrame: [function(frameId) {
        var texture, t1, t2, t3, t4;
        texture = J.$index$asx($.get$TextureCache(), frameId);
        if (texture == null)
          throw H.wrapException(P.Exception_Exception("The frameId \"" + H.S(frameId) + "\" does not exist in the texture cache."));
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t4 = new M.Sprite0(t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t4.texture = texture;
        t4._setupTexture$0();
        return t4;
      }, "call$1", "Sprite_fromFrame$closure", 2, 0, 69, 70, [], "fromFrame"], Sprite_fromImage: [function(imageId, crossorigin, scaleMode) {
        var texture, t1, t2, t3, t4;
        texture = M.Texture_fromImage(imageId, crossorigin, scaleMode);
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t4 = new M.Sprite0(t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t4.texture = texture;
        t4._setupTexture$0();
        return t4;
      }, function(imageId) {
        return M.Sprite_fromImage(imageId, null, null);
      }, null, function(imageId, crossorigin) {
        return M.Sprite_fromImage(imageId, crossorigin, null);
      }, null, "call$3", "call$1", "call$2", "Sprite_fromImage$closure", 2, 4, 71, 12, 12, 72, [], 73, [], 74, [], "fromImage"]}
  },
  "+Sprite": [706],
  SpriteBatch0: {
    "^": "DisplayObjectContainer;textureThing@-707,_ready@-617,fastSpriteBatch@-708,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    _initWebGL$1: [function(gl) {
      this.fastSpriteBatch = M.WebGLFastSpriteBatch$(gl);
      this._ready = true;
    }, "call$1", "get$_initWebGL", 2, 0, 102, 160, [], "_initWebGL"],
    updateTransform$0: [function() {
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
    }, "call$0", "get$updateTransform", 0, 0, 54, "updateTransform"],
    _renderWebGL$1: [function(renderSession) {
      if (this.visible !== true || J.$le$n(this.alpha, 0) || J.$eq(J.get$length$asx(this.children), 0))
        return;
      if (this._ready !== true) {
        this.fastSpriteBatch = M.WebGLFastSpriteBatch$(renderSession.get$gl());
        this._ready = true;
      }
      J.stop$0$x(renderSession.get$spriteBatch());
      renderSession.get$shaderManager().setShader$1(renderSession.get$shaderManager().get$fastShader());
      this.fastSpriteBatch.begin$2(this, renderSession);
      this.fastSpriteBatch.render$1(this);
      J.start$0$x(renderSession.get$spriteBatch());
    }, "call$1", "get$_renderWebGL", 2, 0, 685, 166, [], "_renderWebGL"],
    _renderCanvas$1: [function(renderSession) {
      var context, t1, transform, t2, t3, t4, isRotated, i, t5, child, texture, frame, t6, childTransform;
      context = renderSession.get$_context();
      t1 = J.getInterceptor$x(context);
      t1.set$globalAlpha(context, this._worldAlpha);
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
      transform = this._worldTransform;
      t2 = this.children;
      t3 = J.getInterceptor$asx(t2);
      t4 = J.getInterceptor$x(transform);
      isRotated = true;
      i = 0;
      while (true) {
        t5 = t3.get$length(t2);
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (!(i < t5))
          break;
        c$0: {
          child = t3.$index(t2, i);
          if (child.get$visible() !== true)
            break c$0;
          texture = child.get$texture();
          frame = texture.get$frame();
          t5 = J.getInterceptor$x(child);
          t1.set$globalAlpha(context, J.$mul$ns(this._worldAlpha, t5.get$alpha(child)));
          if (J.$mod$n(child.get$rotation(), 6.283185307179586) === 0) {
            if (isRotated) {
              t1.setTransform$6(context, t4.get$a(transform), transform.get$c(), transform.get$b(), transform.get$d(), transform.get$tx(), transform.get$ty());
              isRotated = false;
            }
            t6 = J.getInterceptor$x(frame);
            t1.drawImageScaledFromSource$9(context, J.get$source$x(texture.get$baseTexture()), t6.get$x(frame), t6.get$y(frame), t6.get$width(frame), t6.get$height(frame), J.floor$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(J.get$x$x(child.get$anchor()), J.$mul$ns(J.$negate$n(t6.get$width(frame)), J.get$x$x(t5.get$scale(child)))), J.get$x$x(t5.get$position(child))), 0.5)), J.floor$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(J.get$y$x(child.get$anchor()), J.$mul$ns(J.$negate$n(t6.get$height(frame)), J.get$y$x(t5.get$scale(child)))), J.get$y$x(t5.get$position(child))), 0.5)), J.$mul$ns(t6.get$width(frame), J.get$x$x(t5.get$scale(child))), J.$mul$ns(t6.get$height(frame), J.get$y$x(t5.get$scale(child))));
          } else {
            if (!isRotated)
              isRotated = true;
            child.updateTransform$0();
            childTransform = child.get$_worldTransform();
            t5 = J.getInterceptor$x(childTransform);
            if (renderSession.get$roundPixels() === true)
              t1.setTransform$6(context, t5.get$a(childTransform), childTransform.get$c(), childTransform.get$b(), childTransform.get$d(), J.floor$0$n(childTransform.get$tx()), J.floor$0$n(childTransform.get$ty()));
            else
              t1.setTransform$6(context, t5.get$a(childTransform), childTransform.get$c(), childTransform.get$b(), childTransform.get$d(), childTransform.get$tx(), childTransform.get$ty());
            t5 = J.getInterceptor$x(frame);
            t1.drawImageScaledFromSource$9(context, J.get$source$x(texture.get$baseTexture()), t5.get$x(frame), t5.get$y(frame), t5.get$width(frame), t5.get$height(frame), J.$add$ns(J.$mul$ns(J.get$x$x(child.get$anchor()), J.$negate$n(t5.get$width(frame))), 0.5), J.$add$ns(J.$mul$ns(J.get$y$x(child.get$anchor()), J.$negate$n(t5.get$height(frame))), 0.5), t5.get$width(frame), t5.get$height(frame));
          }
        }
        ++i;
      }
    }, "call$1", "get$_renderCanvas", 2, 0, 596, 166, [], "_renderCanvas"],
    static: {SpriteBatch$0: [function(textureThing) {
        var t1, t2, t3;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        return new M.SpriteBatch0(textureThing, false, null, [], false, 0, 0, t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
      }, null, null, 0, 2, 75, 12, 76, [], "new SpriteBatch"]}
  },
  "+SpriteBatch": [706],
  Stage0: {
    "^": "DisplayObjectContainer;_dirty:PIXI$Stage0$_dirty@-617,_interactiveEventsAdded@-617,hitArea:PIXI$Stage0$hitArea@-659,backgroundColor*-614,backgroundColorSplit@-709,backgroundColorString@-644,_worldTransform:PIXI$Stage0$_worldTransform@-658,interactionManager@-710,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    get$worldTransform: [function() {
      return this.PIXI$Stage0$_worldTransform;
    }, null, null, 1, 0, 677, "worldTransform"],
    setInteractionDelegate$1: [function(domElement) {
      this.interactionManager.setTargetDomElement$1(domElement);
    }, "call$1", "get$setInteractionDelegate", 2, 0, 596, 711, [], "setInteractionDelegate"],
    updateTransform$0: [function() {
      var j, i;
      this._worldAlpha = 1;
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i).updateTransform$0();
      if (this.PIXI$Stage0$_dirty === true) {
        this.PIXI$Stage0$_dirty = false;
        this.interactionManager.set$dirty(true);
      }
      if (this._interactive === true)
        this.interactionManager.update$0();
    }, "call$0", "get$updateTransform", 0, 0, 17, "updateTransform"],
    setBackgroundColor$1: [function(backgroundColor) {
      var hex;
      this.set$backgroundColor(0, backgroundColor);
      this.backgroundColorSplit = M.hex2rgb(this.get$backgroundColor(this));
      hex = J.toRadixString$1$n(this.get$backgroundColor(this), 16);
      this.backgroundColorString = "#" + (C.JSString_methods.substring$2("000000", 0, 6 - hex.length) + hex);
    }, "call$1", "get$setBackgroundColor", 2, 0, 712, 79, [], "setBackgroundColor"],
    getMousePosition$0: [function() {
      return this.interactionManager.get$mouse().get$global();
    }, "call$0", "get$getMousePosition", 0, 0, 713, "getMousePosition"],
    Stage$2: function(backgroundColor, interactive) {
      var t1, t2, t3;
      this.PIXI$Stage0$_dirty = true;
      this._stage = this;
      if (backgroundColor != null)
        this.set$backgroundColor(0, backgroundColor);
      this.set$interactive(interactive);
      t1 = new M.Point0(null, null);
      t1.x = 0;
      t1.y = 0;
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      t3 = new M.Point0(null, null);
      t3.x = 0;
      t3.y = 0;
      t3 = new M.InteractionManager(this, new M.InteractionData(t1, null, null), t2, t3, true, [], [], null, null, new P.DateTime(Date.now(), false), null, "inherit", false, null);
      t3.isCocoonJS = J.contains$1$asx(window.navigator.appVersion, "CocoonJS");
      this.interactionManager = t3;
      this.setBackgroundColor$1(backgroundColor);
    },
    static: {Stage$: [function(backgroundColor, interactive) {
        var t1, t2, t3, t4;
        t1 = new Float32Array(H._checkLength(9));
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t4 = new M.Stage0(null, false, new M.Rectangle0(0, 0, 100000, 100000), 0, [], null, new M.Matrix(1, 0, 0, 1, 0, 0, t1), null, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t4.Stage$2(backgroundColor, interactive);
        return t4;
      }, null, null, 0, 4, 77, 49, 78, 79, [], 80, [], "new Stage"]}
  },
  "+Stage": [706],
  Rope: {
    "^": "Strip;points*-675,count:PIXI$Rope$count@-616,texture-698,blendMode-702,uvs-672,verticies-672,colors-672,indices-714,updateFrame-617,_vertexBuffer-715,_indexBuffer-715,_uvBuffer-715,_colorBuffer-715,count-614,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    refresh$0: [function() {
      var points, t1, uvs, indices, colors, t2, t3, t4, total, t5, i, index, amount, t6, t7, t8;
      points = this.get$points(this);
      t1 = J.getInterceptor$asx(points);
      if (J.$lt$n(t1.get$length(points), 1))
        return;
      uvs = this.uvs;
      t1.$index(points, 0);
      indices = this.indices;
      colors = this.colors;
      this.PIXI$Rope$count = J.$sub$n(this.PIXI$Rope$count, 0.2);
      t2 = J.getInterceptor$ax(uvs);
      t2.$indexSet(uvs, 0, 0);
      t2.$indexSet(uvs, 1, 0);
      t2.$indexSet(uvs, 2, 0);
      t2.$indexSet(uvs, 3, 1);
      t3 = J.getInterceptor$ax(colors);
      t3.$indexSet(colors, 0, 1);
      t3.$indexSet(colors, 1, 1);
      t4 = J.getInterceptor$ax(indices);
      t4.$indexSet(indices, 0, 0);
      t4.$indexSet(indices, 1, 1);
      total = t1.get$length(points);
      if (typeof total !== "number")
        return H.iae(total);
      t5 = total - 1;
      i = 1;
      for (; i < total; ++i) {
        t1.$index(points, i);
        index = i * 4;
        amount = i / t5;
        t6 = index + 1;
        t7 = index + 3;
        t8 = index + 2;
        if (C.JSInt_methods.$mod(i, 2) !== 0) {
          t2.$indexSet(uvs, index, amount);
          t2.$indexSet(uvs, t6, 0);
          t2.$indexSet(uvs, t8, amount);
          t2.$indexSet(uvs, t7, 1);
        } else {
          t2.$indexSet(uvs, index, amount);
          t2.$indexSet(uvs, t6, 0);
          t2.$indexSet(uvs, t8, amount);
          t2.$indexSet(uvs, t7, 1);
        }
        index = i * 2;
        t3.$indexSet(colors, index, 1);
        t6 = index + 1;
        t3.$indexSet(colors, t6, 1);
        t4.$indexSet(indices, index, index);
        t4.$indexSet(indices, t6, t6);
      }
    }, "call$0", "get$refresh", 0, 0, 54, "refresh"],
    updateTransform$0: [function() {
      var points, t1, lastPoint, perp, verticies, total, t2, t3, i, point, index, t4, nextPoint, t5, perpLength, n;
      points = this.get$points(this);
      t1 = J.getInterceptor$asx(points);
      if (J.$lt$n(t1.get$length(points), 1))
        return;
      lastPoint = t1.$index(points, 0);
      perp = new M.Point0(null, null);
      perp.x = 0;
      perp.y = 0;
      this.PIXI$Rope$count = J.$sub$n(this.PIXI$Rope$count, 0.2);
      verticies = this.verticies;
      total = t1.get$length(points);
      if (typeof total !== "number")
        return H.iae(total);
      t2 = J.getInterceptor$ax(verticies);
      t3 = total - 1;
      i = 0;
      for (; i < total; ++i, lastPoint = point) {
        point = t1.$index(points, i);
        index = i * 4;
        t4 = J.$sub$n(t1.get$length(points), 1);
        if (typeof t4 !== "number")
          return H.iae(t4);
        nextPoint = i < t4 ? t1.$index(points, i + 1) : point;
        t4 = J.getInterceptor$x(nextPoint);
        t5 = J.getInterceptor$x(lastPoint);
        perp.y = J.$negate$n(J.$sub$n(t4.get$x(nextPoint), t5.get$x(lastPoint)));
        t5 = J.$sub$n(t4.get$y(nextPoint), t5.get$y(lastPoint));
        perp.x = t5;
        if ((1 - i / t3) * 10 > 1)
          ;
        t4 = J.$mul$ns(t5, t5);
        t5 = perp.y;
        t5 = J.$add$ns(t4, J.$mul$ns(t5, t5));
        if (typeof t5 !== "number")
          H.throwExpression(P.ArgumentError$(t5));
        perpLength = Math.sqrt(t5);
        n = J.$div$n(J.get$height$x(this.texture), 2);
        perp.x = J.$div$n(perp.x, perpLength);
        perp.y = J.$div$n(perp.y, perpLength);
        perp.x = J.$mul$ns(perp.x, n);
        perp.y = J.$mul$ns(perp.y, n);
        t4 = J.getInterceptor$x(point);
        t2.$indexSet(verticies, index, J.$add$ns(t4.get$x(point), J.toDouble$0$n(perp.x)));
        t2.$indexSet(verticies, index + 1, J.$add$ns(t4.get$y(point), J.toDouble$0$n(perp.y)));
        t2.$indexSet(verticies, index + 2, J.$sub$n(t4.get$x(point), J.toDouble$0$n(perp.x)));
        t2.$indexSet(verticies, index + 3, J.$sub$n(t4.get$y(point), J.toDouble$0$n(perp.y)));
      }
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
    }, "call$0", "get$updateTransform", 0, 0, 54, "updateTransform"],
    setTexture$1: [function(texture) {
      this.texture = texture;
    }, "call$1", "get$setTexture", 2, 0, 67, 68, [], "setTexture"],
    Rope$2: function(texture, points) {
      var t1;
      this.set$points(0, points);
      t1 = J.getInterceptor$asx(points);
      this.verticies = new Float32Array(H._checkLength(J.$mul$ns(t1.get$length(points), 4)));
      this.uvs = new Float32Array(H._checkLength(J.$mul$ns(t1.get$length(points), 4)));
      this.colors = new Float32Array(H._checkLength(J.$mul$ns(t1.get$length(points), 2)));
      this.indices = new Uint16Array(H._checkLength(J.$mul$ns(t1.get$length(points), 2)));
      this.refresh$0();
    },
    static: {Rope$0: [function(texture, points) {
        var t1, t2, t3;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t3 = new M.Rope(null, 0, null, C.BlendModes_0, null, null, null, null, false, null, null, null, null, 0, [], false, 0, 0, t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t3.Strip$1(texture);
        t3.Rope$2(texture, points);
        return t3;
      }, null, null, 4, 0, 81, 68, [], 57, [], "new Rope"]}
  },
  "+Rope": [716],
  BoneData: {
    "^": "Object;name*-644,parent*-717,length*-616,x*-616,y*-616,rotation@-616,scaleX@-616,scaleY@-616",
    static: {BoneData$: [function($name, $parent) {
        return new M.BoneData($name, $parent, 0, 0, 0, 0, 1, 1);
      }, null, null, 4, 0, 82, 83, [], 84, [], "new BoneData"]}
  },
  "+BoneData": [674],
  SlotData: {
    "^": "Object;name*-644,boneData@-717,r*-616,g@-616,b@-616,a*-616,attachmentName@-644",
    static: {SlotData$: [function($name, boneData) {
        return new M.SlotData($name, boneData, 1, 1, 1, 1, null);
      }, null, null, 4, 0, 82, 83, [], 85, [], "new SlotData"]}
  },
  "+SlotData": [674],
  Bone: {
    "^": "Object;parent*-718,data*-717,x*-616,y*-616,rotation@-616,scaleX@-616,scaleY@-616,m00@-616,m01@-616,worldX@-616,m10@-616,m11@-616,worldY@-616,worldRotation@-616,worldScaleX@-616,worldScaleY@-616",
    updateWorldTransform$2: [function(flipX, flipY) {
      var $parent, t1, radians, _cos, _sin, t2;
      $parent = this.parent;
      t1 = this.x;
      if ($parent != null) {
        this.worldX = J.$add$ns(J.$add$ns(J.$mul$ns(t1, $parent.get$m00()), J.$mul$ns(this.y, $parent.get$m01())), $parent.get$worldX());
        this.worldY = J.$add$ns(J.$add$ns(J.$mul$ns(this.x, $parent.get$m10()), J.$mul$ns(this.y, $parent.get$m11())), $parent.get$worldY());
        this.worldScaleX = J.$mul$ns($parent.get$worldScaleX(), this.scaleX);
        this.worldScaleY = J.$mul$ns($parent.get$worldScaleY(), this.scaleY);
        t1 = J.$add$ns($parent.get$worldRotation(), this.rotation);
        this.worldRotation = t1;
      } else {
        this.worldX = t1;
        this.worldY = this.y;
        this.worldScaleX = this.scaleX;
        this.worldScaleY = this.scaleY;
        t1 = this.rotation;
        this.worldRotation = t1;
      }
      radians = J.$div$n(J.$mul$ns(t1, 3.141592653589793), 180);
      _cos = Math.cos(H.checkNum(radians));
      _sin = Math.sin(H.checkNum(radians));
      t1 = this.worldScaleX;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = _cos * t1;
      this.m00 = t2;
      this.m10 = _sin * t1;
      t1 = this.worldScaleY;
      if (typeof t1 !== "number")
        return H.iae(t1);
      this.m01 = -_sin * t1;
      this.m11 = _cos * t1;
      if (flipX === true) {
        this.m00 = -t2;
        this.m01 = J.$negate$n(this.m01);
      }
      if (flipY === true) {
        this.m10 = J.$negate$n(this.m10);
        this.m11 = J.$negate$n(this.m11);
      }
      if ($.Bone_yDown === true) {
        this.m10 = J.$negate$n(this.m10);
        this.m11 = J.$negate$n(this.m11);
      }
    }, "call$2", "get$updateWorldTransform", 4, 0, 719, 720, [], 721, [], "updateWorldTransform"],
    setToSetupPose$0: [function() {
      var data, t1;
      data = this.data;
      t1 = J.getInterceptor$x(data);
      this.x = t1.get$x(data);
      this.y = t1.get$y(data);
      this.rotation = data.get$rotation();
      this.scaleX = data.get$scaleX();
      this.scaleY = data.get$scaleY();
    }, "call$0", "get$setToSetupPose", 0, 0, 54, "setToSetupPose"],
    static: {"^": "Bone_yDown@-617", Bone$: [function(data, $parent) {
        var t1 = new M.Bone($parent, data, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1);
        t1.setToSetupPose$0();
        return t1;
      }, null, null, 4, 0, 86, 87, [], 84, [], "new Bone"]}
  },
  "+Bone": [674],
  Slot: {
    "^": "Object;data*-722,skeleton@-723,bone@-718,sprites@-724,currentSprite@-661,currentSpriteName@-644,r*-616,g@-616,b@-616,a*-616,_attachmentTime@-616,attachment@-725",
    setAttachment$1: [function(attachment) {
      this.attachment = attachment;
      this._attachmentTime = this.skeleton.get$time();
    }, "call$1", "get$setAttachment", 2, 0, 102, 726, [], "setAttachment"],
    setAttachmentTime$1: [function(time) {
      this._attachmentTime = J.$sub$n(this.skeleton.get$time(), time);
    }, "call$1", "get$setAttachmentTime", 2, 0, 102, 727, [], "setAttachmentTime"],
    getAttachmentTime$0: [function() {
      return J.$sub$n(this.skeleton.get$time(), this._attachmentTime);
    }, "call$0", "get$getAttachmentTime", 0, 0, 54, "getAttachmentTime"],
    setToSetupPose$0: [function() {
      var slotDatas, t1, n, i;
      this.r = J.get$r$x(this.data);
      this.g = this.data.get$g();
      this.b = this.data.get$b();
      this.a = J.get$a$x(this.data);
      slotDatas = J.get$data$x(this.skeleton).get$slots();
      t1 = J.getInterceptor$asx(slotDatas);
      n = t1.get$length(slotDatas);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(t1.$index(slotDatas, i), this.data)) {
          this.attachment = this.data.get$attachmentName() == null ? null : this.skeleton.getAttachmentBySlotIndex$2(i, this.data.get$attachmentName());
          this._attachmentTime = this.skeleton.get$time();
          break;
        }
    }, "call$0", "get$setToSetupPose", 0, 0, 54, "setToSetupPose"],
    static: {Slot$: [function(data, skeleton, bone) {
        var t1 = new M.Slot(data, skeleton, bone, null, null, null, 1, 1, 1, 1, 0, null);
        t1.setToSetupPose$0();
        return t1;
      }, null, null, 6, 0, 88, 87, [], 89, [], 90, [], "new Slot"]}
  },
  "+Slot": [674],
  Skin: {
    "^": "Object;name*-644,attachments@-728",
    addAttachment$3: [function(slotIndex, $name, attachment) {
      J.$indexSet$ax(this.attachments, H.S(slotIndex) + ":" + H.S($name), attachment);
    }, "call$3", "get$addAttachment", 6, 0, 729, 730, [], 83, [], 726, [], "addAttachment"],
    getAttachment$2: [function(slotIndex, $name) {
      return J.$index$asx(this.attachments, H.S(slotIndex) + ":" + H.S($name));
    }, "call$2", "get$getAttachment", 4, 0, 731, 730, [], 83, [], "getAttachment"],
    _attachAll$2: [function(skeleton, oldSkin) {
      var t1, key, t2, colon, slotIndex, $name, slot, attachment;
      for (t1 = J.get$iterator$ax(J.get$keys$x(oldSkin.get$attachments())); t1.moveNext$0();) {
        key = t1.get$current();
        t2 = J.getInterceptor$asx(key);
        colon = t2.indexOf$1(key, ":");
        slotIndex = H.Primitives_parseInt(t2.substring$2(key, 0, colon), null, null);
        $name = t2.substring$1(key, J.$add$ns(colon, 1));
        slot = J.$index$asx(skeleton.get$slots(), slotIndex);
        if (slot.get$attachment() != null && J.$eq(J.get$name$x(slot.get$attachment()), $name)) {
          attachment = J.$index$asx(this.attachments, H.S(slotIndex) + ":" + $name);
          if (attachment != null)
            slot.setAttachment$1(attachment);
        }
      }
    }, "call$2", "get$_attachAll", 4, 0, 732, 89, [], 733, [], "_attachAll"],
    static: {Skin$: [function($name) {
        return new M.Skin($name, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }, null, null, 2, 0, 91, 83, [], "new Skin"]}
  },
  "+Skin": [674],
  Animation0: {
    "^": "Object;name*-644,timelines@-734,duration*-616",
    apply$3: [function(skeleton, time, loop) {
      var timelines, t1, n, i;
      if (loop === true && !J.$eq(this.duration, 0))
        time = J.$mod$n(time, this.duration);
      timelines = this.timelines;
      t1 = J.getInterceptor$asx(timelines);
      n = t1.get$length(timelines);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        t1.$index(timelines, i).apply$3(skeleton, time, 1);
    }, "call$3", "get$apply", 6, 0, 735, 89, [], 727, [], 257, [], "apply"],
    mix$4: [function(skeleton, time, loop, alpha) {
      var timelines, t1, n, i;
      if (loop === true && !J.$eq(this.duration, 0))
        time = J.$mod$n(time, this.duration);
      timelines = this.timelines;
      t1 = J.getInterceptor$asx(timelines);
      n = t1.get$length(timelines);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        t1.$index(timelines, i).apply$3(skeleton, time, alpha);
    }, "call$4", "get$mix", 8, 0, 736, 89, [], 727, [], 257, [], 567, [], "mix"],
    static: {Animation$: [function($name, timelines, duration) {
        return new M.Animation0($name, timelines, duration);
      }, null, null, 6, 0, 92, 83, [], 93, [], 94, [], "new Animation"]}
  },
  "+Animation": [674],
  Curves: {
    "^": "Object;curves@-709",
    setLinear$1: [function(frameIndex) {
      J.$indexSet$ax(this.curves, J.$mul$ns(frameIndex, 6), 0);
    }, "call$1", "get$setLinear", 2, 0, 99, 114, [], "setLinear"],
    setStepped$1: [function(frameIndex) {
      J.$indexSet$ax(this.curves, J.$mul$ns(frameIndex, 6), -1);
    }, "call$1", "get$setStepped", 2, 0, 99, 114, [], "setStepped"],
    setCurve$5: [function(frameIndex, cx1, cy1, cx2, cy2) {
      var t1, tmp1x, t2, tmp1y, tmp2x, tmp2y, i, curves, t3, t4, t5, t6, t7;
      t1 = J.getInterceptor$n(cx1);
      tmp1x = J.$add$ns(J.$mul$ns(t1.$negate(cx1), 2), cx2);
      t2 = J.getInterceptor$n(cy1);
      tmp1y = J.$add$ns(J.$mul$ns(t2.$negate(cy1), 2), cy2);
      tmp2x = J.$add$ns(J.$mul$ns(t1.$sub(cx1, cx2), 3), 1);
      tmp2y = J.$add$ns(J.$mul$ns(t2.$sub(cy1, cy2), 3), 1);
      i = J.$mul$ns(frameIndex, 6);
      curves = this.curves;
      t3 = J.getInterceptor$ns(tmp1x);
      t4 = J.getInterceptor$ns(tmp2x);
      t5 = J.getInterceptor$ax(curves);
      t5.$indexSet(curves, i, J.$add$ns(J.$add$ns(t1.$mul(cx1, 0.30000000000000004), t3.$mul(tmp1x, 0.030000000000000006)), t4.$mul(tmp2x, 0.0010000000000000002)));
      t1 = J.getInterceptor$ns(i);
      t6 = J.getInterceptor$ns(tmp1y);
      t7 = J.getInterceptor$ns(tmp2y);
      t5.$indexSet(curves, t1.$add(i, 1), J.$add$ns(J.$add$ns(t2.$mul(cy1, 0.30000000000000004), t6.$mul(tmp1y, 0.030000000000000006)), t7.$mul(tmp2y, 0.0010000000000000002)));
      t5.$indexSet(curves, t1.$add(i, 2), J.$add$ns(t3.$mul(tmp1x, 0.06000000000000001), t4.$mul(tmp2x, 0.006000000000000002)));
      t5.$indexSet(curves, t1.$add(i, 3), J.$add$ns(t6.$mul(tmp1y, 0.06000000000000001), t7.$mul(tmp2y, 0.006000000000000002)));
      t5.$indexSet(curves, t1.$add(i, 4), t4.$mul(tmp2x, 0.006000000000000002));
      t5.$indexSet(curves, t1.$add(i, 5), t7.$mul(tmp2y, 0.006000000000000002));
    }, "call$5", "get$setCurve", 10, 0, 737, 114, [], 738, [], 739, [], 740, [], 741, [], "setCurve"],
    getCurvePercent$2: [function(frameIndex, percent) {
      var t1, curveIndex, dfx, dfy, ddfx, ddfy, dddfx, dddfy, y, x, i, lastX, t2, lastY;
      t1 = J.getInterceptor$n(percent);
      if (t1.$lt(percent, 0))
        percent = 0;
      else if (t1.$gt(percent, 1))
        percent = 1;
      curveIndex = J.$mul$ns(frameIndex, 6);
      dfx = J.$index$asx(this.curves, curveIndex);
      t1 = J.getInterceptor(dfx);
      if (t1.$eq(dfx, 0) || dfx == null)
        return percent;
      if (t1.$eq(dfx, -1))
        return 0;
      t1 = J.getInterceptor$ns(curveIndex);
      dfy = J.$index$asx(this.curves, t1.$add(curveIndex, 1));
      ddfx = J.$index$asx(this.curves, t1.$add(curveIndex, 2));
      ddfy = J.$index$asx(this.curves, t1.$add(curveIndex, 3));
      dddfx = J.$index$asx(this.curves, t1.$add(curveIndex, 4));
      dddfy = J.$index$asx(this.curves, t1.$add(curveIndex, 5));
      for (y = dfy, x = dfx, i = 8; true;) {
        t1 = J.getInterceptor$n(x);
        if (t1.$ge(x, percent)) {
          lastX = t1.$sub(x, dfx);
          t2 = J.getInterceptor$n(y);
          lastY = t2.$sub(y, dfy);
          return J.$add$ns(lastY, J.$div$n(J.$mul$ns(t2.$sub(y, lastY), J.$sub$n(percent, lastX)), t1.$sub(x, lastX)));
        }
        if (i === 0)
          break;
        --i;
        dfx = J.$add$ns(dfx, ddfx);
        dfy = J.$add$ns(dfy, ddfy);
        ddfx = J.$add$ns(ddfx, dddfx);
        ddfy = J.$add$ns(ddfy, dddfy);
        x = t1.$add(x, dfx);
        y = J.$add$ns(y, dfy);
      }
      if (typeof y !== "number")
        return H.iae(y);
      t1 = J.$sub$n(percent, x);
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (typeof x !== "number")
        return H.iae(x);
      return y + (1 - y) * t1 / (1 - x);
    }, "call$2", "get$getCurvePercent", 4, 0, 742, 114, [], 743, [], "getCurvePercent"],
    Curves$1: function(frameCount) {
      var t1 = J.$mul$ns(J.$sub$n(frameCount, 1), 6);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = Array(t1);
      t1.fixed$length = init;
      this.curves = H.setRuntimeTypeInfo(t1, [P.num]);
    },
    static: {Curves$: [function(frameCount) {
        var t1 = new M.Curves(null);
        t1.Curves$1(frameCount);
        return t1;
      }, null, null, 2, 0, 99, 100, [], "new Curves"]}
  },
  "+Curves": [674],
  Timeline: {
    "^": "Object;curves@-744,frames@-745,boneIndex@-614",
    static: {Timeline$: [function() {
        return new M.Timeline(null, null, 0);
      }, null, null, 0, 0, 101, "new Timeline"]}
  },
  "+Timeline": [674],
  RotateTimeline: {
    "^": "Timeline;curves-744,frames-745,boneIndex-614",
    getFrameCount$0: [function() {
      return J.$tdiv$n(J.get$length$asx(this.frames), 2);
    }, "call$0", "get$getFrameCount", 0, 0, 412, "getFrameCount"],
    setFrame$6: [function(frameIndex, time, angle, a, b, c) {
      frameIndex = J.$mul$ns(frameIndex, 2);
      J.$indexSet$ax(this.frames, frameIndex, time);
      J.$indexSet$ax(this.frames, J.$add$ns(frameIndex, 1), angle);
    }, function(frameIndex, time, angle) {
      return this.setFrame$6(frameIndex, time, angle, null, null, null);
    }, "setFrame$3", function(frameIndex, time, angle, a) {
      return this.setFrame$6(frameIndex, time, angle, a, null, null);
    }, "setFrame$4", function(frameIndex, time, angle, a, b) {
      return this.setFrame$6(frameIndex, time, angle, a, b, null);
    }, "setFrame$5", "call$6", "call$3", "call$4", "call$5", "get$setFrame", 6, 6, 746, 12, 12, 12, 114, [], 727, [], 7, [], 348, [], 349, [], 345, [], "setFrame"],
    apply$3: [function(skeleton, time, alpha) {
      var t1, bone, t2, t3, amount, frameIndex, lastFrameValue, frameTime, percent;
      t1 = J.getInterceptor$n(time);
      if (t1.$lt(time, J.$index$asx(this.frames, 0)))
        return;
      bone = J.$index$asx(skeleton.get$bones(), this.boneIndex);
      t2 = this.frames;
      t3 = J.getInterceptor$asx(t2);
      if (t1.$ge(time, t3.$index(t2, J.$sub$n(t3.get$length(t2), 2)))) {
        t1 = J.get$data$x(bone).get$rotation();
        t2 = this.frames;
        t3 = J.getInterceptor$asx(t2);
        amount = J.$sub$n(J.$add$ns(t1, t3.$index(t2, J.$sub$n(t3.get$length(t2), 1))), bone.get$rotation());
        for (; t1 = J.getInterceptor$n(amount), t1.$gt(amount, 180);)
          amount = t1.$sub(amount, 360);
        for (; t1 = J.getInterceptor$n(amount), t1.$lt(amount, -180);)
          amount = t1.$add(amount, 360);
        bone.set$rotation(J.$add$ns(bone.get$rotation(), t1.$mul(amount, alpha)));
        return;
      }
      frameIndex = M.binarySearch(this.frames, time, 2);
      t2 = J.getInterceptor$n(frameIndex);
      lastFrameValue = J.$index$asx(this.frames, t2.$sub(frameIndex, 1));
      frameTime = J.$index$asx(this.frames, frameIndex);
      t1 = J.$div$n(t1.$sub(time, frameTime), J.$sub$n(J.$index$asx(this.frames, t2.$sub(frameIndex, 2)), frameTime));
      if (typeof t1 !== "number")
        return H.iae(t1);
      percent = this.curves.getCurvePercent$2(J.$sub$n(t2.$tdiv(frameIndex, 2), 1), 1 - t1);
      amount = J.$sub$n(J.$index$asx(this.frames, t2.$add(frameIndex, 1)), lastFrameValue);
      for (; t1 = J.getInterceptor$n(amount), t1.$gt(amount, 180);)
        amount = t1.$sub(amount, 360);
      for (; t1 = J.getInterceptor$n(amount), t1.$lt(amount, -180);)
        amount = t1.$add(amount, 360);
      amount = J.$sub$n(J.$add$ns(J.get$data$x(bone).get$rotation(), J.$add$ns(lastFrameValue, t1.$mul(amount, percent))), bone.get$rotation());
      for (; t1 = J.getInterceptor$n(amount), t1.$gt(amount, 180);)
        amount = t1.$sub(amount, 360);
      for (; t1 = J.getInterceptor$n(amount), t1.$lt(amount, -180);)
        amount = t1.$add(amount, 360);
      bone.set$rotation(J.$add$ns(bone.get$rotation(), t1.$mul(amount, alpha)));
    }, "call$3", "get$apply", 6, 0, 747, 89, [], 727, [], 567, [], "apply"],
    RotateTimeline$1: function(frameCount) {
      var t1;
      this.curves = M.Curves$(frameCount);
      t1 = J.$mul$ns(frameCount, 2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = Array(t1);
      t1.fixed$length = init;
      this.frames = t1;
    },
    static: {RotateTimeline$: [function(frameCount) {
        var t1 = new M.RotateTimeline(null, null, 0);
        t1.RotateTimeline$1(frameCount);
        return t1;
      }, null, null, 2, 0, 99, 100, [], "new RotateTimeline"]}
  },
  "+RotateTimeline": [748],
  TranslateTimeline: {
    "^": "Timeline;curves-744,frames-745,boneIndex-614",
    getFrameCount$0: [function() {
      return J.$div$n(J.get$length$asx(this.frames), 3);
    }, "call$0", "get$getFrameCount", 0, 0, 54, "getFrameCount"],
    setFrame$6: [function(frameIndex, time, x, y, a, b) {
      var t1;
      frameIndex = J.$mul$ns(frameIndex, 3);
      J.$indexSet$ax(this.frames, frameIndex, time);
      t1 = J.getInterceptor$ns(frameIndex);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 1), x);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 2), y);
    }, function(frameIndex, time, x, y) {
      return this.setFrame$6(frameIndex, time, x, y, null, null);
    }, "setFrame$4", function(frameIndex, time, x) {
      return this.setFrame$6(frameIndex, time, x, null, null, null);
    }, "setFrame$3", function(frameIndex, time, x, y, a) {
      return this.setFrame$6(frameIndex, time, x, y, a, null);
    }, "setFrame$5", "call$6", "call$4", "call$3", "call$5", "get$setFrame", 6, 6, 749, 12, 12, 12, 114, [], 727, [], 9, [], 10, [], 348, [], 349, [], "setFrame"],
    apply$3: [function(skeleton, time, alpha) {
      var $frames, t1, t2, bone, frameIndex, t3, lastFrameX, lastFrameY, frameTime, percent;
      $frames = this.frames;
      t1 = J.getInterceptor$asx($frames);
      t2 = J.getInterceptor$n(time);
      if (t2.$lt(time, t1.$index($frames, 0)))
        return;
      bone = J.$index$asx(skeleton.get$bones(), this.boneIndex);
      if (t2.$ge(time, t1.$index($frames, J.$sub$n(t1.get$length($frames), 3)))) {
        t2 = J.getInterceptor$x(bone);
        t2.set$x(bone, J.$add$ns(t2.get$x(bone), J.$mul$ns(J.$sub$n(J.$add$ns(J.get$x$x(t2.get$data(bone)), t1.$index($frames, J.$sub$n(t1.get$length($frames), 2))), t2.get$x(bone)), alpha)));
        t2.set$y(bone, J.$add$ns(t2.get$y(bone), J.$mul$ns(J.$sub$n(J.$add$ns(J.get$y$x(t2.get$data(bone)), t1.$index($frames, J.$sub$n(t1.get$length($frames), 1))), t2.get$y(bone)), alpha)));
        return;
      }
      frameIndex = M.binarySearch($frames, time, 3);
      t3 = J.getInterceptor$n(frameIndex);
      lastFrameX = t1.$index($frames, t3.$sub(frameIndex, 2));
      lastFrameY = t1.$index($frames, t3.$sub(frameIndex, 1));
      frameTime = t1.$index($frames, frameIndex);
      t2 = J.$div$n(t2.$sub(time, frameTime), J.$sub$n(t1.$index($frames, t3.$add(frameIndex, -3)), frameTime));
      if (typeof t2 !== "number")
        return H.iae(t2);
      percent = this.curves.getCurvePercent$2(J.$sub$n(t3.$tdiv(frameIndex, 3), 1), 1 - t2);
      t2 = J.getInterceptor$x(bone);
      t2.set$x(bone, J.$add$ns(t2.get$x(bone), J.$mul$ns(J.$sub$n(J.$add$ns(J.$add$ns(J.get$x$x(t2.get$data(bone)), lastFrameX), J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 1)), lastFrameX), percent)), t2.get$x(bone)), alpha)));
      t2.set$y(bone, J.$add$ns(t2.get$y(bone), J.$mul$ns(J.$sub$n(J.$add$ns(J.$add$ns(J.get$y$x(t2.get$data(bone)), lastFrameY), J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 2)), lastFrameY), percent)), t2.get$y(bone)), alpha)));
    }, "call$3", "get$apply", 6, 0, 155, 89, [], 727, [], 567, [], "apply"],
    TranslateTimeline$1: function(frameCount) {
      var t1;
      this.curves = M.Curves$(frameCount);
      t1 = J.$mul$ns(frameCount, 3);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = Array(t1);
      t1.fixed$length = init;
      this.frames = t1;
    },
    static: {TranslateTimeline$: [function(frameCount) {
        var t1 = new M.TranslateTimeline(null, null, 0);
        t1.TranslateTimeline$1(frameCount);
        return t1;
      }, null, null, 2, 0, 99, 100, [], "new TranslateTimeline"]}
  },
  "+TranslateTimeline": [748],
  ScaleTimeline: {
    "^": "Timeline;curves-744,frames-745,boneIndex-614",
    getFrameCount$0: [function() {
      return J.$div$n(J.get$length$asx(this.frames), 3);
    }, "call$0", "get$getFrameCount", 0, 0, 54, "getFrameCount"],
    setFrame$6: [function(frameIndex, time, x, y, a, b) {
      var t1;
      frameIndex = J.$mul$ns(frameIndex, 3);
      J.$indexSet$ax(this.frames, frameIndex, time);
      t1 = J.getInterceptor$ns(frameIndex);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 1), x);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 2), y);
    }, function(frameIndex, time, x, y) {
      return this.setFrame$6(frameIndex, time, x, y, null, null);
    }, "setFrame$4", function(frameIndex, time, x) {
      return this.setFrame$6(frameIndex, time, x, null, null, null);
    }, "setFrame$3", function(frameIndex, time, x, y, a) {
      return this.setFrame$6(frameIndex, time, x, y, a, null);
    }, "setFrame$5", "call$6", "call$4", "call$3", "call$5", "get$setFrame", 6, 6, 749, 12, 12, 12, 114, [], 727, [], 9, [], 10, [], 348, [], 349, [], "setFrame"],
    apply$3: [function(skeleton, time, alpha) {
      var $frames, t1, t2, bone, frameIndex, t3, lastFrameX, lastFrameY, frameTime, percent;
      $frames = this.frames;
      t1 = J.getInterceptor$asx($frames);
      t2 = J.getInterceptor$n(time);
      if (t2.$lt(time, t1.$index($frames, 0)))
        return;
      bone = J.$index$asx(skeleton.get$bones(), this.boneIndex);
      if (t2.$ge(time, t1.$index($frames, J.$sub$n(t1.get$length($frames), 3)))) {
        t2 = J.getInterceptor$x(bone);
        bone.set$scaleX(J.$add$ns(bone.get$scaleX(), J.$mul$ns(J.$sub$n(J.$add$ns(J.$sub$n(t2.get$data(bone).get$scaleX(), 1), t1.$index($frames, J.$sub$n(t1.get$length($frames), 2))), bone.get$scaleX()), alpha)));
        bone.set$scaleY(J.$add$ns(bone.get$scaleY(), J.$mul$ns(J.$sub$n(J.$add$ns(J.$sub$n(t2.get$data(bone).get$scaleY(), 1), t1.$index($frames, J.$sub$n(t1.get$length($frames), 1))), bone.get$scaleY()), alpha)));
        return;
      }
      frameIndex = M.binarySearch($frames, time, 3);
      t3 = J.getInterceptor$n(frameIndex);
      lastFrameX = t1.$index($frames, t3.$sub(frameIndex, 2));
      lastFrameY = t1.$index($frames, t3.$sub(frameIndex, 1));
      frameTime = t1.$index($frames, frameIndex);
      t2 = J.$div$n(t2.$sub(time, frameTime), J.$sub$n(t1.$index($frames, t3.$add(frameIndex, -3)), frameTime));
      if (typeof t2 !== "number")
        return H.iae(t2);
      percent = this.curves.getCurvePercent$2(J.$sub$n(t3.$tdiv(frameIndex, 3), 1), 1 - t2);
      t2 = J.getInterceptor$x(bone);
      bone.set$scaleX(J.$add$ns(bone.get$scaleX(), J.$mul$ns(J.$sub$n(J.$add$ns(J.$add$ns(J.$sub$n(t2.get$data(bone).get$scaleX(), 1), lastFrameX), J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 1)), lastFrameX), percent)), bone.get$scaleX()), alpha)));
      bone.set$scaleY(J.$add$ns(bone.get$scaleY(), J.$mul$ns(J.$sub$n(J.$add$ns(J.$add$ns(J.$sub$n(t2.get$data(bone).get$scaleY(), 1), lastFrameY), J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 2)), lastFrameY), percent)), bone.get$scaleY()), alpha)));
    }, "call$3", "get$apply", 6, 0, 155, 89, [], 727, [], 567, [], "apply"],
    ScaleTimeline$1: function(frameCount) {
      var t1;
      this.curves = M.Curves$(frameCount);
      t1 = J.$mul$ns(frameCount, 3);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = Array(t1);
      t1.fixed$length = init;
      this.frames = t1;
    },
    static: {ScaleTimeline$: [function(frameCount) {
        var t1 = new M.ScaleTimeline(null, null, 0);
        t1.ScaleTimeline$1(frameCount);
        return t1;
      }, null, null, 2, 0, 99, 100, [], "new ScaleTimeline"]}
  },
  "+ScaleTimeline": [748],
  ColorTimeline: {
    "^": "Timeline;slotIndex@-614,curves-744,frames-745,boneIndex-614",
    getFrameCount$0: [function() {
      return J.$div$n(J.get$length$asx(this.frames), 5);
    }, "call$0", "get$getFrameCount", 0, 0, 54, "getFrameCount"],
    setFrame$6: [function(frameIndex, time, r, g, b, a) {
      var t1;
      frameIndex = J.$mul$ns(frameIndex, 5);
      J.$indexSet$ax(this.frames, frameIndex, time);
      t1 = J.getInterceptor$ns(frameIndex);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 1), r);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 2), g);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 3), b);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 4), a);
    }, function(frameIndex, time, r) {
      return this.setFrame$6(frameIndex, time, r, null, null, null);
    }, "setFrame$3", function(frameIndex, time, r, g) {
      return this.setFrame$6(frameIndex, time, r, g, null, null);
    }, "setFrame$4", function(frameIndex, time, r, g, b) {
      return this.setFrame$6(frameIndex, time, r, g, b, null);
    }, "setFrame$5", "call$6", "call$3", "call$4", "call$5", "get$setFrame", 6, 6, 749, 12, 12, 12, 114, [], 727, [], 346, [], 536, [], 349, [], 348, [], "setFrame"],
    apply$3: [function(skeleton, time, alpha) {
      var $frames, t1, t2, slot, i, t3, frameIndex, lastFrameR, lastFrameG, lastFrameB, lastFrameA, frameTime, percent, r, g, b, a;
      $frames = this.frames;
      t1 = J.getInterceptor$asx($frames);
      t2 = J.getInterceptor$n(time);
      if (t2.$lt(time, t1.$index($frames, 0)))
        return;
      slot = J.$index$asx(skeleton.get$slots(), this.slotIndex);
      if (t2.$ge(time, t1.$index($frames, J.$sub$n(t1.get$length($frames), 5)))) {
        i = J.$sub$n(t1.get$length($frames), 1);
        t2 = J.getInterceptor$n(i);
        t3 = J.getInterceptor$x(slot);
        t3.set$r(slot, t1.$index($frames, t2.$sub(i, 3)));
        slot.set$g(t1.$index($frames, t2.$sub(i, 2)));
        slot.set$b(t1.$index($frames, t2.$sub(i, 1)));
        t3.set$a(slot, t1.$index($frames, i));
        return;
      }
      frameIndex = M.binarySearch($frames, time, 5);
      t3 = J.getInterceptor$n(frameIndex);
      lastFrameR = t1.$index($frames, t3.$sub(frameIndex, 4));
      lastFrameG = t1.$index($frames, t3.$sub(frameIndex, 3));
      lastFrameB = t1.$index($frames, t3.$sub(frameIndex, 2));
      lastFrameA = t1.$index($frames, t3.$sub(frameIndex, 1));
      frameTime = t1.$index($frames, frameIndex);
      t2 = J.$div$n(t2.$sub(time, frameTime), J.$sub$n(t1.$index($frames, t3.$sub(frameIndex, 5)), frameTime));
      if (typeof t2 !== "number")
        return H.iae(t2);
      percent = this.curves.getCurvePercent$2(J.$sub$n(t3.$tdiv(frameIndex, 5), 1), 1 - t2);
      r = J.$add$ns(lastFrameR, J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 1)), lastFrameR), percent));
      g = J.$add$ns(lastFrameG, J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 2)), lastFrameG), percent));
      b = J.$add$ns(lastFrameB, J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 3)), lastFrameB), percent));
      a = J.$add$ns(lastFrameA, J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 4)), lastFrameA), percent));
      t1 = J.getInterceptor$x(slot);
      if (J.$lt$n(alpha, 1)) {
        t1.set$r(slot, J.$add$ns(t1.get$r(slot), J.$mul$ns(J.$sub$n(r, t1.get$r(slot)), alpha)));
        slot.set$g(J.$add$ns(slot.get$g(), J.$mul$ns(J.$sub$n(g, slot.get$g()), alpha)));
        slot.set$b(J.$add$ns(slot.get$b(), J.$mul$ns(J.$sub$n(b, slot.get$b()), alpha)));
        t1.set$a(slot, J.$add$ns(t1.get$a(slot), J.$mul$ns(J.$sub$n(a, t1.get$a(slot)), alpha)));
      } else {
        t1.set$r(slot, r);
        slot.set$g(g);
        slot.set$b(b);
        t1.set$a(slot, a);
      }
    }, "call$3", "get$apply", 6, 0, 155, 89, [], 727, [], 567, [], "apply"],
    ColorTimeline$1: function(frameCount) {
      var t1;
      this.curves = M.Curves$(frameCount);
      t1 = J.$mul$ns(frameCount, 5);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = Array(t1);
      t1.fixed$length = init;
      this.frames = t1;
    },
    static: {ColorTimeline$: [function(frameCount) {
        var t1 = new M.ColorTimeline(0, null, null, 0);
        t1.ColorTimeline$1(frameCount);
        return t1;
      }, null, null, 2, 0, 102, 100, [], "new ColorTimeline"]}
  },
  "+ColorTimeline": [748],
  AttachmentTimeline: {
    "^": "Timeline;slotIndex@-614,attachmentNames@-645,curves-744,frames-745,boneIndex-614",
    getFrameCount$0: [function() {
      return J.get$length$asx(this.frames);
    }, "call$0", "get$getFrameCount", 0, 0, 54, "getFrameCount"],
    setFrame$6: [function(frameIndex, time, attachmentName, a, b, c) {
      J.$indexSet$ax(this.frames, frameIndex, time);
      J.$indexSet$ax(this.attachmentNames, frameIndex, attachmentName);
    }, function(frameIndex, time, attachmentName) {
      return this.setFrame$6(frameIndex, time, attachmentName, null, null, null);
    }, "setFrame$3", function(frameIndex, time, attachmentName, a) {
      return this.setFrame$6(frameIndex, time, attachmentName, a, null, null);
    }, "setFrame$4", function(frameIndex, time, attachmentName, a, b) {
      return this.setFrame$6(frameIndex, time, attachmentName, a, b, null);
    }, "setFrame$5", "call$6", "call$3", "call$4", "call$5", "get$setFrame", 6, 6, 750, 12, 12, 12, 114, [], 727, [], 751, [], 348, [], 349, [], 345, [], "setFrame"],
    apply$3: [function(skeleton, time, alpha) {
      var $frames, t1, t2, frameIndex, attachmentName;
      $frames = this.frames;
      t1 = J.getInterceptor$asx($frames);
      t2 = J.getInterceptor$n(time);
      if (t2.$lt(time, t1.$index($frames, 0)))
        return;
      frameIndex = t2.$ge(time, t1.$index($frames, J.$sub$n(t1.get$length($frames), 1))) ? J.$sub$n(t1.get$length($frames), 1) : J.$sub$n(M.binarySearch($frames, time, 1), 1);
      attachmentName = J.$index$asx(this.attachmentNames, frameIndex);
      t1 = J.$index$asx(skeleton.get$slots(), this.slotIndex);
      t1.setAttachment$1(attachmentName == null ? null : skeleton.getAttachmentBySlotIndex$2(this.slotIndex, attachmentName));
    }, "call$3", "get$apply", 6, 0, 155, 89, [], 727, [], 567, [], "apply"],
    AttachmentTimeline$1: function(frameCount) {
      var t1;
      this.curves = M.Curves$(frameCount);
      if (typeof frameCount !== "number")
        return H.iae(frameCount);
      t1 = Array(frameCount);
      t1.fixed$length = init;
      this.frames = t1;
      t1 = Array(frameCount);
      t1.fixed$length = init;
      this.attachmentNames = t1;
    },
    static: {AttachmentTimeline$: [function(frameCount) {
        var t1 = new M.AttachmentTimeline(0, null, null, null, 0);
        t1.AttachmentTimeline$1(frameCount);
        return t1;
      }, null, null, 2, 0, 99, 100, [], "new AttachmentTimeline"]}
  },
  "+AttachmentTimeline": [748],
  SkeletonData: {
    "^": "Object;bones@-752,slots@-753,skins@-645,animations@-754,defaultSkin@-755",
    findBone$1: [function(boneName) {
      var n, i;
      n = J.get$length$asx(this.bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.bones, i)), boneName))
          return J.$index$asx(this.bones, i);
      return;
    }, "call$1", "get$findBone", 2, 0, 756, 757, [], "findBone"],
    findBoneIndex$1: [function(boneName) {
      var n, i;
      n = J.get$length$asx(this.bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.bones, i)), boneName))
          return i;
      return -1;
    }, "call$1", "get$findBoneIndex", 2, 0, 557, 757, [], "findBoneIndex"],
    findSlot$1: [function(slotName) {
      var n, i;
      n = J.get$length$asx(this.slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.slots, i)), slotName))
          return J.$index$asx(this.slots, i);
      return;
    }, "call$1", "get$findSlot", 2, 0, 758, 759, [], "findSlot"],
    findSlotIndex$1: [function(slotName) {
      var n, i;
      n = J.get$length$asx(this.slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.slots, i)), slotName))
          return i;
      return -1;
    }, "call$1", "get$findSlotIndex", 2, 0, 557, 759, [], "findSlotIndex"],
    findSkin$1: [function(skinName) {
      var n, i;
      n = J.get$length$asx(this.skins);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.skins, i)), skinName))
          return J.$index$asx(this.skins, i);
      return;
    }, "call$1", "get$findSkin", 2, 0, 760, 761, [], "findSkin"],
    findAnimation$1: [function(animationName) {
      var n, i;
      n = J.get$length$asx(this.animations);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.animations, i)), animationName))
          return J.$index$asx(this.animations, i);
      return;
    }, "call$1", "get$findAnimation", 2, 0, 762, 763, [], "findAnimation"],
    static: {SkeletonData$: [function() {
        return new M.SkeletonData([], [], [], [], null);
      }, null, null, 0, 0, 54, "new SkeletonData"]}
  },
  "+SkeletonData": [674],
  Skeleton: {
    "^": "Object;data*-764,bones@-765,slots@-766,drawOrder@-766,x*-616,y*-616,skin@-755,r*-616,g@-616,b@-616,a*-616,flipX@-617,flipY@-617,time@-616",
    updateWorldTransform$0: [function() {
      var n, i;
      n = J.get$length$asx(this.bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        J.$index$asx(this.bones, i).updateWorldTransform$2(this.flipX, this.flipY);
    }, "call$0", "get$updateWorldTransform", 0, 0, 54, "updateWorldTransform"],
    setToSetupPose$0: [function() {
      this.setBonesToSetupPose$0();
      this.setSlotsToSetupPose$0();
    }, "call$0", "get$setToSetupPose", 0, 0, 54, "setToSetupPose"],
    setBonesToSetupPose$0: [function() {
      var n, i;
      n = J.get$length$asx(this.bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        J.$index$asx(this.bones, i).setToSetupPose$0();
    }, "call$0", "get$setBonesToSetupPose", 0, 0, 54, "setBonesToSetupPose"],
    setSlotsToSetupPose$0: [function() {
      var n, i;
      n = J.get$length$asx(this.slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        J.$index$asx(this.slots, i).setToSetupPose$0();
    }, "call$0", "get$setSlotsToSetupPose", 0, 0, 54, "setSlotsToSetupPose"],
    getRootBone$0: [function() {
      return !J.$eq(J.get$length$asx(this.bones), 0) ? J.$index$asx(this.bones, 0) : null;
    }, "call$0", "get$getRootBone", 0, 0, 767, "getRootBone"],
    findBone$1: [function(boneName) {
      var n, i;
      n = J.get$length$asx(this.bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.get$data$x(J.$index$asx(this.bones, i))), boneName))
          return J.$index$asx(this.bones, i);
      return;
    }, "call$1", "get$findBone", 2, 0, 768, 757, [], "findBone"],
    findBoneIndex$1: [function(boneName) {
      var n, i;
      n = J.get$length$asx(this.bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.get$data$x(J.$index$asx(this.bones, i))), boneName))
          return i;
      return -1;
    }, "call$1", "get$findBoneIndex", 2, 0, 557, 757, [], "findBoneIndex"],
    findSlot$1: [function(slotName) {
      var n, i;
      n = J.get$length$asx(this.slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.get$data$x(J.$index$asx(this.slots, i))), slotName))
          return J.$index$asx(this.slots, i);
      return;
    }, "call$1", "get$findSlot", 2, 0, 769, 759, [], "findSlot"],
    findSlotIndex$1: [function(slotName) {
      var n, i;
      n = J.get$length$asx(this.slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.get$data$x(J.$index$asx(this.slots, i))), slotName))
          return i;
      return -1;
    }, "call$1", "get$findSlotIndex", 2, 0, 557, 759, [], "findSlotIndex"],
    setSkinByName$1: [function(skinName) {
      var skin, t1;
      skin = this.data.findSkin$1(skinName);
      if (skin == null)
        throw H.wrapException(P.Exception_Exception("Skin not found: " + H.S(skinName)));
      t1 = this.skin;
      if (t1 != null && true)
        skin._attachAll$2(this, t1);
      this.skin = skin;
    }, "call$1", "get$setSkinByName", 2, 0, 91, 761, [], "setSkinByName"],
    setSkin$1: [function(newSkin) {
      var t1 = this.skin;
      if (t1 != null && newSkin != null)
        newSkin._attachAll$2(this, t1);
      this.skin = newSkin;
    }, "call$1", "get$setSkin", 2, 0, 770, 771, [], "setSkin"],
    getAttachmentBySlotName$2: [function(slotName, attachmentName) {
      return this.getAttachmentBySlotIndex$2(this.data.findSlotIndex$1(slotName), attachmentName);
    }, "call$2", "get$getAttachmentBySlotName", 4, 0, 772, 759, [], 751, [], "getAttachmentBySlotName"],
    getAttachmentBySlotIndex$2: [function(slotIndex, attachmentName) {
      var t1, attachment;
      t1 = this.skin;
      if (t1 != null) {
        attachment = t1.getAttachment$2(slotIndex, attachmentName);
        if (attachment != null)
          return attachment;
      }
      if (this.data.get$defaultSkin() != null)
        return this.data.get$defaultSkin().getAttachment$2(slotIndex, attachmentName);
      return;
    }, "call$2", "get$getAttachmentBySlotIndex", 4, 0, 731, 730, [], 751, [], "getAttachmentBySlotIndex"],
    setAttachment$2: [function(slotName, attachmentName) {
      var slots, t1, n, i, slot;
      slots = this.slots;
      t1 = J.getInterceptor$asx(slots);
      n = t1.get$length(slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i) {
        slot = t1.$index(slots, i);
        if (J.$eq(J.get$name$x(J.get$data$x(slot)), slotName)) {
          slot.setAttachment$1(attachmentName != null ? this.getAttachment$2(i, attachmentName) : null);
          return;
        }
      }
      throw H.wrapException(P.Exception_Exception("Slot not found: " + H.S(slotName)));
    }, "call$2", "get$setAttachment", 4, 0, 772, 759, [], 751, [], "setAttachment"],
    getAttachment$2: [function(i, attachmentName) {
      throw H.wrapException(P.Exception_Exception("error"));
    }, "call$2", "get$getAttachment", 4, 0, 773, 424, [], 751, [], "getAttachment"],
    update$1: [function(delta) {
      this.time = J.$add$ns(this.time, delta);
    }, "call$1", "get$update", 2, 0, 620, 774, [], "update"],
    Skeleton$1: function(skeletonData) {
      var n, i, boneData, t1, $parent, t2, slotData, slot;
      this.data = skeletonData;
      n = J.get$length$asx(skeletonData.get$bones());
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i) {
        boneData = J.$index$asx(skeletonData.get$bones(), i);
        t1 = J.getInterceptor$x(boneData);
        $parent = t1.get$parent(boneData) == null ? null : J.$index$asx(this.bones, J.indexOf$1$asx(skeletonData.get$bones(), t1.get$parent(boneData)));
        t1 = this.bones;
        t2 = new M.Bone($parent, boneData, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1);
        t2.setToSetupPose$0();
        J.add$1$ax(t1, t2);
      }
      this.slots = [];
      this.drawOrder = [];
      n = J.get$length$asx(skeletonData.get$slots());
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i) {
        slotData = J.$index$asx(skeletonData.get$slots(), i);
        slot = new M.Slot(slotData, this, J.$index$asx(this.bones, J.indexOf$1$asx(skeletonData.get$bones(), slotData.get$boneData())), null, null, null, 1, 1, 1, 1, 0, null);
        slot.setToSetupPose$0();
        J.add$1$ax(this.slots, slot);
        J.add$1$ax(this.drawOrder, slot);
      }
    },
    static: {Skeleton$: [function(skeletonData) {
        var t1 = new M.Skeleton(null, [], [], [], 0, 0, null, 1, 1, 1, 1, false, false, null);
        t1.Skeleton$1(skeletonData);
        return t1;
      }, null, null, 2, 0, 103, 104, [], "new Skeleton"]}
  },
  "+Skeleton": [674],
  Attachment: {
    "^": "Object;name*-644,offset*-645,uvs@-645,x*-616,y*-616,rotation@-616,scaleX@-616,scaleY@-616,width*-616,height*-616,regionOffsetX@-616,regionOffsetY@-616,regionWidth@-616,regionHeight@-616,regionOriginalWidth@-616,regionOriginalHeight@-616,rendererObject@-775",
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    static: {Attachment$: [function() {
        return new M.Attachment(null, null, null, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, null);
      }, null, null, 0, 0, 105, "new Attachment"]}
  },
  "+Attachment": [674],
  RegionAttachment: {
    "^": "Attachment;name-644,offset-645,uvs-645,x-616,y-616,rotation-616,scaleX-616,scaleY-616,width-616,height-616,regionOffsetX-616,regionOffsetY-616,regionWidth-616,regionHeight-616,regionOriginalWidth-616,regionOriginalHeight-616,rendererObject-775",
    setUVs$5: [function(u, v, u2, v2, rotate) {
      var uvs, t1;
      uvs = this.uvs;
      t1 = J.getInterceptor$ax(uvs);
      if (rotate === true) {
        t1.$indexSet(uvs, 2, u);
        t1.$indexSet(uvs, 3, v2);
        t1.$indexSet(uvs, 4, u);
        t1.$indexSet(uvs, 5, v);
        t1.$indexSet(uvs, 6, u2);
        t1.$indexSet(uvs, 7, v);
        t1.$indexSet(uvs, 0, u2);
        t1.$indexSet(uvs, 1, v2);
      } else {
        t1.$indexSet(uvs, 0, u);
        t1.$indexSet(uvs, 1, v2);
        t1.$indexSet(uvs, 2, u);
        t1.$indexSet(uvs, 3, v);
        t1.$indexSet(uvs, 4, u2);
        t1.$indexSet(uvs, 5, v);
        t1.$indexSet(uvs, 6, u2);
        t1.$indexSet(uvs, 7, v2);
      }
    }, "call$5", "get$setUVs", 10, 0, 776, 777, [], 37, [], 778, [], 779, [], 780, [], "setUVs"],
    updateOffset$0: [function() {
      var regionScaleX, regionScaleY, t1, t2, t3, localX, localY, localX2, localY2, radians, _cos, _sin, localXCos, localXSin, localYCos, localYSin, localX2Cos, localX2Sin, localY2Cos, localY2Sin, offset;
      regionScaleX = J.$mul$ns(J.$div$n(this.width, this.regionOriginalWidth), this.scaleX);
      regionScaleY = J.$mul$ns(J.$div$n(this.height, this.regionOriginalHeight), this.scaleY);
      t1 = J.$div$n(J.$negate$n(this.width), 2);
      t2 = this.scaleX;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = J.$mul$ns(this.regionOffsetX, regionScaleX);
      if (typeof t3 !== "number")
        return H.iae(t3);
      localX = t1 * t2 + t3;
      t3 = J.$div$n(J.$negate$n(this.height), 2);
      t2 = this.scaleY;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t1 = J.$mul$ns(this.regionOffsetY, regionScaleY);
      if (typeof t1 !== "number")
        return H.iae(t1);
      localY = t3 * t2 + t1;
      t1 = J.$mul$ns(this.regionWidth, regionScaleX);
      if (typeof t1 !== "number")
        return H.iae(t1);
      localX2 = localX + t1;
      t1 = J.$mul$ns(this.regionHeight, regionScaleY);
      if (typeof t1 !== "number")
        return H.iae(t1);
      localY2 = localY + t1;
      radians = J.$div$n(J.$mul$ns(this.rotation, 3.141592653589793), 180);
      _cos = Math.cos(H.checkNum(radians));
      _sin = Math.sin(H.checkNum(radians));
      t1 = this.x;
      if (typeof t1 !== "number")
        return H.iae(t1);
      localXCos = localX * _cos + t1;
      localXSin = localX * _sin;
      t2 = this.y;
      if (typeof t2 !== "number")
        return H.iae(t2);
      localYCos = localY * _cos + t2;
      localYSin = localY * _sin;
      localX2Cos = localX2 * _cos + t1;
      localX2Sin = localX2 * _sin;
      localY2Cos = localY2 * _cos + t2;
      localY2Sin = localY2 * _sin;
      offset = this.offset;
      t2 = J.getInterceptor$ax(offset);
      t2.$indexSet(offset, 0, localXCos - localYSin);
      t2.$indexSet(offset, 1, localYCos + localXSin);
      t2.$indexSet(offset, 2, localXCos - localY2Sin);
      t2.$indexSet(offset, 3, localY2Cos + localXSin);
      t2.$indexSet(offset, 4, localX2Cos - localY2Sin);
      t2.$indexSet(offset, 5, localY2Cos + localX2Sin);
      t2.$indexSet(offset, 6, localX2Cos - localYSin);
      t2.$indexSet(offset, 7, localYCos + localX2Sin);
    }, "call$0", "get$updateOffset", 0, 0, 54, "updateOffset"],
    computeVertices$4: [function(x, y, bone, vertices) {
      var m00, m01, m10, m11, offset, t1, t2;
      x = J.$add$ns(x, bone.get$worldX());
      y = J.$add$ns(y, bone.get$worldY());
      m00 = bone.get$m00();
      m01 = bone.get$m01();
      m10 = bone.get$m10();
      m11 = bone.get$m11();
      offset = this.offset;
      t1 = J.getInterceptor$asx(offset);
      t2 = J.getInterceptor$ax(vertices);
      t2.$indexSet(vertices, 0, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 0), m00), J.$mul$ns(t1.$index(offset, 1), m01)), x));
      t2.$indexSet(vertices, 1, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 0), m10), J.$mul$ns(t1.$index(offset, 1), m11)), y));
      t2.$indexSet(vertices, 2, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 2), m00), J.$mul$ns(t1.$index(offset, 3), m01)), x));
      t2.$indexSet(vertices, 3, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 2), m10), J.$mul$ns(t1.$index(offset, 3), m11)), y));
      t2.$indexSet(vertices, 4, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 4), m00), J.$mul$ns(t1.$index(offset, 5), m01)), x));
      t2.$indexSet(vertices, 5, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 4), m10), J.$mul$ns(t1.$index(offset, 5), m11)), y));
      t2.$indexSet(vertices, 6, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 6), m00), J.$mul$ns(t1.$index(offset, 7), m01)), x));
      t2.$indexSet(vertices, 7, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 6), m10), J.$mul$ns(t1.$index(offset, 7), m11)), y));
    }, "call$4", "get$computeVertices", 8, 0, 781, 9, [], 10, [], 90, [], 782, [], "computeVertices"],
    RegionAttachment$1: function($name) {
      var t1;
      this.name = $name;
      t1 = Array(8);
      t1.fixed$length = init;
      this.offset = t1;
      t1 = Array(8);
      t1.fixed$length = init;
      this.uvs = t1;
    },
    $isRegionAttachment: true,
    static: {RegionAttachment$: [function($name) {
        var t1 = new M.RegionAttachment(null, null, null, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, null);
        t1.RegionAttachment$1($name);
        return t1;
      }, null, null, 0, 2, 106, 12, 83, [], "new RegionAttachment"]}
  },
  "+RegionAttachment": [725],
  AnimationStateData: {
    "^": "Object;skeletonData@-764,animationToMixTime@-783,defaultMix@-614",
    setMixByName$3: [function(fromName, toName, duration) {
      var from, to;
      from = this.skeletonData.findAnimation$1(fromName);
      if (from == null)
        throw H.wrapException(P.Exception_Exception("Animation not found: " + H.S(fromName)));
      to = this.skeletonData.findAnimation$1(toName);
      if (to == null)
        throw H.wrapException(P.Exception_Exception("Animation not found: " + H.S(toName)));
      J.$indexSet$ax(this.animationToMixTime, H.S(J.get$name$x(from)) + ":" + H.S(J.get$name$x(to)), duration);
    }, "call$3", "get$setMixByName", 6, 0, 784, 785, [], 786, [], 94, [], "setMixByName"],
    setMix$3: [function(from, to, duration) {
      J.$indexSet$ax(this.animationToMixTime, H.S(J.get$name$x(from)) + ":" + H.S(J.get$name$x(to)), duration);
    }, "call$3", "get$setMix", 6, 0, 787, 788, [], 789, [], 94, [], "setMix"],
    getMix$2: [function(from, to) {
      var time = J.$index$asx(this.animationToMixTime, H.S(J.get$name$x(from)) + ":" + H.S(J.get$name$x(to)));
      return time != null ? time : this.defaultMix;
    }, "call$2", "get$getMix", 4, 0, 790, 788, [], 789, [], "getMix"],
    static: {AnimationStateData$: [function(skeletonData) {
        return new M.AnimationStateData(skeletonData, P.LinkedHashMap_LinkedHashMap$_empty(null, null), 0);
      }, null, null, 2, 0, 103, 104, [], "new AnimationStateData"]}
  },
  "+AnimationStateData": [674],
  Entry: {
    "^": "Object;animation*-791,loop*-617,delay@-616",
    loop$0: function($receiver) {
      return this.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return this.loop.call$3(arg0, arg1, arg2);
    },
    delay$1: function(arg0) {
      return this.delay.call$1(arg0);
    },
    static: {Entry$: [function() {
        return new M.Entry(null, true, 0);
      }, null, null, 0, 0, 107, "new Entry"]}
  },
  "+Entry": [674],
  AnimationState: {
    "^": "Object;stateData@-792,queue@-793,current@-791,previous@-791,currentTime*-616,previousTime@-616,currentLoop@-617,previousLoop@-617,mixTime@-616,mixDuration@-616,animationSpeed@-616",
    previous$0: function() {
      return this.previous.call$0();
    },
    previous$1: function(arg0) {
      return this.previous.call$1(arg0);
    },
    update$1: [function(delta) {
      var entry, t1;
      this.currentTime = J.$add$ns(this.currentTime, J.$mul$ns(delta, this.animationSpeed));
      this.previousTime = J.$add$ns(this.previousTime, delta);
      this.mixTime = J.$add$ns(this.mixTime, delta);
      if (J.$gt$n(J.get$length$asx(this.queue), 0)) {
        entry = J.$index$asx(this.queue, 0);
        if (J.$ge$n(this.currentTime, entry.get$delay())) {
          t1 = J.getInterceptor$x(entry);
          this._setAnimation$2(t1.get$animation(entry), t1.get$loop(entry));
          J.removeAt$1$ax(this.queue, 0);
        }
      }
    }, "call$1", "get$update", 2, 0, 102, 774, [], "update"],
    apply$1: [function(skeleton) {
      var t1, t2, alpha;
      t1 = this.current;
      if (t1 == null)
        return;
      t2 = this.previous;
      if (t2 != null) {
        t2.apply$3(skeleton, this.previousTime, this.previousLoop);
        alpha = J.$div$n(this.mixTime, this.mixDuration);
        if (J.$ge$n(alpha, 1)) {
          this.previous = null;
          alpha = 1;
        }
        this.current.mix$4(skeleton, this.currentTime, this.currentLoop, alpha);
      } else
        t1.apply$3(skeleton, this.currentTime, this.currentLoop);
    }, "call$1", "get$apply", 2, 0, 794, 89, [], "apply"],
    clearAnimation$0: [function() {
      this.previous = null;
      this.current = null;
      J.clear$0$ax(this.queue);
    }, "call$0", "get$clearAnimation", 0, 0, 54, "clearAnimation"],
    _setAnimation$2: [function(animation, loop) {
      var t1;
      this.previous = null;
      if (animation != null && this.current != null) {
        t1 = this.stateData.getMix$2(this.current, animation);
        this.mixDuration = t1;
        if (J.$gt$n(t1, 0)) {
          this.mixTime = 0;
          this.previous = this.current;
          this.previousTime = this.currentTime;
          this.previousLoop = this.currentLoop;
        }
      }
      this.current = animation;
      this.currentLoop = loop;
      this.currentTime = 0;
    }, function(animation) {
      return this._setAnimation$2(animation, true);
    }, "_setAnimation$1", "call$2", "call$1", "get$_setAnimation", 2, 2, 795, 78, 796, [], 257, [], "_setAnimation"],
    setAnimationByName$2: [function(animationName, loop) {
      var animation = this.stateData.get$skeletonData().findAnimation$1(animationName);
      if (animation == null)
        throw H.wrapException(P.Exception_Exception("Animation not found: " + H.S(animationName)));
      J.clear$0$ax(this.queue);
      this._setAnimation$2(animation, loop);
    }, "call$2", "get$setAnimationByName", 4, 0, 119, 763, [], 257, [], "setAnimationByName"],
    setAnimation$2: [function(animation, loop) {
      J.clear$0$ax(this.queue);
      this._setAnimation$2(animation, loop);
    }, function(animation) {
      return this.setAnimation$2(animation, true);
    }, "setAnimation$1", "call$2", "call$1", "get$setAnimation", 2, 2, 795, 78, 796, [], 257, [], "setAnimation"],
    addAnimationByName$3: [function(animationName, loop, delay) {
      var animation, entry, t1, t2, previousAnimation;
      animation = this.stateData.get$skeletonData().findAnimation$1(animationName);
      if (animation == null)
        throw H.wrapException(P.Exception_Exception("Animation not found: " + H.S(animationName)));
      entry = new M.Entry(null, true, 0);
      entry.animation = animation;
      entry.loop = loop;
      if (J.$le$n(delay, 0)) {
        if (!J.$eq(J.get$length$asx(this.queue), 0)) {
          t1 = this.queue;
          t2 = J.getInterceptor$asx(t1);
          previousAnimation = J.get$animation$x(t2.$index(t1, J.$sub$n(t2.get$length(t1), 1)));
        } else
          previousAnimation = this.current;
        delay = previousAnimation != null ? J.$add$ns(J.$sub$n(J.get$duration$x(previousAnimation), this.stateData.getMix$2(previousAnimation, animation)), delay) : 0;
      }
      entry.delay = delay;
      J.add$1$ax(this.queue, entry);
    }, function(animationName) {
      return this.addAnimationByName$3(animationName, true, 0);
    }, "addAnimationByName$1", function(animationName, loop) {
      return this.addAnimationByName$3(animationName, loop, 0);
    }, "addAnimationByName$2", "call$3", "call$1", "call$2", "get$addAnimationByName", 2, 4, 797, 78, 49, 763, [], 257, [], 516, [], "addAnimationByName"],
    addAnimation$3: [function(animation, loop, delay) {
      var entry, t1, t2, previousAnimation;
      entry = new M.Entry(null, true, 0);
      entry.animation = animation;
      entry.loop = loop;
      if (J.$le$n(delay, 0)) {
        if (!J.$eq(J.get$length$asx(this.queue), 0)) {
          t1 = this.queue;
          t2 = J.getInterceptor$asx(t1);
          previousAnimation = J.get$animation$x(t2.$index(t1, J.$sub$n(t2.get$length(t1), 1)));
        } else
          previousAnimation = this.current;
        delay = previousAnimation != null ? J.$add$ns(J.$sub$n(J.get$duration$x(previousAnimation), this.stateData.getMix$2(previousAnimation, animation)), delay) : 0;
      }
      entry.delay = delay;
      J.add$1$ax(this.queue, entry);
    }, function(animation) {
      return this.addAnimation$3(animation, true, 0);
    }, "addAnimation$1", function(animation, loop) {
      return this.addAnimation$3(animation, loop, 0);
    }, "addAnimation$2", "call$3", "call$1", "call$2", "get$addAnimation", 2, 4, 798, 78, 49, 796, [], 257, [], 516, [], "addAnimation"],
    isComplete$0: [function() {
      var t1 = this.current;
      return t1 == null || J.$ge$n(this.currentTime, J.get$duration$x(t1));
    }, "call$0", "get$isComplete", 0, 0, 247, "isComplete"],
    static: {AnimationState$: [function(stateData) {
        return new M.AnimationState(stateData, [], null, null, 0, 0, false, false, 0, 0, 1);
      }, null, null, 2, 0, 108, 109, [], "new AnimationState"]}
  },
  "+AnimationState": [674],
  SkeletonJson: {
    "^": "Object;attachmentLoader@-799,scale*-614",
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    readSkeletonData$1: [function(root) {
      var skeletonData, t1, bones, t2, n, i, boneMap, t3, $parent, boneData, t4, slots, slotMap, slotData, color, skins, skinName, skinMap, skin, t5, slotName, slotIndex, slotEntry, t6, t7, attachmentName, attachment, animations, animationName;
      skeletonData = new M.SkeletonData([], [], [], [], null);
      t1 = J.getInterceptor$asx(root);
      bones = t1.$index(root, "bones");
      t2 = J.getInterceptor$asx(bones);
      n = t2.get$length(bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i) {
        boneMap = t2.$index(bones, i);
        t3 = J.getInterceptor$asx(boneMap);
        if (t3.$index(boneMap, "parent") != null) {
          $parent = skeletonData.findBone$1(t3.$index(boneMap, "parent"));
          if ($parent == null)
            throw H.wrapException(C.JSString_methods.$add("Parent bone not found: ", t3.$index(boneMap, "parent")));
        } else
          $parent = null;
        boneData = new M.BoneData(t3.$index(boneMap, "name"), $parent, 0, 0, 0, 0, 1, 1);
        t4 = t3.$index(boneMap, "length") == null ? 0 : t3.$index(boneMap, "length");
        boneData.length = J.$mul$ns(t4, this.scale);
        t4 = t3.$index(boneMap, "x") == null ? 0 : t3.$index(boneMap, "x");
        boneData.x = J.$mul$ns(t4, this.scale);
        t4 = t3.$index(boneMap, "y") == null ? 0 : t3.$index(boneMap, "y");
        boneData.y = J.$mul$ns(t4, this.scale);
        boneData.rotation = t3.$index(boneMap, "rotation") == null ? 0 : t3.$index(boneMap, "rotation");
        boneData.scaleX = t3.$index(boneMap, "scaleX") == null ? 1 : t3.$index(boneMap, "scaleX");
        boneData.scaleY = t3.$index(boneMap, "scaleY") == null ? 1 : t3.$index(boneMap, "scaleY");
        J.add$1$ax(skeletonData.bones, boneData);
      }
      slots = t1.$index(root, "slots");
      t2 = J.getInterceptor$asx(slots);
      n = t2.get$length(slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i) {
        slotMap = t2.$index(slots, i);
        t3 = J.getInterceptor$asx(slotMap);
        boneData = skeletonData.findBone$1(t3.$index(slotMap, "bone"));
        if (boneData == null)
          throw H.wrapException(P.Exception_Exception("Slot bone not found: " + H.S(t3.$index(slotMap, "bone"))));
        slotData = new M.SlotData(t3.$index(slotMap, "name"), boneData, 1, 1, 1, 1, null);
        color = t3.$index(slotMap, "color");
        if (color != null) {
          slotData.r = M.SkeletonJson_toColor(color, 0);
          slotData.g = M.SkeletonJson_toColor(color, 1);
          slotData.b = M.SkeletonJson_toColor(color, 2);
          slotData.a = M.SkeletonJson_toColor(color, 3);
        }
        slotData.attachmentName = t3.$index(slotMap, "attachment");
        J.add$1$ax(skeletonData.slots, slotData);
      }
      skins = t1.$index(root, "skins");
      for (t2 = J.getInterceptor$x(skins), t3 = J.get$iterator$ax(t2.get$keys(skins)); t3.moveNext$0();) {
        skinName = t3.get$current();
        skinMap = t2.$index(skins, skinName);
        skin = new M.Skin(skinName, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        for (t4 = J.getInterceptor$x(skinMap), t5 = J.get$iterator$ax(t4.get$keys(skinMap)); t5.moveNext$0();) {
          slotName = t5.get$current();
          slotIndex = skeletonData.findSlotIndex$1(slotName);
          slotEntry = t4.$index(skinMap, slotName);
          for (t6 = J.getInterceptor$x(slotEntry), t7 = J.get$iterator$ax(t6.get$keys(slotEntry)); t7.moveNext$0();) {
            attachmentName = t7.get$current();
            attachment = this.readAttachment$3(skin, attachmentName, t6.$index(slotEntry, attachmentName));
            J.$indexSet$ax(skin.attachments, "" + slotIndex + ":" + H.S(attachmentName), attachment);
          }
        }
        J.add$1$ax(skeletonData.skins, skin);
        if (J.$eq(skin.name, "default"))
          skeletonData.defaultSkin = skin;
      }
      animations = t1.$index(root, "animations");
      for (t1 = J.getInterceptor$x(animations), t2 = J.get$iterator$ax(t1.get$keys(animations)); t2.moveNext$0();) {
        animationName = t2.get$current();
        this.readAnimation$3(animationName, t1.$index(animations, animationName), skeletonData);
      }
      return skeletonData;
    }, "call$1", "get$readSkeletonData", 2, 0, 665, 800, [], "readSkeletonData"],
    readAttachment$3: [function(skin, $name, map) {
      var t1, t2, type, attachment, t3, t4, t5, t6, t7, t8, regionScaleX, regionScaleY, localX, localY, localX2, localY2, radians, _cos, _sin, localXCos, localXSin, localYCos, localYSin, localX2Cos, localX2Sin, localY2Cos, localY2Sin;
      t1 = J.getInterceptor$asx(map);
      if (t1.$index(map, "name") != null)
        $name = t1.$index(map, "name");
      t2 = $.get$AttachmentType();
      type = J.$index$asx(t2, t1.$index(map, "type") == null ? "region" : t1.$index(map, "type"));
      if (J.$eq(type, J.$index$asx($.get$AttachmentType(), "region"))) {
        attachment = new M.RegionAttachment(null, null, null, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, null);
        attachment.name = null;
        t2 = Array(8);
        t2.fixed$length = init;
        attachment.offset = t2;
        t3 = Array(8);
        t3.fixed$length = init;
        attachment.uvs = t3;
        t3 = t1.$index(map, "x") == null ? 0 : t1.$index(map, "x");
        t3 = J.$mul$ns(t3, this.scale);
        attachment.x = t3;
        t4 = t1.$index(map, "y") == null ? 0 : t1.$index(map, "y");
        t4 = J.$mul$ns(t4, this.scale);
        attachment.y = t4;
        t5 = t1.$index(map, "scaleX") == null ? 1 : t1.$index(map, "scaleX");
        attachment.scaleX = t5;
        t6 = t1.$index(map, "scaleY") == null ? 1 : t1.$index(map, "scaleY");
        attachment.scaleY = t6;
        t7 = t1.$index(map, "rotation") == null ? 0 : t1.$index(map, "rotation");
        attachment.rotation = t7;
        t8 = t1.$index(map, "width") == null ? 32 : t1.$index(map, "width");
        t8 = J.$mul$ns(t8, this.scale);
        attachment.width = t8;
        t1 = t1.$index(map, "height") == null ? 32 : t1.$index(map, "height");
        t1 = J.$mul$ns(t1, this.scale);
        attachment.height = t1;
        regionScaleX = J.$mul$ns(J.$div$n(t8, 0), t5);
        regionScaleY = J.$mul$ns(J.$div$n(t1, 0), t6);
        t8 = J.$div$n(J.$negate$n(t8), 2);
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (typeof regionScaleX !== "number")
          return H.iae(regionScaleX);
        localX = t8 * t5 + 0 * regionScaleX;
        t1 = J.$div$n(J.$negate$n(t1), 2);
        if (typeof t6 !== "number")
          return H.iae(t6);
        if (typeof regionScaleY !== "number")
          return H.iae(regionScaleY);
        localY = t1 * t6 + 0 * regionScaleY;
        localX2 = localX + 0 * regionScaleX;
        localY2 = localY + 0 * regionScaleY;
        radians = J.$div$n(J.$mul$ns(t7, 3.141592653589793), 180);
        t1 = typeof radians !== "number";
        if (t1)
          H.throwExpression(P.ArgumentError$(radians));
        _cos = Math.cos(radians);
        if (t1)
          H.throwExpression(P.ArgumentError$(radians));
        _sin = Math.sin(radians);
        if (typeof t3 !== "number")
          return H.iae(t3);
        localXCos = localX * _cos + t3;
        localXSin = localX * _sin;
        if (typeof t4 !== "number")
          return H.iae(t4);
        localYCos = localY * _cos + t4;
        localYSin = localY * _sin;
        localX2Cos = localX2 * _cos + t3;
        localX2Sin = localX2 * _sin;
        localY2Cos = localY2 * _cos + t4;
        localY2Sin = localY2 * _sin;
        if (0 < 0 || 0 >= 8)
          return H.ioore(t2, 0);
        t2[0] = localXCos - localYSin;
        if (1 < 0 || 1 >= 8)
          return H.ioore(t2, 1);
        t2[1] = localYCos + localXSin;
        if (2 < 0 || 2 >= 8)
          return H.ioore(t2, 2);
        t2[2] = localXCos - localY2Sin;
        if (3 < 0 || 3 >= 8)
          return H.ioore(t2, 3);
        t2[3] = localY2Cos + localXSin;
        if (4 < 0 || 4 >= 8)
          return H.ioore(t2, 4);
        t2[4] = localX2Cos - localY2Sin;
        if (5 < 0 || 5 >= 8)
          return H.ioore(t2, 5);
        t2[5] = localY2Cos + localX2Sin;
        if (6 < 0 || 6 >= 8)
          return H.ioore(t2, 6);
        t2[6] = localX2Cos - localYSin;
        if (7 < 0 || 7 >= 8)
          return H.ioore(t2, 7);
        t2[7] = localYCos + localX2Sin;
        t1 = new M.AtlasRegion(null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false, null, null, null, null);
        attachment.rendererObject = t1;
        t1.name = $name;
        t1.scale = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        J.$indexSet$ax(t1.scale, "x", t5);
        J.$indexSet$ax(t1.scale, "y", t6);
        t1.rotation = J.$div$n(J.$mul$ns(J.$negate$n(t7), 3.141592653589793), 180);
        return attachment;
      }
      throw H.wrapException(P.Exception_Exception("Unknown attachment type: " + H.S(type)));
    }, "call$3", "get$readAttachment", 6, 0, 801, 802, [], 83, [], 803, [], "readAttachment"],
    readAnimation$3: [function($name, map, skeletonData) {
      var timelines, t1, bones, t2, t3, duration, frameIndex, valueMap, boneName, boneIndex, boneMap, t4, t5, timelineName, values, t6, t7, timeline, t8, t9, t10, n, i, frameIndex0, timelineScale, x, y, slots, slotName, slotMap, slotIndex, color, r, g, b, a;
      timelines = [];
      t1 = J.getInterceptor$asx(map);
      bones = t1.$index(map, "bones");
      for (t2 = J.getInterceptor$x(bones), t3 = J.get$iterator$ax(t2.get$keys(bones)), duration = 0, frameIndex = null, valueMap = null; t3.moveNext$0();) {
        boneName = t3.get$current();
        boneIndex = skeletonData.findBoneIndex$1(boneName);
        if (boneIndex === -1)
          throw H.wrapException(C.JSString_methods.$add("Bone not found: ", boneName));
        boneMap = t2.$index(bones, boneName);
        for (t4 = J.getInterceptor$x(boneMap), t5 = J.get$iterator$ax(t4.get$keys(boneMap)); t5.moveNext$0();) {
          timelineName = t5.get$current();
          values = t4.$index(boneMap, timelineName);
          t6 = J.getInterceptor(timelineName);
          if (t6.$eq(timelineName, "rotate")) {
            t6 = J.getInterceptor$asx(values);
            t7 = t6.get$length(values);
            timeline = new M.RotateTimeline(null, null, 0);
            t8 = new M.Curves(null);
            t9 = J.getInterceptor$n(t7);
            t10 = J.$mul$ns(t9.$sub(t7, 1), 6);
            if (typeof t10 !== "number")
              return H.iae(t10);
            t10 = Array(t10);
            t10.fixed$length = init;
            t10.$builtinTypeInfo = [P.num];
            t8.curves = t10;
            timeline.curves = t8;
            t7 = t9.$mul(t7, 2);
            if (typeof t7 !== "number")
              return H.iae(t7);
            t7 = Array(t7);
            t7.fixed$length = init;
            timeline.frames = t7;
            timeline.boneIndex = boneIndex;
            n = t6.get$length(values);
            if (typeof n !== "number")
              return H.iae(n);
            frameIndex = 0;
            i = 0;
            for (; i < n; ++i) {
              valueMap = t6.$index(values, i);
              t7 = J.getInterceptor$asx(valueMap);
              t8 = t7.$index(valueMap, "time");
              t7 = t7.$index(valueMap, "angle");
              frameIndex0 = frameIndex * 2;
              J.$indexSet$ax(timeline.frames, frameIndex0, t8);
              J.$indexSet$ax(timeline.frames, frameIndex0 + 1, t7);
              M.SkeletonJson_readCurve(timeline, frameIndex, valueMap);
              ++frameIndex;
            }
            timelines.push(timeline);
            t6 = timeline.frames;
            t7 = J.getInterceptor$asx(t6);
            duration = P.max(duration, t7.$index(t6, J.floor$0$n(J.$sub$n(J.$mul$ns(J.$tdiv$n(t7.get$length(t6), 2), 2), 2))));
          } else if (t6.$eq(timelineName, "translate") || t6.$eq(timelineName, "scale")) {
            t7 = J.getInterceptor$asx(values);
            if (t6.$eq(timelineName, "scale")) {
              t6 = t7.get$length(values);
              timeline = new M.ScaleTimeline(null, null, 0);
              t7 = new M.Curves(null);
              t8 = J.getInterceptor$n(t6);
              t9 = J.$mul$ns(t8.$sub(t6, 1), 6);
              if (typeof t9 !== "number")
                return H.iae(t9);
              t9 = Array(t9);
              t9.fixed$length = init;
              t9.$builtinTypeInfo = [P.num];
              t7.curves = t9;
              timeline.curves = t7;
              t6 = t8.$mul(t6, 3);
              if (typeof t6 !== "number")
                return H.iae(t6);
              t6 = Array(t6);
              t6.fixed$length = init;
              timeline.frames = t6;
              timelineScale = 1;
            } else {
              t6 = t7.get$length(values);
              timeline = new M.TranslateTimeline(null, null, 0);
              t7 = new M.Curves(null);
              t8 = J.getInterceptor$n(t6);
              t9 = J.$mul$ns(t8.$sub(t6, 1), 6);
              if (typeof t9 !== "number")
                return H.iae(t9);
              t9 = Array(t9);
              t9.fixed$length = init;
              t9.$builtinTypeInfo = [P.num];
              t7.curves = t9;
              timeline.curves = t7;
              t6 = t8.$mul(t6, 3);
              if (typeof t6 !== "number")
                return H.iae(t6);
              t6 = Array(t6);
              t6.fixed$length = init;
              timeline.frames = t6;
              timelineScale = this.scale;
            }
            timeline.boneIndex = boneIndex;
            t6 = J.getInterceptor$asx(values);
            n = t6.get$length(values);
            if (typeof n !== "number")
              return H.iae(n);
            frameIndex = 0;
            i = 0;
            for (; i < n; ++i) {
              valueMap = t6.$index(values, i);
              t7 = J.getInterceptor$asx(valueMap);
              x = J.$mul$ns(t7.$index(valueMap, "x") == null ? 0 : t7.$index(valueMap, "x"), timelineScale);
              y = J.$mul$ns(t7.$index(valueMap, "y") == null ? 0 : t7.$index(valueMap, "y"), timelineScale);
              timeline.setFrame$4(frameIndex, t7.$index(valueMap, "time"), x, y);
              M.SkeletonJson_readCurve(timeline, frameIndex, valueMap);
              ++frameIndex;
            }
            timelines.push(timeline);
            duration = P.max(duration, J.$index$asx(timeline.frames, J.floor$0$n(J.$sub$n(J.$mul$ns(timeline.getFrameCount$0(), 3), 3))));
          } else
            throw H.wrapException(P.Exception_Exception("Invalid timeline type for a bone: " + H.S(timelineName) + "(" + H.S(boneName) + ")"));
        }
      }
      slots = t1.$index(map, "slots");
      if (slots != null)
        for (t1 = J.getInterceptor$x(slots), t2 = J.get$iterator$ax(t1.get$keys(slots)), values = null; t2.moveNext$0();) {
          slotName = t2.get$current();
          if (t1.containsKey$1(slots, slotName) !== true)
            continue;
          slotMap = t1.$index(slots, slotName);
          slotIndex = skeletonData.findSlotIndex$1(slotName);
          for (t3 = J.getInterceptor$x(slotMap), t4 = J.get$iterator$ax(t3.get$keys(slotMap)); t4.moveNext$0();) {
            timelineName = t4.get$current();
            if (t3.containsKey$1(slotMap, timelineName) !== true)
              continue;
            values = t3.$index(slotMap, timelineName);
            t5 = J.getInterceptor(timelineName);
            if (t5.$eq(timelineName, "color")) {
              t5 = J.getInterceptor$asx(values);
              t6 = t5.get$length(values);
              timeline = new M.ColorTimeline(0, null, null, 0);
              t7 = new M.Curves(null);
              t8 = J.getInterceptor$n(t6);
              t9 = J.$mul$ns(t8.$sub(t6, 1), 6);
              if (typeof t9 !== "number")
                return H.iae(t9);
              t9 = Array(t9);
              t9.fixed$length = init;
              t9.$builtinTypeInfo = [P.num];
              t7.curves = t9;
              timeline.curves = t7;
              t6 = t8.$mul(t6, 5);
              if (typeof t6 !== "number")
                return H.iae(t6);
              t6 = Array(t6);
              t6.fixed$length = init;
              timeline.frames = t6;
              timeline.slotIndex = slotIndex;
              n = t5.get$length(values);
              if (typeof n !== "number")
                return H.iae(n);
              frameIndex = 0;
              i = 0;
              for (; i < n; ++i) {
                valueMap = t5.$index(values, i);
                t6 = J.getInterceptor$asx(valueMap);
                color = t6.$index(valueMap, "color");
                r = M.SkeletonJson_toColor(color, 0);
                g = M.SkeletonJson_toColor(color, 1);
                b = M.SkeletonJson_toColor(color, 2);
                a = M.SkeletonJson_toColor(color, 3);
                t6 = t6.$index(valueMap, "time");
                frameIndex0 = frameIndex * 5;
                J.$indexSet$ax(timeline.frames, frameIndex0, t6);
                J.$indexSet$ax(timeline.frames, frameIndex0 + 1, r);
                J.$indexSet$ax(timeline.frames, frameIndex0 + 2, g);
                J.$indexSet$ax(timeline.frames, frameIndex0 + 3, b);
                J.$indexSet$ax(timeline.frames, frameIndex0 + 4, a);
                M.SkeletonJson_readCurve(timeline, frameIndex, valueMap);
                ++frameIndex;
              }
              timelines.push(timeline);
              t5 = timeline.frames;
              t6 = J.getInterceptor$asx(t5);
              duration = P.max(duration, t6.$index(t5, J.$sub$n(J.$mul$ns(J.$div$n(t6.get$length(t5), 5), 5), 5)));
            } else if (t5.$eq(timelineName, "attachment")) {
              t5 = J.getInterceptor$asx(values);
              t6 = t5.get$length(values);
              timeline = new M.AttachmentTimeline(0, null, null, null, 0);
              t7 = new M.Curves(null);
              t8 = J.$mul$ns(J.$sub$n(t6, 1), 6);
              if (typeof t8 !== "number")
                return H.iae(t8);
              t8 = Array(t8);
              t8.fixed$length = init;
              t8.$builtinTypeInfo = [P.num];
              t7.curves = t8;
              timeline.curves = t7;
              if (typeof t6 !== "number")
                return H.iae(t6);
              t7 = Array(t6);
              t7.fixed$length = init;
              timeline.frames = t7;
              t6 = Array(t6);
              t6.fixed$length = init;
              timeline.attachmentNames = t6;
              timeline.slotIndex = slotIndex;
              n = t5.get$length(values);
              if (typeof n !== "number")
                return H.iae(n);
              frameIndex = 0;
              i = 0;
              for (; i < n; ++i, frameIndex = frameIndex0) {
                valueMap = t5.$index(values, i);
                frameIndex0 = frameIndex + 1;
                t6 = J.getInterceptor$asx(valueMap);
                t7 = t6.$index(valueMap, "time");
                t6 = t6.$index(valueMap, "name");
                J.$indexSet$ax(timeline.frames, frameIndex, t7);
                J.$indexSet$ax(timeline.attachmentNames, frameIndex, t6);
              }
              timelines.push(timeline);
              t5 = timeline.frames;
              t6 = J.getInterceptor$asx(t5);
              duration = P.max(duration, t6.$index(t5, J.$sub$n(t6.get$length(t5), 1)));
            } else
              throw H.wrapException(C.JSString_methods.$add(C.JSString_methods.$add("Invalid timeline type for a slot: ", timelineName) + " (", slotName) + ")");
          }
        }
      J.add$1$ax(skeletonData.get$animations(), new M.Animation0($name, timelines, duration));
    }, "call$3", "get$readAnimation", 6, 0, 804, 83, [], 803, [], 104, [], "readAnimation"],
    static: {SkeletonJson$: [function(attachmentLoader) {
        return new M.SkeletonJson(attachmentLoader, 1);
      }, null, null, 0, 2, 110, 12, 111, [], "new SkeletonJson"], SkeletonJson_readCurve: [function(timeline, frameIndex, valueMap) {
        var t1, curve;
        t1 = J.getInterceptor$asx(valueMap);
        if (t1.$index(valueMap, "curve") == null)
          return;
        if (J.$eq(t1.$index(valueMap, "curve"), "stepped"))
          timeline.get$curves().setStepped$1(frameIndex);
        else if (!!J.getInterceptor(t1.$index(valueMap, "curve")).$isList) {
          curve = t1.$index(valueMap, "curve");
          t1 = J.getInterceptor$asx(curve);
          timeline.get$curves().setCurve$5(frameIndex, t1.$index(curve, 0), t1.$index(curve, 1), t1.$index(curve, 2), t1.$index(curve, 3));
        }
      }, "call$3", "SkeletonJson_readCurve$closure", 6, 0, 112, 113, [], 114, [], 115, [], "readCurve"], SkeletonJson_toColor: [function(hexString, colorIndex) {
        var t1 = J.getInterceptor$asx(hexString);
        if (!J.$eq(t1.get$length(hexString), 8))
          throw H.wrapException(C.JSString_methods.$add("Color hexidecimal length must be 8, recieved: ", hexString));
        return J.$div$n(H.Primitives_parseInt(J.toRadixString$1$n(H.Primitives_parseInt(t1.substring$2(hexString, J.$mul$ns(colorIndex, 2), 2), null, null), 16), null, null), 255);
      }, "call$2", "SkeletonJson_toColor$closure", 4, 0, 116, 117, [], 118, [], "toColor"]}
  },
  "+SkeletonJson": [674],
  Atlas: {
    "^": "Object;textureLoader@-12,pages@-805,regions@-806",
    findRegion$1: [function($name) {
      var n, i;
      n = J.get$length$asx(this.regions);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.regions, i)), $name))
          return J.$index$asx(this.regions, i);
      return;
    }, "call$1", "get$findRegion", 2, 0, 102, 83, [], "findRegion"],
    dispose$0: [function() {
      var pages, t1, n, i;
      pages = this.pages;
      t1 = J.getInterceptor$asx(pages);
      n = t1.get$length(pages);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        this.textureLoader.unload$1(t1.$index(pages, i).get$rendererObject());
    }, "call$0", "get$dispose", 0, 0, 54, "dispose"],
    updateUVs$1: [function(page) {
      var regions, t1, n, t2, i, region, t3;
      regions = this.regions;
      t1 = J.getInterceptor$asx(regions);
      n = t1.get$length(regions);
      if (typeof n !== "number")
        return H.iae(n);
      t2 = J.getInterceptor$x(page);
      i = 0;
      for (; i < n; ++i) {
        region = t1.$index(regions, i);
        t3 = J.getInterceptor$x(region);
        if (!J.$eq(t3.get$page(region), page))
          continue;
        region.set$u(J.$div$n(t3.get$x(region), t2.get$width(page)));
        region.set$v(J.$div$n(t3.get$y(region), t2.get$height(page)));
        if (t3.get$rotate(region) === true) {
          region.set$u2(J.$div$n(J.$add$ns(t3.get$x(region), t3.get$height(region)), t2.get$width(page)));
          region.set$v2(J.$div$n(J.$add$ns(t3.get$y(region), t3.get$width(region)), t2.get$height(page)));
        } else {
          region.set$u2(J.$div$n(J.$add$ns(t3.get$x(region), t3.get$width(region)), t2.get$width(page)));
          region.set$v2(J.$div$n(J.$add$ns(t3.get$y(region), t3.get$height(region)), t2.get$height(page)));
        }
      }
    }, "call$1", "get$updateUVs", 2, 0, 807, 808, [], "updateUVs"],
    Atlas$2: function(atlasText, textureLoader) {
      var reader, tuple, page, line, t1, direction, region, x, y, width, height, t2, t3;
      reader = new M.AtlasReader(null, 0);
      reader.lines = J.split$1$s(atlasText, $.get$AtlasReader_splitReg());
      tuple = [];
      C.JSArray_methods.set$length(tuple, 4);
      for (page = null; true;) {
        line = reader.readLine$0();
        if (line == null)
          break;
        line = J.replace$2$x(line, $.get$AtlasReader_replaceReg(), "");
        if (J.$eq(J.get$length$asx(line), 0))
          page = null;
        else if (page == null) {
          page = new M.AtlasPage(null, null, null, null, null, null, null, 0, 0);
          page.name = line;
          page.format = J.$index$asx($.get$Atlas_Format(), reader.readValue$0());
          reader.readTuple$1(tuple);
          t1 = $.get$Atlas_TextureFilter();
          if (0 >= tuple.length)
            return H.ioore(tuple, 0);
          page.minFilter = J.$index$asx(t1, tuple[0]);
          t1 = $.get$Atlas_TextureFilter();
          if (1 >= tuple.length)
            return H.ioore(tuple, 1);
          page.magFilter = J.$index$asx(t1, tuple[1]);
          direction = reader.readValue$0();
          page.uWrap = J.$index$asx($.get$Atlas_TextureWrap(), "clampToEdge");
          page.vWrap = J.$index$asx($.get$Atlas_TextureWrap(), "clampToEdge");
          t1 = J.getInterceptor(direction);
          if (t1.$eq(direction, "x"))
            page.uWrap = J.$index$asx($.get$Atlas_TextureWrap(), "repeat");
          else if (t1.$eq(direction, "y"))
            page.vWrap = J.$index$asx($.get$Atlas_TextureWrap(), "repeat");
          else if (t1.$eq(direction, "xy")) {
            t1 = J.$index$asx($.get$Atlas_TextureWrap(), "repeat");
            page.vWrap = t1;
            page.uWrap = t1;
          }
          J.load$2$x(this.textureLoader, page, line);
          J.add$1$ax(this.pages, page);
        } else {
          region = new M.AtlasRegion(null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false, null, null, null, null);
          region.name = line;
          region.page = page;
          t1 = J.$eq(reader.readValue$0(), "true");
          region.rotate = t1;
          reader.readTuple$1(tuple);
          if (0 >= tuple.length)
            return H.ioore(tuple, 0);
          x = H.Primitives_parseInt(tuple[0], null, null);
          if (1 >= tuple.length)
            return H.ioore(tuple, 1);
          y = H.Primitives_parseInt(tuple[1], null, null);
          reader.readTuple$1(tuple);
          if (0 >= tuple.length)
            return H.ioore(tuple, 0);
          width = H.Primitives_parseInt(tuple[0], null, null);
          if (1 >= tuple.length)
            return H.ioore(tuple, 1);
          height = H.Primitives_parseInt(tuple[1], null, null);
          t2 = J.getInterceptor$n(x);
          region.u = t2.$div(x, page.width);
          t3 = J.getInterceptor$n(y);
          region.v = t3.$div(y, page.height);
          if (t1) {
            region.u2 = J.$div$n(t2.$add(x, height), page.width);
            region.v2 = J.$div$n(t3.$add(y, width), page.height);
          } else {
            region.u2 = J.$div$n(t2.$add(x, width), page.width);
            region.v2 = J.$div$n(t3.$add(y, height), page.height);
          }
          region.x = x;
          region.y = y;
          region.width = J.abs$0$n(width);
          region.height = J.abs$0$n(height);
          if (reader.readTuple$1(tuple) === 4) {
            if (0 >= tuple.length)
              return H.ioore(tuple, 0);
            t1 = H.Primitives_parseInt(tuple[0], null, null);
            if (1 >= tuple.length)
              return H.ioore(tuple, 1);
            t2 = H.Primitives_parseInt(tuple[1], null, null);
            if (2 >= tuple.length)
              return H.ioore(tuple, 2);
            t3 = H.Primitives_parseInt(tuple[2], null, null);
            if (3 >= tuple.length)
              return H.ioore(tuple, 3);
            region.splits = [t1, t2, t3, H.Primitives_parseInt(tuple[3], null, null)];
            if (reader.readTuple$1(tuple) === 4) {
              if (0 >= tuple.length)
                return H.ioore(tuple, 0);
              t1 = H.Primitives_parseInt(tuple[0], null, null);
              if (1 >= tuple.length)
                return H.ioore(tuple, 1);
              t2 = H.Primitives_parseInt(tuple[1], null, null);
              if (2 >= tuple.length)
                return H.ioore(tuple, 2);
              t3 = H.Primitives_parseInt(tuple[2], null, null);
              if (3 >= tuple.length)
                return H.ioore(tuple, 3);
              region.pads = [t1, t2, t3, H.Primitives_parseInt(tuple[3], null, null)];
              reader.readTuple$1(tuple);
            }
          }
          if (0 >= tuple.length)
            return H.ioore(tuple, 0);
          region.originalWidth = H.Primitives_parseInt(tuple[0], null, null);
          if (1 >= tuple.length)
            return H.ioore(tuple, 1);
          region.originalHeight = H.Primitives_parseInt(tuple[1], null, null);
          reader.readTuple$1(tuple);
          if (0 >= tuple.length)
            return H.ioore(tuple, 0);
          region.offsetX = H.Primitives_parseInt(tuple[0], null, null);
          if (1 >= tuple.length)
            return H.ioore(tuple, 1);
          region.offsetY = H.Primitives_parseInt(tuple[1], null, null);
          region.index = H.Primitives_parseInt(reader.readValue$0(), null, null);
          J.add$1$ax(this.regions, region);
        }
      }
    },
    static: {"^": "Atlas_Format@-783,Atlas_TextureFilter@-783,Atlas_TextureWrap@-783", Atlas$: [function(atlasText, textureLoader) {
        var t1 = new M.Atlas(textureLoader, [], []);
        t1.Atlas$2(atlasText, textureLoader);
        return t1;
      }, null, null, 4, 0, 119, 120, [], 121, [], "new Atlas"]}
  },
  "+Atlas": [674],
  AtlasPage: {
    "^": "Object;name*-644,format*-614,minFilter@-614,magFilter@-614,uWrap@-614,vWrap@-614,rendererObject@-775,width*-616,height*-616",
    static: {AtlasPage$: [function() {
        return new M.AtlasPage(null, null, null, null, null, null, null, 0, 0);
      }, null, null, 0, 0, 122, "new AtlasPage"]}
  },
  "+AtlasPage": [674],
  AtlasRegion: {
    "^": "Object;page*-809,name*-644,x*-616,y*-616,width*-616,height*-616,u@-616,v@-616,u2@-616,v2@-616,offsetX@-616,offsetY@-616,originalWidth@-616,originalHeight@-616,index*-614,rotate*-617,splits@-745,pads@-745,scale*-783,rotation@-616",
    rotate$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.rotate.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    static: {AtlasRegion$: [function() {
        return new M.AtlasRegion(null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false, null, null, null, null);
      }, null, null, 0, 0, 123, "new AtlasRegion"]}
  },
  "+AtlasRegion": [674],
  AtlasReader: {
    "^": "Object;lines@-645,index*-614",
    trim$1: [function(_, value) {
      return J.replace$2$x(value, $.get$AtlasReader_replaceReg(), "");
    }, "call$1", "get$trim", 2, 0, 576, 138, [], "trim"],
    readLine$0: [function() {
      var t1, t2;
      if (J.$ge$n(this.index, J.get$length$asx(this.lines)))
        return;
      t1 = this.lines;
      t2 = this.index;
      this.index = J.$add$ns(t2, 1);
      return J.$index$asx(t1, t2);
    }, "call$0", "get$readLine", 0, 0, 810, "readLine"],
    readValue$0: [function() {
      var line, t1, colon, t2;
      line = this.readLine$0();
      t1 = J.getInterceptor$asx(line);
      colon = t1.indexOf$1(line, ":");
      t2 = J.getInterceptor(colon);
      if (t2.$eq(colon, -1))
        throw H.wrapException(P.Exception_Exception("Invalid line: " + H.S(line)));
      return C.JSString_methods.replace$2(t1.substring$1(line, t2.$add(colon, 1)), $.get$AtlasReader_replaceReg(), "");
    }, "call$0", "get$readValue", 0, 0, 810, "readValue"],
    readTuple$1: [function(tuple) {
      var line, t1, colon, t2, lastMatch, i, comma, t3;
      line = this.readLine$0();
      t1 = J.getInterceptor$asx(line);
      colon = t1.indexOf$1(line, ":");
      t2 = J.getInterceptor(colon);
      if (t2.$eq(colon, -1))
        throw H.wrapException(P.Exception_Exception("Invalid line: " + H.S(line)));
      lastMatch = t2.$add(colon, 1);
      for (t2 = J.getInterceptor$ax(tuple), i = 0; i < 3; ++i) {
        comma = t1.indexOf$2(line, ",", lastMatch);
        t3 = J.getInterceptor(comma);
        if (t3.$eq(comma, -1)) {
          if (i === 0)
            throw H.wrapException(P.Exception_Exception("Invalid line: " + H.S(line)));
          break;
        }
        t2.$indexSet(tuple, i, C.JSString_methods.replace$2(t1.substring$2(line, lastMatch, t3.$sub(comma, lastMatch)), $.get$AtlasReader_replaceReg(), ""));
        lastMatch = t3.$add(comma, 1);
      }
      t2.$indexSet(tuple, i, C.JSString_methods.replace$2(t1.substring$1(line, lastMatch), $.get$AtlasReader_replaceReg(), ""));
      return i + 1;
    }, "call$1", "get$readTuple", 2, 0, 811, 812, [], "readTuple"],
    static: {"^": "AtlasReader_splitReg@-813,AtlasReader_replaceReg@-813", AtlasReader$: [function(text) {
        var t1 = new M.AtlasReader(null, 0);
        t1.lines = J.split$1$s(text, $.get$AtlasReader_splitReg());
        return t1;
      }, null, null, 2, 0, 91, 124, [], "new AtlasReader"]}
  },
  "+AtlasReader": [674],
  AtlasAttachmentLoader: {
    "^": "Object;atlas@-814",
    atlas$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.atlas.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    newAttachment$3: [function(skin, type, $name) {
      var region, attachment, t1, t2, t3, t4, t5, t6, uvs, t7;
      if (J.$eq(type, J.$index$asx($.get$AttachmentType(), "region"))) {
        region = this.atlas.findRegion$1($name);
        if (region == null)
          throw H.wrapException(P.Exception_Exception("Region not found in atlas: " + H.S($name) + " (" + H.S(type) + ")"));
        attachment = M.RegionAttachment$($name);
        attachment.rendererObject = region;
        t1 = region.get$u();
        t2 = region.get$v();
        t3 = region.get$u2();
        t4 = region.get$v2();
        t5 = J.getInterceptor$x(region);
        t6 = t5.get$rotate(region);
        uvs = attachment.uvs;
        t7 = J.getInterceptor$ax(uvs);
        if (t6 === true) {
          t7.$indexSet(uvs, 2, t1);
          t7.$indexSet(uvs, 3, t4);
          t7.$indexSet(uvs, 4, t1);
          t7.$indexSet(uvs, 5, t2);
          t7.$indexSet(uvs, 6, t3);
          t7.$indexSet(uvs, 7, t2);
          t7.$indexSet(uvs, 0, t3);
          t7.$indexSet(uvs, 1, t4);
        } else {
          t7.$indexSet(uvs, 0, t1);
          t7.$indexSet(uvs, 1, t4);
          t7.$indexSet(uvs, 2, t1);
          t7.$indexSet(uvs, 3, t2);
          t7.$indexSet(uvs, 4, t3);
          t7.$indexSet(uvs, 5, t2);
          t7.$indexSet(uvs, 6, t3);
          t7.$indexSet(uvs, 7, t4);
        }
        attachment.regionOffsetX = region.get$offsetX();
        attachment.regionOffsetY = region.get$offsetY();
        attachment.regionWidth = t5.get$width(region);
        attachment.regionHeight = t5.get$height(region);
        attachment.regionOriginalWidth = region.get$originalWidth();
        attachment.regionOriginalHeight = region.get$originalHeight();
        return attachment;
      }
      throw H.wrapException(P.Exception_Exception("Unknown attachment type: " + H.S(type)));
    }, "call$3", "get$newAttachment", 6, 0, 815, 802, [], 137, [], 83, [], "newAttachment"],
    static: {AtlasAttachmentLoader$: [function(atlas) {
        return new M.AtlasAttachmentLoader(atlas);
      }, null, null, 2, 0, 125, 126, [], "new AtlasAttachmentLoader"]}
  },
  "+AtlasAttachmentLoader": [674],
  Spine: {
    "^": "DisplayObjectContainer;skeleton@-723,skeletonData@-764,stateData@-792,state*-816,slotContainers@-817,lastTime@-818,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    updateTransform$0: [function() {
      var now, t1, drawOrder, n, i, slot, attachment, slotContainer, spriteName, bone, t2, t3;
      now = new P.DateTime(Date.now(), false);
      t1 = this.lastTime;
      if (t1 == null) {
        this.lastTime = now;
        t1 = now;
      }
      t1 = C.JSNumber_methods._tdivFast$1(now.difference$1(t1)._duration, 1000);
      this.lastTime = now;
      this.state.update$1(t1 * 0.001);
      this.state.apply$1(this.skeleton);
      this.skeleton.updateWorldTransform$0();
      drawOrder = this.skeleton.get$drawOrder();
      t1 = J.getInterceptor$asx(drawOrder);
      n = t1.get$length(drawOrder);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i) {
        slot = t1.$index(drawOrder, i);
        attachment = slot.get$attachment();
        slotContainer = J.$index$asx(this.slotContainers, i);
        if (!J.getInterceptor(attachment).$isRegionAttachment) {
          slotContainer.set$visible(false);
          continue;
        }
        if (attachment.rendererObject != null)
          if (slot.get$currentSpriteName() == null || !J.$eq(slot.get$currentSpriteName(), attachment.name)) {
            spriteName = J.get$name$x(attachment.rendererObject);
            if (slot.get$currentSprite() != null)
              slot.get$currentSprite().set$visible(false);
            if (slot.get$sprites() == null)
              slot.set$sprites(P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            if (J.$index$asx(slot.get$sprites(), spriteName) != null)
              J.$index$asx(slot.get$sprites(), spriteName).set$visible(true);
            else
              slotContainer.addChild$1(this.createSprite$2(slot, attachment.rendererObject));
            slot.set$currentSprite(J.$index$asx(slot.get$sprites(), spriteName));
            slot.set$currentSpriteName(spriteName);
          }
        slotContainer.set$visible(true);
        bone = slot.get$bone();
        t2 = J.getInterceptor$x(slotContainer);
        J.set$x$x(t2.get$position(slotContainer), J.$add$ns(J.$add$ns(bone.get$worldX(), J.$mul$ns(attachment.x, bone.get$m00())), J.$mul$ns(attachment.y, bone.get$m01())));
        J.set$y$x(t2.get$position(slotContainer), J.$add$ns(J.$add$ns(bone.get$worldY(), J.$mul$ns(attachment.x, bone.get$m10())), J.$mul$ns(attachment.y, bone.get$m11())));
        J.set$x$x(t2.get$scale(slotContainer), bone.get$worldScaleX());
        J.set$y$x(t2.get$scale(slotContainer), bone.get$worldScaleY());
        slotContainer.set$rotation(J.$negate$n(J.$div$n(J.$mul$ns(slot.get$bone().get$worldRotation(), 3.141592653589793), 180)));
        t3 = J.getInterceptor$x(slot);
        t2.set$alpha(slotContainer, t3.get$a(slot));
        slot.get$currentSprite().set$tint(M.rgb2hex([t3.get$r(slot), slot.get$g(), slot.get$b()]));
      }
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
    }, "call$0", "get$updateTransform", 0, 0, 54, "updateTransform"],
    createSprite$2: [function(slot, descriptor) {
      var t1, $name, texture, t2, t3, t4, t5, t6, sprite;
      t1 = J.getInterceptor$x(descriptor);
      $name = J.$index$asx($.get$TextureCache(), t1.get$name(descriptor)) != null ? t1.get$name(descriptor) : H.S(t1.get$name(descriptor)) + ".png";
      texture = J.$index$asx($.get$TextureCache(), $name);
      if (texture == null)
        H.throwExpression(P.Exception_Exception("The frameId \"" + H.S($name) + "\" does not exist in the texture cache"));
      t2 = new M.Point0(null, null);
      t2.x = 0;
      t2.y = 0;
      t3 = new M.Point0(null, null);
      t3.x = 0;
      t3.y = 0;
      t4 = new M.Point0(null, null);
      t4.x = 1;
      t4.y = 1;
      t5 = new M.Point0(null, null);
      t5.x = 0;
      t5.y = 0;
      t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      sprite = new M.Sprite0(t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
      sprite.texture = texture;
      if (texture.get$baseTexture().get$hasLoaded() === true)
        sprite._onTextureUpdate$1(null);
      else
        J.addEventListener$2$x(texture, "update", sprite.get$_onTextureUpdate());
      t2 = J.$index$asx(t1.get$scale(descriptor), "x");
      t3 = J.$index$asx(t1.get$scale(descriptor), "y");
      t4 = new M.Point0(null, null);
      t4.x = t2;
      t4.y = t3;
      sprite.scale = t4;
      sprite.rotation = descriptor.get$rotation();
      t4 = sprite.anchor;
      t3 = J.getInterceptor$x(t4);
      t3.set$y(t4, 0.5);
      t3.set$x(t4, 0.5);
      if (slot.get$sprites() == null)
        slot.set$sprites(P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      J.$indexSet$ax(slot.get$sprites(), t1.get$name(descriptor), sprite);
      return sprite;
    }, "call$2", "get$createSprite", 4, 0, 819, 820, [], 821, [], "createSprite"],
    Spine$1: function(url) {
      var t1, n, t2, i, slot, attachment, t3, t4, t5, t6, t7, slotContainer, spriteName, sprite;
      t1 = J.$index$asx($.get$AnimCache(), url);
      this.skeletonData = t1;
      if (t1 == null)
        throw H.wrapException(P.Exception_Exception("Spine data must be preloaded using PIXI.SpineLoader or PIXI.AssetLoader: " + H.S(url)));
      t1 = M.Skeleton$(t1);
      this.skeleton = t1;
      t1.updateWorldTransform$0();
      t1 = new M.AnimationStateData(this.skeletonData, P.LinkedHashMap_LinkedHashMap$_empty(null, null), 0);
      this.stateData = t1;
      this.state = new M.AnimationState(t1, [], null, null, 0, 0, false, false, 0, 0, 1);
      this.slotContainers = [];
      n = J.get$length$asx(this.skeleton.get$drawOrder());
      if (typeof n !== "number")
        return H.iae(n);
      t1 = this.children;
      t2 = J.getInterceptor$asx(t1);
      i = 0;
      for (; i < n; ++i) {
        slot = J.$index$asx(this.skeleton.get$drawOrder(), i);
        attachment = slot.get$attachment();
        t3 = [];
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = new M.Point0(null, null);
        t5.x = 1;
        t5.y = 1;
        t6 = new M.Point0(null, null);
        t6.x = 0;
        t6.y = 0;
        t7 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        slotContainer = new M.DisplayObjectContainer(t3, false, 0, 0, t4, t5, t6, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t7, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        J.add$1$ax(this.slotContainers, slotContainer);
        this.addChildAt$2(slotContainer, t2.get$length(t1));
        if (!J.getInterceptor(attachment).$isRegionAttachment)
          continue;
        spriteName = J.get$name$x(attachment.rendererObject);
        sprite = this.createSprite$2(slot, attachment.rendererObject);
        slot.set$currentSprite(sprite);
        slot.set$currentSpriteName(spriteName);
        slotContainer.addChildAt$2(sprite, t3.length);
      }
    },
    static: {Spine$: [function(url) {
        var t1, t2, t3;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t3 = new M.Spine(null, null, null, null, [], null, [], false, 0, 0, t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t3.Spine$1(url);
        return t3;
      }, null, null, 2, 0, 91, 127, [], "new Spine"]}
  },
  "+Spine": [706],
  Strip: {
    "^": "DisplayObjectContainer;texture@-698,blendMode@-702,uvs@-672,verticies@-672,colors@-672,indices@-714,updateFrame@-617,_vertexBuffer@-715,_indexBuffer@-715,_uvBuffer@-715,_colorBuffer@-715,count@-614,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    onTextureUpdate$1: [function(e) {
      this.updateFrame = true;
    }, "call$1", "get$onTextureUpdate", 2, 0, 102, 356, [], "onTextureUpdate"],
    _renderWebGL$1: [function(renderSession) {
      var gl, t1, projection, offset, shader, t2, t3;
      if (this.visible !== true || J.$le$n(this.alpha, 0))
        return;
      J.stop$0$x(renderSession.get$spriteBatch());
      if (this._vertexBuffer == null) {
        gl = renderSession.get$gl();
        t1 = J.getInterceptor$x(gl);
        this._vertexBuffer = t1.createBuffer$0(gl);
        this._indexBuffer = t1.createBuffer$0(gl);
        this._uvBuffer = t1.createBuffer$0(gl);
        this._colorBuffer = t1.createBuffer$0(gl);
        t1.bindBuffer$2(gl, 34962, this._vertexBuffer);
        t1.bufferData$3(gl, 34962, this.verticies, 35048);
        t1.bindBuffer$2(gl, 34962, this._uvBuffer);
        t1.bufferData$3(gl, 34962, this.uvs, 35044);
        t1.bindBuffer$2(gl, 34962, this._colorBuffer);
        t1.bufferData$3(gl, 34962, this.colors, 35044);
        t1.bindBuffer$2(gl, 34963, this._indexBuffer);
        t1.bufferData$3(gl, 34963, this.indices, 35044);
      }
      renderSession.get$shaderManager().setShader$1(renderSession.get$shaderManager().get$stripShader());
      gl = renderSession.get$gl();
      projection = renderSession.get$projection();
      offset = J.get$offset$x(renderSession);
      shader = renderSession.get$shaderManager().get$stripShader();
      t1 = J.getInterceptor$x(gl);
      t1.blendFunc$2(gl, 1, 771);
      t1.uniformMatrix3fv$3(gl, shader.get$translationMatrix(), false, this._worldTransform.toArray$1(true));
      t2 = J.getInterceptor$x(projection);
      t1.uniform2f$3(gl, shader.get$projectionVector(), t2.get$x(projection), J.$negate$n(t2.get$y(projection)));
      t2 = J.getInterceptor$x(offset);
      t1.uniform2f$3(gl, shader.get$offsetVector(), J.$negate$n(t2.get$x(offset)), J.$negate$n(t2.get$y(offset)));
      t1.uniform1f$2(gl, J.get$alpha$x(shader), 1);
      if (this._dirty !== true) {
        t1.bindBuffer$2(gl, 34962, this._vertexBuffer);
        t1.bufferSubData$3(gl, 34962, 0, this.verticies);
        t1.vertexAttribPointer$6(gl, shader.get$aVertexPosition(), 2, 5126, false, 0, 0);
        t1.bindBuffer$2(gl, 34962, this._uvBuffer);
        t1.vertexAttribPointer$6(gl, shader.get$aTextureCoord(), 2, 5126, false, 0, 0);
        t1.activeTexture$1(gl, 33984);
        t2 = J.$index$asx(this.texture.get$baseTexture().get$_glTextures(), gl);
        t3 = this.texture;
        t1.bindTexture$2(gl, 3553, t2 == null ? M.createWebGLTexture(t3.get$baseTexture(), gl) : J.$index$asx(t3.get$baseTexture().get$_glTextures(), gl));
        t1.bindBuffer$2(gl, 34963, this._indexBuffer);
      } else {
        this._dirty = false;
        t1.bindBuffer$2(gl, 34962, this._vertexBuffer);
        t1.bufferData$3(gl, 34962, this.verticies, 35044);
        t1.vertexAttribPointer$6(gl, shader.get$aVertexPosition(), 2, 5126, false, 0, 0);
        t1.bindBuffer$2(gl, 34962, this._uvBuffer);
        t1.bufferData$3(gl, 34962, this.uvs, 35044);
        t1.vertexAttribPointer$6(gl, shader.get$aTextureCoord(), 2, 5126, false, 0, 0);
        t1.activeTexture$1(gl, 33984);
        t2 = J.$index$asx(this.texture.get$baseTexture().get$_glTextures(), gl);
        t3 = this.texture;
        t1.bindTexture$2(gl, 3553, t2 == null ? M.createWebGLTexture(t3.get$baseTexture(), gl) : J.$index$asx(t3.get$baseTexture().get$_glTextures(), gl));
        t1.bindBuffer$2(gl, 34963, this._indexBuffer);
        t1.bufferData$3(gl, 34963, this.indices, 35044);
      }
      t1.drawElements$4(gl, 5, J.get$length$asx(this.indices), 5123, 0);
      J.start$0$x(renderSession.get$spriteBatch());
    }, "call$1", "get$_renderWebGL", 2, 0, 684, 166, [], "_renderWebGL"],
    _initWebGL$1: [function(renderSession) {
      var gl, t1;
      gl = renderSession.get$gl();
      t1 = J.getInterceptor$x(gl);
      this._vertexBuffer = t1.createBuffer$0(gl);
      this._indexBuffer = t1.createBuffer$0(gl);
      this._uvBuffer = t1.createBuffer$0(gl);
      this._colorBuffer = t1.createBuffer$0(gl);
      t1.bindBuffer$2(gl, 34962, this._vertexBuffer);
      t1.bufferData$3(gl, 34962, this.verticies, 35048);
      t1.bindBuffer$2(gl, 34962, this._uvBuffer);
      t1.bufferData$3(gl, 34962, this.uvs, 35044);
      t1.bindBuffer$2(gl, 34962, this._colorBuffer);
      t1.bufferData$3(gl, 34962, this.colors, 35044);
      t1.bindBuffer$2(gl, 34963, this._indexBuffer);
      t1.bufferData$3(gl, 34963, this.indices, 35044);
    }, "call$1", "get$_initWebGL", 2, 0, 684, 166, [], "_initWebGL"],
    _renderStrip$1: [function(renderSession) {
      var gl, projection, offset, shader, t1, t2, t3;
      gl = renderSession.get$gl();
      projection = renderSession.get$projection();
      offset = J.get$offset$x(renderSession);
      shader = renderSession.get$shaderManager().get$stripShader();
      t1 = J.getInterceptor$x(gl);
      t1.blendFunc$2(gl, 1, 771);
      t1.uniformMatrix3fv$3(gl, shader.get$translationMatrix(), false, this._worldTransform.toArray$1(true));
      t2 = J.getInterceptor$x(projection);
      t1.uniform2f$3(gl, shader.get$projectionVector(), t2.get$x(projection), J.$negate$n(t2.get$y(projection)));
      t2 = J.getInterceptor$x(offset);
      t1.uniform2f$3(gl, shader.get$offsetVector(), J.$negate$n(t2.get$x(offset)), J.$negate$n(t2.get$y(offset)));
      t1.uniform1f$2(gl, J.get$alpha$x(shader), 1);
      if (this._dirty !== true) {
        t1.bindBuffer$2(gl, 34962, this._vertexBuffer);
        t1.bufferSubData$3(gl, 34962, 0, this.verticies);
        t1.vertexAttribPointer$6(gl, shader.get$aVertexPosition(), 2, 5126, false, 0, 0);
        t1.bindBuffer$2(gl, 34962, this._uvBuffer);
        t1.vertexAttribPointer$6(gl, shader.get$aTextureCoord(), 2, 5126, false, 0, 0);
        t1.activeTexture$1(gl, 33984);
        t2 = J.$index$asx(this.texture.get$baseTexture().get$_glTextures(), gl);
        t3 = this.texture;
        t1.bindTexture$2(gl, 3553, t2 == null ? M.createWebGLTexture(t3.get$baseTexture(), gl) : J.$index$asx(t3.get$baseTexture().get$_glTextures(), gl));
        t1.bindBuffer$2(gl, 34963, this._indexBuffer);
      } else {
        this._dirty = false;
        t1.bindBuffer$2(gl, 34962, this._vertexBuffer);
        t1.bufferData$3(gl, 34962, this.verticies, 35044);
        t1.vertexAttribPointer$6(gl, shader.get$aVertexPosition(), 2, 5126, false, 0, 0);
        t1.bindBuffer$2(gl, 34962, this._uvBuffer);
        t1.bufferData$3(gl, 34962, this.uvs, 35044);
        t1.vertexAttribPointer$6(gl, shader.get$aTextureCoord(), 2, 5126, false, 0, 0);
        t1.activeTexture$1(gl, 33984);
        t2 = J.$index$asx(this.texture.get$baseTexture().get$_glTextures(), gl);
        t3 = this.texture;
        t1.bindTexture$2(gl, 3553, t2 == null ? M.createWebGLTexture(t3.get$baseTexture(), gl) : J.$index$asx(t3.get$baseTexture().get$_glTextures(), gl));
        t1.bindBuffer$2(gl, 34963, this._indexBuffer);
        t1.bufferData$3(gl, 34963, this.indices, 35044);
      }
      t1.drawElements$4(gl, 5, J.get$length$asx(this.indices), 5123, 0);
    }, "call$1", "get$_renderStrip", 2, 0, 684, 166, [], "_renderStrip"],
    _renderCanvas$1: [function(renderSession) {
      var context, transform, t1, t2, verticies, uvs, $length, t3, t4, i, t5, index, x0, x1, t6, x2, t7, y0, t8, y1, t9, y2, t10, centerX, t11, centerY, normX, normY, t12, dist, t13, t14, u0, u1, u2, v0, v1, v2, delta, deltaA, deltaB, deltaC, deltaD, deltaE, deltaF;
      context = J.get$context$x(renderSession);
      transform = this._worldTransform;
      t1 = J.getInterceptor$x(context);
      t2 = J.getInterceptor$x(transform);
      if (renderSession.get$roundPixels() === true)
        t1.setTransform$6(context, t2.get$a(transform), transform.get$c(), transform.get$b(), transform.get$d(), J.floor$0$n(transform.get$tx()), J.floor$0$n(transform.get$ty()));
      else
        t1.setTransform$6(context, t2.get$a(transform), transform.get$c(), transform.get$b(), transform.get$d(), transform.get$tx(), transform.get$ty());
      verticies = this.verticies;
      uvs = this.uvs;
      t1 = J.getInterceptor$asx(verticies);
      $length = J.$div$n(t1.get$length(verticies), 2);
      this.set$count(J.$add$ns(this.get$count(), 1));
      t2 = J.getInterceptor$n($length);
      t3 = J.getInterceptor$asx(uvs);
      t4 = J.getInterceptor$x(context);
      i = 0;
      while (true) {
        t5 = t2.$sub($length, 2);
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (!(i < t5))
          break;
        index = i * 2;
        x0 = t1.$index(verticies, index);
        t5 = index + 2;
        x1 = t1.$index(verticies, t5);
        t6 = index + 4;
        x2 = t1.$index(verticies, t6);
        t7 = index + 1;
        y0 = t1.$index(verticies, t7);
        t8 = index + 3;
        y1 = t1.$index(verticies, t8);
        t9 = index + 5;
        y2 = t1.$index(verticies, t9);
        t10 = J.getInterceptor$ns(x0);
        centerX = J.$div$n(J.$add$ns(t10.$add(x0, x1), x2), 3);
        t11 = J.getInterceptor$ns(y0);
        centerY = J.$div$n(J.$add$ns(t11.$add(y0, y1), y2), 3);
        normX = t10.$sub(x0, centerX);
        normY = t11.$sub(y0, centerY);
        t11 = J.getInterceptor$ns(normX);
        t10 = J.getInterceptor$ns(normY);
        t12 = J.$add$ns(t11.$mul(normX, normX), t10.$mul(normY, normY));
        if (typeof t12 !== "number")
          H.throwExpression(P.ArgumentError$(t12));
        dist = Math.sqrt(t12);
        t12 = dist + 3;
        t13 = J.getInterceptor$ns(centerX);
        x0 = t13.$add(centerX, J.$mul$ns(t11.$div(normX, dist), t12));
        t11 = J.getInterceptor$ns(centerY);
        y0 = t11.$add(centerY, J.$mul$ns(t10.$div(normY, dist), t12));
        normX = J.$sub$n(x1, centerX);
        normY = J.$sub$n(y1, centerY);
        t12 = J.getInterceptor$ns(normX);
        t10 = J.getInterceptor$ns(normY);
        t14 = J.$add$ns(t12.$mul(normX, normX), t10.$mul(normY, normY));
        if (typeof t14 !== "number")
          H.throwExpression(P.ArgumentError$(t14));
        dist = Math.sqrt(t14);
        t14 = dist + 3;
        x1 = t13.$add(centerX, J.$mul$ns(t12.$div(normX, dist), t14));
        y1 = t11.$add(centerY, J.$mul$ns(t10.$div(normY, dist), t14));
        normX = J.$sub$n(x2, centerX);
        normY = J.$sub$n(y2, centerY);
        t14 = J.getInterceptor$ns(normX);
        t10 = J.getInterceptor$ns(normY);
        t12 = J.$add$ns(t14.$mul(normX, normX), t10.$mul(normY, normY));
        if (typeof t12 !== "number")
          H.throwExpression(P.ArgumentError$(t12));
        dist = Math.sqrt(t12);
        t12 = dist + 3;
        x2 = t13.$add(centerX, J.$mul$ns(t14.$div(normX, dist), t12));
        y2 = t11.$add(centerY, J.$mul$ns(t10.$div(normY, dist), t12));
        u0 = J.$mul$ns(t3.$index(uvs, index), J.get$width$x(this.texture));
        u1 = J.$mul$ns(t3.$index(uvs, t5), J.get$width$x(this.texture));
        u2 = J.$mul$ns(t3.$index(uvs, t6), J.get$width$x(this.texture));
        v0 = J.$mul$ns(t3.$index(uvs, t7), J.get$height$x(this.texture));
        v1 = J.$mul$ns(t3.$index(uvs, t8), J.get$height$x(this.texture));
        v2 = J.$mul$ns(t3.$index(uvs, t9), J.get$height$x(this.texture));
        t4.save$0(context);
        t4.beginPath$0(context);
        t4.moveTo$2(context, x0, y0);
        t4.lineTo$2(context, x1, y1);
        t4.lineTo$2(context, x2, y2);
        t4.closePath$0(context);
        t4.clip$0(context);
        t5 = J.getInterceptor$ns(u0);
        t6 = J.getInterceptor$ns(v0);
        t7 = J.getInterceptor$ns(u1);
        t8 = J.getInterceptor$ns(v1);
        delta = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t5.$mul(u0, v1), t6.$mul(v0, u2)), t7.$mul(u1, v2)), t8.$mul(v1, u2)), t6.$mul(v0, u1)), t5.$mul(u0, v2));
        t9 = J.getInterceptor$ns(x0);
        t10 = J.getInterceptor$ns(x1);
        deltaA = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t9.$mul(x0, v1), t6.$mul(v0, x2)), t10.$mul(x1, v2)), t8.$mul(v1, x2)), t6.$mul(v0, x1)), t9.$mul(x0, v2));
        deltaB = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t5.$mul(u0, x1), t9.$mul(x0, u2)), t7.$mul(u1, x2)), t10.$mul(x1, u2)), t9.$mul(x0, u1)), t5.$mul(u0, x2));
        deltaC = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(t5.$mul(u0, v1), x2), J.$mul$ns(t6.$mul(v0, x1), u2)), J.$mul$ns(t9.$mul(x0, u1), v2)), J.$mul$ns(t9.$mul(x0, v1), u2)), J.$mul$ns(t6.$mul(v0, u1), x2)), J.$mul$ns(t5.$mul(u0, x1), v2));
        t9 = J.getInterceptor$ns(y0);
        t10 = J.getInterceptor$ns(y1);
        deltaD = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t9.$mul(y0, v1), t6.$mul(v0, y2)), t10.$mul(y1, v2)), t8.$mul(v1, y2)), t6.$mul(v0, y1)), t9.$mul(y0, v2));
        deltaE = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t5.$mul(u0, y1), t9.$mul(y0, u2)), t7.$mul(u1, y2)), t10.$mul(y1, u2)), t9.$mul(y0, u1)), t5.$mul(u0, y2));
        deltaF = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(t5.$mul(u0, v1), y2), J.$mul$ns(t6.$mul(v0, y1), u2)), J.$mul$ns(t9.$mul(y0, u1), v2)), J.$mul$ns(t9.$mul(y0, v1), u2)), J.$mul$ns(t6.$mul(v0, u1), y2)), J.$mul$ns(t5.$mul(u0, y1), v2));
        t4.transform$6(context, J.$div$n(deltaA, delta), J.$div$n(deltaD, delta), J.$div$n(deltaB, delta), J.$div$n(deltaE, delta), J.$div$n(deltaC, delta), J.$div$n(deltaF, delta));
        t4.drawImage$3(context, J.get$source$x(this.texture.get$baseTexture()), 0, 0);
        t4.restore$0(context);
        ++i;
      }
    }, "call$1", "get$_renderCanvas", 2, 0, 684, 166, [], "_renderCanvas"],
    Strip$1: function(texture) {
      this.texture = texture;
      this.uvs = new Float32Array(H._ensureNativeList([0, 1, 1, 1, 1, 0, 0, 1]));
      this.verticies = new Float32Array(H._ensureNativeList([0, 0, 100, 0, 100, 100, 0, 100]));
      this.colors = new Float32Array(H._ensureNativeList([1, 1, 1, 1]));
      this.indices = new Uint16Array(H._ensureNativeList([0, 1, 2, 3]));
      this._dirty = true;
    },
    static: {Strip$: [function(texture) {
        var t1, t2, t3;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t3 = new M.Strip(null, C.BlendModes_0, null, null, null, null, false, null, null, null, null, 0, [], false, 0, 0, t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t3.Strip$1(texture);
        return t3;
      }, null, null, 2, 0, 67, 68, [], "new Strip"]}
  },
  "+Strip": [706],
  TilingSprite: {
    "^": "Sprite0;_PIXI$_width:PIXI$TilingSprite$_PIXI$_width@-616,_PIXI$_height:PIXI$TilingSprite$_PIXI$_height@-616,tileScale@-652,tilePosition@-652,_PIXI$__tilePattern@-822,tilingTexture@-698,refreshTexture@-617,tileScaleOffset@-652,anchor-652,texture-698,updateFrame-617,PIXI$Sprite0$_PIXI$_width-616,PIXI$Sprite0$_PIXI$_height-616,_uvs-699,tintedTexture-700,buffer-701,tint-614,cachedTint-614,blendMode-702,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    get$width: [function(_) {
      return this.PIXI$TilingSprite$_PIXI$_width;
    }, null, null, 1, 0, 619, "width"],
    set$width: [function(_, value) {
      this.PIXI$TilingSprite$_PIXI$_width = value;
    }, null, null, 3, 0, 102, 138, [], "width"],
    get$height: [function(_) {
      return this.PIXI$TilingSprite$_PIXI$_height;
    }, null, null, 1, 0, 619, "height"],
    set$height: [function(_, value) {
      this.PIXI$TilingSprite$_PIXI$_height = value;
    }, null, null, 3, 0, 102, 138, [], "height"],
    setTexture$1: [function(texture) {
      if (J.$eq(this.texture, texture))
        return;
      this.texture = texture;
      this.refreshTexture = true;
      this.cachedTint = 16777215;
    }, "call$1", "get$setTexture", 2, 0, 67, 68, [], "setTexture"],
    _renderWebGL$1: [function(renderSession) {
      var t1, j, i;
      if (J.$eq(this.visible, false) || J.$eq(this.alpha, 0))
        return;
      if (this._mask != null) {
        J.stop$0$x(renderSession.get$spriteBatch());
        renderSession.get$maskManager().pushMask$2(this._mask, renderSession);
        J.start$0$x(renderSession.get$spriteBatch());
      }
      if (this._filters != null) {
        J.flush$0$x(renderSession.get$spriteBatch());
        renderSession.get$filterManager().pushFilter$1(this._filterBlock);
      }
      if (this.tilingTexture == null || this.refreshTexture === true) {
        this.generateTilingTexture$1(true);
        t1 = this.tilingTexture;
        if (t1 != null && t1.get$needsUpdate() === true) {
          M.updateWebGLTexture(this.tilingTexture.get$baseTexture(), renderSession.get$gl());
          this.tilingTexture.set$needsUpdate(false);
        }
      } else
        renderSession.get$spriteBatch().renderTilingSprite$1(this);
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._renderWebGL$1(renderSession);
      J.stop$0$x(renderSession.get$spriteBatch());
      if (this._filters != null)
        renderSession.get$filterManager().popFilter$0();
      if (this._mask != null)
        renderSession.get$maskManager().popMask$2(this._mask, renderSession);
      J.start$0$x(renderSession.get$spriteBatch());
    }, "call$1", "get$_renderWebGL", 2, 0, 684, 166, [], "_renderWebGL"],
    _renderCanvas$1: [function(renderSession) {
      var t1, context, t2, transform, t3, tilePosition, tileScale, t4, t5, j, i;
      if (J.$eq(this.visible, false) || J.$eq(this.alpha, 0))
        return;
      t1 = J.getInterceptor$x(renderSession);
      context = t1.get$context(renderSession);
      if (this._mask != null)
        renderSession.get$maskManager().pushMask$2(this._mask, context);
      t2 = J.getInterceptor$x(context);
      t2.set$globalAlpha(context, this._worldAlpha);
      transform = this._worldTransform;
      t2.setTransform$6(context, J.get$a$x(transform), transform.get$c(), transform.get$b(), transform.get$d(), transform.get$tx(), transform.get$ty());
      if (this._PIXI$__tilePattern == null || this.refreshTexture === true) {
        this.generateTilingTexture$1(false);
        t3 = this.tilingTexture;
        if (t3 != null) {
          t3 = J.getInterceptor(J.get$source$x(t3.get$baseTexture()));
          if (!!t3.$isCanvasElement)
            this._PIXI$__tilePattern = t2.createPattern$2(context, H.interceptedTypeCast(J.get$source$x(this.tilingTexture.get$baseTexture()), "$isCanvasElement"), "repeat");
          else if (!!t3.$isImageElement)
            this._PIXI$__tilePattern = t2.createPatternFromImage$2(context, J.get$source$x(this.tilingTexture.get$baseTexture()), "repeat");
          else
            throw H.wrapException(P.Exception_Exception("null source"));
        } else
          return;
      }
      if (!J.$eq(this.blendMode, renderSession.get$currentBlendMode())) {
        renderSession.set$currentBlendMode(this.blendMode);
        t2.set$globalCompositeOperation(context, J.$index$asx($.blendModesCanvas, renderSession.get$currentBlendMode()));
      }
      t2.beginPath$0(context);
      tilePosition = this.tilePosition;
      tileScale = this.tileScale;
      t3 = J.getInterceptor$x(tilePosition);
      t3.set$x(tilePosition, J.$mod$n(t3.get$x(tilePosition), J.get$width$x(this.tilingTexture.get$baseTexture())));
      t3.set$y(tilePosition, J.$mod$n(t3.get$y(tilePosition), J.get$height$x(this.tilingTexture.get$baseTexture())));
      t4 = J.getInterceptor$x(tileScale);
      t2.scale$2(context, t4.get$x(tileScale), t4.get$y(tileScale));
      t2.translate$2(context, t3.get$x(tilePosition), t3.get$y(tilePosition));
      t2.set$fillStyle(context, this._PIXI$__tilePattern);
      t2.fillRect$4(context, J.$add$ns(J.$negate$n(t3.get$x(tilePosition)), J.$mul$ns(J.get$x$x(this.anchor), J.$negate$n(this.PIXI$TilingSprite$_PIXI$_width))), J.$add$ns(J.$negate$n(t3.get$y(tilePosition)), J.$mul$ns(J.get$y$x(this.anchor), J.$negate$n(this.PIXI$TilingSprite$_PIXI$_height))), J.$div$n(this.PIXI$TilingSprite$_PIXI$_width, t4.get$x(tileScale)), J.$div$n(this.PIXI$TilingSprite$_PIXI$_height, t4.get$y(tileScale)));
      t5 = t4.get$x(tileScale);
      if (typeof t5 !== "number")
        return H.iae(t5);
      t4 = t4.get$y(tileScale);
      if (typeof t4 !== "number")
        return H.iae(t4);
      t2.scale$2(context, 1 / t5, 1 / t4);
      t2.translate$2(context, J.$negate$n(t3.get$x(tilePosition)), J.$negate$n(t3.get$y(tilePosition)));
      t2.closePath$0(context);
      if (this._mask != null)
        renderSession.get$maskManager().popMask$1(t1.get$context(renderSession));
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._renderCanvas$1(renderSession);
    }, "call$1", "get$_renderCanvas", 2, 0, 684, 166, [], "_renderCanvas"],
    getBounds$1: [function(matrix) {
      var width, height, t1, t2, w0, w1, h0, h1, worldTransform, a, b, c, d, tx, ty, x1, t3, t4, y1, x2, y2, x3, y3, x4, y4, minX, t5, minY, t6, t7, t8, maxX, maxY, bounds;
      width = this.PIXI$TilingSprite$_PIXI$_width;
      height = this.PIXI$TilingSprite$_PIXI$_height;
      t1 = J.get$x$x(this.anchor);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = J.getInterceptor$ns(width);
      w0 = t2.$mul(width, 1 - t1);
      w1 = t2.$mul(width, J.$negate$n(J.get$x$x(this.anchor)));
      t2 = J.get$y$x(this.anchor);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t1 = J.getInterceptor$ns(height);
      h0 = t1.$mul(height, 1 - t2);
      h1 = t1.$mul(height, J.$negate$n(J.get$y$x(this.anchor)));
      worldTransform = this._worldTransform;
      t1 = J.getInterceptor$asx(worldTransform);
      a = t1.$index(worldTransform, 0);
      b = t1.$index(worldTransform, 3);
      c = t1.$index(worldTransform, 1);
      d = t1.$index(worldTransform, 4);
      tx = t1.$index(worldTransform, 2);
      ty = t1.$index(worldTransform, 5);
      t1 = J.getInterceptor$ns(a);
      t2 = J.getInterceptor$ns(c);
      x1 = J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h1)), tx);
      t3 = J.getInterceptor$ns(d);
      t4 = J.getInterceptor$ns(b);
      y1 = J.$add$ns(J.$add$ns(t3.$mul(d, h1), t4.$mul(b, w1)), ty);
      x2 = J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h1)), tx);
      y2 = J.$add$ns(J.$add$ns(t3.$mul(d, h1), t4.$mul(b, w0)), ty);
      x3 = J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h0)), tx);
      y3 = J.$add$ns(J.$add$ns(t3.$mul(d, h0), t4.$mul(b, w0)), ty);
      x4 = J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h0)), tx);
      y4 = J.$add$ns(J.$add$ns(t3.$mul(d, h0), t4.$mul(b, w1)), ty);
      t1 = J.getInterceptor$n(x1);
      minX = t1.$lt(x1, 1 / 0) ? x1 : 1 / 0;
      t2 = J.getInterceptor$n(x2);
      if (t2.$lt(x2, minX))
        minX = x2;
      t3 = J.getInterceptor$n(x3);
      if (t3.$lt(x3, minX))
        minX = x3;
      t4 = J.getInterceptor$n(x4);
      if (t4.$lt(x4, minX))
        minX = x4;
      t5 = J.getInterceptor$n(y1);
      minY = t5.$lt(y1, 1 / 0) ? y1 : 1 / 0;
      t6 = J.getInterceptor$n(y2);
      if (t6.$lt(y2, minY))
        minY = y2;
      t7 = J.getInterceptor$n(y3);
      if (t7.$lt(y3, minY))
        minY = y3;
      t8 = J.getInterceptor$n(y4);
      if (t8.$lt(y4, minY))
        minY = y4;
      maxX = t1.$gt(x1, -1 / 0) ? x1 : -1 / 0;
      if (t2.$gt(x2, maxX))
        maxX = x2;
      if (t3.$gt(x3, maxX))
        maxX = x3;
      if (t4.$gt(x4, maxX))
        maxX = x4;
      maxY = t5.$gt(y1, -1 / 0) ? y1 : -1 / 0;
      if (t6.$gt(y2, maxY))
        maxY = y2;
      if (t7.$gt(y3, maxY))
        maxY = y3;
      if (t8.$gt(y4, maxY))
        maxY = y4;
      bounds = this._bounds;
      t1 = J.getInterceptor$x(bounds);
      t1.set$x(bounds, minX);
      t1.set$width(bounds, J.$sub$n(maxX, minX));
      t1.set$y(bounds, minY);
      t1.set$height(bounds, J.$sub$n(maxY, minY));
      this._currentBounds = bounds;
      return bounds;
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 682, 12, 580, [], "getBounds"],
    generateTilingTexture$1: [function(forcePowerOfTwo) {
      var texture, frame, t1, isFrame, t2, targetWidth, targetHeight, canvasBuffer;
      texture = this.texture;
      if (texture.get$baseTexture().get$hasLoaded() !== true)
        return;
      frame = texture.get$frame();
      t1 = J.getInterceptor$x(frame);
      isFrame = !J.$eq(t1.get$width(frame), J.get$width$x(texture.get$baseTexture())) || !J.$eq(t1.get$height(frame), J.get$height$x(texture.get$baseTexture()));
      t2 = forcePowerOfTwo !== true;
      if (t2)
        if (isFrame) {
          targetWidth = t1.get$width(frame);
          targetHeight = t1.get$height(frame);
        } else {
          targetWidth = null;
          targetHeight = null;
        }
      else {
        targetWidth = M.getNextPowerOfTwo(t1.get$width(frame));
        targetHeight = M.getNextPowerOfTwo(t1.get$height(frame));
        if (!J.$eq(t1.get$width(frame), targetWidth) || !J.$eq(t1.get$height(frame), targetHeight))
          ;
      }
      if (!t2 || isFrame) {
        t2 = this.tilingTexture;
        if (t2 != null && t2.get$isTiling() === true) {
          canvasBuffer = this.tilingTexture.get$canvasBuffer();
          J.resize$2$x(canvasBuffer, targetWidth, targetHeight);
          J.set$width$x(this.tilingTexture.get$baseTexture(), targetWidth);
          J.set$height$x(this.tilingTexture.get$baseTexture(), targetHeight);
          this.tilingTexture.set$needsUpdate(true);
        } else {
          canvasBuffer = M.CanvasBuffer$(targetWidth, targetHeight);
          t2 = M.Texture$(M.BaseTexture_fromCanvas(canvasBuffer.canvas, null), null);
          this.tilingTexture = t2;
          t2.canvasBuffer = canvasBuffer;
          this.tilingTexture.set$isTiling(true);
        }
        J.drawImageScaledFromSource$9$x(J.get$context$x(canvasBuffer), J.get$source$x(texture.get$baseTexture()), J.get$x$x(texture.get$crop()), J.get$y$x(texture.get$crop()), J.get$width$x(texture.get$crop()), J.get$height$x(texture.get$crop()), 0, 0, targetWidth, targetHeight);
        J.set$x$x(this.tileScaleOffset, J.$div$n(t1.get$width(frame), targetWidth));
        J.set$y$x(this.tileScaleOffset, J.$div$n(t1.get$height(frame), targetHeight));
      } else {
        t1 = this.tilingTexture;
        if (t1 != null && t1.get$isTiling() === true)
          this.tilingTexture.destroy$1(true);
        J.set$x$x(this.tileScaleOffset, 1);
        J.set$y$x(this.tileScaleOffset, 1);
        this.tilingTexture = texture;
      }
      this.refreshTexture = false;
      this.tilingTexture.get$baseTexture().set$_powerOf2(true);
    }, "call$1", "get$generateTilingTexture", 2, 0, 639, 823, [], "generateTilingTexture"],
    _onTextureUpdate$1: [function(e) {
    }, "call$1", "get$_onTextureUpdate", 2, 0, 705, 356, [], "_onTextureUpdate"],
    TilingSprite$3: function(texture, width, height) {
      var t1;
      this.PIXI$TilingSprite$_PIXI$_width = width;
      this.PIXI$TilingSprite$_PIXI$_height = height;
      texture.get$baseTexture().set$_powerOf2(true);
      t1 = new M.Point0(null, null);
      t1.x = 1;
      t1.y = 1;
      this.tileScale = t1;
      t1 = new M.Point0(null, null);
      t1.x = 0;
      t1.y = 0;
      this.tilePosition = t1;
      this.renderable = true;
      this.tint = 16777215;
      this.blendMode = C.BlendModes_0;
    },
    static: {TilingSprite$: [function(texture, width, height) {
        var t1, t2, t3, t4, t5;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = new M.TilingSprite(null, null, null, null, null, null, false, t1, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t5.texture = texture;
        t5._setupTexture$0();
        t5.TilingSprite$3(texture, width, height);
        return t5;
      }, null, null, 2, 4, 128, 129, 129, 68, [], 31, [], 52, [], "new TilingSprite"]}
  },
  "+TilingSprite": [661],
  AbstractFilter: {
    "^": "Object;passes@-663,shaders@-783,dirty@-617,padding*-614,uniforms@-783,fragmentSrc@-645",
    static: {AbstractFilter$: [function() {
        var t1 = new M.AbstractFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        return t1;
      }, null, null, 0, 0, 54, "new AbstractFilter"]}
  },
  "+AbstractFilter": [674],
  AlphaMaskFilter: {
    "^": "AbstractFilter;texture@-698,passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    onTextureLoaded$1: [function(e) {
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "x", J.get$width$x(J.$index$asx(J.$index$asx(this.uniforms, "mask"), "value")));
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "y", J.get$height$x(J.$index$asx(J.$index$asx(this.uniforms, "mask"), "value")));
      H.interceptedTypeCast(J.$index$asx(J.$index$asx(this.uniforms, "mask"), "value").get$baseTexture(), "$isBaseTexture").removeEventListener$2(0, "loaded", this.get$onTextureLoaded());
    }, "call$1", "get$onTextureLoaded", 2, 0, 102, 356, [], "onTextureLoaded"],
    get$map: [function(_) {
      return J.$index$asx(J.$index$asx(this.uniforms, "mask"), "value");
    }, null, null, 1, 0, 824, "map"],
    map$1: function($receiver, arg0) {
      return this.get$map(this).call$1(arg0);
    },
    set$map: [function(_, value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "mask"), "value", value);
    }, null, null, 3, 0, 67, 138, [], "map"],
    AlphaMaskFilter$1: function(texture) {
      this.texture.get$baseTexture().set$_powerOf2(true);
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["mask", P.LinkedHashMap_LinkedHashMap$_literal(["type", "sampler2D", "value", this.texture], null, null), "mapDimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 1, "y", 5112], null, null)], null, null), "dimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "4fv", "value", [0, 0, 0, 0]], null, null)], null, null);
      if (this.texture.get$baseTexture().get$hasLoaded() === true) {
        J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mask"), "value"), "x", J.get$width$x(this.texture));
        J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mask"), "value"), "y", J.get$height$x(this.texture));
      } else
        J.addEventListener$2$x(this.texture.get$baseTexture(), "loaded", this.get$onTextureLoaded());
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D mask;", "uniform sampler2D uSampler;", "uniform vec2 offset;", "uniform vec4 dimensions;", "uniform vec2 mapDimensions;", "void main(void) {", "   vec2 mapCords = vTextureCoord.xy;", "   mapCords += (dimensions.zw + offset)/ dimensions.xy ;", "   mapCords.y *= -1.0;", "   mapCords.y += 1.0;", "   mapCords *= dimensions.xy / mapDimensions;", "   vec4 original =  texture2D(uSampler, vTextureCoord);", "   float maskAlpha =  texture2D(mask, mapCords).r;", "   original *= maskAlpha;", "   gl_FragColor =  original;", "}"];
    },
    static: {AlphaMaskFilter$: [function(texture) {
        var t1 = new M.AlphaMaskFilter(texture, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.AlphaMaskFilter$1(texture);
        return t1;
      }, null, null, 2, 0, 67, 68, [], "new AlphaMaskFilter"]}
  },
  "+AlphaMaskFilter": [825],
  BlurFilter: {
    "^": "AbstractFilter;blurXFilter@-826,blurYFilter@-827,passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    get$blur: [function(_) {
      return J.get$blur$x(this.blurXFilter);
    }, null, null, 1, 0, 619, "blur"],
    set$blur: [function(_, value) {
      var t1 = this.blurXFilter;
      J.set$blur$x(this.blurYFilter, value);
      J.set$blur$x(t1, value);
    }, null, null, 3, 0, 620, 138, [], "blur"],
    get$blurX: [function() {
      return J.get$blur$x(this.blurXFilter);
    }, null, null, 1, 0, 619, "blurX"],
    set$blurX: [function(value) {
      J.set$blur$x(this.blurXFilter, value);
    }, null, null, 3, 0, 620, 138, [], "blurX"],
    get$blurY: [function() {
      return J.get$blur$x(this.blurYFilter);
    }, null, null, 1, 0, 619, "blurY"],
    set$blurY: [function(value) {
      J.set$blur$x(this.blurYFilter, value);
    }, null, null, 3, 0, 620, 138, [], "blurY"],
    BlurFilter$0: function() {
      var t1 = new M.BlurXFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
      t1.passes = [t1];
      t1.BlurXFilter$0();
      this.blurXFilter = t1;
      t1 = new M.BlurYFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
      t1.passes = [t1];
      t1.BlurYFilter$0();
      this.blurYFilter = t1;
      this.passes = [this.blurXFilter, t1];
    },
    static: {BlurFilter$: [function() {
        var t1 = new M.BlurFilter(null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.BlurFilter$0();
        return t1;
      }, null, null, 0, 0, 54, "new BlurFilter"]}
  },
  "+BlurFilter": [825],
  BlurXFilter: {
    "^": "AbstractFilter;passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    get$blur: [function(_) {
      return J.$div$n(J.$index$asx(J.$index$asx(this.uniforms, "blur"), "value"), 0.00014285714285714287);
    }, null, null, 1, 0, 619, "blur"],
    set$blur: [function(_, value) {
      var t1;
      this.dirty = true;
      t1 = J.$index$asx(this.uniforms, "blur");
      if (typeof value !== "number")
        return H.iae(value);
      J.$indexSet$ax(t1, "value", 0.00014285714285714287 * value);
    }, null, null, 3, 0, 102, 138, [], "blur"],
    BlurXFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["blur", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 0.001953125], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float blur;", "uniform sampler2D uSampler;", "void main(void) {", "   vec4 sum = vec4(0.0);", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - 4.0*blur, vTextureCoord.y)) * 0.05;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - 3.0*blur, vTextureCoord.y)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - 2.0*blur, vTextureCoord.y)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - blur, vTextureCoord.y)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + blur, vTextureCoord.y)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + 2.0*blur, vTextureCoord.y)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + 3.0*blur, vTextureCoord.y)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + 4.0*blur, vTextureCoord.y)) * 0.05;", "   gl_FragColor = sum;", "}"];
    },
    static: {BlurXFilter$: [function() {
        var t1 = new M.BlurXFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.BlurXFilter$0();
        return t1;
      }, null, null, 0, 0, 54, "new BlurXFilter"]}
  },
  "+BlurXFilter": [825],
  BlurYFilter: {
    "^": "AbstractFilter;passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    get$blur: [function(_) {
      return J.$div$n(J.$index$asx(J.$index$asx(this.uniforms, "blur"), "value"), 0.00014285714285714287);
    }, null, null, 1, 0, 619, "blur"],
    set$blur: [function(_, value) {
      var t1;
      this.dirty = true;
      t1 = J.$index$asx(this.uniforms, "blur");
      if (typeof value !== "number")
        return H.iae(value);
      J.$indexSet$ax(t1, "value", 0.00014285714285714287 * value);
    }, null, null, 3, 0, 102, 138, [], "blur"],
    BlurYFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["blur", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 0.001953125], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float blur;", "uniform sampler2D uSampler;", "void main(void) {", "   vec4 sum = vec4(0.0);", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 4.0*blur)) * 0.05;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 3.0*blur)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 2.0*blur)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - blur)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + blur)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 2.0*blur)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 3.0*blur)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 4.0*blur)) * 0.05;", "   gl_FragColor = sum;", "}"];
    },
    static: {BlurYFilter$: [function() {
        var t1 = new M.BlurYFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.BlurYFilter$0();
        return t1;
      }, null, null, 0, 0, 54, "new BlurYFilter"]}
  },
  "+BlurYFilter": [825],
  ColorMatrixFilter: {
    "^": "AbstractFilter;passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    get$matrix: [function() {
      return J.$index$asx(J.$index$asx(this.uniforms, "matrix"), "value");
    }, null, null, 1, 0, 828, "matrix"],
    set$matrix: [function(value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "matrix"), "value", value);
    }, null, null, 3, 0, 102, 138, [], "matrix"],
    ColorMatrixFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["matrix", P.LinkedHashMap_LinkedHashMap$_literal(["type", "mat4", "value", [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float invert;", "uniform mat4 matrix;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * matrix;", "}"];
    },
    static: {ColorMatrixFilter$: [function() {
        var t1 = new M.ColorMatrixFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.ColorMatrixFilter$0();
        return t1;
      }, null, null, 0, 0, 54, "new ColorMatrixFilter"]}
  },
  "+ColorMatrixFilter": [825],
  ColorStepFilter: {
    "^": "AbstractFilter;passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    get$step: [function(_) {
      return J.$index$asx(J.$index$asx(this.uniforms, "step"), "value");
    }, null, null, 1, 0, 619, "step"],
    step$0: function($receiver) {
      return this.get$step(this).call$0();
    },
    step$1: function($receiver, arg0) {
      return this.get$step(this).call$1(arg0);
    },
    set$step: [function(_, value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "step"), "value", value);
    }, null, null, 3, 0, 620, 138, [], "step"],
    ColorStepFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["step", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 5], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "uniform float step;", "void main(void) {", "   vec4 color = texture2D(uSampler, vTextureCoord);", "   color = floor(color * step) / step;", "   gl_FragColor = color;", "}"];
    },
    static: {ColorStepFilter$: [function() {
        var t1 = new M.ColorStepFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.ColorStepFilter$0();
        return t1;
      }, null, null, 0, 0, 54, "new ColorStepFilter"]}
  },
  "+ColorStepFilter": [825],
  CrossHatchFilter: {
    "^": "AbstractFilter;passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    get$blur: [function(_) {
      return J.$div$n(J.$index$asx(J.$index$asx(this.uniforms, "blur"), "value"), 0.00014285714285714287);
    }, null, null, 1, 0, 619, "blur"],
    set$blur: [function(_, value) {
      var t1 = J.$index$asx(this.uniforms, "blur");
      if (typeof value !== "number")
        return H.iae(value);
      J.$indexSet$ax(t1, "value", 0.00014285714285714287 * value);
    }, null, null, 3, 0, 620, 138, [], "blur"],
    CrossHatchFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["blur", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 0.001953125], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float blur;", "uniform sampler2D uSampler;", "void main(void) {", "    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);", "    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);", "    if (lum < 1.00) {", "        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "    if (lum < 0.75) {", "        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "    if (lum < 0.50) {", "        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "    if (lum < 0.3) {", "        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "}"];
    },
    static: {CrossHatchFilter$: [function() {
        var t1 = new M.CrossHatchFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.CrossHatchFilter$0();
        return t1;
      }, null, null, 0, 0, 54, "new CrossHatchFilter"]}
  },
  "+CrossHatchFilter": [825],
  DisplacementFilter: {
    "^": "AbstractFilter;texture@-698,passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    onTextureLoaded$1: [function(e) {
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "x", J.get$width$x(J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value")));
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "y", J.get$height$x(J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value")));
      J.removeEventListener$2$x(J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value").get$baseTexture(), "loaded", this.get$onTextureLoaded());
    }, "call$1", "get$onTextureLoaded", 2, 0, 102, 356, [], "onTextureLoaded"],
    get$map: [function(_) {
      return J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value");
    }, null, null, 1, 0, 824, "map"],
    map$1: function($receiver, arg0) {
      return this.get$map(this).call$1(arg0);
    },
    set$map: [function(_, value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "displacementMap"), "value", value);
    }, null, null, 3, 0, 67, 138, [], "map"],
    get$scale: [function(_) {
      var p, t1, t2, t3;
      p = J.$index$asx(J.$index$asx(this.uniforms, "scale"), "value");
      t1 = J.getInterceptor$asx(p);
      t2 = t1.$index(p, "x");
      t1 = t1.$index(p, "y");
      t3 = new M.Point0(null, null);
      t3.x = t2;
      t3.y = t1;
      return t3;
    }, null, null, 1, 0, 713, "scale"],
    scale$2: function($receiver, arg0, arg1) {
      return this.get$scale(this).call$2(arg0, arg1);
    },
    set$scale: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      J.$indexSet$ax(J.$index$asx(this.uniforms, "scale"), "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", t1.get$x(value), "y", t1.get$y(value)], null, null));
    }, null, null, 3, 0, 829, 138, [], "scale"],
    get$offset: [function(_) {
      var p, t1, t2, t3;
      p = J.$index$asx(J.$index$asx(this.uniforms, "offset"), "value");
      t1 = J.getInterceptor$asx(p);
      t2 = t1.$index(p, "x");
      t1 = t1.$index(p, "y");
      t3 = new M.Point0(null, null);
      t3.x = t2;
      t3.y = t1;
      return t3;
    }, null, null, 1, 0, 713, "offset"],
    offset$2: function($receiver, arg0, arg1) {
      return this.get$offset(this).call$2(arg0, arg1);
    },
    set$offset: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      J.$indexSet$ax(J.$index$asx(this.uniforms, "offset"), "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", t1.get$x(value), "y", t1.get$y(value)], null, null));
    }, null, null, 3, 0, 829, 138, [], "offset"],
    DisplacementFilter$1: function(texture) {
      this.passes = [this];
      this.texture.get$baseTexture().set$_powerOf2(true);
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["displacementMap", P.LinkedHashMap_LinkedHashMap$_literal(["type", "sampler2D", "value", this.texture], null, null), "scale", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 30, "y", 30], null, null)], null, null), "offset", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 0, "y", 0], null, null)], null, null), "mapDimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 1, "y", 5112], null, null)], null, null), "dimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "4fv", "value", [0, 0, 0, 0]], null, null)], null, null);
      if (this.texture.get$baseTexture().get$hasLoaded() === true) {
        J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "x", J.get$width$x(this.texture));
        J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "y", J.get$height$x(this.texture));
      } else
        J.addEventListener$2$x(this.texture.get$baseTexture(), "loaded", this.get$onTextureLoaded());
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D displacementMap;", "uniform sampler2D uSampler;", "uniform vec2 scale;", "uniform vec2 offset;", "uniform vec4 dimensions;", "uniform vec2 mapDimensions;", "void main(void) {", "   vec2 mapCords = vTextureCoord.xy;", "   mapCords += (dimensions.zw + offset)/ dimensions.xy ;", "   mapCords.y *= -1.0;", "   mapCords.y += 1.0;", "   vec2 matSample = texture2D(displacementMap, mapCords).xy;", "   matSample -= 0.5;", "   matSample *= scale;", "   matSample /= mapDimensions;", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + matSample.x, vTextureCoord.y + matSample.y));", "   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb, 1.0);", "   vec2 cord = vTextureCoord;", "}"];
    },
    static: {DisplacementFilter$: [function(texture) {
        var t1 = new M.DisplacementFilter(texture, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.DisplacementFilter$1(texture);
        return t1;
      }, null, null, 2, 0, 67, 68, [], "new DisplacementFilter"]}
  },
  "+DisplacementFilter": [825],
  DotScreenFilter: {
    "^": "AbstractFilter;passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    get$scale: [function(_) {
      return J.$index$asx(J.$index$asx(this.uniforms, "scale"), "value");
    }, null, null, 1, 0, 619, "scale"],
    scale$2: function($receiver, arg0, arg1) {
      return this.get$scale(this).call$2(arg0, arg1);
    },
    set$scale: [function(_, value) {
      this.dirty = true;
      J.$indexSet$ax(J.$index$asx(this.uniforms, "scale"), "value", value);
    }, null, null, 3, 0, 620, 138, [], "scale"],
    get$angle: [function(_) {
      return J.$index$asx(J.$index$asx(this.uniforms, "angle"), "value");
    }, null, null, 1, 0, 619, "angle"],
    angle$0: function($receiver) {
      return this.get$angle(this).call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.get$angle(this).call$2(arg0, arg1);
    },
    set$angle: [function(_, value) {
      this.dirty = true;
      J.$indexSet$ax(J.$index$asx(this.uniforms, "angle"), "value", value);
    }, null, null, 3, 0, 620, 138, [], "angle"],
    DotScreenFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["scale", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 1], null, null), "angle", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 5], null, null), "dimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "4fv", "value", [0, 0, 0, 0]], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec4 dimensions;", "uniform sampler2D uSampler;", "uniform float angle;", "uniform float scale;", "float pattern() {", "   float s = sin(angle), c = cos(angle);", "   vec2 tex = vTextureCoord * dimensions.xy;", "   vec2 point = vec2(", "       c * tex.x - s * tex.y,", "       s * tex.x + c * tex.y", "   ) * scale;", "   return (sin(point.x) * sin(point.y)) * 4.0;", "}", "void main() {", "   vec4 color = texture2D(uSampler, vTextureCoord);", "   float average = (color.r + color.g + color.b) / 3.0;", "   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);", "}"];
    },
    static: {DotScreenFilter$: [function() {
        var t1 = new M.DotScreenFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.DotScreenFilter$0();
        return t1;
      }, null, null, 0, 0, 54, "new DotScreenFilter"]}
  },
  "+DotScreenFilter": [825],
  FilterBlock: {
    "^": "Object;visible@-617,renderable@-617,target*-696,_filterArea@-659,filterArea@-659,filterPasses@-663,_glFilterTexture@-830",
    static: {FilterBlock$: [function() {
        return new M.FilterBlock(true, true, null, null, null, [], null);
      }, null, null, 0, 0, 54, "new FilterBlock"]}
  },
  "+FilterBlock": [674],
  GrayFilter: {
    "^": "AbstractFilter;passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    get$gray: [function() {
      return J.$index$asx(J.$index$asx(this.uniforms, "gray"), "value");
    }, null, null, 1, 0, 619, "gray"],
    set$gray: [function(value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "gray"), "value", value);
    }, null, null, 3, 0, 620, 138, [], "gray"],
    GrayFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["gray", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 1], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "uniform float gray;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);", "}"];
    },
    static: {GrayFilter$: [function() {
        var t1 = new M.GrayFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.GrayFilter$0();
        return t1;
      }, null, null, 0, 0, 54, "new GrayFilter"]}
  },
  "+GrayFilter": [825],
  InvertFilter: {
    "^": "AbstractFilter;passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    get$invert: [function() {
      return J.$index$asx(J.$index$asx(this.uniforms, "invert"), "value");
    }, null, null, 1, 0, 619, "invert"],
    invert$0: function() {
      return this.get$invert().call$0();
    },
    set$invert: [function(value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "invert"), "value", value);
    }, null, null, 3, 0, 620, 138, [], "invert"],
    InvertFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["invert", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 1], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float invert;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "   gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);", "}"];
    },
    static: {InvertFilter$: [function() {
        var t1 = new M.InvertFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.InvertFilter$0();
        return t1;
      }, null, null, 0, 0, 54, "new InvertFilter"]}
  },
  "+InvertFilter": [825],
  NormalMapFilter: {
    "^": "AbstractFilter;texture@-698,passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    onTextureLoaded$1: [function(e) {
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "x", J.get$width$x(J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value")));
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "y", J.get$height$x(J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value")));
      J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value").get$baseTexture().off$2("loaded", this.get$onTextureLoaded());
    }, "call$1", "get$onTextureLoaded", 2, 0, 102, 356, [], "onTextureLoaded"],
    get$map: [function(_) {
      return J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value");
    }, null, null, 1, 0, 824, "map"],
    map$1: function($receiver, arg0) {
      return this.get$map(this).call$1(arg0);
    },
    set$map: [function(_, value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "displacementMap"), "value", value);
    }, null, null, 3, 0, 67, 138, [], "map"],
    get$scale: [function(_) {
      var p, t1, t2, t3;
      p = J.$index$asx(J.$index$asx(this.uniforms, "scale"), "value");
      t1 = J.getInterceptor$asx(p);
      t2 = t1.$index(p, "x");
      t1 = t1.$index(p, "y");
      t3 = new M.Point0(null, null);
      t3.x = t2;
      t3.y = t1;
      return t3;
    }, null, null, 1, 0, 713, "scale"],
    scale$2: function($receiver, arg0, arg1) {
      return this.get$scale(this).call$2(arg0, arg1);
    },
    set$scale: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      J.$indexSet$ax(J.$index$asx(this.uniforms, "scale"), "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", t1.get$x(value), "y", t1.get$y(value)], null, null));
    }, null, null, 3, 0, 829, 138, [], "scale"],
    get$offset: [function(_) {
      var p, t1, t2, t3;
      p = J.$index$asx(J.$index$asx(this.uniforms, "offset"), "value");
      t1 = J.getInterceptor$asx(p);
      t2 = t1.$index(p, "x");
      t1 = t1.$index(p, "y");
      t3 = new M.Point0(null, null);
      t3.x = t2;
      t3.y = t1;
      return t3;
    }, null, null, 1, 0, 713, "offset"],
    offset$2: function($receiver, arg0, arg1) {
      return this.get$offset(this).call$2(arg0, arg1);
    },
    set$offset: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      J.$indexSet$ax(J.$index$asx(this.uniforms, "offset"), "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", t1.get$x(value), "y", t1.get$y(value)], null, null));
    }, null, null, 3, 0, 829, 138, [], "offset"],
    NormalMapFilter$0: function() {
      this.passes = [this];
      this.texture.get$baseTexture().set$_powerOf2(true);
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["displacementMap", P.LinkedHashMap_LinkedHashMap$_literal(["type", "sampler2D", "value", this.texture], null, null), "scale", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 15, "y", 15], null, null)], null, null), "offset", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 0, "y", 0], null, null)], null, null), "mapDimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 1, "y", 1], null, null)], null, null), "dimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "4f", "value", [0, 0, 0, 0]], null, null), "LightPos", P.LinkedHashMap_LinkedHashMap$_literal(["type", "3f", "value", [0, 1, 0]], null, null)], null, null);
      if (this.texture.get$baseTexture().get$hasLoaded() === true) {
        J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "x", J.get$width$x(this.texture));
        J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "y", J.get$height$x(this.texture));
      } else
        J.addEventListener$2$x(this.texture.get$baseTexture(), "loaded", this.get$onTextureLoaded());
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D displacementMap;", "uniform sampler2D uSampler;", "uniform vec4 dimensions;", "const vec2 Resolution = vec2(1.0,1.0);", "uniform vec3 LightPos;", "const vec4 LightColor = vec4(1.0, 1.0, 1.0, 1.0);", "const vec4 AmbientColor = vec4(1.0, 1.0, 1.0, 0.5);", "const vec3 Falloff = vec3(0.0, 1.0, 0.2);", "uniform vec3 LightDir;", "uniform vec2 mapDimensions;", "void main(void) {", "vec2 mapCords = vTextureCoord.xy;", "vec4 color = texture2D(uSampler, vTextureCoord.st);", "vec3 nColor = texture2D(displacementMap, vTextureCoord.st).rgb;", "mapCords *= vec2(dimensions.x/512.0, dimensions.y/512.0);", "mapCords.y *= -1.0;", "mapCords.y += 1.0;", "vec4 DiffuseColor = texture2D(uSampler, vTextureCoord);", "vec3 NormalMap = texture2D(displacementMap, mapCords).rgb;", "vec3 LightDir = vec3(LightPos.xy - (mapCords.xy), LightPos.z);", "float D = length(LightDir);", "vec3 N = normalize(NormalMap * 2.0 - 1.0);", "vec3 L = normalize(LightDir);", "vec3 Diffuse = (LightColor.rgb * LightColor.a) * max(dot(N, L), 0.0);", "vec3 Ambient = AmbientColor.rgb * AmbientColor.a;", "float Attenuation = 1.0 / ( Falloff.x + (Falloff.y*D) + (Falloff.z*D*D) );", "vec3 Intensity = Ambient + Diffuse * Attenuation;", "vec3 FinalColor = DiffuseColor.rgb * Intensity;", "gl_FragColor = vColor * vec4(FinalColor, DiffuseColor.a);", "}"];
    },
    static: {NormalMapFilter$: [function() {
        var t1 = new M.NormalMapFilter(null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.NormalMapFilter$0();
        return t1;
      }, null, null, 0, 0, 54, "new NormalMapFilter"]}
  },
  "+NormalMapFilter": [825],
  PixelateFilter: {
    "^": "AbstractFilter;passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    get$size: [function(_) {
      var p, t1, t2, t3;
      p = J.$index$asx(J.$index$asx(this.uniforms, "pixelSize"), "value");
      t1 = J.getInterceptor$asx(p);
      t2 = t1.$index(p, "x");
      t1 = t1.$index(p, "y");
      t3 = new M.Point0(null, null);
      t3.x = t2;
      t3.y = t1;
      return t3;
    }, null, null, 1, 0, 713, "size"],
    size$1: function($receiver, arg0) {
      return this.get$size(this).call$1(arg0);
    },
    set$size: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      J.$indexSet$ax(J.$index$asx(this.uniforms, "pixelSize"), "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", t1.get$x(value), "y", t1.get$y(value)], null, null));
    }, null, null, 3, 0, 829, 138, [], "size"],
    PixelateFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["invert", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 0], null, null), "dimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "4fv", "value", new Float32Array(H._ensureNativeList([10000, 100, 10, 10]))], null, null), "pixelSize", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 10, "y", 10], null, null)], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec2 testDim;", "uniform vec4 dimensions;", "uniform vec2 pixelSize;", "uniform sampler2D uSampler;", "void main(void) {", "   vec2 coord = vTextureCoord;", "   vec2 size = dimensions.xy/pixelSize;", "   vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;", "   gl_FragColor = texture2D(uSampler, color);", "}"];
    },
    static: {PixelateFilter$: [function() {
        var t1 = new M.PixelateFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.PixelateFilter$0();
        return t1;
      }, null, null, 0, 0, 54, "new PixelateFilter"]}
  },
  "+PixelateFilter": [825],
  RGBSplitFilter: {
    "^": "AbstractFilter;passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    get$angle: [function(_) {
      return J.$div$n(J.$index$asx(J.$index$asx(this.uniforms, "blur"), "value"), 0.00014285714285714287);
    }, null, null, 1, 0, 619, "angle"],
    angle$0: function($receiver) {
      return this.get$angle(this).call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.get$angle(this).call$2(arg0, arg1);
    },
    set$blur: [function(_, value) {
      var t1 = J.$index$asx(this.uniforms, "blur");
      if (typeof value !== "number")
        return H.iae(value);
      J.$indexSet$ax(t1, "value", 0.00014285714285714287 * value);
    }, null, null, 3, 0, 620, 138, [], "blur"],
    RGBSplitFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["red", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 20, "y", 20], null, null)], null, null), "green", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", -20, "y", 20], null, null)], null, null), "blue", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 20, "y", -20], null, null)], null, null), "dimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "4fv", "value", [0, 0, 0, 0]], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec2 red;", "uniform vec2 green;", "uniform vec2 blue;", "uniform vec4 dimensions;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;", "   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;", "   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;", "   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;", "}"];
    },
    static: {RGBSplitFilter$: [function() {
        var t1 = new M.RGBSplitFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.RGBSplitFilter$0();
        return t1;
      }, null, null, 0, 0, 54, "new RGBSplitFilter"]}
  },
  "+RGBSplitFilter": [825],
  SepiaFilter: {
    "^": "AbstractFilter;passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    static: {SepiaFilter$: [function() {
        var t1 = new M.SepiaFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        return t1;
      }, null, null, 0, 0, 54, "new SepiaFilter"]}
  },
  "+SepiaFilter": [825],
  SmartBlurFilter: {
    "^": "AbstractFilter;passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    static: {SmartBlurFilter$: [function() {
        var t1 = new M.SmartBlurFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        return t1;
      }, null, null, 0, 0, 54, "new SmartBlurFilter"]}
  },
  "+SmartBlurFilter": [825],
  TwistFilter: {
    "^": "AbstractFilter;passes-663,shaders-783,dirty-617,padding-614,uniforms-783,fragmentSrc-645",
    static: {TwistFilter$: [function() {
        var t1 = new M.TwistFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        return t1;
      }, null, null, 0, 0, 54, "new TwistFilter"]}
  },
  "+TwistFilter": [825],
  InteractionData: {
    "^": "Object;global@-652,target*-706,originalEvent@-831",
    getLocalPosition$1: [function(displayObject) {
      var worldTransform, a00, a01, a02, a10, a11, a12, t1, t2, t3, t4, id, t5;
      worldTransform = displayObject.get$_worldTransform();
      a00 = J.get$a$x(worldTransform);
      a01 = worldTransform.get$b();
      a02 = worldTransform.get$tx();
      a10 = worldTransform.get$c();
      a11 = worldTransform.get$d();
      a12 = worldTransform.get$ty();
      t1 = J.getInterceptor$ns(a00);
      t2 = J.getInterceptor$n(a10);
      t3 = J.getInterceptor$ns(a01);
      t4 = J.$add$ns(t1.$mul(a00, a11), t3.$mul(a01, t2.$negate(a10)));
      if (typeof t4 !== "number")
        return H.iae(t4);
      id = 1 / t4;
      t4 = J.getInterceptor$ns(a12);
      t5 = J.getInterceptor$ns(a02);
      t3 = J.$add$ns(J.$add$ns(J.$mul$ns(J.$mul$ns(a11, id), J.get$x$x(this.global)), J.$mul$ns(J.$mul$ns(t3.$negate(a01), id), J.get$y$x(this.global))), J.$mul$ns(J.$sub$n(t4.$mul(a12, a01), t5.$mul(a02, a11)), id));
      t5 = J.$add$ns(J.$add$ns(J.$mul$ns(t1.$mul(a00, id), J.get$y$x(this.global)), J.$mul$ns(J.$mul$ns(t2.$negate(a10), id), J.get$x$x(this.global))), J.$mul$ns(J.$add$ns(J.$mul$ns(t4.$negate(a12), a00), t5.$mul(a02, a10)), id));
      t4 = new M.Point0(null, null);
      t4.x = t3;
      t4.y = t5;
      return t4;
    }, "call$1", "get$getLocalPosition", 2, 0, 832, 833, [], "getLocalPosition"],
    static: {InteractionData$: [function() {
        var t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        return new M.InteractionData(t1, null, null);
      }, null, null, 0, 0, 130, "new InteractionData"]}
  },
  "+InteractionData": [674],
  InteractionManager: {
    "^": "Object;stage@-657,mouse@-834,touchs@-656,tempPoint@-652,mouseoverEnabled@-617,pool<-835,interactiveItems@-651,interactionDOMElement@-836,target*-837,last*-818,dirty@-617,currentCursorStyle@-644,mouseOut@-617,isCocoonJS@-617",
    collectInteractiveSprite$2: [function(displayObject, iParent) {
      var children, t1, i, t2, child;
      children = J.get$children$x(displayObject);
      t1 = J.getInterceptor$asx(children);
      for (i = J.$sub$n(t1.get$length(children), 1); t2 = J.getInterceptor$n(i), t2.$ge(i, 0); i = t2.$sub(i, 1)) {
        child = t1.$index(children, i);
        if (child.get$_interactive() === true) {
          iParent.set$interactiveChildren(true);
          J.add$1$ax(this.interactiveItems, child);
          if (J.$gt$n(J.get$length$asx(J.get$children$x(child)), 0))
            this.collectInteractiveSprite$2(child, child);
        } else if (J.$gt$n(J.get$length$asx(J.get$children$x(child)), 0))
          this.collectInteractiveSprite$2(child, iParent);
      }
    }, "call$2", "get$collectInteractiveSprite", 4, 0, 838, 833, [], 839, [], "collectInteractiveSprite"],
    setTarget$1: [function(target) {
      this.target = target;
      if (this.interactionDOMElement == null)
        this.setTargetDomElement$1(J.get$view$x(target));
    }, "call$1", "get$setTarget", 2, 0, 840, 97, [], "setTarget"],
    setTargetDomElement$1: [function(domElement) {
      var t1, t2;
      this.removeEvents$0();
      this.interactionDOMElement = domElement;
      t1 = J.getInterceptor$x(domElement);
      t1.addEventListener$3(domElement, "mousemove", this.get$onMouseMove(this), true);
      t1.addEventListener$3(domElement, "mousedown", this.get$onMouseDown(this), true);
      t1.addEventListener$3(domElement, "mouseout", this.get$onMouseOut(this), true);
      t1.addEventListener$3(domElement, "touchstart", this.get$onTouchStart(this), true);
      t1.addEventListener$3(domElement, "touchend", this.get$onTouchEnd(this), true);
      t1.addEventListener$3(domElement, "touchmove", this.get$onTouchMove(this), true);
      t1 = window;
      t2 = this.get$onMouseUp(this);
      C.Window_methods._addEventListener$3(t1, "mouseup", t2, true);
    }, "call$1", "get$setTargetDomElement", 2, 0, 841, 711, [], "setTargetDomElement"],
    removeEvents$0: [function() {
      var t1, t2;
      t1 = this.interactionDOMElement;
      if (t1 == null)
        return;
      J.removeEventListener$3$x(t1, "mousemove", this.get$onMouseMove(this), true);
      J.removeEventListener$3$x(this.interactionDOMElement, "mousedown", this.get$onMouseDown(this), true);
      J.removeEventListener$3$x(this.interactionDOMElement, "mouseout", this.get$onMouseOut(this), true);
      J.removeEventListener$3$x(this.interactionDOMElement, "touchstart", this.get$onTouchStart(this), true);
      J.removeEventListener$3$x(this.interactionDOMElement, "touchend", this.get$onTouchEnd(this), true);
      J.removeEventListener$3$x(this.interactionDOMElement, "touchmove", this.get$onTouchMove(this), true);
      this.interactionDOMElement = null;
      t1 = window;
      t2 = this.get$onMouseUp(this);
      C.Window_methods._removeEventListener$3(t1, "mouseup", t2, true);
    }, "call$0", "get$removeEvents", 0, 0, 17, "removeEvents"],
    update$0: [function() {
      var now, $length, i, cursor, over, item;
      if (this.target == null)
        return;
      now = new P.DateTime(Date.now(), false);
      if (C.JSNumber_methods._tdivFast$1(now.difference$1(this.last)._duration, 1000) * 30 / 1000 < 1)
        return;
      this.last = now;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      $length = J.get$length$asx(this.interactiveItems);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      cursor = "inherit";
      over = false;
      for (; i < $length; ++i) {
        item = J.$index$asx(this.interactiveItems, i);
        item.set$__hit(this.hitTest$2(item, this.mouse));
        J.set$target$x(this.mouse, item);
        if (item.get$__hit() === true && !over) {
          if (item.get$buttonMode() === true)
            cursor = item.get$defaultCursor();
          if (!!J.getInterceptor(item).$isDisplayObjectContainer && item.interactiveChildren !== true)
            over = true;
          if (item.get$__isOver() !== true) {
            if (item.get$mouseover() != null)
              item.mouseover$1(this.mouse);
            item.set$__isOver(true);
          }
        } else if (item.get$__isOver() === true) {
          if (item.get$mouseout() != null)
            item.mouseout$1(this.mouse);
          item.set$__isOver(false);
        }
      }
      if (!J.$eq(this.currentCursorStyle, cursor)) {
        this.currentCursorStyle = cursor;
        J.set$cursor$x(J.get$style$x(this.interactionDOMElement), cursor);
      }
    }, "call$0", "get$update", 0, 0, 17, "update"],
    rebuildInteractiveGraph$0: [function() {
      var len, i, item, t1;
      this.dirty = false;
      len = J.get$length$asx(this.interactiveItems);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i) {
        item = J.$index$asx(this.interactiveItems, i);
        if (!!J.getInterceptor(item).$isDisplayObjectContainer)
          item.interactiveChildren = false;
      }
      this.interactiveItems = [];
      if (this.stage.get$interactive() === true)
        J.add$1$ax(this.interactiveItems, this.stage);
      t1 = this.stage;
      this.collectInteractiveSprite$2(t1, t1);
    }, "call$0", "get$rebuildInteractiveGraph", 0, 0, 54, "rebuildInteractiveGraph"],
    onMouseMove$1: [function(_, $event) {
      var rect, t1, t2, t3, t4, t5, t6, $length, i, item;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      this.mouse.set$originalEvent($event);
      rect = J.getBoundingClientRect$0$x(this.interactionDOMElement);
      t1 = this.mouse.get$global();
      t2 = J.getInterceptor$x($event);
      t3 = t2.get$client($event);
      t3 = t3.get$x(t3);
      t4 = J.getInterceptor$x(rect);
      t5 = t4.get$left(rect);
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t5 !== "number")
        return H.iae(t5);
      t6 = J.$div$n(J.get$width$x(this.target), t4.get$width(rect));
      if (typeof t6 !== "number")
        return H.iae(t6);
      J.set$x$x(t1, (t3 - t5) * t6);
      t6 = this.mouse.get$global();
      t2 = t2.get$client($event);
      t2 = t2.get$y(t2);
      t5 = t4.get$top(rect);
      if (typeof t2 !== "number")
        return t2.$sub();
      if (typeof t5 !== "number")
        return H.iae(t5);
      t4 = J.$div$n(J.get$height$x(this.target), t4.get$height(rect));
      if (typeof t4 !== "number")
        return H.iae(t4);
      J.set$y$x(t6, (t2 - t5) * t4);
      $length = J.get$length$asx(this.interactiveItems);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        item = J.$index$asx(this.interactiveItems, i);
        if (item.get$mousemove() != null)
          item.mousemove$1(this.mouse);
      }
    }, "call$1", "get$onMouseMove", 2, 0, 842, 666, [], "onMouseMove"],
    onMouseDown$1: [function(_, $event) {
      var $length, i, item;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      this.mouse.set$originalEvent($event);
      J.preventDefault$0$x(this.mouse.get$originalEvent());
      $length = J.get$length$asx(this.interactiveItems);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        item = J.$index$asx(this.interactiveItems, i);
        if (item.get$mousedown() != null || J.get$click$x(item) != null) {
          item.set$__mouseIsDown(true);
          item.set$__hit(this.hitTest$2(item, this.mouse));
          if (item.get$__hit() === true) {
            if (item.get$mousedown() != null)
              item.mousedown$1(this.mouse);
            item.set$__isDown(true);
            if (!!J.getInterceptor(item).$isDisplayObjectContainer && item.interactiveChildren !== true)
              break;
          }
        }
      }
    }, "call$1", "get$onMouseDown", 2, 0, 843, 666, [], "onMouseDown"],
    onMouseOut$1: [function(_, $event) {
      var $length, i, item;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      $length = J.get$length$asx(this.interactiveItems);
      J.set$cursor$x(J.get$style$x(this.interactionDOMElement), "inherit");
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        item = J.$index$asx(this.interactiveItems, i);
        if (item.get$__isOver() === true) {
          J.set$target$x(this.mouse, item);
          if (item.get$mouseout() != null)
            item.mouseout$1(this.mouse);
          item.set$__isOver(false);
        }
      }
      this.mouseOut = true;
      J.set$x$x(this.mouse.get$global(), -10000);
      J.set$y$x(this.mouse.get$global(), -10000);
    }, "call$1", "get$onMouseOut", 2, 0, 843, 666, [], "onMouseOut"],
    onMouseUp$1: [function(_, $event) {
      var $length, up, i, item, t1;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      this.mouse.set$originalEvent($event);
      $length = J.get$length$asx(this.interactiveItems);
      if (typeof $length !== "number")
        return H.iae($length);
      up = false;
      i = 0;
      for (; i < $length; ++i) {
        item = J.$index$asx(this.interactiveItems, i);
        item.set$__hit(this.hitTest$2(item, this.mouse));
        if (item.get$__hit() === true && !up) {
          if (item.get$mouseup() != null)
            item.mouseup$1(this.mouse);
          if (item.get$__isDown() === true) {
            t1 = J.getInterceptor$x(item);
            if (t1.get$click(item) != null)
              t1.click$1(item, this.mouse);
          }
          if (!!J.getInterceptor(item).$isDisplayObjectContainer && item.interactiveChildren !== true)
            up = true;
        } else if (item.get$__isDown() === true)
          if (item.get$mouseupoutside() != null)
            item.mouseupoutside$1(this.mouse);
        item.set$__isDown(false);
      }
    }, "call$1", "get$onMouseUp", 2, 0, 842, 666, [], "onMouseUp"],
    hitTest$2: [function(item, interactionData) {
      var global, t1, worldTransform, a00, a01, a02, a10, a11, a12, t2, t3, t4, t5, id, t6, t7, x, y, width, height, x1, y1, $length, i;
      global = interactionData.get$global();
      if (!item.get$worldVisible())
        return false;
      t1 = J.getInterceptor(item);
      worldTransform = item.get$_worldTransform();
      a00 = J.get$a$x(worldTransform);
      a01 = worldTransform.get$b();
      a02 = worldTransform.get$tx();
      a10 = worldTransform.get$c();
      a11 = worldTransform.get$d();
      a12 = worldTransform.get$ty();
      t2 = J.getInterceptor$ns(a00);
      t3 = J.getInterceptor$n(a10);
      t4 = J.getInterceptor$ns(a01);
      t5 = J.$add$ns(t2.$mul(a00, a11), t4.$mul(a01, t3.$negate(a10)));
      if (typeof t5 !== "number")
        return H.iae(t5);
      id = 1 / t5;
      t5 = J.getInterceptor$x(global);
      t6 = J.getInterceptor$ns(a12);
      t7 = J.getInterceptor$ns(a02);
      x = J.$add$ns(J.$add$ns(J.$mul$ns(J.$mul$ns(a11, id), t5.get$x(global)), J.$mul$ns(J.$mul$ns(t4.$negate(a01), id), t5.get$y(global))), J.$mul$ns(J.$sub$n(t6.$mul(a12, a01), t7.$mul(a02, a11)), id));
      y = J.$add$ns(J.$add$ns(J.$mul$ns(t2.$mul(a00, id), t5.get$y(global)), J.$mul$ns(J.$mul$ns(t3.$negate(a10), id), t5.get$x(global))), J.$mul$ns(J.$add$ns(J.$mul$ns(t6.$negate(a12), a00), t7.$mul(a02, a10)), id));
      t7 = J.getInterceptor$x(interactionData);
      t7.set$target(interactionData, item);
      if (item.get$hitArea() != null) {
        J.get$contains$asx(item.get$hitArea());
        t2 = true;
      } else
        t2 = false;
      if (t2) {
        if (J.contains$2$asx(item.get$hitArea(), x, y)) {
          t7.set$target(interactionData, item);
          return true;
        }
        return false;
      } else if (!!t1.$isSprite0) {
        width = J.get$width$x(item.get$texture().get$frame());
        height = J.get$height$x(item.get$texture().get$frame());
        x1 = J.$mul$ns(J.$negate$n(width), J.get$x$x(item.get$anchor()));
        t2 = J.getInterceptor$n(x);
        if (t2.$gt(x, x1) && t2.$lt(x, J.$add$ns(x1, width))) {
          y1 = J.$mul$ns(J.$negate$n(height), J.get$y$x(item.get$anchor()));
          t2 = J.getInterceptor$n(y);
          if (t2.$gt(y, y1) && t2.$lt(y, J.$add$ns(y1, height))) {
            t7.set$target(interactionData, item);
            return true;
          }
        }
      }
      $length = J.get$length$asx(t1.get$children(item));
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i)
        if (this.hitTest$2(J.$index$asx(t1.get$children(item), i), interactionData)) {
          t7.set$target(interactionData, item);
          return true;
        }
      return false;
    }, "call$2", "get$hitTest", 4, 0, 844, 845, [], 846, [], "hitTest"],
    onTouchMove$1: [function(_, $event) {
      var t1, changedTouches, i, touchEvent, t2, identifier, touchData, rect, t3, t4, t5, t6, t7, j, item;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      if (this.isCocoonJS === true) {
        t1 = [];
        C.JSArray_methods.addAll$1(t1, J.map$1$ax(J.$index$asx(P.JsObject_JsObject$fromBrowserObject($event), "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t1), [null]);
      } else
        changedTouches = J.get$changedTouches$x($event);
      for (t1 = J.getInterceptor$asx(changedTouches), i = 0; i < t1.get$length(changedTouches); ++i) {
        if (this.isCocoonJS === true) {
          touchEvent = P.JsObject_JsObject$fromBrowserObject(t1.$index(changedTouches, i));
          t2 = J.getInterceptor$asx(touchEvent);
          identifier = t2.$index(touchEvent, "identifier");
          touchData = J.$index$asx(this.touchs, identifier);
          touchData.set$originalEvent($event);
          J.set$x$x(touchData.get$global(), t2.$index(touchEvent, "clientX"));
          J.set$y$x(touchData.get$global(), t2.$index(touchEvent, "clientY"));
        } else {
          rect = J.getBoundingClientRect$0$x(this.interactionDOMElement);
          touchEvent = t1.$index(changedTouches, i);
          t2 = J.getInterceptor$x(touchEvent);
          identifier = t2.get$identifier(touchEvent);
          touchData = J.$index$asx(this.touchs, identifier);
          touchData.set$originalEvent($event);
          t3 = touchData.get$global();
          t4 = t2.get$client(touchEvent);
          t4 = t4.get$x(t4);
          t5 = J.getInterceptor$x(rect);
          t6 = t5.get$left(rect);
          if (typeof t4 !== "number")
            return t4.$sub();
          if (typeof t6 !== "number")
            return H.iae(t6);
          t7 = J.$div$n(J.get$width$x(this.target), t5.get$width(rect));
          if (typeof t7 !== "number")
            return H.iae(t7);
          J.set$x$x(t3, (t4 - t6) * t7);
          t7 = touchData.get$global();
          t2 = t2.get$client(touchEvent);
          t2 = t2.get$y(t2);
          t6 = t5.get$top(rect);
          if (typeof t2 !== "number")
            return t2.$sub();
          if (typeof t6 !== "number")
            return H.iae(t6);
          t5 = J.$div$n(J.get$height$x(this.target), t5.get$height(rect));
          if (typeof t5 !== "number")
            return H.iae(t5);
          J.set$y$x(t7, (t2 - t6) * t5);
        }
        j = 0;
        while (true) {
          t2 = J.get$length$asx(this.interactiveItems);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(j < t2))
            break;
          item = J.$index$asx(this.interactiveItems, j);
          if (item.get$touchmove() != null && J.$index$asx(item.get$__touchData(), identifier) != null)
            item.touchmove$1(touchData);
          ++j;
        }
      }
    }, "call$1", "get$onTouchMove", 2, 0, 596, 666, [], "onTouchMove"],
    onTouchStart$1: [function(_, $event) {
      var ev, t1, t2, changedTouches, t3, i, touchData, t4, touchEvent, identifier, rect, t5, t6, t7, t8, t9, $length, j, item;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      if (this.isCocoonJS === true) {
        ev = P.JsObject_JsObject$fromBrowserObject($event);
        t1 = J.getInterceptor$asx(ev);
        t2 = [];
        C.JSArray_methods.addAll$1(t2, J.map$1$ax(t1.$index(ev, "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t2), [null]);
        t1.$index(ev, "preventDefault").apply$2$thisArg([], ev);
      } else {
        t1 = J.getInterceptor$x($event);
        changedTouches = t1.get$changedTouches($event);
        t1.preventDefault$0($event);
      }
      for (t1 = J.getInterceptor$asx(changedTouches), t2 = this.pool, t3 = J.getInterceptor$asx(t2), i = 0; i < t1.get$length(changedTouches); ++i) {
        touchData = J.$gt$n(t3.get$length(t2), 0) ? t3.removeLast$0(t2) : null;
        if (touchData == null) {
          t4 = new M.Point0(null, null);
          t4.x = 0;
          t4.y = 0;
          touchData = new M.InteractionData(t4, null, null);
        }
        touchData.set$originalEvent($event);
        if (this.isCocoonJS === true) {
          touchEvent = P.JsObject_JsObject$fromBrowserObject(t1.$index(changedTouches, i));
          t4 = J.getInterceptor$asx(touchEvent);
          identifier = t4.$index(touchEvent, "identifier");
          J.set$x$x(touchData.get$global(), t4.$index(touchEvent, "clientX"));
          J.set$y$x(touchData.get$global(), t4.$index(touchEvent, "clientY"));
        } else {
          touchEvent = t1.$index(changedTouches, i);
          t4 = J.getInterceptor$x(touchEvent);
          identifier = t4.get$identifier(touchEvent);
          rect = J.getBoundingClientRect$0$x(this.interactionDOMElement);
          t5 = touchData.get$global();
          t6 = t4.get$client(touchEvent);
          t6 = t6.get$x(t6);
          t7 = J.getInterceptor$x(rect);
          t8 = t7.get$left(rect);
          if (typeof t6 !== "number")
            return t6.$sub();
          if (typeof t8 !== "number")
            return H.iae(t8);
          t9 = J.$div$n(J.get$width$x(this.target), t7.get$width(rect));
          if (typeof t9 !== "number")
            return H.iae(t9);
          J.set$x$x(t5, (t6 - t8) * t9);
          t9 = touchData.get$global();
          t4 = t4.get$client(touchEvent);
          t4 = t4.get$y(t4);
          t8 = t7.get$top(rect);
          if (typeof t4 !== "number")
            return t4.$sub();
          if (typeof t8 !== "number")
            return H.iae(t8);
          t7 = J.$div$n(J.get$height$x(this.target), t7.get$height(rect));
          if (typeof t7 !== "number")
            return H.iae(t7);
          J.set$y$x(t9, (t4 - t8) * t7);
        }
        J.$indexSet$ax(this.touchs, identifier, touchData);
        $length = J.get$length$asx(this.interactiveItems);
        if (typeof $length !== "number")
          return H.iae($length);
        j = 0;
        for (; j < $length; ++j) {
          item = J.$index$asx(this.interactiveItems, j);
          if (item.get$touchstart() != null || item.get$tap() != null) {
            item.set$__hit(this.hitTest$2(item, touchData));
            if (item.get$__hit() === true) {
              if (item.get$touchstart() != null)
                item.touchstart$1(touchData);
              item.set$__isDown(true);
              if (item.get$__touchData() == null)
                item.set$__touchData(P.LinkedHashMap_LinkedHashMap$_empty(null, null));
              J.$indexSet$ax(item.get$__touchData(), identifier, touchData);
              if (!!J.getInterceptor(item).$isDisplayObjectContainer && item.interactiveChildren !== true)
                break;
            }
          }
        }
      }
    }, "call$1", "get$onTouchStart", 2, 0, 596, 666, [], "onTouchStart"],
    onTouchEnd$1: [function(_, $event) {
      var t1, changedTouches, t2, t3, i, touchEvent, t4, identifier, touchData, rect, t5, t6, t7, t8, t9, $length, up, j, item;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      if (this.isCocoonJS === true) {
        t1 = [];
        C.JSArray_methods.addAll$1(t1, J.map$1$ax(J.$index$asx(P.JsObject_JsObject$fromBrowserObject($event), "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t1), [null]);
      } else
        changedTouches = J.get$changedTouches$x($event);
      for (t1 = J.getInterceptor$asx(changedTouches), t2 = this.pool, t3 = J.getInterceptor$ax(t2), i = 0; i < t1.get$length(changedTouches); ++i) {
        if (this.isCocoonJS === true) {
          touchEvent = P.JsObject_JsObject$fromBrowserObject(t1.$index(changedTouches, i));
          t4 = J.getInterceptor$asx(touchEvent);
          identifier = t4.$index(touchEvent, "identifier");
          touchData = J.$index$asx(this.touchs, identifier);
          J.set$x$x(touchData.get$global(), t4.$index(touchEvent, "clientX"));
          J.set$y$x(touchData.get$global(), t4.$index(touchEvent, "clientY"));
        } else {
          touchEvent = t1.$index(changedTouches, i);
          t4 = J.getInterceptor$x(touchEvent);
          identifier = t4.get$identifier(touchEvent);
          touchData = J.$index$asx(this.touchs, identifier);
          rect = J.getBoundingClientRect$0$x(this.interactionDOMElement);
          t5 = touchData.get$global();
          t6 = t4.get$client(touchEvent);
          t6 = t6.get$x(t6);
          t7 = J.getInterceptor$x(rect);
          t8 = t7.get$left(rect);
          if (typeof t6 !== "number")
            return t6.$sub();
          if (typeof t8 !== "number")
            return H.iae(t8);
          t9 = J.$div$n(J.get$width$x(this.target), t7.get$width(rect));
          if (typeof t9 !== "number")
            return H.iae(t9);
          J.set$x$x(t5, (t6 - t8) * t9);
          t9 = touchData.get$global();
          t4 = t4.get$client(touchEvent);
          t4 = t4.get$y(t4);
          t8 = t7.get$top(rect);
          if (typeof t4 !== "number")
            return t4.$sub();
          if (typeof t8 !== "number")
            return H.iae(t8);
          t7 = J.$div$n(J.get$height$x(this.target), t7.get$height(rect));
          if (typeof t7 !== "number")
            return H.iae(t7);
          J.set$y$x(t9, (t4 - t8) * t7);
        }
        $length = J.get$length$asx(this.interactiveItems);
        if (typeof $length !== "number")
          return H.iae($length);
        up = false;
        j = 0;
        for (; j < $length; ++j) {
          item = J.$index$asx(this.interactiveItems, j);
          if (item.get$__touchData() != null && J.$index$asx(item.get$__touchData(), identifier) != null) {
            item.set$__hit(this.hitTest$2(item, J.$index$asx(item.get$__touchData(), identifier)));
            touchData.set$originalEvent($event);
            if (item.get$touchend() != null || item.get$tap() != null) {
              if (item.get$__hit() === true && !up) {
                if (item.get$touchend() != null)
                  item.touchend$1(touchData);
                if (item.get$__isDown() === true)
                  if (item.get$tap() != null)
                    item.tap$1(touchData);
                if (!!J.getInterceptor(item).$isDisplayObjectContainer && item.interactiveChildren !== true)
                  up = true;
              } else if (item.get$__isDown() === true)
                if (item.get$touchendoutside() != null)
                  item.touchendoutside$1(touchData);
              item.set$__isDown(false);
            }
            J.$indexSet$ax(item.get$__touchData(), identifier, null);
          }
        }
        t3.add$1(t2, touchData);
        J.$indexSet$ax(this.touchs, identifier, null);
      }
    }, "call$1", "get$onTouchEnd", 2, 0, 596, 666, [], "onTouchEnd"],
    static: {InteractionManager$: [function(stage) {
        var t1, t2, t3;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t3 = new M.InteractionManager(stage, new M.InteractionData(t1, null, null), t2, t3, true, [], [], null, null, new P.DateTime(Date.now(), false), null, "inherit", false, null);
        t3.isCocoonJS = J.contains$1$asx(window.navigator.appVersion, "CocoonJS");
        return t3;
      }, null, null, 2, 0, 131, 132, [], "new InteractionManager"]}
  },
  "+InteractionManager": [674],
  AssetLoader: {
    "^": "EventTarget0;assetURLs@-847,crossorigin@-617,loadCount@-614,onProgress*-0,onComplete*-0,listeners-848",
    onProgress$1: function($receiver, arg0) {
      return this.onProgress.call$1(arg0);
    },
    onComplete$0: function($receiver) {
      return this.onComplete.call$0();
    },
    _getDataType$1: [function(str) {
      var t1, data, sepIdx, info;
      t1 = J.getInterceptor$s(str);
      if (t1.substring$2(str, 0, 5).toLowerCase() === "data:") {
        data = t1.substring$1(str, 5);
        sepIdx = C.JSString_methods.indexOf$1(data, ",");
        if (sepIdx === -1)
          return;
        t1 = C.JSString_methods.substring$2(data, 0, sepIdx).split(";");
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        info = t1[0];
        if (info == null) {
          J.toLowerCase$0$s(info);
          t1 = false;
        } else
          t1 = true;
        if (t1)
          return "txt";
        t1 = J.split$1$s(info, "/");
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        return J.toLowerCase$0$s(t1.pop());
      }
      return;
    }, "call$1", "get$_getDataType", 2, 0, 91, 849, [], "_getDataType"],
    load$0: [function(_) {
      var t1, i, t2, fileName, fileType, loader;
      t1 = new M.AssetLoader_load_onLoad(this);
      this.loadCount = J.get$length$asx(this.assetURLs);
      i = 0;
      while (true) {
        t2 = J.get$length$asx(this.assetURLs);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        fileName = J.$index$asx(this.assetURLs, i);
        fileType = this._getDataType$1(fileName);
        if (fileType == null) {
          t2 = J.split$1$s(C.JSArray_methods.removeAt$1(J.split$1$s(fileName, "?"), 0), ".");
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          fileType = J.toLowerCase$0$s(t2.pop());
        }
        loader = M.Loader_Loader$loaderByType(fileType, fileName, this.crossorigin);
        loader.addEventListener$2(0, "loaded", t1);
        loader.load$0(0);
        ++i;
      }
    }, "call$0", "get$load", 0, 0, 54, "load"],
    onAssetLoaded$1: [function(loader) {
      var t1;
      this.loadCount = J.$sub$n(this.loadCount, 1);
      t1 = new M.PixiEvent(null, null, null);
      t1.type = "onProgress";
      t1.content = this;
      t1.loader = loader;
      this.dispatchEvent$1(0, t1);
      if (this.onProgress != null)
        this.onProgress$1(0, loader);
      if (J.$eq(this.loadCount, 0)) {
        t1 = new M.PixiEvent(null, null, null);
        t1.type = "onComplete";
        t1.content = this;
        this.dispatchEvent$1(0, t1);
        if (this.onComplete != null)
          this.onComplete$0(0);
      }
    }, "call$1", "get$onAssetLoaded", 2, 0, 102, 227, [], "onAssetLoaded"],
    static: {AssetLoader$: [function(assetURLs, crossorigin) {
        return new M.AssetLoader(assetURLs, crossorigin, 0, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }, null, null, 2, 2, 133, 19, 134, [], 73, [], "new AssetLoader"]}
  },
  "+AssetLoader": [850],
  AssetLoader_load_onLoad: {
    "^": "Closure:102;scope_0",
    call$1: [function(evt) {
      var t1, t2, t3;
      t1 = this.scope_0;
      t2 = J.get$content$x(evt);
      t1.loadCount = J.$sub$n(t1.loadCount, 1);
      t3 = new M.PixiEvent(null, null, null);
      t3.type = "onProgress";
      t3.content = t1;
      t3.loader = t2;
      t1.dispatchEvent$1(0, t3);
      if (t1.onProgress != null)
        t1.onProgress$1(0, t2);
      if (J.$eq(t1.loadCount, 0)) {
        t2 = new M.PixiEvent(null, null, null);
        t2.type = "onComplete";
        t2.content = t1;
        t1.dispatchEvent$1(0, t2);
        if (t1.onComplete != null)
          t1.onComplete$0(0);
      }
    }, "call$1", null, 2, 0, 102, 851, [], "call"]
  },
  AtlasLoader: {
    "^": "Loader0;atlas@-783,images@-645,currentImageId@-614,url-644,crossorigin-617,baseUrl-644,ajaxRequest-852,loaded-617,texture-853,listeners-848",
    atlas$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.atlas.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    load$0: [function(_) {
      var t1 = new XMLHttpRequest();
      this.ajaxRequest = t1;
      t1 = C.HttpRequest_methods.get$onReadyStateChange(t1);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$onAtlasLoaded()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      J.open$3$async$x(this.ajaxRequest, "GET", this.url, true);
      J.overrideMimeType$1$x(this.ajaxRequest, "application/json");
      J.send$1$x(this.ajaxRequest, null);
    }, "call$0", "get$load", 0, 0, 54, "load"],
    onAtlasLoaded$1: [function(e) {
      var result, lineCount, currentImageId, currentFrame, nameInNextLine, i, t1, text, realSize, j, textureUrl, frameData, t2, t3, rect, t4, t5, t6;
      if (J.get$readyState$x(this.ajaxRequest) === 4)
        if (J.get$status$x(this.ajaxRequest) === 200 || J.indexOf$1$asx(window.location.href, "http") === -1) {
          this.atlas = P.LinkedHashMap_LinkedHashMap$_literal(["meta", P.LinkedHashMap_LinkedHashMap$_literal(["image", []], null, null), "frames", []], null, null);
          result = J.split$1$s(J.get$responseText$x(this.ajaxRequest), $.get$Loader_resultReg());
          for (lineCount = -3, currentImageId = 0, currentFrame = null, nameInNextLine = false, i = 0; i < result.length; ++i) {
            t1 = J.replaceAll$2$s(result[i], $.get$Loader_resultSplit(), "");
            if (i >= result.length)
              return H.ioore(result, i);
            result[i] = t1;
            if (J.$eq(t1, ""))
              nameInNextLine = i + 1;
            if (i >= result.length)
              return H.ioore(result, i);
            if (J.$gt$n(J.get$length$asx(result[i]), 0)) {
              if (nameInNextLine === i) {
                t1 = J.$index$asx(J.$index$asx(this.atlas, "meta"), "image");
                if (i >= result.length)
                  return H.ioore(result, i);
                J.add$1$ax(t1, result[i]);
                currentImageId = J.$sub$n(J.get$length$asx(J.$index$asx(J.$index$asx(this.atlas, "meta"), "image")), 1);
                J.add$1$ax(J.$index$asx(this.atlas, "frames"), P.LinkedHashMap_LinkedHashMap$_empty(null, null));
                lineCount = -3;
              } else if (lineCount > 0) {
                t1 = C.JSInt_methods.$mod(lineCount, 7);
                if (t1 === 1) {
                  if (currentFrame != null)
                    J.$indexSet$ax(J.$index$asx(J.$index$asx(this.atlas, "frames"), currentImageId), currentFrame.get$name(currentFrame), currentFrame);
                  if (i >= result.length)
                    return H.ioore(result, i);
                  currentFrame = P.LinkedHashMap_LinkedHashMap$_literal(["name", result[i], "frame", P.LinkedHashMap_LinkedHashMap$_empty(null, null)], null, null);
                } else {
                  if (i >= result.length)
                    return H.ioore(result, i);
                  text = J.split$1$s(result[i], " ");
                  if (t1 === 3) {
                    t1 = currentFrame.get$frame();
                    if (1 >= text.length)
                      return H.ioore(text, 1);
                    t1.set$x(0, H.Primitives_parseInt(J.replaceAll$2$s(text[1], ",", ""), null, null));
                    t1 = currentFrame.get$frame();
                    if (2 >= text.length)
                      return H.ioore(text, 2);
                    t1.set$y(0, H.Primitives_parseInt(text[2], null, null));
                  } else if (t1 === 4) {
                    t1 = currentFrame.get$frame();
                    if (1 >= text.length)
                      return H.ioore(text, 1);
                    t1.set$w(H.Primitives_parseInt(J.replaceAll$2$s(text[1], ",", ""), null, null));
                    t1 = currentFrame.get$frame();
                    if (2 >= text.length)
                      return H.ioore(text, 2);
                    t1.set$h(H.Primitives_parseInt(text[2], null, null));
                  } else if (t1 === 5) {
                    if (1 >= text.length)
                      return H.ioore(text, 1);
                    t1 = H.Primitives_parseInt(J.replaceAll$2$s(text[1], ",", ""), null, null);
                    if (2 >= text.length)
                      return H.ioore(text, 2);
                    realSize = P.LinkedHashMap_LinkedHashMap$_literal(["x", 0, "y", 0, "w", t1, "h", H.Primitives_parseInt(text[2], null, null)], null, null);
                    if (J.$gt$n(realSize.$index(0, "w"), currentFrame.get$frame().get$w()) || J.$gt$n(realSize.$index(0, "h"), currentFrame.get$frame().get$h())) {
                      currentFrame.set$trimmed(true);
                      currentFrame.set$realSize(realSize);
                    } else
                      currentFrame.set$trimmed(false);
                  }
                }
              }
              ++lineCount;
            }
          }
          if (currentFrame != null)
            J.$indexSet$ax(J.$index$asx(J.$index$asx(this.atlas, "frames"), currentImageId), currentFrame.get$name(currentFrame), currentFrame);
          if (J.$gt$n(J.get$length$asx(J.$index$asx(J.$index$asx(this.atlas, "meta"), "image")), 0)) {
            this.images = [];
            j = 0;
            while (true) {
              t1 = J.get$length$asx(J.$index$asx(J.$index$asx(this.atlas, "meta"), "image"));
              if (typeof t1 !== "number")
                return H.iae(t1);
              if (!(j < t1))
                break;
              textureUrl = J.$add$ns(this.baseUrl, J.$index$asx(J.$index$asx(J.$index$asx(this.atlas, "meta"), "image"), j));
              frameData = J.$index$asx(J.$index$asx(this.atlas, "frames"), j);
              t1 = this.images;
              t2 = this.crossorigin;
              t3 = new M.ImageLoader(null, [], textureUrl, t2, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
              t3.baseUrl = J.replaceFirst$2$s(textureUrl, $.get$Loader_baseReg(), "");
              t3.PIXI$ImageLoader$texture = M.Texture_fromImage(textureUrl, t2, null);
              J.add$1$ax(t1, t3);
              for (t1 = J.getInterceptor$ax(frameData), t2 = t1.get$iterator(frameData); t2.moveNext$0();) {
                i = t2.get$current();
                rect = t1.$index(frameData, i).get$frame();
                if (rect === true) {
                  t3 = $.get$TextureCache();
                  t4 = J.$index$asx(this.images, j).get$texture().get$baseTexture();
                  t5 = new M.Rectangle0(0, 0, 0, 0);
                  t6 = J.getInterceptor$x(rect);
                  t5.x = t6.get$x(rect);
                  t5.y = t6.get$y(rect);
                  t5.width = rect.get$w();
                  t5.height = rect.get$h();
                  J.$indexSet$ax(t3, i, M.Texture$(t4, t5));
                  if (t1.$index(frameData, i).get$trimmed() === true) {
                    J.$index$asx($.get$TextureCache(), i).set$realSize(t1.$index(frameData, i).get$realSize());
                    J.set$x$x(J.get$trim$s(J.$index$asx($.get$TextureCache(), i)), 0);
                    J.set$y$x(J.get$trim$s(J.$index$asx($.get$TextureCache(), i)), 0);
                  }
                }
              }
              ++j;
            }
            this.currentImageId = 0;
            j = 0;
            while (true) {
              t1 = J.get$length$asx(this.images);
              if (typeof t1 !== "number")
                return H.iae(t1);
              if (!(j < t1))
                break;
              J.addEventListener$2$x(J.$index$asx(this.images, j), "loaded", this.get$onLoaded());
              ++j;
            }
            J.load$0$x(J.$index$asx(this.images, this.currentImageId));
          } else
            this.onLoaded$0();
        } else
          this.onError$0(0);
    }, "call$1", "get$onAtlasLoaded", 2, 0, 102, 356, [], "onAtlasLoaded"],
    onLoaded$0: [function() {
      if (J.$gt$n(J.$sub$n(J.get$length$asx(this.images), 1), this.currentImageId)) {
        var t1 = J.$add$ns(this.currentImageId, 1);
        this.currentImageId = t1;
        J.load$0$x(J.$index$asx(this.images, t1));
      } else {
        this.loaded = true;
        t1 = new M.PixiEvent(null, null, null);
        t1.type = "loaded";
        t1.content = this;
        this.dispatchEvent$1(0, t1);
      }
    }, "call$0", "get$onLoaded", 0, 0, 54, "onLoaded"],
    onError$0: [function(_) {
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "error";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onError", 0, 0, 54, "onError"],
    static: {AtlasLoader$: [function(url, crossorigin) {
        var t1 = new M.AtlasLoader(null, null, 0, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        return t1;
      }, null, null, 4, 0, 135, 127, [], 73, [], "new AtlasLoader"]}
  },
  "+AtlasLoader": [854],
  BitmapFontLoader: {
    "^": "Loader0;baseUrl:PIXI$BitmapFontLoader$baseUrl@-644,url-644,crossorigin-617,baseUrl-644,ajaxRequest-852,loaded-617,texture-853,listeners-848",
    load$0: [function(_) {
      var t1 = new XMLHttpRequest();
      this.ajaxRequest = t1;
      t1 = C.HttpRequest_methods.get$onReadyStateChange(t1);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$onXMLLoaded()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      J.open$3$async$x(this.ajaxRequest, "GET", this.url, true);
      J.send$1$x(this.ajaxRequest, null);
    }, "call$0", "get$load", 0, 0, 54, "load"],
    onXMLLoaded$1: [function(e) {
      var responseXML, t1, t2, textureUrl, image, data, info, common, letters, i, charCode, t3, t4, t5, t6, t7, kernings, first, second, amount;
      if (J.get$readyState$x(this.ajaxRequest) === 4)
        if (J.get$status$x(this.ajaxRequest) === 200 || J.indexOf$1$asx(window.location.protocol, "http") === -1) {
          responseXML = J.get$responseXml$x(this.ajaxRequest);
          if (responseXML == null)
            throw H.wrapException(P.Exception_Exception("can not load font."));
          t1 = this.PIXI$BitmapFontLoader$baseUrl;
          t2 = responseXML.getElementsByTagName("page");
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          textureUrl = J.$add$ns(t1, J.getAttribute$1$x(t2[0], "file"));
          t2 = this.crossorigin;
          image = new M.ImageLoader(null, [], textureUrl, t2, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
          image.baseUrl = J.replaceFirst$2$s(textureUrl, $.get$Loader_baseReg(), "");
          t2 = M.Texture_fromImage(textureUrl, t2, null);
          image.PIXI$ImageLoader$texture = t2;
          this.texture = t2.get$baseTexture();
          data = new M.ChartData(null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
          t2 = responseXML.getElementsByTagName("info");
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          info = t2[0];
          t2 = responseXML.getElementsByTagName("common");
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          common = t2[0];
          t2 = J.getInterceptor$x(info);
          data.font = t2.getAttribute$1(info, "face");
          data.size = H.Primitives_parseInt(t2.getAttribute$1(info, "size"), null, null);
          data.lineHeight = H.Primitives_parseInt(J.getAttribute$1$x(common, "lineHeight"), null, null);
          letters = responseXML.getElementsByTagName("char");
          for (i = 0; i < letters.length; ++i) {
            charCode = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "id"), null, null);
            if (i >= letters.length)
              return H.ioore(letters, i);
            t1 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "x"), null, null);
            if (i >= letters.length)
              return H.ioore(letters, i);
            t2 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "y"), null, null);
            if (i >= letters.length)
              return H.ioore(letters, i);
            t3 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "width"), null, null);
            if (i >= letters.length)
              return H.ioore(letters, i);
            t4 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "height"), null, null);
            t5 = data.chars;
            t6 = new M.Char(null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            if (i >= letters.length)
              return H.ioore(letters, i);
            t6.xOffset = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "xoffset"), null, null);
            if (i >= letters.length)
              return H.ioore(letters, i);
            t6.yOffset = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "yoffset"), null, null);
            if (i >= letters.length)
              return H.ioore(letters, i);
            t6.xAdvance = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "xadvance"), null, null);
            t7 = $.get$TextureCache();
            t4 = M.Texture$(this.texture, new M.Rectangle0(t1, t2, t3, t4));
            J.$indexSet$ax(t7, charCode, t4);
            t6.texture = t4;
            J.$indexSet$ax(t5, charCode, t6);
          }
          kernings = responseXML.getElementsByTagName("kerning");
          for (i = 0; i < kernings.length; ++i) {
            first = H.Primitives_parseInt(J.getAttribute$1$x(kernings[i], "first"), null, null);
            if (i >= kernings.length)
              return H.ioore(kernings, i);
            second = H.Primitives_parseInt(J.getAttribute$1$x(kernings[i], "second"), null, null);
            if (i >= kernings.length)
              return H.ioore(kernings, i);
            amount = H.Primitives_parseInt(J.getAttribute$1$x(kernings[i], "amount"), null, null);
            J.$indexSet$ax(J.$index$asx(data.chars, second).get$kernings(), first, amount);
          }
          J.$indexSet$ax($.get$BitmapText_fonts(), data.font, data);
          image.addEventListener$2(0, "loaded", new M.BitmapFontLoader_onXMLLoaded_closure(this));
          image.load$0(0);
        }
    }, "call$1", "get$onXMLLoaded", 2, 0, 102, 356, [], "onXMLLoaded"],
    onLoaded$0: [function() {
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "loaded";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onLoaded", 0, 0, 54, "onLoaded"],
    static: {BitmapFontLoader$: [function(url, crossorigin) {
        var t1 = new M.BitmapFontLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.PIXI$BitmapFontLoader$baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        return t1;
      }, null, null, 4, 0, 135, 127, [], 73, [], "new BitmapFontLoader"]}
  },
  "+BitmapFontLoader": [854],
  BitmapFontLoader_onXMLLoaded_closure: {
    "^": "Closure:102;scope_0",
    call$1: [function(e) {
      var t1, t2;
      t1 = this.scope_0;
      t2 = new M.PixiEvent(null, null, null);
      t2.type = "loaded";
      t2.content = t1;
      t1.dispatchEvent$1(0, t2);
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  ImageLoader: {
    "^": "Loader0;texture:PIXI$ImageLoader$texture@-698,frames@-697,url-644,crossorigin-617,baseUrl-644,ajaxRequest-852,loaded-617,texture-853,listeners-848",
    load$0: [function(_) {
      if (this.PIXI$ImageLoader$texture.get$baseTexture().get$hasLoaded() !== true)
        J.addEventListener$2$x(this.PIXI$ImageLoader$texture.get$baseTexture(), "loaded", new M.ImageLoader_load_closure(this));
      else
        this.onLoaded$0();
    }, "call$0", "get$load", 0, 0, 54, "load"],
    onLoaded$0: [function() {
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "loaded";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onLoaded", 0, 0, 54, "onLoaded"],
    loadFramedSpriteSheet$3: [function(frameWidth, frameHeight, textureName) {
      var cols, rows, t1, t2, i, y, x, t3, t4, texture;
      this.frames = [];
      cols = J.floor$0$n(J.$div$n(J.get$width$x(this.PIXI$ImageLoader$texture), frameWidth));
      rows = J.floor$0$n(J.$div$n(J.get$height$x(this.PIXI$ImageLoader$texture), frameHeight));
      for (t1 = textureName === true, t2 = J.getInterceptor$ns(textureName), i = 0, y = 0; y < rows; ++y)
        for (x = 0; x < cols; ++x, ++i) {
          t3 = this.PIXI$ImageLoader$texture;
          t4 = new M.Rectangle0(0, 0, 0, 0);
          if (typeof frameWidth !== "number")
            return H.iae(frameWidth);
          t4.x = x * frameWidth;
          if (typeof frameHeight !== "number")
            return H.iae(frameHeight);
          t4.y = y * frameHeight;
          t4.width = frameWidth;
          t4.height = frameHeight;
          texture = M.Texture$(t3, t4);
          J.add$1$ax(this.frames, texture);
          if (t1)
            J.$indexSet$ax($.get$TextureCache(), J.$add$ns(t2.$add(textureName, "-"), i), texture);
        }
      if (this.PIXI$ImageLoader$texture.get$baseTexture().get$hasLoaded() !== true)
        J.addEventListener$2$x(this.PIXI$ImageLoader$texture.get$baseTexture(), "loaded", new M.ImageLoader_loadFramedSpriteSheet_closure(this));
      else
        this.onLoaded$0();
    }, "call$3", "get$loadFramedSpriteSheet", 6, 0, 155, 270, [], 271, [], 855, [], "loadFramedSpriteSheet"],
    static: {ImageLoader$: [function(url, crossorigin) {
        var t1 = new M.ImageLoader(null, [], url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        t1.PIXI$ImageLoader$texture = M.Texture_fromImage(url, crossorigin, null);
        return t1;
      }, null, null, 4, 0, 135, 127, [], 73, [], "new ImageLoader"]}
  },
  "+ImageLoader": [854],
  ImageLoader_load_closure: {
    "^": "Closure:102;this_0",
    call$1: [function(e) {
      this.this_0.onLoaded$0();
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  ImageLoader_loadFramedSpriteSheet_closure: {
    "^": "Closure:102;scope_0",
    call$1: [function(e) {
      this.scope_0.onLoaded$0();
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  JsonLoader: {
    "^": "Loader0;json@-783,url-644,crossorigin-617,baseUrl-644,ajaxRequest-852,loaded-617,texture-853,listeners-848",
    json$3: function(arg0, arg1, arg2) {
      return this.json.call$3(arg0, arg1, arg2);
    },
    load$0: [function(_) {
      var t1 = new XMLHttpRequest();
      this.ajaxRequest = t1;
      C.HttpRequest_methods.get$onLoad(t1).listen$1(new M.JsonLoader_load_closure(this));
      J.open$3$async$x(this.ajaxRequest, "GET", this.url, true);
      J.send$0$x(this.ajaxRequest);
    }, "call$0", "get$load", 0, 0, 54, "load"],
    onJSONLoaded$0: [function() {
      var t1, textureUrl, image, frameData, t2, i, rect, t3, t4, t5, t6, actualSize, realSize, skeletonData;
      if (J.get$responseText$x(this.ajaxRequest) == null) {
        this.onError$0(0);
        return;
      }
      t1 = C.JsonCodec_null_null.decode$1(J.get$responseText$x(this.ajaxRequest));
      this.json = t1;
      if (J.$index$asx(t1, "frames") != null) {
        textureUrl = J.$add$ns(this.baseUrl, J.$index$asx(J.$index$asx(this.json, "meta"), "image"));
        t1 = this.crossorigin;
        image = new M.ImageLoader(null, [], textureUrl, t1, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        image.baseUrl = J.replaceFirst$2$s(textureUrl, $.get$Loader_baseReg(), "");
        t1 = M.Texture_fromImage(textureUrl, t1, null);
        image.PIXI$ImageLoader$texture = t1;
        frameData = J.$index$asx(this.json, "frames");
        this.texture = t1.get$baseTexture();
        image.addEventListener$2(0, "loaded", new M.JsonLoader_onJSONLoaded_closure(this));
        for (t1 = J.getInterceptor$x(frameData), t2 = J.get$iterator$ax(t1.get$keys(frameData)); t2.moveNext$0();) {
          i = t2.get$current();
          rect = J.$index$asx(t1.$index(frameData, i), "frame");
          if (rect != null) {
            t3 = $.get$TextureCache();
            t4 = this.texture;
            t5 = new M.Rectangle0(0, 0, 0, 0);
            t6 = J.getInterceptor$asx(rect);
            t5.x = t6.$index(rect, "x");
            t5.y = t6.$index(rect, "y");
            t5.width = t6.$index(rect, "w");
            t5.height = t6.$index(rect, "h");
            J.$indexSet$ax(t3, i, M.Texture$(t4, t5));
            J.$index$asx($.get$TextureCache(), i).set$crop(new M.Rectangle0(t6.$index(rect, "x"), t6.$index(rect, "y"), t6.$index(rect, "w"), t6.$index(rect, "h")));
            if (J.$index$asx(t1.$index(frameData, i), "trimmed") === true) {
              actualSize = J.$index$asx(t1.$index(frameData, i), "sourceSize");
              realSize = J.$index$asx(t1.$index(frameData, i), "spriteSourceSize");
              t3 = J.getInterceptor$asx(realSize);
              t4 = J.getInterceptor$asx(actualSize);
              J.set$trim$s(J.$index$asx($.get$TextureCache(), i), new M.Rectangle0(t3.$index(realSize, "x"), t3.$index(realSize, "y"), t4.$index(actualSize, "w"), t4.$index(actualSize, "h")));
            }
          }
        }
        image.load$0(0);
      } else if (J.$index$asx(this.json, "bones") != null) {
        skeletonData = new M.SkeletonJson(null, 1).readSkeletonData$1(this.json);
        J.$indexSet$ax($.get$AnimCache(), this.url, skeletonData);
        this.onLoaded$0();
      } else
        this.onLoaded$0();
    }, "call$0", "get$onJSONLoaded", 0, 0, 54, "onJSONLoaded"],
    onLoaded$0: [function() {
      this.loaded = true;
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "loaded";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onLoaded", 0, 0, 54, "onLoaded"],
    onError$0: [function(_) {
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "error";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onError", 0, 0, 54, "onError"],
    static: {JsonLoader$: [function(url, crossorigin) {
        var t1 = new M.JsonLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        return t1;
      }, null, null, 4, 0, 135, 127, [], 73, [], "new JsonLoader"]}
  },
  "+JsonLoader": [854],
  JsonLoader_load_closure: {
    "^": "Closure:102;this_0",
    call$1: [function(e) {
      this.this_0.onJSONLoaded$0();
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  JsonLoader_onJSONLoaded_closure: {
    "^": "Closure:102;this_0",
    call$1: [function(e) {
      this.this_0.onLoaded$0();
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  Loader0: {
    "^": "EventTarget0;url*-644,crossorigin@-617,baseUrl@-644,ajaxRequest@-852,loaded*-617,texture@-853,listeners-848",
    static: {"^": "Loader_baseReg@-813,Loader_resultReg@-813,Loader_resultSplit@-813", Loader$: [function(url, crossorigin) {
        var t1 = new M.Loader0(url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        return t1;
      }, null, null, 4, 0, 135, 127, [], 73, [], "new Loader"], Loader_Loader$loaderByType: [function(type, url, crossorigin) {
        var t1;
        switch (type) {
          case "jpg":
          case "jpeg":
          case "png":
          case "gif":
          case "webp":
            t1 = new M.ImageLoader(null, [], url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
            t1.PIXI$ImageLoader$texture = M.Texture_fromImage(url, crossorigin, null);
            return t1;
          case "json":
            t1 = new M.JsonLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
            return t1;
          case "atlas":
            t1 = new M.AtlasLoader(null, null, 0, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
            return t1;
          case "anim":
            t1 = new M.SpineLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
            return t1;
          case "xml":
          case "fnt":
            t1 = new M.BitmapFontLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            t1.PIXI$BitmapFontLoader$baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
            return t1;
          default:
            throw H.wrapException(P.Exception_Exception(H.S(type) + " is an unsupported file type"));
        }
      }, "call$3", null, 6, 0, 136, 137, [], 127, [], 73, [], "new Loader$loaderByType"]}
  },
  "+Loader": [850],
  SpineLoader: {
    "^": "Loader0;json@-12,url-644,crossorigin-617,baseUrl-644,ajaxRequest-852,loaded-617,texture-853,listeners-848",
    json$3: function(arg0, arg1, arg2) {
      return this.json.call$3(arg0, arg1, arg2);
    },
    load$0: [function(_) {
      var t1, jsonLoader;
      t1 = this.url;
      jsonLoader = new M.JsonLoader(null, t1, this.crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      jsonLoader.baseUrl = J.replaceFirst$2$s(t1, $.get$Loader_baseReg(), "");
      jsonLoader.addEventListener$2(0, "loaded", new M.SpineLoader_load_closure(this));
      jsonLoader.load$0(0);
    }, "call$0", "get$load", 0, 0, 54, "load"],
    onLoaded$0: [function() {
      this.loaded = true;
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "loaded";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onLoaded", 0, 0, 54, "onLoaded"],
    static: {SpineLoader$: [function(url, crossorigin) {
        var t1 = new M.SpineLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        return t1;
      }, null, null, 4, 0, 135, 127, [], 73, [], "new SpineLoader"]}
  },
  "+SpineLoader": [854],
  SpineLoader_load_closure: {
    "^": "Closure:705;scope_0",
    call$1: [function($event) {
      var t1, t2;
      t1 = this.scope_0;
      t1.json = J.get$content$x($event).get$json();
      t1.loaded = true;
      t2 = new M.PixiEvent(null, null, null);
      t2.type = "loaded";
      t2.content = t1;
      t1.dispatchEvent$1(0, t2);
    }, "call$1", null, 2, 0, 705, 666, [], "call"]
  },
  SpriteSheetLoader: {
    "^": "Loader0;json@-12,url-644,crossorigin-617,baseUrl-644,ajaxRequest-852,loaded-617,texture-853,listeners-848",
    json$3: function(arg0, arg1, arg2) {
      return this.json.call$3(arg0, arg1, arg2);
    },
    load$0: [function(_) {
      var t1, jsonLoader;
      t1 = this.url;
      jsonLoader = new M.JsonLoader(null, t1, this.crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      jsonLoader.baseUrl = J.replaceFirst$2$s(t1, $.get$Loader_baseReg(), "");
      jsonLoader.addEventListener$2(0, "loaded", new M.SpriteSheetLoader_load_closure(this));
      jsonLoader.load$0(0);
    }, "call$0", "get$load", 0, 0, 54, "load"],
    onLoaded$0: [function() {
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "loaded";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onLoaded", 0, 0, 54, "onLoaded"],
    static: {SpriteSheetLoader$: [function(url, crossorigin) {
        var t1 = new M.SpriteSheetLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        return t1;
      }, null, null, 4, 0, 135, 127, [], 73, [], "new SpriteSheetLoader"]}
  },
  "+SpriteSheetLoader": [854],
  SpriteSheetLoader_load_closure: {
    "^": "Closure:705;scope_0",
    call$1: [function($event) {
      var t1, t2;
      t1 = this.scope_0;
      t1.json = J.get$content$x($event).get$json();
      t2 = new M.PixiEvent(null, null, null);
      t2.type = "loaded";
      t2.content = t1;
      t1.dispatchEvent$1(0, t2);
    }, "call$1", null, 2, 0, 705, 666, [], "call"]
  },
  BlendModes: {
    "^": "Object;value>-614",
    static: {"^": "BlendModes_NORMAL<-12,BlendModes_ADD<-12,BlendModes_MULTIPLY<-12,BlendModes_SCREEN<-12,BlendModes_OVERLAY<-12,BlendModes_DARKEN<-12,BlendModes_LIGHTEN<-12,BlendModes_COLOR_DODGE<-12,BlendModes_COLOR_BURN<-12,BlendModes_HARD_LIGHT<-12,BlendModes_SOFT_LIGHT<-12,BlendModes_DIFFERENCE<-12,BlendModes_EXCLUSION<-12,BlendModes_HUE<-12,BlendModes_SATURATION<-12,BlendModes_COLOR<-12,BlendModes_LUMINOSITY<-12,BlendModes_NONE<-12", BlendModes$_: [function(value) {
        return new M.BlendModes(value);
      }, null, null, 2, 0, 99, 138, [], "new BlendModes$_"]}
  },
  "+BlendModes": [674],
  scaleModes: {
    "^": "Object;value>-614",
    static: {"^": "scaleModes_DEFAULT<-12,scaleModes_LINEAR<-12,scaleModes_NEAREST<-12", scaleModes$_: [function(value) {
        return new M.scaleModes(value);
      }, null, null, 2, 0, 99, 138, [], "new scaleModes$_"]}
  },
  "+scaleModes": [674],
  GraphicsData: {
    "^": "Object;points*-709,fillAlpha@-616,fillColor@-616,fill*-617,lineWidth*-616,lineAlpha@-616,lineColor@-616,type*-614",
    fill$0: function($receiver) {
      return this.fill.call$0();
    },
    fill$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.fill.call$4(arg0, arg1, arg2, arg3);
    },
    fill$6: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5) {
      return this.fill.call$6(arg0, arg1, arg2, arg3, arg4, arg5);
    },
    static: {GraphicsData$: [function() {
        return new M.GraphicsData([], 1, 0, null, 1, 1, 0, $.Graphics_POLY);
      }, null, null, 0, 0, 139, "new GraphicsData"]}
  },
  "+GraphicsData": [674],
  Graphics0: {
    "^": "DisplayObjectContainer;fillAlpha@-616,lineWidth*-616,lineColor@-616,fillColor@-616,filling@-617,lineAlpha@-616,_graphicsData<-856,tint@-614,blendMode@-702,_currentPath@-857,_webGL@-858,_isMask@-617,bounds@-659,boundsPadding@-614,clearDirty@-617,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    set$cacheAsBitmap: [function(value) {
      if (J.$eq(this._cacheAsBitmap, value))
        return;
      if (value === true)
        this._generateCachedSprite$0();
      else {
        this._cachedSprite.get$texture().destroy$1(true);
        this._cachedSprite = null;
      }
      this._cacheAsBitmap = value;
    }, null, null, 3, 0, 639, 138, [], "cacheAsBitmap"],
    lineStyle$3: [function(lineWidth, color, alpha) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      this.lineWidth = lineWidth;
      this.lineColor = color;
      this.lineAlpha = alpha;
      t1 = $.Graphics_POLY;
      t2 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, t1);
      t2.lineWidth = lineWidth;
      t2.lineColor = color;
      t2.lineAlpha = alpha;
      t2.fillColor = this.fillColor;
      t2.fillAlpha = this.fillAlpha;
      t2.fill = this.filling;
      t2.points = [];
      t2.type = t1;
      this._currentPath = t2;
      J.add$1$ax(this._graphicsData, t2);
      return this;
    }, function(lineWidth) {
      return this.lineStyle$3(lineWidth, 0, 1);
    }, "lineStyle$1", function(lineWidth, color) {
      return this.lineStyle$3(lineWidth, color, 1);
    }, "lineStyle$2", function() {
      return this.lineStyle$3(0, 0, 1);
    }, "lineStyle$0", "call$3", "call$1", "call$2", "call$0", "get$lineStyle", 0, 6, 859, 49, 49, 433, 860, [], 152, [], 567, [], "lineStyle"],
    moveTo$2: [function(_, x, y) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      t1 = $.Graphics_POLY;
      t2 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, t1);
      t2.lineWidth = this.lineWidth;
      t2.lineColor = this.lineColor;
      t2.lineAlpha = this.lineAlpha;
      t2.fillColor = this.fillColor;
      t2.fillAlpha = this.fillAlpha;
      t2.fill = this.filling;
      t2.points = [];
      t2.type = t1;
      this._currentPath = t2;
      J.addAll$1$ax(t2.points, [x, y]);
      J.add$1$ax(this._graphicsData, this._currentPath);
      return this;
    }, "call$2", "get$moveTo", 4, 0, 861, 9, [], 10, [], "moveTo"],
    lineTo$2: [function(_, x, y) {
      J.addAll$1$ax(J.get$points$x(this._currentPath), [x, y]);
      this._dirty = true;
      return this;
    }, "call$2", "get$lineTo", 4, 0, 861, 9, [], 10, [], "lineTo"],
    quadraticCurveTo$4: [function(_, cpX, cpY, toX, toY) {
      var points, t1, fromX, fromY, t2, t3, t4, t5, t6, t7, i, j, xa, ya;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0))
        this.moveTo$2(0, 0, 0);
      points = J.get$points$x(this._currentPath);
      t1 = J.getInterceptor$asx(points);
      if (J.$eq(t1.get$length(points), 0))
        this.moveTo$2(0, 0, 0);
      fromX = t1.$index(points, J.$sub$n(t1.get$length(points), 2));
      fromY = t1.$index(points, J.$sub$n(t1.get$length(points), 1));
      for (t2 = J.getInterceptor$n(cpX), t3 = J.getInterceptor$ns(fromX), t4 = J.getInterceptor$n(cpY), t5 = J.getInterceptor$ns(fromY), t6 = J.getInterceptor$n(toX), t7 = J.getInterceptor$n(toY), i = 1; i <= 20; ++i) {
        j = i / 20;
        xa = t3.$add(fromX, J.$mul$ns(t2.$sub(cpX, fromX), j));
        ya = t5.$add(fromY, J.$mul$ns(t4.$sub(cpY, fromY), j));
        t1.addAll$1(points, [J.$add$ns(xa, J.$mul$ns(J.$sub$n(t2.$add(cpX, J.$mul$ns(t6.$sub(toX, cpX), j)), xa), j)), J.$add$ns(ya, J.$mul$ns(J.$sub$n(t4.$add(cpY, J.$mul$ns(t7.$sub(toY, cpY), j)), ya), j))]);
      }
      this._dirty = true;
      return this;
    }, "call$4", "get$quadraticCurveTo", 8, 0, 862, 176, [], 177, [], 178, [], 179, [], "quadraticCurveTo"],
    bezierCurveTo$6: [function(_, cpX, cpY, cpX2, cpY2, toX, toY) {
      var points, t1, fromX, fromY, i, j, dt, dt2, dt3, t2, t3, t4;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0))
        this.moveTo$2(0, 0, 0);
      points = J.get$points$x(this._currentPath);
      t1 = J.getInterceptor$asx(points);
      fromX = t1.$index(points, J.$sub$n(t1.get$length(points), 2));
      fromY = t1.$index(points, J.$sub$n(t1.get$length(points), 1));
      for (i = 1; i < 20; ++i) {
        j = i / 20;
        dt = 1 - j;
        dt2 = dt * dt;
        dt3 = dt2 * dt;
        t2 = j * j;
        t3 = t2 * j;
        if (typeof fromX !== "number")
          return H.iae(fromX);
        t4 = 3 * dt2 * j;
        if (typeof cpX !== "number")
          return H.iae(cpX);
        t2 = 3 * dt * t2;
        if (typeof cpX2 !== "number")
          return H.iae(cpX2);
        if (typeof toX !== "number")
          return H.iae(toX);
        if (typeof fromY !== "number")
          return H.iae(fromY);
        if (typeof cpY !== "number")
          return H.iae(cpY);
        if (typeof cpY2 !== "number")
          return H.iae(cpY2);
        if (typeof toY !== "number")
          return H.iae(toY);
        t1.addAll$1(points, [dt3 * fromX + t4 * cpX + t2 * cpX2 + t3 * toX, dt3 * fromY + t4 * cpY + t2 * cpY2 + t3 * toY]);
      }
      this._dirty = true;
      return this;
    }, "call$6", "get$bezierCurveTo", 12, 0, 863, 176, [], 177, [], 864, [], 865, [], 178, [], 179, [], "bezierCurveTo"],
    arcTo$5: [function(_, x1, y1, x2, y2, radius) {
      var points, t1, fromX, a1, b1, a2, b2, t2, t3, mm, dd, t4, cc, tt, t5, k1, k2, j1, t6, j2, cx, cy, px, py, qx, qy, startAngle, endAngle;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0))
        this.moveTo$2(0, x1, y1);
      points = J.get$points$x(this._currentPath);
      t1 = J.getInterceptor$asx(points);
      fromX = t1.$index(points, J.$sub$n(t1.get$length(points), 2));
      a1 = J.$sub$n(t1.$index(points, J.$sub$n(t1.get$length(points), 1)), y1);
      b1 = J.$sub$n(fromX, x1);
      a2 = J.$sub$n(y2, y1);
      b2 = J.$sub$n(x2, x1);
      t2 = J.getInterceptor$ns(a1);
      t3 = J.getInterceptor$ns(b1);
      mm = J.abs$0$n(J.$sub$n(t2.$mul(a1, b2), t3.$mul(b1, a2)));
      if (J.$lt$n(mm, 1e-8) || J.$eq(radius, 0))
        t1.addAll$1(points, [x1, y1]);
      else {
        dd = J.$add$ns(t2.$mul(a1, a1), t3.$mul(b1, b1));
        t1 = J.getInterceptor$ns(a2);
        t4 = J.getInterceptor$ns(b2);
        cc = J.$add$ns(t1.$mul(a2, a2), t4.$mul(b2, b2));
        tt = J.$add$ns(t2.$mul(a1, a2), t3.$mul(b1, b2));
        t5 = J.getInterceptor$ns(radius);
        k1 = J.$div$n(t5.$mul(radius, Math.sqrt(H.checkNum(dd))), mm);
        k2 = J.$div$n(t5.$mul(radius, Math.sqrt(H.checkNum(cc))), mm);
        t5 = J.getInterceptor$ns(k1);
        j1 = J.$div$n(t5.$mul(k1, tt), dd);
        t6 = J.getInterceptor$ns(k2);
        j2 = J.$div$n(t6.$mul(k2, tt), cc);
        cx = J.$add$ns(t5.$mul(k1, b2), t6.$mul(k2, b1));
        cy = J.$add$ns(t5.$mul(k1, a2), t6.$mul(k2, a1));
        px = t3.$mul(b1, t6.$add(k2, j1));
        py = t2.$mul(a1, t6.$add(k2, j1));
        qx = t4.$mul(b2, t5.$add(k1, j2));
        qy = t1.$mul(a2, t5.$add(k1, j2));
        t5 = J.$sub$n(py, cy);
        t1 = J.$sub$n(px, cx);
        startAngle = Math.atan2(H.checkNum(t5), H.checkNum(t1));
        t1 = J.$sub$n(qy, cy);
        t5 = J.$sub$n(qx, cx);
        endAngle = Math.atan2(H.checkNum(t1), H.checkNum(t5));
        this.arc$6(0, J.$add$ns(cx, x1), J.$add$ns(cy, y1), radius, startAngle, endAngle, J.$gt$n(t3.$mul(b1, a2), t4.$mul(b2, a1)));
      }
      this._dirty = true;
      return this;
    }, "call$5", "get$arcTo", 10, 0, 866, 351, [], 352, [], 353, [], 354, [], 50, [], "arcTo"],
    arc$6: [function(_, cx, cy, radius, startAngle, endAngle, anticlockwise) {
      var t1, startX, startY, points, t2, sweep, segs, theta, theta2, cTheta, sTheta, segMinus, remainder, t3, i, angle, t4, c, s;
      t1 = Math.cos(H.checkNum(startAngle));
      if (typeof radius !== "number")
        return H.iae(radius);
      startX = J.$add$ns(cx, t1 * radius);
      startY = J.$add$ns(cy, Math.sin(H.checkNum(startAngle)) * radius);
      points = J.get$points$x(this._currentPath);
      t1 = J.getInterceptor$asx(points);
      if (!J.$eq(t1.get$length(points), 0) && !J.$eq(t1.$index(points, J.$sub$n(t1.get$length(points), 2)), startX) || !J.$eq(t1.$index(points, J.$sub$n(t1.get$length(points), 1)), startY)) {
        this.moveTo$2(0, startX, startY);
        points = J.get$points$x(this._currentPath);
      }
      t1 = J.getInterceptor(startAngle);
      if (t1.$eq(startAngle, endAngle))
        return this;
      t2 = anticlockwise === true;
      if (!t2 && J.$le$n(endAngle, startAngle))
        endAngle = J.$add$ns(endAngle, 6.283185307179586);
      else if (t2 && t1.$le(startAngle, endAngle))
        startAngle = t1.$add(startAngle, 6.283185307179586);
      sweep = t2 ? J.$mul$ns(J.$sub$n(startAngle, endAngle), -1) : J.$sub$n(endAngle, startAngle);
      t1 = J.getInterceptor$n(sweep);
      segs = J.$div$n(t1.abs$0(sweep), 6.283185307179586) * 40;
      if (t1.$eq(sweep, 0))
        return this;
      theta = t1.$div(sweep, segs * 2);
      t1 = J.getInterceptor$ns(theta);
      theta2 = t1.$mul(theta, 2);
      cTheta = Math.cos(H.checkNum(theta));
      sTheta = Math.sin(H.checkNum(theta));
      segMinus = segs - 1;
      remainder = C.JSNumber_methods.$mod(segMinus, 1) / segMinus;
      for (t2 = J.getInterceptor$ax(points), t3 = J.getInterceptor$ns(theta2), i = 0; i <= segMinus; ++i) {
        angle = J.$add$ns(t1.$add(theta, startAngle), t3.$mul(theta2, i + remainder * i));
        t4 = typeof angle !== "number";
        if (t4)
          H.throwExpression(P.ArgumentError$(angle));
        c = Math.cos(angle);
        if (t4)
          H.throwExpression(P.ArgumentError$(angle));
        s = -Math.sin(angle);
        if (typeof cx !== "number")
          return H.iae(cx);
        if (typeof cy !== "number")
          return H.iae(cy);
        t2.addAll$1(points, [(cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy]);
      }
      this._dirty = true;
      return this;
    }, function($receiver, cx, cy, radius, startAngle, endAngle) {
      return this.arc$6($receiver, cx, cy, radius, startAngle, endAngle, false);
    }, "arc$5", "call$6", "call$5", "get$arc", 10, 2, 867, 19, 238, [], 239, [], 50, [], 868, [], 869, [], 870, [], "arc"],
    drawPath$1: [function(path) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      t1 = $.Graphics_POLY;
      t2 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, t1);
      t2.lineWidth = this.lineWidth;
      t2.lineColor = this.lineColor;
      t2.lineAlpha = this.lineAlpha;
      t2.fillColor = this.fillColor;
      t2.fillAlpha = this.fillAlpha;
      t2.fill = this.filling;
      t2.points = [];
      t2.type = t1;
      this._currentPath = t2;
      J.add$1$ax(this._graphicsData, t2);
      J.addAll$1$ax(J.get$points$x(this._currentPath), path);
      this._dirty = true;
      return this;
    }, "call$1", "get$drawPath", 2, 0, 871, 13, [], "drawPath"],
    beginFill$2: [function(color, alpha) {
      this.filling = true;
      this.fillColor = color;
      this.fillAlpha = alpha;
      return this;
    }, function(color) {
      return this.beginFill$2(color, 1);
    }, "beginFill$1", function() {
      return this.beginFill$2(null, 1);
    }, "beginFill$0", "call$2", "call$1", "call$0", "get$beginFill", 0, 4, 872, 12, 433, 152, [], 567, [], "beginFill"],
    endFill$0: [function() {
      this.filling = false;
      this.fillColor = null;
      this.fillAlpha = 1;
      return this;
    }, "call$0", "get$endFill", 0, 0, 678, "endFill"],
    drawRect$4: [function(x, y, width, height) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      t1 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, $.Graphics_POLY);
      t1.lineWidth = this.lineWidth;
      t1.lineColor = this.lineColor;
      t1.lineAlpha = this.lineAlpha;
      t1.fillColor = this.fillColor;
      t1.fillAlpha = this.fillAlpha;
      t1.fill = this.filling;
      t1.points = [x, y, width, height];
      t1.type = $.Graphics_RECT;
      this._currentPath = t1;
      J.add$1$ax(this._graphicsData, t1);
      this._dirty = true;
      return this;
    }, "call$4", "get$drawRect", 8, 0, 862, 9, [], 10, [], 31, [], 52, [], "drawRect"],
    drawRoundedRect$5: [function(x, y, width, height, radius) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      t1 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, $.Graphics_POLY);
      t1.lineWidth = this.lineWidth;
      t1.lineColor = this.lineColor;
      t1.lineAlpha = this.lineAlpha;
      t1.fillColor = this.fillColor;
      t1.fillAlpha = this.fillAlpha;
      t1.fill = this.filling;
      t1.points = [x, y, width, height, radius];
      t1.type = $.Graphics_RREC;
      this._currentPath = t1;
      J.add$1$ax(this._graphicsData, t1);
      this._dirty = true;
      return this;
    }, "call$5", "get$drawRoundedRect", 10, 0, 866, 9, [], 10, [], 31, [], 52, [], 50, [], "drawRoundedRect"],
    drawCircle$3: [function(x, y, radius) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      t1 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, $.Graphics_POLY);
      t1.lineWidth = this.lineWidth;
      t1.lineColor = this.lineColor;
      t1.lineAlpha = this.lineAlpha;
      t1.fillColor = this.fillColor;
      t1.fillAlpha = this.fillAlpha;
      t1.fill = this.filling;
      t1.points = [x, y, radius, radius];
      t1.type = $.Graphics_CIRC;
      this._currentPath = t1;
      J.add$1$ax(this._graphicsData, t1);
      this._dirty = true;
      return this;
    }, "call$3", "get$drawCircle", 6, 0, 873, 9, [], 10, [], 50, [], "drawCircle"],
    drawEllipse$4: [function(x, y, width, height) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      t1 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, $.Graphics_POLY);
      t1.lineWidth = this.lineWidth;
      t1.lineColor = this.lineColor;
      t1.lineAlpha = this.lineAlpha;
      t1.fillColor = this.fillColor;
      t1.fillAlpha = this.fillAlpha;
      t1.fill = this.filling;
      t1.points = [x, y, width, height];
      t1.type = $.Graphics_ELIP;
      this._currentPath = t1;
      J.add$1$ax(this._graphicsData, t1);
      this._dirty = true;
      return this;
    }, "call$4", "get$drawEllipse", 8, 0, 874, 9, [], 10, [], 31, [], 52, [], "drawEllipse"],
    clear$0: [function(_) {
      this.lineWidth = 0;
      this.filling = false;
      this._dirty = true;
      this.clearDirty = true;
      J.clear$0$ax(this._graphicsData);
      this.bounds = null;
      return this;
    }, "call$0", "get$clear", 0, 0, 678, "clear"],
    generateTexture$1: [function(renderer) {
      var bounds, t1, canvasBuffer, texture;
      bounds = this.getBounds$0();
      t1 = J.getInterceptor$x(bounds);
      canvasBuffer = M.CanvasBuffer$(t1.get$width(bounds), t1.get$height(bounds));
      texture = M.Texture$(M.BaseTexture_fromCanvas(canvasBuffer.canvas, null), null);
      J.translate$2$x(canvasBuffer.context, J.$negate$n(t1.get$x(bounds)), J.$negate$n(t1.get$y(bounds)));
      M.CanvasGraphics_renderGraphics(this, canvasBuffer.context);
      return texture;
    }, function() {
      return this.generateTexture$1(null);
    }, "generateTexture$0", "call$1", "call$0", "get$generateTexture", 0, 2, 875, 12, 213, [], "generateTexture"],
    _renderWebGL$1: [function(renderSession) {
      var blendModeWebGL, t1, j, i;
      if (J.$eq(this.visible, false) || J.$eq(this.alpha, 0) || J.$eq(this._isMask, true))
        return;
      if (this._cacheAsBitmap === true) {
        if (this._dirty === true) {
          this._generateCachedSprite$0();
          M.updateWebGLTexture(this._cachedSprite.get$texture().get$baseTexture(), renderSession.get$gl());
          this._dirty = false;
        }
        J.set$alpha$x(this._cachedSprite, this.alpha);
        this._cachedSprite._renderWebGL$1(renderSession);
        return;
      } else {
        J.stop$0$x(renderSession.get$spriteBatch());
        renderSession.get$blendModeManager().setBlendMode$1(this.blendMode);
        if (this._mask != null)
          renderSession.get$maskManager().pushMask$2(this._mask, renderSession);
        if (this._filters != null)
          renderSession.get$filterManager().pushFilter$1(this._filterBlock);
        if (!J.$eq(this.blendMode, renderSession.get$blendModeManager().get$currentBlendMode())) {
          renderSession.get$blendModeManager().set$currentBlendMode(this.blendMode);
          blendModeWebGL = J.$index$asx($.blendModesWebGL, renderSession.get$blendModeManager().get$currentBlendMode());
          t1 = J.getInterceptor$asx(blendModeWebGL);
          J.blendFunc$2$x(renderSession.get$spriteBatch().get$gl(), t1.$index(blendModeWebGL, 0), t1.$index(blendModeWebGL, 1));
        }
        M.WebGLGraphics_renderGraphics(this, renderSession);
        if (!J.$eq(J.get$length$asx(this.get$children(this)), 0)) {
          J.start$0$x(renderSession.get$spriteBatch());
          j = J.get$length$asx(this.get$children(this));
          if (typeof j !== "number")
            return H.iae(j);
          i = 0;
          for (; i < j; ++i)
            J.$index$asx(this.get$children(this), i)._renderWebGL$1(renderSession);
          J.stop$0$x(renderSession.get$spriteBatch());
        }
        if (this._filters != null)
          renderSession.get$filterManager().popFilter$0();
        if (this._mask != null)
          renderSession.get$maskManager().popMask$2(this._mask, renderSession);
        renderSession.set$drawCount(J.$add$ns(renderSession.get$drawCount(), 1));
        J.start$0$x(renderSession.get$spriteBatch());
      }
    }, "call$1", "get$_renderWebGL", 2, 0, 685, 166, [], "_renderWebGL"],
    _renderCanvas$1: [function(renderSession) {
      var t1, context, transform, j, i;
      if (J.$eq(this.visible, false) || J.$eq(this.alpha, 0) || J.$eq(this._isMask, true))
        return;
      t1 = J.getInterceptor$x(renderSession);
      context = t1.get$context(renderSession);
      transform = this._worldTransform;
      if (!J.$eq(this.blendMode, renderSession.get$currentBlendMode())) {
        renderSession.set$currentBlendMode(this.blendMode);
        J.set$globalCompositeOperation$x(context, J.$index$asx($.blendModesCanvas, renderSession.get$currentBlendMode()));
      }
      if (this._mask != null)
        renderSession.get$maskManager().pushMask$2(this._mask, t1.get$context(renderSession));
      J.setTransform$6$x(context, J.get$a$x(transform), transform.get$c(), transform.get$b(), transform.get$d(), transform.get$tx(), transform.get$ty());
      M.CanvasGraphics_renderGraphics(this, context);
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._renderCanvas$1(renderSession);
      if (this._mask != null)
        renderSession.get$maskManager().popMask$1(t1.get$context(renderSession));
    }, "call$1", "get$_renderCanvas", 2, 0, 685, 166, [], "_renderCanvas"],
    getBounds$1: [function(matrix) {
      var w0, w1, h0, h1, a, b, c, d, tx, ty, t1, t2, x1, t3, t4, y1, x2, y2, x3, y3, x4, y4, minX, minY, t5, t6, maxX, maxY, bounds;
      if (matrix == null)
        matrix = this._worldTransform;
      if (this.bounds == null)
        this._updateBounds$0();
      w0 = J.get$x$x(this.bounds);
      w1 = J.$add$ns(J.get$width$x(this.bounds), J.get$x$x(this.bounds));
      h0 = J.get$y$x(this.bounds);
      h1 = J.$add$ns(J.get$height$x(this.bounds), J.get$y$x(this.bounds));
      a = J.get$a$x(matrix);
      b = matrix.get$c();
      c = matrix.get$b();
      d = matrix.get$d();
      tx = matrix.get$tx();
      ty = matrix.get$ty();
      t1 = J.getInterceptor$ns(a);
      t2 = J.getInterceptor$ns(c);
      x1 = J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h1)), tx);
      t3 = J.getInterceptor$ns(d);
      t4 = J.getInterceptor$ns(b);
      y1 = J.$add$ns(J.$add$ns(t3.$mul(d, h1), t4.$mul(b, w1)), ty);
      x2 = J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h1)), tx);
      y2 = J.$add$ns(J.$add$ns(t3.$mul(d, h1), t4.$mul(b, w0)), ty);
      x3 = J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h0)), tx);
      y3 = J.$add$ns(J.$add$ns(t3.$mul(d, h0), t4.$mul(b, w0)), ty);
      x4 = J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h0)), tx);
      y4 = J.$add$ns(J.$add$ns(t3.$mul(d, h0), t4.$mul(b, w1)), ty);
      t1 = J.getInterceptor$n(x2);
      minX = t1.$lt(x2, x1) ? x2 : x1;
      t2 = J.getInterceptor$n(x3);
      if (t2.$lt(x3, minX))
        minX = x3;
      t3 = J.getInterceptor$n(x4);
      if (t3.$lt(x4, minX))
        minX = x4;
      t4 = J.getInterceptor$n(y2);
      minY = t4.$lt(y2, y1) ? y2 : y1;
      t5 = J.getInterceptor$n(y3);
      if (t5.$lt(y3, minY))
        minY = y3;
      t6 = J.getInterceptor$n(y4);
      if (t6.$lt(y4, minY))
        minY = y4;
      maxX = t1.$gt(x2, x1) ? x2 : x1;
      if (t2.$gt(x3, maxX))
        maxX = x3;
      if (t3.$gt(x4, maxX))
        maxX = x4;
      maxY = t4.$gt(y2, y1) ? y2 : y1;
      if (t5.$gt(y3, maxY))
        maxY = y3;
      if (t6.$gt(y4, maxY))
        maxY = y4;
      bounds = this._bounds;
      t1 = J.getInterceptor$x(bounds);
      t1.set$x(bounds, minX);
      t1.set$width(bounds, J.$sub$n(maxX, minX));
      t1.set$y(bounds, minY);
      t1.set$height(bounds, J.$sub$n(maxY, minY));
      return bounds;
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 682, 12, 580, [], "getBounds"],
    _updateBounds$0: [function() {
      var t1, t2, minX, maxX, minY, maxY, x, y, w, h, i, t3, data, type, lineWidth, points, t4, j, padding;
      t1 = this._graphicsData;
      t2 = J.getInterceptor$asx(t1);
      minX = 1 / 0;
      maxX = -1 / 0;
      minY = 1 / 0;
      maxY = -1 / 0;
      x = null;
      y = null;
      w = null;
      h = null;
      i = 0;
      while (true) {
        t3 = t2.get$length(t1);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        data = t2.$index(t1, i);
        t3 = J.getInterceptor$x(data);
        type = t3.get$type(data);
        lineWidth = t3.get$lineWidth(data);
        points = t3.get$points(data);
        t3 = J.getInterceptor(type);
        if (t3.$eq(type, $.Graphics_RECT) || t3.$eq(type, $.Graphics_RREC)) {
          t3 = J.getInterceptor$asx(points);
          t4 = J.getInterceptor$n(lineWidth);
          x = J.$sub$n(t3.$index(points, 0), t4.$div(lineWidth, 2));
          y = J.$sub$n(t3.$index(points, 1), t4.$div(lineWidth, 2));
          w = J.$add$ns(t3.$index(points, 2), lineWidth);
          h = J.$add$ns(t3.$index(points, 3), lineWidth);
          t3 = J.getInterceptor$n(x);
          if (t3.$lt(x, minX))
            minX = x;
          if (J.$gt$n(t3.$add(x, w), maxX))
            maxX = t3.$add(x, w);
          t3 = J.getInterceptor$n(y);
          if (t3.$lt(y, minY))
            minY = x;
          if (J.$gt$n(t3.$add(y, h), maxY))
            maxY = t3.$add(y, h);
        } else if (t3.$eq(type, $.Graphics_CIRC) || t3.$eq(type, $.Graphics_ELIP)) {
          t3 = J.getInterceptor$asx(points);
          x = t3.$index(points, 0);
          y = t3.$index(points, 1);
          t4 = J.getInterceptor$n(lineWidth);
          w = J.$add$ns(t3.$index(points, 2), t4.$div(lineWidth, 2));
          h = J.$add$ns(t3.$index(points, 3), t4.$div(lineWidth, 2));
          t3 = J.getInterceptor$n(x);
          if (J.$lt$n(t3.$sub(x, w), minX))
            minX = t3.$sub(x, w);
          if (J.$gt$n(t3.$add(x, w), maxX))
            maxX = t3.$add(x, w);
          t3 = J.getInterceptor$n(y);
          if (J.$lt$n(t3.$sub(y, h), minY))
            minY = t3.$sub(y, h);
          if (J.$gt$n(t3.$add(y, h), maxY))
            maxY = t3.$add(y, h);
        } else {
          t3 = J.getInterceptor$asx(points);
          j = 0;
          while (true) {
            t4 = t3.get$length(points);
            if (typeof t4 !== "number")
              return H.iae(t4);
            if (!(j < t4))
              break;
            x = t3.$index(points, j);
            y = t3.$index(points, j + 1);
            t4 = J.getInterceptor$n(x);
            if (J.$lt$n(t4.$sub(x, lineWidth), minX))
              minX = t4.$sub(x, lineWidth);
            if (J.$gt$n(t4.$add(x, lineWidth), maxX))
              maxX = t4.$add(x, lineWidth);
            t4 = J.getInterceptor$n(y);
            if (J.$lt$n(t4.$sub(y, lineWidth), minY))
              minY = t4.$sub(y, lineWidth);
            if (J.$gt$n(t4.$add(y, lineWidth), maxY))
              maxY = t4.$add(y, lineWidth);
            j += 2;
          }
        }
        ++i;
      }
      padding = this.boundsPadding;
      t1 = J.getInterceptor$ns(padding);
      this.bounds = new M.Rectangle0(J.$sub$n(minX, padding), J.$sub$n(minY, padding), J.$add$ns(J.$sub$n(maxX, minX), t1.$mul(padding, 2)), J.$add$ns(J.$sub$n(maxY, minY), t1.$mul(padding, 2)));
    }, "call$0", "get$_updateBounds", 0, 0, 54, "_updateBounds"],
    _generateCachedSprite$0: [function() {
      var bounds, t1, t2, canvasBuffer, texture, t3, t4;
      bounds = this.getLocalBounds$0();
      t1 = this._cachedSprite;
      t2 = J.getInterceptor$x(bounds);
      if (t1 == null) {
        canvasBuffer = M.CanvasBuffer$(t2.get$width(bounds), t2.get$height(bounds));
        texture = M.Texture$(M.BaseTexture_fromCanvas(canvasBuffer.canvas, null), null);
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t4 = new M.Sprite0(t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t4.texture = texture;
        t4._setupTexture$0();
        this._cachedSprite = t4;
        t4.buffer = canvasBuffer;
        this._cachedSprite.set$_worldTransform(this._worldTransform);
      } else
        J.resize$2$x(J.get$buffer$x(t1), t2.get$width(bounds), t2.get$height(bounds));
      t1 = J.getInterceptor$x(bounds);
      J.set$x$x(this._cachedSprite.get$anchor(), J.$negate$n(J.$div$n(t1.get$x(bounds), t1.get$width(bounds))));
      J.set$y$x(this._cachedSprite.get$anchor(), J.$negate$n(J.$div$n(t1.get$y(bounds), t1.get$height(bounds))));
      J.translate$2$x(J.get$context$x(J.get$buffer$x(this._cachedSprite)), J.$negate$n(t1.get$x(bounds)), J.$negate$n(t1.get$y(bounds)));
      M.CanvasGraphics_renderGraphics(this, J.get$context$x(J.get$buffer$x(this._cachedSprite)));
      J.set$alpha$x(this._cachedSprite, this.alpha);
    }, "call$0", "get$_generateCachedSprite", 0, 0, 54, "_generateCachedSprite"],
    _destroyCachedSprite$0: [function() {
      this._cachedSprite.get$texture().destroy$1(true);
      this._cachedSprite = null;
    }, "call$0", "get$_destroyCachedSprite", 0, 0, 54, "_destroyCachedSprite"],
    Graphics$0: function() {
      this.renderable = true;
      this.blendMode = C.BlendModes_0;
      this._dirty = true;
    },
    static: {"^": "Graphics_POLY@-614,Graphics_RECT@-614,Graphics_CIRC@-614,Graphics_ELIP@-614,Graphics_RREC@-614", Graphics$0: [function() {
        var t1, t2, t3, t4, t5;
        t1 = $.Graphics_POLY;
        t2 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = new M.Graphics0(1, 1, 0, 0, false, 1, [], 16777215, null, new M.GraphicsData([], 1, 0, null, 1, 1, 0, t1), t2, false, null, 0, false, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t5.Graphics$0();
        return t5;
      }, null, null, 0, 0, 54, "new Graphics"]}
  },
  "+Graphics": [706],
  CanvasGraphics: {
    "^": "Object;",
    static: {CanvasGraphics$: [function() {
        return new M.CanvasGraphics();
      }, null, null, 0, 0, 54, "new CanvasGraphics"], CanvasGraphics_renderGraphics: [function(graphics, context) {
        var worldAlpha, t1, color, i, t2, data, points, t3, t4, j, ellipseData, w, h, x, t5, y, ox, oy, xe, t6, ye, xm, ym, rx, ry, width, height, radius, maxRadius;
        worldAlpha = graphics.get$_worldAlpha();
        t1 = J.getInterceptor$x(context);
        color = "";
        i = 0;
        while (true) {
          t2 = J.get$length$asx(graphics.get$_graphicsData());
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          c$0: {
            data = J.$index$asx(graphics.get$_graphicsData(), i);
            t2 = J.getInterceptor$x(data);
            points = t2.get$points(data);
            t3 = J.getInterceptor$asx(points);
            if (t3.get$isEmpty(points) === true)
              break c$0;
            t4 = J.floor$0$n(data.get$lineColor());
            t4.toString;
            color = "#" + C.JSString_methods.padLeft$2(t4.toString(16), 6, "0");
            t1.set$strokeStyle(context, color);
            t1.set$lineWidth(context, t2.get$lineWidth(data));
            if (J.$eq(t2.get$type(data), $.Graphics_POLY)) {
              t1.beginPath$0(context);
              t1.moveTo$2(context, t3.$index(points, 0), t3.$index(points, 1));
              j = 1;
              while (true) {
                t4 = J.$div$n(t3.get$length(points), 2);
                if (typeof t4 !== "number")
                  return H.iae(t4);
                if (!(j < t4))
                  break;
                t4 = j * 2;
                t1.lineTo$2(context, t3.$index(points, t4), t3.$index(points, t4 + 1));
                ++j;
              }
              if (J.$eq(t3.$index(points, 0), t3.$index(points, J.$sub$n(t3.get$length(points), 2))) && J.$eq(t3.$index(points, 1), t3.$index(points, J.$sub$n(t3.get$length(points), 1))))
                t1.closePath$0(context);
              if (t2.get$fill(data) === true) {
                t1.set$globalAlpha(context, J.$mul$ns(data.get$fillAlpha(), worldAlpha));
                t3 = J.floor$0$n(data.get$fillColor());
                t3.toString;
                color = "#" + C.JSString_methods.padLeft$2(t3.toString(16), 6, "0");
                t1.set$fillStyle(context, color);
                t1.fill$0(context);
              }
              if (!J.$eq(t2.get$lineWidth(data), 0)) {
                t1.set$globalAlpha(context, J.$mul$ns(data.get$lineAlpha(), worldAlpha));
                t1.stroke$0(context);
              }
            } else if (J.$eq(t2.get$type(data), $.Graphics_RECT)) {
              if (t2.get$fill(data) === true) {
                t1.set$globalAlpha(context, J.$mul$ns(data.get$fillAlpha(), worldAlpha));
                t4 = J.floor$0$n(data.get$fillColor());
                t4.toString;
                color = "#" + C.JSString_methods.padLeft$2(t4.toString(16), 6, "0");
                t1.set$fillStyle(context, color);
                t1.fillRect$4(context, t3.$index(points, 0), t3.$index(points, 1), t3.$index(points, 2), t3.$index(points, 3));
              }
              if (!J.$eq(t2.get$lineWidth(data), 0)) {
                t1.set$globalAlpha(context, J.$mul$ns(data.get$lineAlpha(), worldAlpha));
                t1.strokeRect$4(context, t3.$index(points, 0), t3.$index(points, 1), t3.$index(points, 2), t3.$index(points, 3));
              }
            } else if (J.$eq(t2.get$type(data), $.Graphics_CIRC)) {
              t1.beginPath$0(context);
              t1.arc$5(context, t3.$index(points, 0), t3.$index(points, 1), t3.$index(points, 2), 0, 6.283185307179586);
              t1.closePath$0(context);
              if (t2.get$fill(data) === true) {
                t1.set$globalAlpha(context, J.$mul$ns(data.get$fillAlpha(), worldAlpha));
                t3 = J.floor$0$n(data.get$fillColor());
                t3.toString;
                color = "#" + C.JSString_methods.padLeft$2(t3.toString(16), 6, "0");
                t1.set$fillStyle(context, color);
                t1.fill$0(context);
              }
              if (!J.$eq(t2.get$lineWidth(data), 0)) {
                t1.set$globalAlpha(context, J.$mul$ns(data.get$lineAlpha(), worldAlpha));
                t1.stroke$0(context);
              }
            } else if (J.$eq(t2.get$type(data), $.Graphics_ELIP)) {
              ellipseData = t2.get$points(data);
              t3 = J.getInterceptor$asx(ellipseData);
              w = J.$mul$ns(t3.$index(ellipseData, 2), 2);
              h = J.$mul$ns(t3.$index(ellipseData, 3), 2);
              t4 = J.getInterceptor$n(w);
              x = J.$sub$n(t3.$index(ellipseData, 0), t4.$div(w, 2));
              t5 = J.getInterceptor$n(h);
              y = J.$sub$n(t3.$index(ellipseData, 1), t5.$div(h, 2));
              t1.beginPath$0(context);
              ox = J.$mul$ns(t4.$div(w, 2), 0.5522848);
              oy = J.$mul$ns(t5.$div(h, 2), 0.5522848);
              t3 = J.getInterceptor$ns(x);
              xe = t3.$add(x, w);
              t6 = J.getInterceptor$ns(y);
              ye = t6.$add(y, h);
              xm = t3.$add(x, t4.$div(w, 2));
              ym = t6.$add(y, t5.$div(h, 2));
              t1.moveTo$2(context, x, ym);
              t5 = J.getInterceptor$n(ym);
              t6 = J.getInterceptor$n(xm);
              t1.bezierCurveTo$6(context, x, t5.$sub(ym, oy), t6.$sub(xm, ox), y, xm, y);
              t1.bezierCurveTo$6(context, t6.$add(xm, ox), y, xe, t5.$sub(ym, oy), xe, ym);
              t1.bezierCurveTo$6(context, xe, t5.$add(ym, oy), t6.$add(xm, ox), ye, xm, ye);
              t1.bezierCurveTo$6(context, t6.$sub(xm, ox), ye, x, t5.$add(ym, oy), x, ym);
              t1.closePath$0(context);
              if (t2.get$fill(data) === true) {
                t1.set$globalAlpha(context, J.$mul$ns(data.get$fillAlpha(), worldAlpha));
                t3 = J.floor$0$n(data.get$fillColor());
                t3.toString;
                color = "#" + C.JSString_methods.padLeft$2(t3.toString(16), 6, "0");
                t1.set$fillStyle(context, color);
                t1.fill$0(context);
              }
              if (!J.$eq(t2.get$lineWidth(data), 0)) {
                t1.set$globalAlpha(context, J.$mul$ns(data.get$lineAlpha(), worldAlpha));
                t1.stroke$0(context);
              }
            } else if (J.$eq(t2.get$type(data), $.Graphics_RREC)) {
              rx = t3.$index(points, 0);
              ry = t3.$index(points, 1);
              width = t3.$index(points, 2);
              height = t3.$index(points, 3);
              radius = t3.$index(points, 4);
              maxRadius = C.JSNumber_methods.toInt$0(Math.floor(P.min(width, height) / 2));
              if (J.$gt$n(radius, maxRadius))
                radius = maxRadius;
              t1.beginPath$0(context);
              t3 = J.getInterceptor$ns(ry);
              t1.moveTo$2(context, rx, t3.$add(ry, radius));
              t1.lineTo$2(context, rx, J.$sub$n(t3.$add(ry, height), radius));
              t4 = J.getInterceptor$ns(rx);
              t1.quadraticCurveTo$4(context, rx, t3.$add(ry, height), t4.$add(rx, radius), t3.$add(ry, height));
              t1.lineTo$2(context, J.$sub$n(t4.$add(rx, width), radius), t3.$add(ry, height));
              t1.quadraticCurveTo$4(context, t4.$add(rx, width), t3.$add(ry, height), t4.$add(rx, width), J.$sub$n(t3.$add(ry, height), radius));
              t1.lineTo$2(context, t4.$add(rx, width), t3.$add(ry, radius));
              t1.quadraticCurveTo$4(context, t4.$add(rx, width), ry, J.$sub$n(t4.$add(rx, width), radius), ry);
              t1.lineTo$2(context, t4.$add(rx, radius), ry);
              t1.quadraticCurveTo$4(context, rx, ry, rx, t3.$add(ry, radius));
              t1.closePath$0(context);
              if (t2.get$fill(data) === true) {
                t1.set$globalAlpha(context, J.$mul$ns(data.get$fillAlpha(), worldAlpha));
                t3 = J.floor$0$n(data.get$fillColor());
                t3.toString;
                color = "#" + C.JSString_methods.padLeft$2(t3.toString(16), 6, "0");
                t1.set$fillStyle(context, color);
                t1.fill$0(context);
              }
              if (!J.$eq(t2.get$lineWidth(data), 0)) {
                t1.set$globalAlpha(context, J.$mul$ns(data.get$lineAlpha(), worldAlpha));
                t1.stroke$0(context);
              }
            }
          }
          ++i;
        }
      }, "call$2", "CanvasGraphics_renderGraphics$closure", 4, 0, 140, 141, [], 142, [], "renderGraphics"], CanvasGraphics_renderGraphicsMask: [function(graphics, context) {
        var len, t1, i, data, t2, points, j, t3, ellipseData, w, h, x, t4, y, ox, oy, xe, t5, ye, xm, ym, rx, ry, width, height, radius, maxRadius;
        len = J.get$length$asx(graphics.get$_graphicsData());
        t1 = J.getInterceptor(len);
        if (t1.$eq(len, 0))
          return;
        if (t1.$gt(len, 1)) {
          window;
          if (typeof console != "undefined")
            console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object");
        }
        for (t1 = J.getInterceptor$x(context), i = 0; i < 1; ++i) {
          data = J.$index$asx(graphics.get$_graphicsData(), i);
          t2 = J.getInterceptor$x(data);
          points = t2.get$points(data);
          if (J.$eq(t2.get$type(data), $.Graphics_POLY)) {
            t1.beginPath$0(context);
            t2 = J.getInterceptor$asx(points);
            t1.moveTo$2(context, t2.$index(points, 0), t2.$index(points, 1));
            j = 1;
            while (true) {
              t3 = J.$div$n(t2.get$length(points), 2);
              if (typeof t3 !== "number")
                return H.iae(t3);
              if (!(j < t3))
                break;
              t3 = j * 2;
              t1.lineTo$2(context, t2.$index(points, t3), t2.$index(points, t3 + 1));
              ++j;
            }
            if (J.$eq(t2.$index(points, 0), t2.$index(points, J.$sub$n(t2.get$length(points), 2))) && J.$eq(t2.$index(points, 1), t2.$index(points, J.$sub$n(t2.get$length(points), 1))))
              t1.closePath$0(context);
          } else if (J.$eq(t2.get$type(data), $.Graphics_RECT)) {
            t1.beginPath$0(context);
            t2 = J.getInterceptor$asx(points);
            t1.rect$4(context, t2.$index(points, 0), t2.$index(points, 1), t2.$index(points, 2), t2.$index(points, 3));
            t1.closePath$0(context);
          } else if (J.$eq(t2.get$type(data), $.Graphics_CIRC)) {
            t1.beginPath$0(context);
            t2 = J.getInterceptor$asx(points);
            t1.arc$5(context, t2.$index(points, 0), t2.$index(points, 1), t2.$index(points, 2), 0, 6.283185307179586);
            t1.closePath$0(context);
          } else if (J.$eq(t2.get$type(data), $.Graphics_ELIP)) {
            ellipseData = t2.get$points(data);
            t2 = J.getInterceptor$asx(ellipseData);
            w = J.$mul$ns(t2.$index(ellipseData, 2), 2);
            h = J.$mul$ns(t2.$index(ellipseData, 3), 2);
            t3 = J.getInterceptor$n(w);
            x = J.$sub$n(t2.$index(ellipseData, 0), t3.$div(w, 2));
            t4 = J.getInterceptor$n(h);
            y = J.$sub$n(t2.$index(ellipseData, 1), t4.$div(h, 2));
            t1.beginPath$0(context);
            ox = J.$mul$ns(t3.$div(w, 2), 0.5522848);
            oy = J.$mul$ns(t4.$div(h, 2), 0.5522848);
            t2 = J.getInterceptor$ns(x);
            xe = t2.$add(x, w);
            t5 = J.getInterceptor$ns(y);
            ye = t5.$add(y, h);
            xm = t2.$add(x, t3.$div(w, 2));
            ym = t5.$add(y, t4.$div(h, 2));
            t1.moveTo$2(context, x, ym);
            t4 = J.getInterceptor$n(ym);
            t5 = J.getInterceptor$n(xm);
            t1.bezierCurveTo$6(context, x, t4.$sub(ym, oy), t5.$sub(xm, ox), y, xm, y);
            t1.bezierCurveTo$6(context, t5.$add(xm, ox), y, xe, t4.$sub(ym, oy), xe, ym);
            t1.bezierCurveTo$6(context, xe, t4.$add(ym, oy), t5.$add(xm, ox), ye, xm, ye);
            t1.bezierCurveTo$6(context, t5.$sub(xm, ox), ye, x, t4.$add(ym, oy), x, ym);
            t1.closePath$0(context);
          } else if (J.$eq(t2.get$type(data), $.Graphics_RREC)) {
            t2 = J.getInterceptor$asx(points);
            rx = t2.$index(points, 0);
            ry = t2.$index(points, 1);
            width = t2.$index(points, 2);
            height = t2.$index(points, 3);
            radius = t2.$index(points, 4);
            maxRadius = C.JSNumber_methods.toInt$0(Math.floor(P.min(width, height) / 2));
            if (J.$gt$n(radius, maxRadius))
              radius = maxRadius;
            t1.beginPath$0(context);
            t2 = J.getInterceptor$ns(ry);
            t1.moveTo$2(context, rx, t2.$add(ry, radius));
            t1.lineTo$2(context, rx, J.$sub$n(t2.$add(ry, height), radius));
            t3 = J.getInterceptor$ns(rx);
            t1.quadraticCurveTo$4(context, rx, t2.$add(ry, height), t3.$add(rx, radius), t2.$add(ry, height));
            t1.lineTo$2(context, J.$sub$n(t3.$add(rx, width), radius), t2.$add(ry, height));
            t1.quadraticCurveTo$4(context, t3.$add(rx, width), t2.$add(ry, height), t3.$add(rx, width), J.$sub$n(t2.$add(ry, height), radius));
            t1.lineTo$2(context, t3.$add(rx, width), t2.$add(ry, radius));
            t1.quadraticCurveTo$4(context, t3.$add(rx, width), ry, J.$sub$n(t3.$add(rx, width), radius), ry);
            t1.lineTo$2(context, t3.$add(rx, radius), ry);
            t1.quadraticCurveTo$4(context, rx, ry, rx, t2.$add(ry, radius));
            t1.closePath$0(context);
          }
        }
      }, "call$2", "CanvasGraphics_renderGraphicsMask$closure", 4, 0, 140, 141, [], 142, [], "renderGraphicsMask"]}
  },
  "+CanvasGraphics": [674],
  CanvasRenderer: {
    "^": "Renderer;clearBeforeRender@-617,roundPixels@-617,context*-876,refresh@-617,count@-614,type-614,transparent-617,antialias-617,preserveDrawingBuffer-617,width-616,height-616,view-836,projection-652,offset-652,contextLost-617,options-783,gl-877,shaderManager-878,spriteBatch-879,maskManager-880,filterManager-881,stencilManager-882,blendModeManager-883,renderSession-884,__stage-657",
    refresh$0: function() {
      return this.refresh.call$0();
    },
    refresh$2: function(arg0, arg1) {
      return this.refresh.call$2(arg0, arg1);
    },
    render$1: [function(stage) {
      var t1;
      J.set$length$asx($.get$texturesToUpdate(), 0);
      J.set$length$asx($.get$texturesToDestroy(), 0);
      stage.updateTransform$0();
      J.setTransform$6$x(this.context, 1, 0, 0, 1, 0, 0);
      J.set$globalAlpha$x(this.context, 1);
      t1 = this.transparent === true;
      if (!t1 && this.clearBeforeRender === true) {
        J.set$fillStyle$x(this.context, stage.get$backgroundColorString());
        J.fillRect$4$x(this.context, 0, 0, this.width, this.height);
      } else if (t1 && this.clearBeforeRender === true)
        J.clearRect$4$x(this.context, 0, 0, this.width, this.height);
      this.renderDisplayObject$1(stage);
      if (stage.get$interactive() === true)
        if (stage.get$_interactiveEventsAdded() !== true) {
          stage.set$_interactiveEventsAdded(true);
          stage.get$interactionManager().setTarget$1(this);
        }
      if (J.$gt$n(J.get$length$asx($.get$Texture_frameUpdates()), 0))
        J.set$length$asx($.get$Texture_frameUpdates(), 0);
    }, "call$1", "get$render", 2, 0, 131, 132, [], "render"],
    resize$2: [function(_, width, height) {
      var t1, t2;
      t1 = J.getInterceptor$n(width);
      this.width = t1.toInt$0(width);
      t2 = J.getInterceptor$n(height);
      this.height = t2.toInt$0(height);
      J.set$width$x(this.view, t1.toInt$0(width));
      J.set$height$x(this.view, t2.toInt$0(height));
    }, "call$2", "get$resize", 4, 0, 149, 31, [], 52, [], "resize"],
    renderDisplayObject$3: [function(displayObject, context, buffer) {
      var t1 = this.renderSession;
      J.set$context$x(t1, context == null ? this.context : context);
      displayObject._renderCanvas$1(this.renderSession);
    }, function(displayObject, context) {
      return this.renderDisplayObject$3(displayObject, context, null);
    }, "renderDisplayObject$2", function(displayObject) {
      return this.renderDisplayObject$3(displayObject, null, null);
    }, "renderDisplayObject$1", "call$3", "call$2", "call$1", "get$renderDisplayObject", 2, 4, 885, 12, 12, 833, [], 142, [], 886, [], "renderDisplayObject"],
    renderStripFlat$1: [function(strip) {
      var context, verticies, t1, $length, t2, t3, i, t4, index, x0, x1, x2, y0, y1, y2;
      context = this.context;
      verticies = strip.get$verticies();
      t1 = J.getInterceptor$asx(verticies);
      $length = J.$div$n(t1.get$length(verticies), 2);
      this.count = J.$add$ns(this.count, 1);
      t2 = J.getInterceptor$x(context);
      t2.beginPath$0(context);
      t3 = J.getInterceptor$n($length);
      i = 1;
      while (true) {
        t4 = t3.$sub($length, 2);
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (!(i < t4))
          break;
        index = i * 2;
        x0 = t1.$index(verticies, index);
        x1 = t1.$index(verticies, index + 2);
        x2 = t1.$index(verticies, index + 4);
        y0 = t1.$index(verticies, index + 1);
        y1 = t1.$index(verticies, index + 3);
        y2 = t1.$index(verticies, index + 5);
        t2.moveTo$2(context, x0, y0);
        t2.lineTo$2(context, x1, y1);
        t2.lineTo$2(context, x2, y2);
        ++i;
      }
      t2.set$fillStyle(context, "#FF0000");
      t2.fill$0(context);
      t2.closePath$0(context);
    }, "call$1", "get$renderStripFlat", 2, 0, 102, 887, [], "renderStripFlat"],
    renderStrip$1: [function(strip) {
      var context, verticies, uvs, t1, $length, t2, t3, t4, i, t5, index, x0, x1, t6, x2, t7, y0, t8, y1, t9, y2, u0, u1, u2, v0, v1, v2, delta, t10, deltaA, deltaB, deltaC, deltaD, deltaE, deltaF;
      context = this.context;
      verticies = strip.get$verticies();
      uvs = strip.get$uvs();
      t1 = J.getInterceptor$asx(verticies);
      $length = J.$div$n(t1.get$length(verticies), 2);
      this.count = J.$add$ns(this.count, 1);
      t2 = J.getInterceptor$n($length);
      t3 = J.getInterceptor$asx(uvs);
      t4 = J.getInterceptor$x(context);
      i = 1;
      while (true) {
        t5 = t2.$sub($length, 2);
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (!(i < t5))
          break;
        index = i * 2;
        x0 = t1.$index(verticies, index);
        t5 = index + 2;
        x1 = t1.$index(verticies, t5);
        t6 = index + 4;
        x2 = t1.$index(verticies, t6);
        t7 = index + 1;
        y0 = t1.$index(verticies, t7);
        t8 = index + 3;
        y1 = t1.$index(verticies, t8);
        t9 = index + 5;
        y2 = t1.$index(verticies, t9);
        u0 = J.$mul$ns(t3.$index(uvs, index), J.get$width$x(strip.get$texture()));
        u1 = J.$mul$ns(t3.$index(uvs, t5), J.get$width$x(strip.get$texture()));
        u2 = J.$mul$ns(t3.$index(uvs, t6), J.get$width$x(strip.get$texture()));
        v0 = J.$mul$ns(t3.$index(uvs, t7), J.get$height$x(strip.get$texture()));
        v1 = J.$mul$ns(t3.$index(uvs, t8), J.get$height$x(strip.get$texture()));
        v2 = J.$mul$ns(t3.$index(uvs, t9), J.get$height$x(strip.get$texture()));
        t4.save$0(context);
        t4.beginPath$0(context);
        t4.moveTo$2(context, x0, y0);
        t4.lineTo$2(context, x1, y1);
        t4.lineTo$2(context, x2, y2);
        t4.closePath$0(context);
        t4.clip$0(context);
        t9 = J.getInterceptor$ns(u0);
        t8 = J.getInterceptor$ns(v0);
        t7 = J.getInterceptor$ns(u1);
        t6 = J.getInterceptor$ns(v1);
        delta = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t9.$mul(u0, v1), t8.$mul(v0, u2)), t7.$mul(u1, v2)), t6.$mul(v1, u2)), t8.$mul(v0, u1)), t9.$mul(u0, v2));
        t5 = J.getInterceptor$ns(x0);
        t10 = J.getInterceptor$ns(x1);
        deltaA = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t5.$mul(x0, v1), t8.$mul(v0, x2)), t10.$mul(x1, v2)), t6.$mul(v1, x2)), t8.$mul(v0, x1)), t5.$mul(x0, v2));
        deltaB = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t9.$mul(u0, x1), t5.$mul(x0, u2)), t7.$mul(u1, x2)), t10.$mul(x1, u2)), t5.$mul(x0, u1)), t9.$mul(u0, x2));
        deltaC = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(t9.$mul(u0, v1), x2), J.$mul$ns(t8.$mul(v0, x1), u2)), J.$mul$ns(t5.$mul(x0, u1), v2)), J.$mul$ns(t5.$mul(x0, v1), u2)), J.$mul$ns(t8.$mul(v0, u1), x2)), J.$mul$ns(t9.$mul(u0, x1), v2));
        t5 = J.getInterceptor$ns(y0);
        t10 = J.getInterceptor$ns(y1);
        deltaD = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t5.$mul(y0, v1), t8.$mul(v0, y2)), t10.$mul(y1, v2)), t6.$mul(v1, y2)), t8.$mul(v0, y1)), t5.$mul(y0, v2));
        deltaE = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t9.$mul(u0, y1), t5.$mul(y0, u2)), t7.$mul(u1, y2)), t10.$mul(y1, u2)), t5.$mul(y0, u1)), t9.$mul(u0, y2));
        deltaF = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(t9.$mul(u0, v1), y2), J.$mul$ns(t8.$mul(v0, y1), u2)), J.$mul$ns(t5.$mul(y0, u1), v2)), J.$mul$ns(t5.$mul(y0, v1), u2)), J.$mul$ns(t8.$mul(v0, u1), y2)), J.$mul$ns(t9.$mul(u0, y1), v2));
        t4.transform$6(context, J.$div$n(deltaA, delta), J.$div$n(deltaD, delta), J.$div$n(deltaB, delta), J.$div$n(deltaE, delta), J.$div$n(deltaC, delta), J.$div$n(deltaF, delta));
        t4.drawImage$3(context, J.get$source$x(strip.get$texture().get$baseTexture()), 0, 0);
        t4.restore$0(context);
        ++i;
      }
    }, "call$1", "get$renderStrip", 2, 0, 102, 887, [], "renderStrip"],
    CanvasRenderer$5: function(width, height, view, transparent, antialias) {
      var t1, t2, t3;
      $.defaultRenderer = this;
      this.type = 1;
      this.width = J.toInt$0$n(width);
      this.height = J.toInt$0$n(height);
      this.transparent = transparent;
      this.antialias = antialias;
      if (view == null)
        view = W.CanvasElement_CanvasElement(null, null);
      this.view = view;
      J.set$width$x(view, J.toInt$0$n(this.width));
      J.set$height$x(this.view, J.toInt$0$n(this.height));
      if ($.blendModesCanvas == null) {
        $.blendModesCanvas = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = M.canUseNewCanvasBlendModes();
        t2 = $.blendModesCanvas;
        if (t1) {
          J.$indexSet$ax(t2, C.BlendModes_0, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_1, "lighter");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_2, "multiply");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_3, "screen");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_4, "overlay");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_5, "darken");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_6, "lighten");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_7, "color-dodge");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_8, "color-burn");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_9, "hard-light");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_10, "soft-light");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_11, "difference");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_12, "exclusion");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_13, "hue");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_14, "saturation");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_15, "color");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_16, "luminosity");
        } else {
          J.$indexSet$ax(t2, C.BlendModes_0, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_1, "lighter");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_2, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_3, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_4, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_5, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_6, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_7, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_8, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_9, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_10, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_11, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_12, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_13, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_14, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_15, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_16, "source-over");
        }
      }
      t1 = J.getContext$2$x(this.view, "2d", P.LinkedHashMap_LinkedHashMap$_literal(["alpha", this.transparent], null, null));
      this.context = t1;
      t2 = new M.CanvasMaskManager();
      this.maskManager = t2;
      t3 = new M.RenderSession(null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, false);
      t3.context = t1;
      t3.maskManager = t2;
      t3.scaleMode = null;
      t3.smoothProperty = null;
      this.renderSession = t3;
    },
    static: {CanvasRenderer$: [function(width, height, view, transparent, antialias) {
        var t1 = new M.CanvasRenderer(true, false, null, true, 0, 0, false, false, false, 100, 100, null, null, null, false, null, null, null, null, null, null, null, null, null, null);
        t1.CanvasRenderer$5(width, height, view, transparent, antialias);
        return t1;
      }, null, null, 0, 10, 143, 144, 145, 12, 19, 19, 31, [], 52, [], 146, [], 147, [], 148, [], "new CanvasRenderer"]}
  },
  "+CanvasRenderer": [837],
  CanvasBuffer: {
    "^": "Object;width*-616,height*-616,canvas*-836,context*-876",
    clear$0: [function(_) {
      J.clearRect$4$x(this.context, 0, 0, this.width, this.height);
    }, "call$0", "get$clear", 0, 0, 54, "clear"],
    resize$2: [function(_, width, height) {
      J.set$width$x(this.canvas, width);
      this.width = width;
      J.set$height$x(this.canvas, height);
      this.height = height;
    }, "call$2", "get$resize", 4, 0, 149, 31, [], 52, [], "resize"],
    CanvasBuffer$2: function(width, height) {
      var t1 = document.createElement("canvas", null);
      this.canvas = t1;
      J.set$width$x(t1, J.toInt$0$n(this.width));
      J.set$height$x(this.canvas, J.toInt$0$n(this.height));
      this.context = J.getContext$1$x(this.canvas, "2d");
    },
    static: {CanvasBuffer$: [function(width, height) {
        var t1 = new M.CanvasBuffer(width, height, null, null);
        t1.CanvasBuffer$2(width, height);
        return t1;
      }, null, null, 4, 0, 149, 31, [], 52, [], "new CanvasBuffer"]}
  },
  "+CanvasBuffer": [674],
  CanvasMaskManager: {
    "^": "MaskManager;",
    pushMask$2: [function(maskData, context) {
      var t1, cacheAlpha, transform;
      t1 = J.getInterceptor$x(context);
      t1.save$0(context);
      cacheAlpha = J.get$alpha$x(maskData);
      transform = maskData.get$_worldTransform();
      t1.setTransform$6(context, J.get$a$x(transform), transform.get$c(), transform.get$b(), transform.get$d(), transform.get$tx(), transform.get$ty());
      M.CanvasGraphics_renderGraphicsMask(maskData, context);
      t1.clip$0(context);
      maskData.set$_worldAlpha(cacheAlpha);
    }, function(maskData) {
      return this.pushMask$2(maskData, null);
    }, "pushMask$1", "call$2", "call$1", "get$pushMask", 2, 2, 888, 12, 889, [], 142, [], "pushMask"],
    popMask$2: [function(context, renderSession) {
      J.restore$0$x(context);
    }, function(context) {
      return this.popMask$2(context, null);
    }, "popMask$1", "call$2", "call$1", "get$popMask", 2, 2, 890, 12, 142, [], 166, [], "popMask"],
    destroy$0: [function() {
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    setContext$1: [function(a) {
    }, "call$1", "get$setContext", 2, 0, 159, 348, [], "setContext"],
    static: {CanvasMaskManager$: [function() {
        return new M.CanvasMaskManager();
      }, null, null, 0, 0, 54, "new CanvasMaskManager"]}
  },
  "+CanvasMaskManager": [880],
  CanvasTinter: {
    "^": "Object;",
    static: {"^": "CanvasTinter_cacheStepsPerColorChannel@-614,CanvasTinter_convertTintToImage@-617,CanvasTinter_canUseMultiply@-617,CanvasTinter_tintMethod@-12,CanvasTinter_canvas@-836", CanvasTinter$: [function() {
        return new M.CanvasTinter();
      }, null, null, 0, 0, 54, "new CanvasTinter"], CanvasTinter_getTintedTexture: [function(sprite, color) {
        var texture, step, rgbValues, t1, t2, stringColor, canvas, tintImage;
        texture = sprite.get$texture();
        step = $.CanvasTinter_cacheStepsPerColorChannel;
        rgbValues = M.hex2rgb(color);
        if (0 >= rgbValues.length)
          return H.ioore(rgbValues, 0);
        t1 = P.min(255, J.$mul$ns(J.$div$n(rgbValues[0], step), step));
        t2 = rgbValues.length;
        if (0 >= t2)
          return H.ioore(rgbValues, 0);
        rgbValues[0] = t1;
        if (1 >= t2)
          return H.ioore(rgbValues, 1);
        t2 = P.min(255, J.$mul$ns(J.$div$n(rgbValues[1], step), step));
        t1 = rgbValues.length;
        if (1 >= t1)
          return H.ioore(rgbValues, 1);
        rgbValues[1] = t2;
        if (2 >= t1)
          return H.ioore(rgbValues, 2);
        t1 = P.min(255, J.$mul$ns(J.$div$n(rgbValues[2], step), step));
        if (2 >= rgbValues.length)
          return H.ioore(rgbValues, 2);
        rgbValues[2] = t1;
        color = C.JSNumber_methods.toInt$0(Math.floor(M.rgb2hex(rgbValues)));
        stringColor = "#" + C.JSString_methods.padLeft$2(C.JSInt_methods.toRadixString$1(color, 16), 6, "0");
        if (texture.get$tintCache() == null)
          texture.set$tintCache(P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        if (J.$index$asx(texture.get$tintCache(), stringColor) != null)
          return J.$index$asx(texture.get$tintCache(), stringColor);
        canvas = $.CanvasTinter_canvas;
        canvas = canvas != null ? canvas : W.CanvasElement_CanvasElement(null, null);
        $.get$CanvasTinter_tintMethod().call$3(texture, color, canvas);
        if ($.CanvasTinter_convertTintToImage === true) {
          tintImage = W.ImageElement_ImageElement(null, null, null);
          J.set$src$x(tintImage, J.toDataUrl$0$x(canvas));
          J.$indexSet$ax(texture.get$tintCache(), stringColor, tintImage);
        } else {
          J.$indexSet$ax(texture.get$tintCache(), stringColor, canvas);
          $.CanvasTinter_canvas = null;
        }
        return canvas;
      }, "call$2", "CanvasTinter_getTintedTexture$closure", 4, 0, 150, 151, [], 152, [], "getTintedTexture"], CanvasTinter_tintWithMultiply: [function(texture, color, canvas) {
        var t1, context, frame, t2;
        t1 = J.getInterceptor$x(canvas);
        context = t1.getContext$1(canvas, "2d");
        frame = texture.get$frame();
        t2 = J.getInterceptor$x(frame);
        t1.set$width(canvas, t2.get$width(frame));
        t1.set$height(canvas, t2.get$height(frame));
        t1 = J.getInterceptor$x(context);
        t1.set$fillStyle(context, "#" + C.JSString_methods.padLeft$2(J.toRadixString$1$n(color, 16), 6, "0"));
        t1.fillRect$4(context, 0, 0, t2.get$width(frame), t2.get$height(frame));
        t1.set$globalCompositeOperation(context, "multiply");
        t1.drawImageScaledFromSource$9(context, J.get$source$x(texture.get$baseTexture()), t2.get$x(frame), t2.get$y(frame), t2.get$width(frame), t2.get$height(frame), 0, 0, t2.get$width(frame), t2.get$height(frame));
        t1.set$globalCompositeOperation(context, "destination-atop");
        t1.drawImageScaledFromSource$9(context, J.get$source$x(texture.get$baseTexture()), t2.get$x(frame), t2.get$y(frame), t2.get$width(frame), t2.get$height(frame), 0, 0, t2.get$width(frame), t2.get$height(frame));
      }, "call$3", "CanvasTinter_tintWithMultiply$closure", 6, 0, 153, 68, [], 152, [], 154, [], "tintWithMultiply"], CanvasTinter_tintWithOverlay: [function(texture, color, canvas) {
        var t1, context, frame, t2;
        t1 = J.getInterceptor$x(canvas);
        context = t1.getContext$1(canvas, "2d");
        frame = texture.get$frame();
        t2 = J.getInterceptor$x(frame);
        t1.set$width(canvas, t2.get$width(frame));
        t1.set$height(canvas, t2.get$height(frame));
        t1 = J.getInterceptor$x(context);
        t1.set$globalCompositeOperation(context, "copy");
        t1.set$fillStyle(context, "#" + C.JSString_methods.padLeft$2(J.toRadixString$1$n(color, 16), 6, "0"));
        t1.fillRect$4(context, 0, 0, t2.get$width(frame), t2.get$height(frame));
        t1.set$globalCompositeOperation(context, "destination-atop");
        t1.drawImageScaledFromSource$9(context, J.get$source$x(texture.get$baseTexture()), t2.get$x(frame), t2.get$y(frame), t2.get$width(frame), t2.get$height(frame), 0, 0, t2.get$width(frame), t2.get$height(frame));
      }, "call$3", "CanvasTinter_tintWithOverlay$closure", 6, 0, 153, 68, [], 152, [], 154, [], "tintWithOverlay"], CanvasTinter_tintWithPerPixel: [function(texture, color, canvas) {
        var t1, context, frame, t2, rgbValues, t3, r, g, b, pixelData, pixels, i, t4;
        t1 = J.getInterceptor$x(canvas);
        context = t1.getContext$1(canvas, "2d");
        frame = texture.get$frame();
        t2 = J.getInterceptor$x(frame);
        t1.set$width(canvas, t2.get$width(frame));
        t1.set$height(canvas, t2.get$height(frame));
        t1 = J.getInterceptor$x(context);
        t1.set$globalCompositeOperation(context, "copy");
        t1.drawImage$9(context, J.get$source$x(texture.get$baseTexture()), t2.get$x(frame), t2.get$y(frame), t2.get$width(frame), t2.get$height(frame), 0, 0, t2.get$width(frame), t2.get$height(frame));
        rgbValues = M.hex2rgb(color);
        t3 = rgbValues.length;
        if (0 >= t3)
          return H.ioore(rgbValues, 0);
        r = rgbValues[0];
        if (1 >= t3)
          return H.ioore(rgbValues, 1);
        g = rgbValues[1];
        if (2 >= t3)
          return H.ioore(rgbValues, 2);
        b = rgbValues[2];
        pixelData = t1.getImageData$4(context, 0, 0, t2.get$width(frame), t2.get$height(frame));
        pixels = J.get$data$x(pixelData);
        for (t2 = pixels.length, i = 0; i < t2; i += 4) {
          t3 = pixels[i];
          if (typeof r !== "number")
            return H.iae(r);
          pixels[i] = t3 * r;
          t3 = i + 1;
          if (t3 >= t2)
            return H.ioore(pixels, t3);
          t4 = pixels[t3];
          if (typeof g !== "number")
            return H.iae(g);
          pixels[t3] = t4 * g;
          t4 = i + 2;
          if (t4 >= t2)
            return H.ioore(pixels, t4);
          t3 = pixels[t4];
          if (typeof b !== "number")
            return H.iae(b);
          pixels[t4] = t3 * b;
        }
        t1.putImageData$3(context, pixelData, 0, 0);
      }, "call$3", "CanvasTinter_tintWithPerPixel$closure", 6, 0, 155, 68, [], 152, [], 154, [], "tintWithPerPixel"], CanvasTinter_roundColor: [function(color) {
        var step, rgbValues, t1, t2;
        step = $.CanvasTinter_cacheStepsPerColorChannel;
        rgbValues = M.hex2rgb(color);
        if (0 >= rgbValues.length)
          return H.ioore(rgbValues, 0);
        t1 = P.min(255, J.$mul$ns(J.$div$n(rgbValues[0], step), step));
        t2 = rgbValues.length;
        if (0 >= t2)
          return H.ioore(rgbValues, 0);
        rgbValues[0] = t1;
        if (1 >= t2)
          return H.ioore(rgbValues, 1);
        t2 = P.min(255, J.$mul$ns(J.$div$n(rgbValues[1], step), step));
        t1 = rgbValues.length;
        if (1 >= t1)
          return H.ioore(rgbValues, 1);
        rgbValues[1] = t2;
        if (2 >= t1)
          return H.ioore(rgbValues, 2);
        t1 = P.min(255, J.$mul$ns(J.$div$n(rgbValues[2], step), step));
        if (2 >= rgbValues.length)
          return H.ioore(rgbValues, 2);
        rgbValues[2] = t1;
        return C.JSNumber_methods.toInt$0(Math.floor(M.rgb2hex(rgbValues)));
      }, "call$1", "CanvasTinter_roundColor$closure", 2, 0, 156, 152, [], "roundColor"]}
  },
  "+CanvasTinter": [674],
  MaskManager: {
    "^": "Object;",
    static: {MaskManager$: [function() {
        return new M.MaskManager();
      }, null, null, 0, 0, 157, "new MaskManager"]}
  },
  "+MaskManager": [674],
  RenderSession: {
    "^": "Object;gl@-877,projection@-652,offset*-652,drawCount@-614,shaderManager@-878,maskManager@-880,filterManager@-881,spriteBatch@-879,blendModeManager@-883,stencilManager@-882,renderer@-837,currentBlendMode@-702,scaleMode@-891,smoothProperty@-644,context*-876,roundPixels@-617",
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    spriteBatch$3: function(arg0, arg1, arg2) {
      return this.spriteBatch.call$3(arg0, arg1, arg2);
    },
    static: {RenderSession$: [function() {
        return new M.RenderSession(null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, false);
      }, null, null, 0, 0, 158, "new RenderSession"]}
  },
  "+RenderSession": [674],
  Renderer: {
    "^": "Object;type*-614,transparent@-617,antialias@-617,preserveDrawingBuffer@-617,width*-616,height*-616,view*-836,projection@-652,offset*-652,contextLost@-617,options*-783,gl@-877,shaderManager@-878,spriteBatch@-879,maskManager@-880,filterManager@-881,stencilManager@-882,blendModeManager@-883,renderSession@-884,__stage@-657",
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    spriteBatch$3: function(arg0, arg1, arg2) {
      return this.spriteBatch.call$3(arg0, arg1, arg2);
    },
    static: {Renderer$: [function() {
        return new M.Renderer(0, false, false, false, 100, 100, null, null, null, false, null, null, null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 54, "new Renderer"]}
  },
  "+Renderer": [674],
  ComplexPrimitiveShader: {
    "^": "Shader;gl@-877,program@-892,fragmentSrc@-847,vertexSrc@-847,attributes:PIXI$ComplexPrimitiveShader$attributes*-645,uniforms@-12,uSampler-893,projectionVector-893,offsetVector-893,dimensions-893,uMatrix-893,tintColor-893,color-893,translationMatrix-893,alpha-893,aVertexPosition-614,aPositionCoord-614,aScale-614,aRotation-614,aTextureCoord-614,colorAttribute-614,attributes-645,_UID-614",
    init$0: [function() {
      var program, t1;
      program = M.compileProgram(this.gl, this.vertexSrc, this.fragmentSrc);
      J.useProgram$1$x(this.gl, program);
      this.projectionVector = J.getUniformLocation$2$x(this.gl, program, "projectionVector");
      this.offsetVector = J.getUniformLocation$2$x(this.gl, program, "offsetVector");
      this.tintColor = J.getUniformLocation$2$x(this.gl, program, "tint");
      this.color = J.getUniformLocation$2$x(this.gl, program, "color");
      t1 = J.getAttribLocation$2$x(this.gl, program, "aVertexPosition");
      this.aVertexPosition = t1;
      this.PIXI$ComplexPrimitiveShader$attributes = [t1, this.colorAttribute];
      this.translationMatrix = J.getUniformLocation$2$x(this.gl, program, "translationMatrix");
      this.alpha = J.getUniformLocation$2$x(this.gl, program, "alpha");
      this.program = program;
    }, "call$0", "get$init", 0, 0, 54, "init"],
    destroy$0: [function() {
      J.deleteProgram$1$x(this.gl, this.program);
      this.uniforms = null;
      this.gl = null;
      this.PIXI$ComplexPrimitiveShader$attributes = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    ComplexPrimitiveShader$1: function(gl) {
      var t1 = $._UID;
      $._UID = J.$add$ns(t1, 1);
      $._UID = t1;
      this.program = null;
      this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"];
      this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"];
      this.init$0();
    },
    static: {ComplexPrimitiveShader$: [function(gl) {
        var t1 = new M.ComplexPrimitiveShader(gl, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.ComplexPrimitiveShader$1(gl);
        return t1;
      }, null, null, 2, 0, 159, 160, [], "new ComplexPrimitiveShader"]}
  },
  "+ComplexPrimitiveShader": [894],
  PixiFastShader: {
    "^": "Shader;gl@-877,program@-892,fragmentSrc@-847,vertexSrc@-847,textureCount@-614,uSampler:PIXI$PixiFastShader$uSampler@-893,projectionVector:PIXI$PixiFastShader$projectionVector@-893,offsetVector:PIXI$PixiFastShader$offsetVector@-893,dimensions:PIXI$PixiFastShader$dimensions@-893,uMatrix:PIXI$PixiFastShader$uMatrix@-893,aVertexPosition:PIXI$PixiFastShader$aVertexPosition@-614,aPositionCoord:PIXI$PixiFastShader$aPositionCoord@-614,aScale:PIXI$PixiFastShader$aScale@-614,aRotation:PIXI$PixiFastShader$aRotation@-614,aTextureCoord:PIXI$PixiFastShader$aTextureCoord@-614,colorAttribute:PIXI$PixiFastShader$colorAttribute@-614,attributes:PIXI$PixiFastShader$attributes*-645,uniforms@-12,uSampler-893,projectionVector-893,offsetVector-893,dimensions-893,uMatrix-893,tintColor-893,color-893,translationMatrix-893,alpha-893,aVertexPosition-614,aPositionCoord-614,aScale-614,aRotation-614,aTextureCoord-614,colorAttribute-614,attributes-645,_UID-614",
    init$0: [function() {
      var program, t1;
      program = M.compileProgram(this.gl, this.vertexSrc, this.fragmentSrc);
      J.useProgram$1$x(this.gl, program);
      this.PIXI$PixiFastShader$uSampler = J.getUniformLocation$2$x(this.gl, program, "uSampler");
      this.PIXI$PixiFastShader$projectionVector = J.getUniformLocation$2$x(this.gl, program, "projectionVector");
      this.PIXI$PixiFastShader$offsetVector = J.getUniformLocation$2$x(this.gl, program, "offsetVector");
      this.PIXI$PixiFastShader$dimensions = J.getUniformLocation$2$x(this.gl, program, "dimensions");
      this.PIXI$PixiFastShader$uMatrix = J.getUniformLocation$2$x(this.gl, program, "uMatrix");
      this.PIXI$PixiFastShader$aVertexPosition = J.getAttribLocation$2$x(this.gl, program, "aVertexPosition");
      this.PIXI$PixiFastShader$aPositionCoord = J.getAttribLocation$2$x(this.gl, program, "aPositionCoord");
      this.PIXI$PixiFastShader$aScale = J.getAttribLocation$2$x(this.gl, program, "aScale");
      this.PIXI$PixiFastShader$aRotation = J.getAttribLocation$2$x(this.gl, program, "aRotation");
      this.PIXI$PixiFastShader$aTextureCoord = J.getAttribLocation$2$x(this.gl, program, "aTextureCoord");
      t1 = J.getAttribLocation$2$x(this.gl, program, "aColor");
      this.PIXI$PixiFastShader$colorAttribute = t1;
      if (t1 === -1)
        this.PIXI$PixiFastShader$colorAttribute = 2;
      this.PIXI$PixiFastShader$attributes = [this.PIXI$PixiFastShader$aVertexPosition, this.PIXI$PixiFastShader$aPositionCoord, this.PIXI$PixiFastShader$aScale, this.PIXI$PixiFastShader$aRotation, this.PIXI$PixiFastShader$aTextureCoord, this.PIXI$PixiFastShader$colorAttribute];
      this.program = program;
    }, "call$0", "get$init", 0, 0, 54, "init"],
    destroy$0: [function() {
      J.deleteProgram$1$x(this.gl, this.program);
      this.uniforms = null;
      this.gl = null;
      this.PIXI$PixiFastShader$attributes = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    static: {PixiFastShader$: [function(gl) {
        var t1, t2;
        t1 = new M.PixiFastShader(gl, null, ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t2 = $._UID;
        $._UID = J.$add$ns(t2, 1);
        t1._UID = t2;
        t1.init$0();
        return t1;
      }, null, null, 2, 0, 159, 160, [], "new PixiFastShader"]}
  },
  "+PixiFastShader": [894],
  PixiShader: {
    "^": "Shader;gl@-877,program@-892,fragmentSrc@-847,vertexSrc@-847,textureCount@-614,uSampler:PIXI$PixiShader$uSampler@-893,projectionVector:PIXI$PixiShader$projectionVector@-893,offsetVector:PIXI$PixiShader$offsetVector@-893,dimensions:PIXI$PixiShader$dimensions@-893,uMatrix:PIXI$PixiShader$uMatrix@-893,aVertexPosition:PIXI$PixiShader$aVertexPosition@-614,aPositionCoord:PIXI$PixiShader$aPositionCoord@-614,aScale:PIXI$PixiShader$aScale@-614,aRotation:PIXI$PixiShader$aRotation@-614,aTextureCoord:PIXI$PixiShader$aTextureCoord@-614,colorAttribute:PIXI$PixiShader$colorAttribute@-614,attributes:PIXI$PixiShader$attributes*-645,uniforms@-783,uSampler-893,projectionVector-893,offsetVector-893,dimensions-893,uMatrix-893,tintColor-893,color-893,translationMatrix-893,alpha-893,aVertexPosition-614,aPositionCoord-614,aScale-614,aRotation-614,aTextureCoord-614,colorAttribute-614,attributes-645,_UID-614",
    init$0: [function() {
      var t1, t2, program, key;
      t1 = this.gl;
      t2 = this.vertexSrc;
      if (t2 == null)
        t2 = $.get$PixiShader_defaultVertexSrc();
      program = M.compileProgram(t1, t2, this.fragmentSrc);
      J.useProgram$1$x(this.gl, program);
      this.PIXI$PixiShader$uSampler = J.getUniformLocation$2$x(this.gl, program, "uSampler");
      this.PIXI$PixiShader$projectionVector = J.getUniformLocation$2$x(this.gl, program, "projectionVector");
      this.PIXI$PixiShader$offsetVector = J.getUniformLocation$2$x(this.gl, program, "offsetVector");
      this.PIXI$PixiShader$dimensions = J.getUniformLocation$2$x(this.gl, program, "dimensions");
      this.PIXI$PixiShader$aVertexPosition = J.getAttribLocation$2$x(this.gl, program, "aVertexPosition");
      this.PIXI$PixiShader$aTextureCoord = J.getAttribLocation$2$x(this.gl, program, "aTextureCoord");
      t2 = J.getAttribLocation$2$x(this.gl, program, "aColor");
      this.PIXI$PixiShader$colorAttribute = t2;
      if (t2 === -1)
        this.PIXI$PixiShader$colorAttribute = 2;
      this.PIXI$PixiShader$attributes = [this.PIXI$PixiShader$aVertexPosition, this.PIXI$PixiShader$aTextureCoord, this.PIXI$PixiShader$colorAttribute];
      for (t1 = J.get$iterator$ax(J.get$keys$x(this.uniforms)); t1.moveNext$0();) {
        key = t1.get$current();
        J.$indexSet$ax(J.$index$asx(this.uniforms, key), "uniformLocation", J.getUniformLocation$2$x(this.gl, program, key));
      }
      this.initUniforms$0();
      this.program = program;
    }, "call$0", "get$init", 0, 0, 54, "init"],
    initUniforms$0: [function() {
      var gl, t1, t2, key, uniform, t3, type, t4, line;
      this.textureCount = 1;
      gl = this.gl;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this.uniforms)), t2 = J.getInterceptor$x(gl); t1.moveNext$0();) {
        key = t1.get$current();
        uniform = J.$index$asx(this.uniforms, key);
        t3 = J.getInterceptor$asx(uniform);
        type = t3.$index(uniform, "type");
        t4 = J.getInterceptor(type);
        if (t4.$eq(type, "sampler2D")) {
          t3.$indexSet(uniform, "_init", false);
          if (t3.$index(uniform, "value") != null)
            this.initSampler2D$1(uniform);
        } else if (t4.$eq(type, "mat2") || t4.$eq(type, "mat3") || t4.$eq(type, "mat4")) {
          t3.$indexSet(uniform, "glMatrix", true);
          t3.$indexSet(uniform, "glValueLength", 1);
          if (t4.$eq(type, "mat2"))
            t3.$indexSet(uniform, "glFunc", t2.get$uniformMatrix2fv(gl));
          else if (t4.$eq(type, "mat3"))
            t3.$indexSet(uniform, "glFunc", t2.get$uniformMatrix3fv(gl));
          else if (t4.$eq(type, "mat4"))
            t3.$indexSet(uniform, "glFunc", t2.get$uniformMatrix4fv(gl));
        } else {
          switch (type) {
            case "1f":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform1f(gl));
              t3.$indexSet(uniform, "glValueLength", 1);
              break;
            case "1i":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform1i(gl));
              t3.$indexSet(uniform, "glValueLength", 1);
              break;
            case "2f":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform2f(gl));
              t3.$indexSet(uniform, "glValueLength", 2);
              break;
            case "2i":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform2i(gl));
              t3.$indexSet(uniform, "glValueLength", 2);
              break;
            case "2fv":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform2fv(gl));
              t3.$indexSet(uniform, "glValueLength", 1);
              break;
            case "3f":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform3f(gl));
              t3.$indexSet(uniform, "glValueLength", 3);
              break;
            case "3i":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform3i(gl));
              t3.$indexSet(uniform, "glValueLength", 3);
              break;
            case "3fv":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform3fv(gl));
              t3.$indexSet(uniform, "glValueLength", 1);
              break;
            case "4f":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform4f(gl));
              t3.$indexSet(uniform, "glValueLength", 4);
              break;
            case "4i":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform4i(gl));
              t3.$indexSet(uniform, "glValueLength", 4);
              break;
            case "4fv":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform4fv(gl));
              t3.$indexSet(uniform, "glValueLength", 1);
              break;
          }
          if (t3.$index(uniform, "glFunc") == null) {
            line = H.S(type);
            H.printString(line);
            throw H.wrapException(P.Exception_Exception("no shuch function!"));
          }
        }
      }
    }, "call$0", "get$initUniforms", 0, 0, 54, "initUniforms"],
    initSampler2D$1: [function(uniform) {
      var t1, line, t2, t3, data, magFilter, minFilter, wrapS, wrapT, width, height;
      t1 = J.getInterceptor$asx(uniform);
      if (t1.$index(uniform, "value") == null || t1.$index(uniform, "value").get$baseTexture() == null || t1.$index(uniform, "value").get$baseTexture().get$hasLoaded() !== true)
        return;
      line = H.S(this.textureCount);
      H.printString(line);
      t2 = this.gl;
      t3 = this.textureCount;
      if (typeof t3 !== "number")
        return H.iae(t3);
      J.activeTexture$1$x(t2, 33984 + t3);
      J.bindTexture$2$x(this.gl, 3553, J.$index$asx(t1.$index(uniform, "value").get$baseTexture().get$_glTextures(), this.gl));
      if (t1.$index(uniform, "textureData") != null) {
        data = t1.$index(uniform, "textureData");
        magFilter = data.get$magFilter() === true ? data.get$magFilter() : 9729;
        minFilter = data.get$minFilter() === true ? data.get$minFilter() : 9729;
        data.get$wrapS();
        data.get$wrapT();
        data.get$luminance();
        t2 = J.getInterceptor$asx(data);
        if (t2.$index(data, "repeat") != null) {
          wrapS = 10497;
          wrapT = 10497;
        } else {
          wrapS = 33071;
          wrapT = 33071;
        }
        t3 = this.gl;
        J.pixelStorei$2$x(t3, 37440, data.get$flipY() === true ? 1 : 0);
        if (t2.get$width(data) === true) {
          width = t2.get$width(data) === true ? t2.get$width(data) : 512;
          height = t2.get$height(data) === true ? t2.get$height(data) : 2;
          t2.get$border(data);
          J.texImage2D$9$x(this.gl, 3553, 0, 6408, width, height, 0, 6408, 5121, null);
        } else
          J.texImage2D$6$x(this.gl, 3553, 0, 6408, 6408, 5121, J.get$source$x(J.$index$asx(t1.$index(uniform, "value"), "baseTexture")));
        J.texParameteri$3$x(this.gl, 3553, 10240, magFilter);
        J.texParameteri$3$x(this.gl, 3553, 10241, minFilter);
        J.texParameteri$3$x(this.gl, 3553, 10242, wrapS);
        J.texParameteri$3$x(this.gl, 3553, 10243, wrapT);
      }
      J.uniform1i$2$x(this.gl, t1.$index(uniform, "uniformLocation"), this.textureCount);
      t1.$indexSet(uniform, "_init", true);
      this.textureCount = J.$add$ns(this.textureCount, 1);
    }, "call$1", "get$initSampler2D", 2, 0, 665, 895, [], "initSampler2D"],
    syncUniforms$0: [function() {
      var gl, t1, t2, key, uniform, t3, $location, flist, transpose, t4, texture;
      this.textureCount = 1;
      gl = this.gl;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this.uniforms)), t2 = J.getInterceptor$x(gl); t1.moveNext$0();) {
        key = t1.get$current();
        uniform = J.$index$asx(this.uniforms, key);
        t3 = J.getInterceptor$asx(uniform);
        if (J.$eq(t3.$index(uniform, "glValueLength"), 1))
          if (J.$eq(t3.$index(uniform, "glMatrix"), true)) {
            $location = t3.$index(uniform, "uniformLocation");
            flist = new Float32Array(H._ensureNativeList(t3.$index(uniform, "value")));
            transpose = t3.$index(uniform, "transpose") != null && t3.$index(uniform, "transpose");
            t3.$index(uniform, "glFunc").call$3($location, transpose, flist);
          } else {
            $location = t3.$index(uniform, "uniformLocation");
            if (!!J.getInterceptor(t3.$index(uniform, "value")).$isList) {
              flist = new Float32Array(H._ensureNativeList(t3.$index(uniform, "value")));
              t3.$index(uniform, "glFunc").call$2($location, flist);
            } else
              t3.$index(uniform, "glFunc").call$2($location, t3.$index(uniform, "value"));
          }
        else if (J.$eq(t3.$index(uniform, "glValueLength"), 2))
          t3.$index(uniform, "glFunc").call$3(t3.$index(uniform, "uniformLocation"), J.$index$asx(t3.$index(uniform, "value"), "x"), J.$index$asx(t3.$index(uniform, "value"), "y"));
        else if (J.$eq(t3.$index(uniform, "glValueLength"), 3))
          t3.$index(uniform, "glFunc").call$4(t3.$index(uniform, "uniformLocation"), J.$index$asx(t3.$index(uniform, "value"), "x"), J.$index$asx(t3.$index(uniform, "value"), "y"), J.$index$asx(t3.$index(uniform, "value"), "z"));
        else if (J.$eq(t3.$index(uniform, "glValueLength"), 4))
          t3.$index(uniform, "glFunc").call$5(t3.$index(uniform, "uniformLocation"), J.$index$asx(t3.$index(uniform, "value"), 0), J.$index$asx(t3.$index(uniform, "value"), 1), J.$index$asx(t3.$index(uniform, "value"), 2), J.$index$asx(t3.$index(uniform, "value"), 3));
        else if (J.$eq(t3.$index(uniform, "type"), "sampler2D"))
          if (t3.$index(uniform, "_init") != null) {
            t4 = this.textureCount;
            if (typeof t4 !== "number")
              return H.iae(t4);
            t2.activeTexture$1(gl, 33984 + t4);
            texture = J.$index$asx(t3.$index(uniform, "value").get$baseTexture().get$_glTextures(), gl);
            t2.bindTexture$2(gl, 3553, texture == null ? M.createWebGLTexture(t3.$index(uniform, "value").get$baseTexture(), gl) : texture);
            t2.uniform1i$2(gl, t3.$index(uniform, "uniformLocation"), this.textureCount);
            this.textureCount = J.$add$ns(this.textureCount, 1);
          } else
            this.initSampler2D$1(uniform);
      }
    }, "call$0", "get$syncUniforms", 0, 0, 54, "syncUniforms"],
    destroy$0: [function() {
      J.deleteProgram$1$x(this.gl, this.program);
      this.uniforms = null;
      this.gl = null;
      this.PIXI$PixiShader$attributes = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    static: {"^": "PixiShader_defaultVertexSrc@-847", PixiShader$: [function(gl) {
        var t1, t2;
        t1 = new M.PixiShader(gl, null, ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], null, 0, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t2 = $._UID;
        $._UID = J.$add$ns(t2, 1);
        t1._UID = t2;
        t1.init$0();
        return t1;
      }, null, null, 2, 0, 159, 160, [], "new PixiShader"]}
  },
  "+PixiShader": [894],
  PrimitiveShader: {
    "^": "Shader;gl@-877,program@-12,fragmentSrc@-847,vertexSrc@-847,projectionVector:PIXI$PrimitiveShader$projectionVector@-893,offsetVector:PIXI$PrimitiveShader$offsetVector@-893,tintColor:PIXI$PrimitiveShader$tintColor@-893,translationMatrix:PIXI$PrimitiveShader$translationMatrix@-893,alpha:PIXI$PrimitiveShader$alpha*-893,aVertexPosition:PIXI$PrimitiveShader$aVertexPosition@-614,colorAttribute:PIXI$PrimitiveShader$colorAttribute@-614,attributes:PIXI$PrimitiveShader$attributes*-745,uniforms@-12,uSampler-893,projectionVector-893,offsetVector-893,dimensions-893,uMatrix-893,tintColor-893,color-893,translationMatrix-893,alpha-893,aVertexPosition-614,aPositionCoord-614,aScale-614,aRotation-614,aTextureCoord-614,colorAttribute-614,attributes-645,_UID-614",
    init$0: [function() {
      var program, t1;
      program = M.compileProgram(this.gl, this.vertexSrc, this.fragmentSrc);
      J.useProgram$1$x(this.gl, program);
      this.PIXI$PrimitiveShader$projectionVector = J.getUniformLocation$2$x(this.gl, program, "projectionVector");
      this.PIXI$PrimitiveShader$offsetVector = J.getUniformLocation$2$x(this.gl, program, "offsetVector");
      this.PIXI$PrimitiveShader$tintColor = J.getUniformLocation$2$x(this.gl, program, "tint");
      this.PIXI$PrimitiveShader$aVertexPosition = J.getAttribLocation$2$x(this.gl, program, "aVertexPosition");
      t1 = J.getAttribLocation$2$x(this.gl, program, "aColor");
      this.PIXI$PrimitiveShader$colorAttribute = t1;
      this.PIXI$PrimitiveShader$attributes = [this.PIXI$PrimitiveShader$aVertexPosition, t1];
      this.PIXI$PrimitiveShader$translationMatrix = J.getUniformLocation$2$x(this.gl, program, "translationMatrix");
      this.PIXI$PrimitiveShader$alpha = J.getUniformLocation$2$x(this.gl, program, "alpha");
      this.program = program;
    }, "call$0", "get$init", 0, 0, 54, "init"],
    destroy$0: [function() {
      J.deleteProgram$1$x(this.gl, this.program);
      this.uniforms = null;
      this.gl = null;
      this.PIXI$PrimitiveShader$attributes = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    static: {PrimitiveShader$: [function(gl) {
        var t1, t2;
        t1 = new M.PrimitiveShader(gl, null, ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t2 = $._UID;
        $._UID = J.$add$ns(t2, 1);
        t1._UID = t2;
        t1.init$0();
        return t1;
      }, null, null, 2, 0, 159, 160, [], "new PrimitiveShader"]}
  },
  "+PrimitiveShader": [894],
  Shader: {
    "^": "Object;uSampler@-893,projectionVector@-893,offsetVector@-893,dimensions@-893,uMatrix@-893,tintColor@-893,color*-893,translationMatrix@-893,alpha*-893,aVertexPosition@-614,aPositionCoord@-614,aScale@-614,aRotation@-614,aTextureCoord@-614,colorAttribute@-614,attributes*-645,_UID@-614",
    static: {Shader$: [function() {
        return new M.Shader(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 161, "new Shader"]}
  },
  "+Shader": [674],
  StripShader: {
    "^": "Shader;program@-892,gl@-877,fragmentSrc@-847,vertexSrc@-847,uSampler:PIXI$StripShader$uSampler@-893,projectionVector:PIXI$StripShader$projectionVector@-893,offsetVector:PIXI$StripShader$offsetVector@-893,dimensions:PIXI$StripShader$dimensions@-893,uMatrix:PIXI$StripShader$uMatrix@-893,translationMatrix:PIXI$StripShader$translationMatrix@-893,alpha:PIXI$StripShader$alpha*-893,aVertexPosition:PIXI$StripShader$aVertexPosition@-614,aPositionCoord:PIXI$StripShader$aPositionCoord@-614,aScale:PIXI$StripShader$aScale@-614,aRotation:PIXI$StripShader$aRotation@-614,aTextureCoord:PIXI$StripShader$aTextureCoord@-614,colorAttribute:PIXI$StripShader$colorAttribute@-614,attributes:PIXI$StripShader$attributes*-645,uSampler-893,projectionVector-893,offsetVector-893,dimensions-893,uMatrix-893,tintColor-893,color-893,translationMatrix-893,alpha-893,aVertexPosition-614,aPositionCoord-614,aScale-614,aRotation-614,aTextureCoord-614,colorAttribute-614,attributes-645,_UID-614",
    init$0: [function() {
      var program, t1;
      program = M.compileProgram(this.gl, this.vertexSrc, this.fragmentSrc);
      J.useProgram$1$x(this.gl, program);
      this.PIXI$StripShader$uSampler = J.getUniformLocation$2$x(this.gl, program, "uSampler");
      this.PIXI$StripShader$projectionVector = J.getUniformLocation$2$x(this.gl, program, "projectionVector");
      this.PIXI$StripShader$offsetVector = J.getUniformLocation$2$x(this.gl, program, "offsetVector");
      this.PIXI$StripShader$colorAttribute = J.getAttribLocation$2$x(this.gl, program, "aColor");
      this.PIXI$StripShader$aVertexPosition = J.getAttribLocation$2$x(this.gl, program, "aVertexPosition");
      t1 = J.getAttribLocation$2$x(this.gl, program, "aTextureCoord");
      this.PIXI$StripShader$aTextureCoord = t1;
      this.PIXI$StripShader$attributes = [this.PIXI$StripShader$aVertexPosition, t1];
      this.PIXI$StripShader$translationMatrix = J.getUniformLocation$2$x(this.gl, program, "translationMatrix");
      this.PIXI$StripShader$alpha = J.getUniformLocation$2$x(this.gl, program, "alpha");
      this.program = program;
    }, "call$0", "get$init", 0, 0, 54, "init"],
    destroy$0: [function() {
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    static: {StripShader$: [function(gl) {
        var t1, t2;
        t1 = new M.StripShader(null, gl, ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "}"], ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t2 = $._UID;
        $._UID = J.$add$ns(t2, 1);
        t1._UID = t2;
        t1.init$0();
        return t1;
      }, null, null, 2, 0, 159, 160, [], "new StripShader"]}
  },
  "+StripShader": [894],
  FilterTexture: {
    "^": "Object;gl@-877,frameBuffer@-896,renderBuffer@-897,texture@-12,width*-614,height*-614",
    clear$0: [function(_) {
      var gl, t1;
      gl = this.gl;
      t1 = J.getInterceptor$x(gl);
      t1.clearColor$4(gl, 0, 0, 0, 0);
      t1.clear$1(gl, 16384);
    }, "call$0", "get$clear", 0, 0, 54, "clear"],
    resize$2: [function(_, width, height) {
      var gl, t1;
      width = J.toInt$0$n(width);
      height = J.toInt$0$n(height);
      if (J.$eq(this.width, width) && J.$eq(this.height, height))
        return;
      this.width = width;
      this.height = height;
      gl = this.gl;
      t1 = J.getInterceptor$x(gl);
      t1.bindTexture$2(gl, 3553, this.texture);
      W.ImageElement_ImageElement(null, null, null);
      t1.texImage2DTyped$9(gl, 3553, 0, 6408, width, height, 0, 6408, 5121, null);
      t1.bindRenderbuffer$2(gl, 36161, this.renderBuffer);
      t1.renderbufferStorage$4(gl, 36161, 34041, width, height);
    }, "call$2", "get$resize", 4, 0, 149, 31, [], 52, [], "resize"],
    destroy$0: [function() {
      var gl, t1;
      gl = this.gl;
      t1 = J.getInterceptor$x(gl);
      t1.deleteFramebuffer$1(gl, this.frameBuffer);
      t1.deleteTexture$1(gl, this.texture);
      this.frameBuffer = null;
      this.texture = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    FilterTexture$4: function(gl, width, height, scaleMode) {
      var t1, t2;
      this.frameBuffer = J.createFramebuffer$0$x(this.gl);
      t1 = J.createTexture$0$x(this.gl);
      this.texture = t1;
      J.bindTexture$2$x(this.gl, 3553, t1);
      t1 = this.gl;
      t2 = J.getInterceptor(scaleMode);
      J.texParameteri$3$x(t1, 3553, 10240, t2.$eq(scaleMode, C.scaleModes_1) ? 9729 : 9728);
      t1 = this.gl;
      J.texParameteri$3$x(t1, 3553, 10241, t2.$eq(scaleMode, C.scaleModes_1) ? 9729 : 9728);
      J.texParameteri$3$x(this.gl, 3553, 10242, 33071);
      J.texParameteri$3$x(this.gl, 3553, 10243, 33071);
      J.bindFramebuffer$2$x(this.gl, 36160, this.frameBuffer);
      J.framebufferTexture2D$5$x(this.gl, 36160, 36064, 3553, this.texture, 0);
      t1 = J.createRenderbuffer$0$x(this.gl);
      this.renderBuffer = t1;
      J.bindRenderbuffer$2$x(this.gl, 36161, t1);
      J.framebufferRenderbuffer$4$x(this.gl, 36160, 33306, 36161, this.renderBuffer);
      this.resize$2(0, width, height);
    },
    static: {FilterTexture$: [function(gl, width, height, scaleMode) {
        var t1 = new M.FilterTexture(gl, null, null, null, null, null);
        t1.FilterTexture$4(gl, width, height, scaleMode);
        return t1;
      }, null, null, 6, 2, 162, 163, 160, [], 31, [], 52, [], 74, [], "new FilterTexture"]}
  },
  "+FilterTexture": [674],
  WebGLBlendModeManager: {
    "^": "Object;gl@-877,currentBlendMode@-702",
    setBlendMode$1: [function(blendMode) {
      var blendModeWebGL, t1;
      if (J.$eq(this.currentBlendMode, blendMode))
        return false;
      this.currentBlendMode = blendMode;
      blendModeWebGL = J.$index$asx($.blendModesWebGL, blendMode);
      t1 = J.getInterceptor$asx(blendModeWebGL);
      J.blendFunc$2$x(this.gl, t1.$index(blendModeWebGL, 0), t1.$index(blendModeWebGL, 1));
      return true;
    }, "call$1", "get$setBlendMode", 2, 0, 898, 899, [], "setBlendMode"],
    destroy$0: [function() {
      this.gl = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    static: {WebGLBlendModeManager$: [function(gl) {
        var t1 = new M.WebGLBlendModeManager(gl, null);
        t1.currentBlendMode = C.BlendModes_99999;
        return t1;
      }, null, null, 2, 0, 159, 160, [], "new WebGLBlendModeManager"]}
  },
  "+WebGLBlendModeManager": [674],
  WebGLFastSpriteBatch: {
    "^": "Object;gl@-877,vertSize@-614,maxSize@-614,size*-614,numVerts@-614,numIndices@-614,vertices@-672,indices@-714,vertexBuffer@-715,indexBuffer@-715,lastIndexCount@-614,drawing@-617,currentBatchSize@-614,currentBaseTexture@-853,currentBlendMode@-702,renderSession@-884,shader@-894,matrix@-672",
    size$1: function($receiver, arg0) {
      return this.size.call$1(arg0);
    },
    setContext$1: [function(gl) {
      var t1, t2;
      this.gl = gl;
      t1 = J.getInterceptor$x(gl);
      this.vertexBuffer = t1.createBuffer$0(gl);
      t2 = t1.createBuffer$0(gl);
      this.indexBuffer = t2;
      t1.bindBuffer$2(gl, 34963, t2);
      t1.bufferData$3(gl, 34963, this.indices, 35044);
      t1.bindBuffer$2(gl, 34962, this.vertexBuffer);
      t1.bufferData$3(gl, 34962, this.vertices, 35048);
      this.currentBlendMode = C.BlendModes_99999;
    }, "call$1", "get$setContext", 2, 0, 159, 160, [], "setContext"],
    begin$2: [function(spriteBatch, renderSession) {
      this.renderSession = renderSession;
      this.shader = renderSession.get$shaderManager().get$fastShader();
      this.matrix = spriteBatch.get$_worldTransform().toArray$1(true);
      this.start$0(0);
    }, "call$2", "get$begin", 4, 0, 900, 901, [], 166, [], "begin"],
    end$0: [function() {
      this.flush$0(0);
    }, "call$0", "get$end", 0, 0, 54, "end"],
    render$1: [function(spriteBatch) {
      var children, t1, sprite, j, i;
      children = J.get$children$x(spriteBatch);
      t1 = J.getInterceptor$asx(children);
      sprite = t1.$index(children, 0);
      if (sprite.get$texture().get$_uvs() == null)
        return;
      this.currentBaseTexture = sprite.get$texture().get$baseTexture();
      if (!J.$eq(sprite.get$blendMode(), this.currentBlendMode))
        this.setBlendMode$1(sprite.get$blendMode());
      j = t1.get$length(children);
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        this.renderSprite$1(t1.$index(children, i));
      this.flush$0(0);
    }, "call$1", "get$render", 2, 0, 902, 901, [], "render"],
    renderSprite$1: [function(sprite) {
      var verticies, uvs, trim, t1, w1, w0, h1, h0, t2, index, index0, t3;
      if (sprite.get$visible() !== true)
        return;
      if (!J.$eq(sprite.get$texture().get$baseTexture(), this.currentBaseTexture)) {
        this.flush$0(0);
        this.currentBaseTexture = sprite.get$texture().get$baseTexture();
        if (sprite.get$texture().get$_uvs() == null)
          return;
      }
      verticies = this.vertices;
      uvs = sprite.get$texture().get$_uvs();
      J.get$width$x(sprite.get$texture().get$frame());
      J.get$height$x(sprite.get$texture().get$frame());
      if (J.get$trim$s(sprite.get$texture()) != null) {
        trim = J.get$trim$s(sprite.get$texture());
        t1 = J.getInterceptor$x(trim);
        w1 = J.$sub$n(t1.get$x(trim), J.$mul$ns(J.get$x$x(sprite.get$anchor()), t1.get$width(trim)));
        w0 = J.$add$ns(w1, J.get$width$x(sprite.get$texture().get$frame()));
        h1 = J.$sub$n(t1.get$y(trim), J.$mul$ns(J.get$y$x(sprite.get$anchor()), t1.get$height(trim)));
        h0 = J.$add$ns(h1, J.get$height$x(sprite.get$texture().get$frame()));
      } else {
        t1 = J.get$width$x(sprite.get$texture().get$frame());
        t2 = J.get$x$x(sprite.get$anchor());
        if (typeof t2 !== "number")
          return H.iae(t2);
        w0 = J.$mul$ns(t1, 1 - t2);
        w1 = J.$mul$ns(J.get$width$x(sprite.get$texture().get$frame()), J.$negate$n(J.get$x$x(sprite.get$anchor())));
        t2 = J.get$height$x(sprite.get$texture().get$frame());
        t1 = J.get$y$x(sprite.get$anchor());
        if (typeof t1 !== "number")
          return H.iae(t1);
        h0 = J.$mul$ns(t2, 1 - t1);
        h1 = J.$mul$ns(J.get$height$x(sprite.get$texture().get$frame()), J.$negate$n(J.get$y$x(sprite.get$anchor())));
      }
      index = J.$mul$ns(J.$mul$ns(this.currentBatchSize, 4), this.vertSize);
      index0 = J.$add$ns(index, 1);
      t1 = J.getInterceptor$ax(verticies);
      t1.$indexSet(verticies, index, w1);
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, h1);
      index0 = J.$add$ns(index, 1);
      t2 = J.getInterceptor$x(sprite);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$position(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$position(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$scale(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$scale(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, sprite.get$rotation());
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, uvs.get$x0());
      index0 = J.$add$ns(index, 1);
      t3 = J.getInterceptor$x(uvs);
      t1.$indexSet(verticies, index, t3.get$y1(uvs));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.toDouble$0$n(t2.get$alpha(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, w0);
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, h1);
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$position(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$position(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$scale(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$scale(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, sprite.get$rotation());
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, t3.get$x1(uvs));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, t3.get$y1(uvs));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.toDouble$0$n(t2.get$alpha(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, w0);
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, h0);
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$position(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$position(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$scale(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$scale(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, sprite.get$rotation());
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, t3.get$x2(uvs));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, t3.get$y2(uvs));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.toDouble$0$n(t2.get$alpha(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, w1);
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, h0);
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$position(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$position(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$scale(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$scale(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, sprite.get$rotation());
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, uvs.get$x3());
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, uvs.get$y3());
      J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.toDouble$0$n(t2.get$alpha(sprite)));
      t2 = J.$add$ns(this.currentBatchSize, 1);
      this.currentBatchSize = t2;
      if (J.$ge$n(t2, this.size))
        this.flush$0(0);
    }, "call$1", "get$renderSprite", 2, 0, 903, 151, [], "renderSprite"],
    flush$0: [function(_) {
      var gl, t1, t2, t3;
      if (J.$eq(this.currentBatchSize, 0))
        return;
      gl = this.gl;
      if (J.$index$asx(this.currentBaseTexture.get$_glTextures(), gl) == null)
        M.createWebGLTexture(this.currentBaseTexture, gl);
      t1 = J.getInterceptor$x(gl);
      t1.bindTexture$2(gl, 3553, J.$index$asx(this.currentBaseTexture.get$_glTextures(), gl));
      t2 = J.$gt$n(this.currentBatchSize, J.$mul$ns(this.size, 0.5));
      t3 = this.vertices;
      if (t2)
        t1.bufferSubData$3(gl, 34962, 0, t3);
      else
        t1.bufferSubData$3(gl, 34962, 0, J.sublist$2$ax(t3, 0, J.$mul$ns(J.$mul$ns(this.currentBatchSize, 4), this.vertSize)));
      t1.drawElements$4(gl, 4, J.$mul$ns(this.currentBatchSize, 6), 5123, 0);
      this.currentBatchSize = 0;
      t1 = this.renderSession;
      t1.set$drawCount(J.$add$ns(t1.get$drawCount(), 1));
    }, "call$0", "get$flush", 0, 0, 54, "flush"],
    stop$0: [function(_) {
      this.flush$0(0);
    }, "call$0", "get$stop", 0, 0, 54, "stop"],
    start$0: [function(_) {
      var gl, t1, projection, t2, stride;
      gl = this.gl;
      t1 = J.getInterceptor$x(gl);
      t1.activeTexture$1(gl, 33984);
      t1.bindBuffer$2(gl, 34962, this.vertexBuffer);
      t1.bindBuffer$2(gl, 34963, this.indexBuffer);
      projection = this.renderSession.get$projection();
      t2 = J.getInterceptor$x(projection);
      t1.uniform2f$3(gl, this.shader.get$projectionVector(), t2.get$x(projection), t2.get$y(projection));
      t1.uniformMatrix3fv$3(gl, this.shader.get$uMatrix(), false, this.matrix);
      stride = J.$mul$ns(this.vertSize, 4);
      t1.vertexAttribPointer$6(gl, this.shader.get$aVertexPosition(), 2, 5126, false, stride, 0);
      t1.vertexAttribPointer$6(gl, this.shader.get$aPositionCoord(), 2, 5126, false, stride, 8);
      t1.vertexAttribPointer$6(gl, this.shader.get$aScale(), 2, 5126, false, stride, 16);
      t1.vertexAttribPointer$6(gl, this.shader.get$aRotation(), 1, 5126, false, stride, 24);
      t1.vertexAttribPointer$6(gl, this.shader.get$aTextureCoord(), 2, 5126, false, stride, 28);
      t1.vertexAttribPointer$6(gl, this.shader.get$colorAttribute(), 1, 5126, false, stride, 36);
      if (!J.$eq(this.currentBlendMode, C.BlendModes_0))
        this.setBlendMode$1(C.BlendModes_0);
    }, "call$0", "get$start", 0, 0, 54, "start"],
    setBlendMode$1: [function(blendMode) {
      var blendModeWebGL, t1;
      this.flush$0(0);
      this.currentBlendMode = blendMode;
      blendModeWebGL = J.$index$asx($.blendModesWebGL, blendMode);
      t1 = J.getInterceptor$asx(blendModeWebGL);
      J.blendFunc$2$x(this.gl, t1.$index(blendModeWebGL, 0), t1.$index(blendModeWebGL, 1));
    }, "call$1", "get$setBlendMode", 2, 0, 904, 899, [], "setBlendMode"],
    WebGLFastSpriteBatch$1: function(gl) {
      var t1, i, j;
      t1 = this.maxSize;
      this.size = t1;
      this.numVerts = J.$mul$ns(J.$mul$ns(t1, 4), this.vertSize);
      this.numIndices = J.$mul$ns(this.maxSize, 6);
      this.vertices = new Float32Array(H._checkLength(this.numVerts));
      this.indices = new Uint16Array(H._checkLength(this.numIndices));
      i = 0;
      j = 0;
      while (true) {
        t1 = this.numIndices;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$indexSet$ax(this.indices, i, j);
        J.$indexSet$ax(this.indices, i + 1, j + 1);
        t1 = j + 2;
        J.$indexSet$ax(this.indices, i + 2, t1);
        J.$indexSet$ax(this.indices, i + 3, j);
        J.$indexSet$ax(this.indices, i + 4, t1);
        J.$indexSet$ax(this.indices, i + 5, j + 3);
        i += 6;
        j += 4;
      }
      this.setContext$1(gl);
    },
    static: {WebGLFastSpriteBatch$: [function(gl) {
        var t1 = new M.WebGLFastSpriteBatch(null, 10, 6000, null, null, null, null, null, null, null, 0, false, 0, null, C.BlendModes_0, null, null, null);
        t1.WebGLFastSpriteBatch$1(gl);
        return t1;
      }, null, null, 2, 0, 159, 160, [], "new WebGLFastSpriteBatch"]}
  },
  "+WebGLFastSpriteBatch": [674],
  WebGLFilterManager: {
    "^": "Object;gl@-877,transparent@-617,filterStack@-905,offsetX@-616,offsetY@-616,texturePool@-906,renderSession@-884,width*-614,height*-614,defaultShader@-907,vertexArray@-672,uvArray@-672,colorBuffer@-715,indexBuffer@-715,vertexBuffer@-715,uvBuffer@-715,buffer*-896,colorArray@-672",
    setContext$1: [function(gl) {
      var t1;
      this.gl = gl;
      this.texturePool = [];
      t1 = J.getInterceptor$x(gl);
      this.vertexBuffer = t1.createBuffer$0(gl);
      this.uvBuffer = t1.createBuffer$0(gl);
      this.colorBuffer = t1.createBuffer$0(gl);
      this.indexBuffer = t1.createBuffer$0(gl);
      this.vertexArray = new Float32Array(H._ensureNativeList([0, 0, 1, 0, 0, 1, 1, 1]));
      t1.bindBuffer$2(gl, 34962, this.vertexBuffer);
      t1.bufferData$3(gl, 34962, this.vertexArray, 35044);
      this.uvArray = new Float32Array(H._ensureNativeList([0, 0, 1, 0, 0, 1, 1, 1]));
      t1.bindBuffer$2(gl, 34962, this.uvBuffer);
      t1.bufferData$3(gl, 34962, this.uvArray, 35044);
      this.colorArray = new Float32Array(H._ensureNativeList([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]));
      t1.bindBuffer$2(gl, 34962, this.colorBuffer);
      t1.bufferData$3(gl, 34962, this.colorArray, 35044);
      t1.bindBuffer$2(gl, 34963, this.indexBuffer);
      t1.bufferData$3(gl, 34963, new Uint16Array(H._ensureNativeList([0, 1, 2, 1, 3, 2])), 35044);
    }, "call$1", "get$setContext", 2, 0, 102, 160, [], "setContext"],
    begin$2: [function(renderSession, buffer) {
      var projection, t1;
      this.renderSession = renderSession;
      this.defaultShader = renderSession.get$shaderManager().get$defaultShader();
      projection = this.renderSession.get$projection();
      t1 = J.getInterceptor$x(projection);
      this.width = J.toInt$0$n(J.$mul$ns(t1.get$x(projection), 2));
      this.height = J.toInt$0$n(J.$mul$ns(J.$negate$n(t1.get$y(projection)), 2));
      this.buffer = buffer;
    }, "call$2", "get$begin", 4, 0, 908, 166, [], 886, [], "begin"],
    pushFilter$1: [function(filterBlock) {
      var gl, projection, offset, t1, filter, texture, t2, filterArea, padding, t3;
      gl = this.gl;
      projection = this.renderSession.get$projection();
      offset = J.get$offset$x(this.renderSession);
      t1 = J.getInterceptor$x(filterBlock);
      filterBlock.set$_filterArea(t1.get$target(filterBlock).get$filterArea() == null ? t1.get$target(filterBlock).getBounds$0() : t1.get$target(filterBlock).get$filterArea());
      J.add$1$ax(this.filterStack, filterBlock);
      filter = J.$index$asx(filterBlock.get$filterPasses(), 0);
      this.offsetX = J.$add$ns(this.offsetX, J.get$x$x(filterBlock.get$_filterArea()));
      this.offsetY = J.$add$ns(this.offsetY, J.get$y$x(filterBlock.get$_filterArea()));
      texture = J.$gt$n(J.get$length$asx(this.texturePool), 0) ? J.removeLast$0$ax(this.texturePool) : null;
      t1 = this.width;
      t2 = this.height;
      if (texture == null)
        texture = M.FilterTexture$(this.gl, t1, t2, C.scaleModes_0);
      else
        J.resize$2$x(texture, t1, t2);
      t1 = J.getInterceptor$x(gl);
      t1.bindTexture$2(gl, 3553, texture.get$texture());
      filterArea = filterBlock.get$_filterArea();
      padding = J.get$padding$x(filter);
      t2 = J.getInterceptor$x(filterArea);
      t2.set$x(filterArea, J.$sub$n(t2.get$x(filterArea), padding));
      t2.set$y(filterArea, J.$sub$n(t2.get$y(filterArea), padding));
      t3 = J.getInterceptor$ns(padding);
      t2.set$width(filterArea, J.$add$ns(t2.get$width(filterArea), t3.$mul(padding, 2)));
      t2.set$height(filterArea, J.$add$ns(t2.get$height(filterArea), t3.$mul(padding, 2)));
      if (J.$lt$n(t2.get$x(filterArea), 0))
        t2.set$x(filterArea, 0);
      if (J.$gt$n(t2.get$width(filterArea), this.width))
        t2.set$width(filterArea, this.width);
      if (J.$lt$n(t2.get$y(filterArea), 0))
        t2.set$y(filterArea, 0);
      if (J.$gt$n(t2.get$height(filterArea), this.height))
        t2.set$height(filterArea, this.height);
      t1.bindFramebuffer$2(gl, 36160, texture.get$frameBuffer());
      t1.viewport$4(gl, 0, 0, J.toInt$0$n(t2.get$width(filterArea)), J.toInt$0$n(t2.get$height(filterArea)));
      t3 = J.getInterceptor$x(projection);
      t3.set$x(projection, J.$div$n(t2.get$width(filterArea), 2));
      t3.set$y(projection, J.$div$n(J.$negate$n(t2.get$height(filterArea)), 2));
      t3 = J.getInterceptor$x(offset);
      t3.set$x(offset, J.$negate$n(t2.get$x(filterArea)));
      t3.set$y(offset, J.$negate$n(t2.get$y(filterArea)));
      this.renderSession.get$shaderManager().setShader$1(this.defaultShader);
      t1.uniform2f$3(gl, this.defaultShader.get$projectionVector(), J.$div$n(t2.get$width(filterArea), 2), J.$div$n(J.$negate$n(t2.get$height(filterArea)), 2));
      t1.uniform2f$3(gl, this.defaultShader.get$offsetVector(), -J.toDouble$0$n(t2.get$x(filterArea)), -J.toDouble$0$n(t2.get$y(filterArea)));
      t1.colorMask$4(gl, true, true, true, true);
      t1.clearColor$4(gl, 0, 0, 0, 0);
      t1.clear$1(gl, 16384);
      filterBlock.set$_glFilterTexture(texture);
    }, "call$1", "get$pushFilter", 2, 0, 909, 910, [], "pushFilter"],
    popFilter$0: [function() {
      var filterBlock, filterArea, texture, projection, offset, t1, outputTexture, inputTexture, i, t2, filterPass, t0, filter, sizeX, sizeY, buffer, offsetX, offsetY, currentFilter, t3, x, y, t4, t5;
      filterBlock = J.removeLast$0$ax(this.filterStack);
      filterArea = filterBlock.get$_filterArea();
      texture = filterBlock.get$_glFilterTexture();
      projection = this.renderSession.get$projection();
      offset = J.get$offset$x(this.renderSession);
      if (J.$gt$n(J.get$length$asx(filterBlock.get$filterPasses()), 1)) {
        t1 = J.getInterceptor$x(filterArea);
        J.viewport$4$x(this.gl, 0, 0, J.toInt$0$n(t1.get$width(filterArea)), J.toInt$0$n(t1.get$height(filterArea)));
        J.bindBuffer$2$x(this.gl, 34962, this.vertexBuffer);
        J.$indexSet$ax(this.vertexArray, 0, 0);
        J.$indexSet$ax(this.vertexArray, 1, J.toDouble$0$n(t1.get$height(filterArea)));
        J.$indexSet$ax(this.vertexArray, 2, J.toDouble$0$n(t1.get$width(filterArea)));
        J.$indexSet$ax(this.vertexArray, 3, J.toDouble$0$n(t1.get$height(filterArea)));
        J.$indexSet$ax(this.vertexArray, 4, 0);
        J.$indexSet$ax(this.vertexArray, 5, 0);
        J.$indexSet$ax(this.vertexArray, 6, J.toDouble$0$n(t1.get$width(filterArea)));
        J.$indexSet$ax(this.vertexArray, 7, 0);
        J.bufferSubData$3$x(this.gl, 34962, 0, this.vertexArray);
        J.bindBuffer$2$x(this.gl, 34962, this.uvBuffer);
        J.$indexSet$ax(this.uvArray, 2, J.$div$n(t1.get$width(filterArea), this.width));
        J.$indexSet$ax(this.uvArray, 5, J.$div$n(t1.get$height(filterArea), this.height));
        J.$indexSet$ax(this.uvArray, 6, J.$div$n(t1.get$width(filterArea), this.width));
        J.$indexSet$ax(this.uvArray, 7, J.$div$n(t1.get$height(filterArea), this.height));
        J.bufferSubData$3$x(this.gl, 34962, 0, this.uvArray);
        outputTexture = J.$gt$n(J.get$length$asx(this.texturePool), 0) ? J.removeLast$0$ax(this.texturePool) : null;
        if (outputTexture == null)
          outputTexture = M.FilterTexture$(this.gl, this.width, this.height, C.scaleModes_0);
        J.resize$2$x(outputTexture, this.width, this.height);
        J.bindFramebuffer$2$x(this.gl, 36160, outputTexture.get$frameBuffer());
        J.clear$1$ax(this.gl, 16384);
        J.disable$1$x(this.gl, 3042);
        inputTexture = texture;
        i = 0;
        while (true) {
          t2 = J.$sub$n(J.get$length$asx(filterBlock.get$filterPasses()), 1);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          filterPass = J.$index$asx(filterBlock.get$filterPasses(), i);
          J.bindFramebuffer$2$x(this.gl, 36160, outputTexture.get$frameBuffer());
          J.activeTexture$1$x(this.gl, 33984);
          J.bindTexture$2$x(this.gl, 3553, inputTexture.get$texture());
          this.applyFilterPass$4(filterPass, filterArea, t1.get$width(filterArea), t1.get$height(filterArea));
          ++i;
          t0 = outputTexture;
          outputTexture = inputTexture;
          inputTexture = t0;
        }
        J.enable$1$x(this.gl, 3042);
        J.add$1$ax(this.texturePool, outputTexture);
        texture = inputTexture;
      }
      filter = J.$index$asx(filterBlock.get$filterPasses(), J.$sub$n(J.get$length$asx(filterBlock.get$filterPasses()), 1));
      t1 = J.getInterceptor$x(filterArea);
      this.offsetX = J.$sub$n(this.offsetX, t1.get$x(filterArea));
      this.offsetY = J.$sub$n(this.offsetY, t1.get$y(filterArea));
      sizeX = this.width;
      sizeY = this.height;
      buffer = this.buffer;
      if (J.$eq(J.get$length$asx(this.filterStack), 0)) {
        J.colorMask$4$x(this.gl, true, true, true, true);
        offsetX = 0;
        offsetY = 0;
      } else {
        t1 = this.filterStack;
        t2 = J.getInterceptor$asx(t1);
        currentFilter = t2.$index(t1, J.$sub$n(t2.get$length(t1), 1));
        filterArea = currentFilter.get$_filterArea();
        t1 = J.getInterceptor$x(filterArea);
        sizeX = t1.get$width(filterArea);
        sizeY = t1.get$height(filterArea);
        offsetX = t1.get$x(filterArea);
        offsetY = t1.get$y(filterArea);
        buffer = currentFilter.get$_glFilterTexture().get$frameBuffer();
      }
      t1 = J.getInterceptor$n(sizeX);
      t2 = J.getInterceptor$x(projection);
      t2.set$x(projection, t1.$div(sizeX, 2));
      t3 = J.getInterceptor$n(sizeY);
      t2.set$y(projection, J.$div$n(t3.$negate(sizeY), 2));
      t2 = J.getInterceptor$x(offset);
      t2.set$x(offset, offsetX);
      t2.set$y(offset, offsetY);
      filterArea = filterBlock.get$_filterArea();
      t2 = J.getInterceptor$x(filterArea);
      x = J.$add$ns(J.$sub$n(t2.get$x(filterArea), offsetX), 0);
      y = J.$add$ns(J.$sub$n(t2.get$y(filterArea), offsetY), 0);
      J.bindBuffer$2$x(this.gl, 34962, this.vertexBuffer);
      J.$indexSet$ax(this.vertexArray, 0, x);
      t4 = J.getInterceptor$ns(y);
      J.$indexSet$ax(this.vertexArray, 1, t4.$add(y, t2.get$height(filterArea)));
      t5 = J.getInterceptor$ns(x);
      J.$indexSet$ax(this.vertexArray, 2, t5.$add(x, t2.get$width(filterArea)));
      J.$indexSet$ax(this.vertexArray, 3, t4.$add(y, t2.get$height(filterArea)));
      J.$indexSet$ax(this.vertexArray, 4, x);
      J.$indexSet$ax(this.vertexArray, 5, y);
      J.$indexSet$ax(this.vertexArray, 6, t5.$add(x, t2.get$width(filterArea)));
      J.$indexSet$ax(this.vertexArray, 7, y);
      J.bufferSubData$3$x(this.gl, 34962, 0, this.vertexArray);
      J.bindBuffer$2$x(this.gl, 34962, this.uvBuffer);
      J.$indexSet$ax(this.uvArray, 2, J.$div$n(t2.get$width(filterArea), this.width));
      J.$indexSet$ax(this.uvArray, 5, J.$div$n(t2.get$height(filterArea), this.height));
      J.$indexSet$ax(this.uvArray, 6, J.$div$n(t2.get$width(filterArea), this.width));
      J.$indexSet$ax(this.uvArray, 7, J.$div$n(t2.get$height(filterArea), this.height));
      J.bufferSubData$3$x(this.gl, 34962, 0, this.uvArray);
      J.viewport$4$x(this.gl, 0, 0, t1.toInt$0(sizeX), t3.toInt$0(sizeY));
      J.bindFramebuffer$2$x(this.gl, 36160, buffer);
      J.activeTexture$1$x(this.gl, 33984);
      J.bindTexture$2$x(this.gl, 3553, texture.get$texture());
      this.applyFilterPass$4(filter, filterArea, sizeX, sizeY);
      this.renderSession.get$shaderManager().setShader$1(this.defaultShader);
      J.uniform2f$3$x(this.gl, this.defaultShader.get$projectionVector(), t1.$div(sizeX, 2), J.$div$n(t3.$negate(sizeY), 2));
      J.uniform2f$3$x(this.gl, this.defaultShader.get$offsetVector(), J.$negate$n(offsetX), J.$negate$n(offsetY));
      J.add$1$ax(this.texturePool, texture);
      filterBlock.set$_glFilterTexture(null);
    }, "call$0", "get$popFilter", 0, 0, 54, "popFilter"],
    applyFilterPass$4: [function(filter, filterArea, width, height) {
      var shader, t1;
      shader = J.$index$asx(filter.get$shaders(), this.gl);
      if (shader == null) {
        shader = new M.PixiShader(this.gl, null, ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], null, 0, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1 = $._UID;
        $._UID = J.$add$ns(t1, 1);
        shader._UID = t1;
        shader.init$0();
        shader.fragmentSrc = filter.get$fragmentSrc();
        shader.uniforms = filter.get$uniforms();
        shader.init$0();
        J.$indexSet$ax(filter.get$shaders(), this.gl, shader);
      }
      this.renderSession.get$shaderManager().setShader$1(shader);
      J.uniform2f$3$x(this.gl, shader.get$projectionVector(), J.$div$n(width, 2), J.$div$n(J.$negate$n(height), 2));
      J.uniform2f$3$x(this.gl, shader.get$offsetVector(), 0, 0);
      if (J.$index$asx(filter.get$uniforms(), "dimensions") != null) {
        J.$indexSet$ax(J.$index$asx(J.$index$asx(filter.get$uniforms(), "dimensions"), "value"), 0, J.toDouble$0$n(this.width));
        J.$indexSet$ax(J.$index$asx(J.$index$asx(filter.get$uniforms(), "dimensions"), "value"), 1, J.toDouble$0$n(this.height));
        J.$indexSet$ax(J.$index$asx(J.$index$asx(filter.get$uniforms(), "dimensions"), "value"), 2, J.toDouble$0$n(J.$index$asx(this.vertexArray, 0)));
        J.$indexSet$ax(J.$index$asx(J.$index$asx(filter.get$uniforms(), "dimensions"), "value"), 3, J.toDouble$0$n(J.$index$asx(this.vertexArray, 5)));
      }
      shader.syncUniforms$0();
      J.bindBuffer$2$x(this.gl, 34962, this.vertexBuffer);
      J.vertexAttribPointer$6$x(this.gl, shader.get$aVertexPosition(), 2, 5126, false, 0, 0);
      J.bindBuffer$2$x(this.gl, 34962, this.uvBuffer);
      J.vertexAttribPointer$6$x(this.gl, shader.get$aTextureCoord(), 2, 5126, false, 0, 0);
      J.bindBuffer$2$x(this.gl, 34962, this.colorBuffer);
      J.vertexAttribPointer$6$x(this.gl, shader.get$colorAttribute(), 2, 5126, false, 0, 0);
      J.bindBuffer$2$x(this.gl, 34963, this.indexBuffer);
      J.drawElements$4$x(this.gl, 4, 6, 5123, 0);
      t1 = this.renderSession;
      t1.set$drawCount(J.$add$ns(t1.get$drawCount(), 1));
    }, "call$4", "get$applyFilterPass", 8, 0, 911, 912, [], 913, [], 31, [], 52, [], "applyFilterPass"],
    initShaderBuffers$0: [function() {
      var gl, t1;
      gl = this.gl;
      t1 = J.getInterceptor$x(gl);
      this.vertexBuffer = t1.createBuffer$0(gl);
      this.uvBuffer = t1.createBuffer$0(gl);
      this.colorBuffer = t1.createBuffer$0(gl);
      this.indexBuffer = t1.createBuffer$0(gl);
      this.vertexArray = new Float32Array(H._ensureNativeList([0, 0, 1, 0, 0, 1, 1, 1]));
      t1.bindBuffer$2(gl, 34962, this.vertexBuffer);
      t1.bufferData$3(gl, 34962, this.vertexArray, 35044);
      this.uvArray = new Float32Array(H._ensureNativeList([0, 0, 1, 0, 0, 1, 1, 1]));
      t1.bindBuffer$2(gl, 34962, this.uvBuffer);
      t1.bufferData$3(gl, 34962, this.uvArray, 35044);
      this.colorArray = new Float32Array(H._ensureNativeList([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]));
      t1.bindBuffer$2(gl, 34962, this.colorBuffer);
      t1.bufferData$3(gl, 34962, this.colorArray, 35044);
      t1.bindBuffer$2(gl, 34963, this.indexBuffer);
      t1.bufferData$3(gl, 34963, new Uint16Array(H._ensureNativeList([0, 1, 2, 1, 3, 2])), 35044);
    }, "call$0", "get$initShaderBuffers", 0, 0, 54, "initShaderBuffers"],
    destroy$0: [function() {
      var gl, i, t1;
      gl = this.gl;
      this.filterStack = null;
      this.offsetX = 0;
      this.offsetY = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.texturePool);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$index$asx(this.texturePool, i).destroy$0();
        ++i;
      }
      this.texturePool = null;
      t1 = J.getInterceptor$x(gl);
      t1.deleteBuffer$1(gl, this.vertexBuffer);
      t1.deleteBuffer$1(gl, this.uvBuffer);
      t1.deleteBuffer$1(gl, this.colorBuffer);
      t1.deleteBuffer$1(gl, this.indexBuffer);
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    static: {WebGLFilterManager$: [function(gl, transparent) {
        var t1 = new M.WebGLFilterManager(null, transparent, [], 0, 0, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.setContext$1(gl);
        return t1;
      }, null, null, 4, 0, 164, 160, [], 147, [], "new WebGLFilterManager"]}
  },
  "+WebGLFilterManager": [674],
  WebGLGraphicsData: {
    "^": "Object;gl@-877,color*-709,points*-709,indices@-709,lastIndex@-614,buffer*-715,indexBuffer@-715,mode*-614,alpha*-616,dirty@-617,glPoints@-672,glIndicies@-714,data*-914",
    reset$0: [function(_) {
      this.points = [];
      this.indices = [];
      this.lastIndex = 0;
    }, "call$0", "get$reset", 0, 0, 54, "reset"],
    upload$0: [function(_) {
      var gl, t1;
      gl = this.gl;
      this.glPoints = new Float32Array(H._ensureNativeList(J.toList$0$ax(J.map$1$ax(this.points, new M.WebGLGraphicsData_upload_closure()))));
      t1 = J.getInterceptor$x(gl);
      t1.bindBuffer$2(gl, 34962, this.buffer);
      t1.bufferData$3(gl, 34962, this.glPoints, 35044);
      this.glIndicies = new Uint16Array(H._ensureNativeList(J.toList$0$ax(J.map$1$ax(this.indices, new M.WebGLGraphicsData_upload_closure0()))));
      t1.bindBuffer$2(gl, 34963, this.indexBuffer);
      t1.bufferData$3(gl, 34963, this.glIndicies, 35044);
      this.dirty = false;
    }, "call$0", "get$upload", 0, 0, 54, "upload"],
    WebGLGraphicsData$1: function(gl) {
      this.color = [0, 0, 0];
      this.points = [];
      this.indices = [];
      this.lastIndex = 0;
      this.buffer = J.createBuffer$0$x(this.gl);
      this.indexBuffer = J.createBuffer$0$x(this.gl);
      this.mode = 1;
      this.alpha = 1;
      this.dirty = true;
    },
    static: {WebGLGraphicsData$: [function(gl) {
        var t1 = new M.WebGLGraphicsData(gl, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.WebGLGraphicsData$1(gl);
        return t1;
      }, null, null, 2, 0, 159, 160, [], "new WebGLGraphicsData"]}
  },
  "+WebGLGraphicsData": [674],
  WebGLGraphicsData_upload_closure: {
    "^": "Closure:102;",
    call$1: [function(s) {
      return J.toDouble$0$n(s);
    }, "call$1", null, 2, 0, 102, 545, [], "call"]
  },
  WebGLGraphicsData_upload_closure0: {
    "^": "Closure:620;",
    call$1: [function(s) {
      return J.toInt$0$n(s);
    }, "call$1", null, 2, 0, 620, 545, [], "call"]
  },
  WebGLGraphics: {
    "^": "Object;",
    static: {"^": "WebGLGraphics_graphicsDataPool@-914,WebGLGraphics_last@-614", WebGLGraphics$: [function() {
        return new M.WebGLGraphics();
      }, null, null, 0, 0, 54, "new WebGLGraphics"], WebGLGraphics_renderGraphics: [function(graphics, renderSession) {
        var gl, projection, offset, shader, webGL, t1, t2, t3, t4, i, t5, webGLData, t6, colorList, tintColor;
        gl = renderSession.get$gl();
        projection = renderSession.get$projection();
        offset = J.get$offset$x(renderSession);
        shader = renderSession.get$shaderManager().get$primitiveShader();
        if (graphics.get$_dirty() === true)
          M.WebGLGraphics_updateGraphics(graphics, gl);
        webGL = J.$index$asx(graphics.get$_webGL(), gl);
        t1 = J.getInterceptor$x(webGL);
        t2 = J.getInterceptor$x(gl);
        t3 = J.getInterceptor$x(projection);
        t4 = J.getInterceptor$x(offset);
        i = 0;
        while (true) {
          t5 = J.get$length$asx(t1.get$data(webGL));
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (!(i < t5))
            break;
          if (J.$eq(J.get$mode$x(J.$index$asx(t1.get$data(webGL), i)), 1)) {
            webGLData = J.$index$asx(t1.get$data(webGL), i);
            renderSession.get$stencilManager().pushStencil$3(graphics, webGLData, renderSession);
            t2.drawElements$4(gl, 6, 4, 5123, J.$mul$ns(J.$sub$n(J.get$length$asx(webGLData.get$indices()), 4), 2));
            renderSession.get$stencilManager().popStencil$3(graphics, webGLData, renderSession);
            $.WebGLGraphics_last = J.get$mode$x(webGLData);
          } else {
            webGLData = J.$index$asx(t1.get$data(webGL), i);
            t5 = graphics.get$tint();
            t6 = J.getInterceptor$n(t5);
            colorList = [(t6.$shr(t5, 16) & 255) / 255, (t6.$shr(t5, 8) & 255) / 255, t6.$and(t5, 255) / 255];
            tintColor = new Float32Array(3);
            t5 = colorList.length;
            if (0 >= t5)
              return H.ioore(colorList, 0);
            tintColor[0] = colorList[0];
            if (1 >= t5)
              return H.ioore(colorList, 1);
            tintColor[1] = colorList[1];
            if (2 >= t5)
              return H.ioore(colorList, 2);
            tintColor[2] = colorList[2];
            renderSession.get$shaderManager().setShader$1(shader);
            shader = renderSession.get$shaderManager().get$primitiveShader();
            t2.uniformMatrix3fv$3(gl, shader.get$translationMatrix(), false, graphics.get$_worldTransform().toArray$1(true));
            t2.uniform2f$3(gl, shader.get$projectionVector(), t3.get$x(projection), J.$negate$n(t3.get$y(projection)));
            t2.uniform2f$3(gl, shader.get$offsetVector(), J.$negate$n(t4.get$x(offset)), J.$negate$n(t4.get$y(offset)));
            t2.uniform3fv$2(gl, shader.get$tintColor(), tintColor);
            t2.uniform1f$2(gl, J.get$alpha$x(shader), graphics.get$_worldAlpha());
            t2.bindBuffer$2(gl, 34962, J.get$buffer$x(webGLData));
            t2.vertexAttribPointer$6(gl, shader.get$aVertexPosition(), 2, 5126, false, 24, 0);
            t2.vertexAttribPointer$6(gl, shader.get$colorAttribute(), 4, 5126, false, 24, 8);
            t2.bindBuffer$2(gl, 34963, webGLData.get$indexBuffer());
            t2.drawElements$4(gl, 5, J.get$length$asx(webGLData.get$indices()), 5123, 0);
          }
          ++i;
        }
      }, "call$2", "WebGLGraphics_renderGraphics$closure", 4, 0, 165, 141, [], 166, [], "renderGraphics"], WebGLGraphics_updateGraphics: [function(graphics, gl) {
        var webGL, t1, i, t2, graphicsData, webGLData, data, rectData, t3, x, y, width, height, t4, color, alpha, r, g, b, verts, indices, vertPos, t5, tempPoints;
        webGL = J.$index$asx(graphics.get$_webGL(), gl);
        if (webGL == null) {
          t1 = graphics.get$_webGL();
          webGL = M.WebGLGraphicsData$(gl);
          webGL.lastIndex = 0;
          webGL.data = [];
          webGL.gl = gl;
          J.$indexSet$ax(t1, gl, webGL);
        }
        graphics.set$_dirty(false);
        if (graphics.get$clearDirty() === true) {
          graphics.set$clearDirty(false);
          t1 = J.getInterceptor$x(webGL);
          i = 0;
          while (true) {
            t2 = J.get$length$asx(t1.get$data(webGL));
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            graphicsData = J.$index$asx(t1.get$data(webGL), i);
            J.reset$0$x(graphicsData);
            J.add$1$ax($.get$WebGLGraphics_graphicsDataPool(), graphicsData);
            ++i;
          }
          t1.set$data(webGL, []);
          webGL.set$lastIndex(0);
        }
        for (i = webGL.get$lastIndex(), webGLData = null; t1 = J.getInterceptor$n(i), t1.$lt(i, J.get$length$asx(graphics.get$_graphicsData())); i = t1.$add(i, 1)) {
          data = J.$index$asx(graphics.get$_graphicsData(), i);
          t2 = J.getInterceptor$x(data);
          if (J.$eq(t2.get$type(data), $.Graphics_POLY)) {
            if (t2.get$fill(data) === true)
              if (J.$gt$n(J.get$length$asx(t2.get$points(data)), 6))
                if (J.$gt$n(J.get$length$asx(t2.get$points(data)), 10)) {
                  webGLData = M.WebGLGraphics_switchMode(webGL, 1);
                  M.WebGLGraphics_buildComplexPoly(data, webGLData);
                } else {
                  webGLData = M.WebGLGraphics_switchMode(webGL, 0);
                  M.WebGLGraphics_buildPoly(data, webGLData);
                }
            if (J.$gt$n(t2.get$lineWidth(data), 0)) {
              webGLData = M.WebGLGraphics_switchMode(webGL, 0);
              M.WebGLGraphics_buildLine(data, webGLData);
            }
          } else {
            webGLData = M.WebGLGraphics_switchMode(webGL, 0);
            if (J.$eq(t2.get$type(data), $.Graphics_RECT)) {
              rectData = t2.get$points(data);
              t3 = J.getInterceptor$asx(rectData);
              x = t3.$index(rectData, 0);
              y = t3.$index(rectData, 1);
              width = t3.$index(rectData, 2);
              height = t3.$index(rectData, 3);
              if (t2.get$fill(data) === true) {
                t3 = data.get$fillColor();
                t4 = J.getInterceptor$n(t3);
                color = [(t4.$shr(t3, 16) & 255) / 255, (t4.$shr(t3, 8) & 255) / 255, t4.$and(t3, 255) / 255];
                alpha = data.get$fillAlpha();
                if (0 >= color.length)
                  return H.ioore(color, 0);
                r = J.$mul$ns(color[0], alpha);
                if (1 >= color.length)
                  return H.ioore(color, 1);
                g = J.$mul$ns(color[1], alpha);
                if (2 >= color.length)
                  return H.ioore(color, 2);
                b = J.$mul$ns(color[2], alpha);
                verts = J.get$points$x(webGLData);
                indices = webGLData.get$indices();
                t3 = J.getInterceptor$asx(verts);
                vertPos = J.$div$n(t3.get$length(verts), 6);
                t3.addAll$1(verts, [x, y]);
                t3.addAll$1(verts, [r, g, b, alpha]);
                t4 = J.getInterceptor$ns(x);
                t3.addAll$1(verts, [t4.$add(x, width), y]);
                t3.addAll$1(verts, [r, g, b, alpha]);
                t5 = J.getInterceptor$ns(y);
                t3.addAll$1(verts, [x, t5.$add(y, height)]);
                t3.addAll$1(verts, [r, g, b, alpha]);
                t3.addAll$1(verts, [t4.$add(x, width), t5.$add(y, height)]);
                t3.addAll$1(verts, [r, g, b, alpha]);
                t3 = J.getInterceptor$ns(vertPos);
                J.addAll$1$ax(indices, [vertPos, vertPos, t3.$add(vertPos, 1), t3.$add(vertPos, 2), t3.$add(vertPos, 3), t3.$add(vertPos, 3)]);
              }
              if (!J.$eq(t2.get$lineWidth(data), 0)) {
                tempPoints = t2.get$points(data);
                t3 = J.getInterceptor$ns(x);
                t4 = J.getInterceptor$ns(y);
                t2.set$points(data, [x, y, t3.$add(x, width), y, t3.$add(x, width), t4.$add(y, height), x, t4.$add(y, height), x, y]);
                M.WebGLGraphics_buildLine(data, webGLData);
                t2.set$points(data, tempPoints);
              }
            } else if (J.$eq(t2.get$type(data), $.Graphics_CIRC) || J.$eq(t2.get$type(data), $.Graphics_ELIP))
              M.WebGLGraphics_buildCircle(data, webGLData);
            else if (J.$eq(t2.get$type(data), $.Graphics_RREC))
              M.WebGLGraphics_buildRoundedRectangle(data, webGLData);
          }
          webGL.set$lastIndex(J.$add$ns(webGL.get$lastIndex(), 1));
        }
        t1 = J.getInterceptor$x(webGL);
        i = 0;
        while (true) {
          t2 = J.get$length$asx(t1.get$data(webGL));
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          webGLData = J.$index$asx(t1.get$data(webGL), i);
          if (webGLData.get$dirty() === true)
            J.upload$0$x(webGLData);
          ++i;
        }
      }, "call$2", "WebGLGraphics_updateGraphics$closure", 4, 0, 167, 141, [], 160, [], "updateGraphics"], WebGLGraphics_switchMode: [function(webGL, type) {
        var t1, webGLData;
        t1 = J.getInterceptor$x(webGL);
        if (J.$eq(J.get$length$asx(t1.get$data(webGL)), 0)) {
          webGLData = J.$gt$n(J.get$length$asx($.get$WebGLGraphics_graphicsDataPool()), 0) ? J.removeLast$0$ax($.get$WebGLGraphics_graphicsDataPool()) : null;
          if (webGLData == null)
            webGLData = M.WebGLGraphicsData$(webGL.get$gl());
          J.set$mode$x(webGLData, type);
          J.add$1$ax(t1.get$data(webGL), webGLData);
        } else {
          webGLData = J.$index$asx(t1.get$data(webGL), J.$sub$n(J.get$length$asx(t1.get$data(webGL)), 1));
          if (!J.$eq(J.get$mode$x(webGLData), type) || J.$eq(type, 1)) {
            webGLData = J.$gt$n(J.get$length$asx($.get$WebGLGraphics_graphicsDataPool()), 0) ? J.removeLast$0$ax($.get$WebGLGraphics_graphicsDataPool()) : M.WebGLGraphicsData$(webGL.get$gl());
            J.set$mode$x(webGLData, type);
            J.add$1$ax(t1.get$data(webGL), webGLData);
          }
        }
        webGLData.set$dirty(true);
        return webGLData;
      }, "call$2", "WebGLGraphics_switchMode$closure", 4, 0, 168, 169, [], 137, [], "switchMode"], WebGLGraphics_buildRectangle: [function(graphicsData, webGLData) {
        var t1, rectData, t2, x, y, width, height, t3, color, alpha, r, g, b, verts, indices, vertPos, t4, tempPoints;
        t1 = J.getInterceptor$x(graphicsData);
        rectData = t1.get$points(graphicsData);
        t2 = J.getInterceptor$asx(rectData);
        x = t2.$index(rectData, 0);
        y = t2.$index(rectData, 1);
        width = t2.$index(rectData, 2);
        height = t2.$index(rectData, 3);
        if (t1.get$fill(graphicsData) === true) {
          t2 = graphicsData.get$fillColor();
          t3 = J.getInterceptor$n(t2);
          color = [(t3.$shr(t2, 16) & 255) / 255, (t3.$shr(t2, 8) & 255) / 255, t3.$and(t2, 255) / 255];
          alpha = graphicsData.get$fillAlpha();
          if (0 >= color.length)
            return H.ioore(color, 0);
          r = J.$mul$ns(color[0], alpha);
          if (1 >= color.length)
            return H.ioore(color, 1);
          g = J.$mul$ns(color[1], alpha);
          if (2 >= color.length)
            return H.ioore(color, 2);
          b = J.$mul$ns(color[2], alpha);
          verts = J.get$points$x(webGLData);
          indices = webGLData.get$indices();
          t2 = J.getInterceptor$asx(verts);
          vertPos = J.$div$n(t2.get$length(verts), 6);
          t2.addAll$1(verts, [x, y]);
          t2.addAll$1(verts, [r, g, b, alpha]);
          t3 = J.getInterceptor$ns(x);
          t2.addAll$1(verts, [t3.$add(x, width), y]);
          t2.addAll$1(verts, [r, g, b, alpha]);
          t4 = J.getInterceptor$ns(y);
          t2.addAll$1(verts, [x, t4.$add(y, height)]);
          t2.addAll$1(verts, [r, g, b, alpha]);
          t2.addAll$1(verts, [t3.$add(x, width), t4.$add(y, height)]);
          t2.addAll$1(verts, [r, g, b, alpha]);
          t2 = J.getInterceptor$ns(vertPos);
          J.addAll$1$ax(indices, [vertPos, vertPos, t2.$add(vertPos, 1), t2.$add(vertPos, 2), t2.$add(vertPos, 3), t2.$add(vertPos, 3)]);
        }
        if (!J.$eq(t1.get$lineWidth(graphicsData), 0)) {
          tempPoints = t1.get$points(graphicsData);
          t2 = J.getInterceptor$ns(x);
          t3 = J.getInterceptor$ns(y);
          t1.set$points(graphicsData, [x, y, t2.$add(x, width), y, t2.$add(x, width), t3.$add(y, height), x, t3.$add(y, height), x, y]);
          M.WebGLGraphics_buildLine(graphicsData, webGLData);
          t1.set$points(graphicsData, tempPoints);
        }
      }, "call$2", "WebGLGraphics_buildRectangle$closure", 4, 0, 170, 171, [], 172, [], "buildRectangle"], WebGLGraphics_quadraticBezierCurve: [function(fromX, fromY, cpX, cpY, toX, toY) {
        var points, t1, i, j, xa, ya, xb, yb;
        points = [];
        t1 = new M.WebGLGraphics_quadraticBezierCurve_getPt();
        for (i = 0; i <= 20; ++i) {
          j = i / 20;
          xa = t1.call$3(fromX, cpX, j);
          ya = t1.call$3(fromY, cpY, j);
          xb = t1.call$3(cpX, toX, j);
          yb = t1.call$3(cpY, toY, j);
          C.JSArray_methods.addAll$1(points, [t1.call$3(xa, xb, j), t1.call$3(ya, yb, j)]);
        }
        return points;
      }, "call$6", "WebGLGraphics_quadraticBezierCurve$closure", 12, 0, 173, 174, [], 175, [], 176, [], 177, [], 178, [], 179, [], "quadraticBezierCurve"], WebGLGraphics_buildRoundedRectangle: [function(graphicsData, webGLData) {
        var t1, points, t2, x, y, width, height, radius, recPoints, t3, color, alpha, r, g, b, verts, indices, vecPos, triangles, i, t4, tempPoints;
        t1 = J.getInterceptor$x(graphicsData);
        points = t1.get$points(graphicsData);
        t2 = J.getInterceptor$asx(points);
        x = t2.$index(points, 0);
        y = t2.$index(points, 1);
        width = t2.$index(points, 2);
        height = t2.$index(points, 3);
        radius = t2.$index(points, 4);
        recPoints = [];
        t2 = J.getInterceptor$ns(y);
        C.JSArray_methods.addAll$1(recPoints, [x, t2.$add(y, radius)]);
        t3 = J.getInterceptor$ns(x);
        C.JSArray_methods.addAll$1(recPoints, M.WebGLGraphics_quadraticBezierCurve(x, J.$sub$n(t2.$add(y, height), radius), x, t2.$add(y, height), t3.$add(x, radius), t2.$add(y, height)));
        C.JSArray_methods.addAll$1(recPoints, M.WebGLGraphics_quadraticBezierCurve(J.$sub$n(t3.$add(x, width), radius), t2.$add(y, height), t3.$add(x, width), t2.$add(y, height), t3.$add(x, width), J.$sub$n(t2.$add(y, height), radius)));
        C.JSArray_methods.addAll$1(recPoints, M.WebGLGraphics_quadraticBezierCurve(t3.$add(x, width), t2.$add(y, radius), t3.$add(x, width), y, J.$sub$n(t3.$add(x, width), radius), y));
        C.JSArray_methods.addAll$1(recPoints, M.WebGLGraphics_quadraticBezierCurve(t3.$add(x, radius), y, x, y, x, t2.$add(y, radius)));
        if (t1.get$fill(graphicsData) === true) {
          t2 = graphicsData.get$fillColor();
          t3 = J.getInterceptor$n(t2);
          color = [(t3.$shr(t2, 16) & 255) / 255, (t3.$shr(t2, 8) & 255) / 255, t3.$and(t2, 255) / 255];
          alpha = graphicsData.get$fillAlpha();
          if (0 >= color.length)
            return H.ioore(color, 0);
          r = J.$mul$ns(color[0], alpha);
          if (1 >= color.length)
            return H.ioore(color, 1);
          g = J.$mul$ns(color[1], alpha);
          if (2 >= color.length)
            return H.ioore(color, 2);
          b = J.$mul$ns(color[2], alpha);
          verts = J.get$points$x(webGLData);
          indices = webGLData.get$indices();
          t2 = J.getInterceptor$asx(verts);
          vecPos = J.$div$n(t2.get$length(verts), 6);
          triangles = M.PolyK_Triangulate(recPoints);
          for (t3 = J.getInterceptor$ax(indices), i = 0; i < triangles.length; i += 3) {
            t3.add$1(indices, J.$add$ns(triangles[i], vecPos));
            if (i >= triangles.length)
              return H.ioore(triangles, i);
            t3.add$1(indices, J.$add$ns(triangles[i], vecPos));
            t4 = i + 1;
            if (t4 >= triangles.length)
              return H.ioore(triangles, t4);
            t3.add$1(indices, J.$add$ns(triangles[t4], vecPos));
            t4 = i + 2;
            if (t4 >= triangles.length)
              return H.ioore(triangles, t4);
            t3.add$1(indices, J.$add$ns(triangles[t4], vecPos));
            if (t4 >= triangles.length)
              return H.ioore(triangles, t4);
            t3.add$1(indices, J.$add$ns(triangles[t4], vecPos));
          }
          for (i = 0; t3 = recPoints.length, i < t3; ++i) {
            t4 = recPoints[i];
            ++i;
            if (i >= t3)
              return H.ioore(recPoints, i);
            t2.addAll$1(verts, [t4, recPoints[i], r, g, b, alpha]);
          }
        }
        if (!J.$eq(t1.get$lineWidth(graphicsData), 0)) {
          tempPoints = t1.get$points(graphicsData);
          t1.set$points(graphicsData, recPoints);
          M.WebGLGraphics_buildLine(graphicsData, webGLData);
          t1.set$points(graphicsData, tempPoints);
        }
      }, "call$2", "WebGLGraphics_buildRoundedRectangle$closure", 4, 0, 170, 171, [], 172, [], "buildRoundedRectangle"], WebGLGraphics_buildCircle: [function(graphicsData, webGLData) {
        var t1, rectData, t2, x, y, width, height, t3, color, alpha, r, g, b, verts, indices, vecPos, t4, t5, i, t6, t7, vecPos0, vecPos1, tempPoints;
        t1 = J.getInterceptor$x(graphicsData);
        rectData = t1.get$points(graphicsData);
        t2 = J.getInterceptor$asx(rectData);
        x = t2.$index(rectData, 0);
        y = t2.$index(rectData, 1);
        width = t2.$index(rectData, 2);
        height = t2.$index(rectData, 3);
        if (t1.get$fill(graphicsData) === true) {
          t2 = graphicsData.get$fillColor();
          t3 = J.getInterceptor$n(t2);
          color = [(t3.$shr(t2, 16) & 255) / 255, (t3.$shr(t2, 8) & 255) / 255, t3.$and(t2, 255) / 255];
          alpha = graphicsData.get$fillAlpha();
          if (0 >= color.length)
            return H.ioore(color, 0);
          r = J.$mul$ns(color[0], alpha);
          if (1 >= color.length)
            return H.ioore(color, 1);
          g = J.$mul$ns(color[1], alpha);
          if (2 >= color.length)
            return H.ioore(color, 2);
          b = J.$mul$ns(color[2], alpha);
          verts = J.get$points$x(webGLData);
          indices = webGLData.get$indices();
          t2 = J.getInterceptor$asx(verts);
          vecPos = J.$div$n(t2.get$length(verts), 6);
          t3 = J.getInterceptor$ax(indices);
          t3.add$1(indices, vecPos);
          for (t4 = J.getInterceptor$ns(y), t5 = J.getInterceptor$ns(x), i = 0; i < 41; ++i, vecPos = vecPos1) {
            t2.addAll$1(verts, [x, y, r, g, b, alpha]);
            t6 = 0.15707963267948966 * i;
            t7 = Math.sin(t6);
            if (typeof width !== "number")
              return H.iae(width);
            t7 = t5.$add(x, t7 * width);
            t6 = Math.cos(t6);
            if (typeof height !== "number")
              return H.iae(height);
            t2.addAll$1(verts, [t7, t4.$add(y, t6 * height), r, g, b, alpha]);
            vecPos0 = J.$add$ns(vecPos, 1);
            vecPos1 = J.$add$ns(vecPos0, 1);
            t3.addAll$1(indices, [vecPos, vecPos0]);
          }
          t3.add$1(indices, J.$sub$n(vecPos, 1));
        }
        if (!J.$eq(t1.get$lineWidth(graphicsData), 0)) {
          tempPoints = t1.get$points(graphicsData);
          t1.set$points(graphicsData, []);
          for (t2 = J.getInterceptor$ns(y), t3 = J.getInterceptor$ns(x), i = 0; i < 41; ++i) {
            t4 = t1.get$points(graphicsData);
            t5 = 0.15707963267948966 * i;
            t6 = Math.sin(t5);
            if (typeof width !== "number")
              return H.iae(width);
            t6 = t3.$add(x, t6 * width);
            t5 = Math.cos(t5);
            if (typeof height !== "number")
              return H.iae(height);
            J.addAll$1$ax(t4, [t6, t2.$add(y, t5 * height)]);
          }
          M.WebGLGraphics_buildLine(graphicsData, webGLData);
          t1.set$points(graphicsData, tempPoints);
        }
      }, "call$2", "WebGLGraphics_buildCircle$closure", 4, 0, 170, 171, [], 172, [], "buildCircle"], WebGLGraphics_buildLine: [function(graphicsData, webGLData) {
        var t1, points, t2, t3, t4, firstPoint, t5, lastPoint, t6, midPointX, midPointY, verts, indices, $length, indexCount, indexStart, width, color, alpha, r, g, b, p1x, p1y, p2x, perpx, perpy, t7, dist, i, px, py, perp3x, perp3y, pdist, p2y, p3x, p3y, perp2x, perp2y, a1, b1, c1, a2, b2, c2, denom, indexStart0;
        t1 = J.getInterceptor$x(graphicsData);
        points = t1.get$points(graphicsData);
        t2 = J.getInterceptor$asx(points);
        if (J.$lt$n(t2.get$length(points), 4))
          return;
        t3 = t2.$index(points, 0);
        t4 = t2.$index(points, 1);
        firstPoint = new M.Point0(null, null);
        firstPoint.x = t3;
        firstPoint.y = t4;
        t5 = t2.$index(points, J.$sub$n(t2.get$length(points), 2));
        t2 = t2.$index(points, J.$sub$n(t2.get$length(points), 1));
        lastPoint = new M.Point0(null, null);
        lastPoint.x = t5;
        lastPoint.y = t2;
        if (J.$eq(t3, t5) && J.$eq(t4, t2)) {
          points = P.List_List$from(points, true, null);
          if (0 >= points.length)
            return H.ioore(points, 0);
          points.pop();
          if (0 >= points.length)
            return H.ioore(points, 0);
          points.pop();
          t2 = points.length;
          t5 = t2 - 2;
          if (t5 < 0)
            return H.ioore(points, t5);
          t5 = points[t5];
          t6 = t2 - 1;
          if (t6 < 0)
            return H.ioore(points, t6);
          t6 = points[t6];
          lastPoint = new M.Point0(null, null);
          lastPoint.x = t5;
          lastPoint.y = t6;
          midPointX = J.$add$ns(t5, J.$mul$ns(J.$sub$n(t3, t5), 0.5));
          midPointY = J.$add$ns(t6, J.$mul$ns(J.$sub$n(t4, t6), 0.5));
          H.IterableMixinWorkaround_insertAllList(points, 0, [midPointX, midPointY]);
          C.JSArray_methods.addAll$1(points, [midPointX, midPointY]);
        }
        verts = J.get$points$x(webGLData);
        indices = webGLData.get$indices();
        t2 = J.getInterceptor$asx(points);
        $length = J.$tdiv$n(t2.get$length(points), 2);
        indexCount = t2.get$length(points);
        t3 = J.getInterceptor$asx(verts);
        indexStart = J.$tdiv$n(t3.get$length(verts), 6);
        width = J.$div$n(t1.get$lineWidth(graphicsData), 2);
        t1 = graphicsData.get$lineColor();
        t4 = J.getInterceptor$n(t1);
        color = [(t4.$shr(t1, 16) & 255) / 255, (t4.$shr(t1, 8) & 255) / 255, t4.$and(t1, 255) / 255];
        alpha = graphicsData.get$lineAlpha();
        if (0 >= color.length)
          return H.ioore(color, 0);
        r = J.$mul$ns(color[0], alpha);
        if (1 >= color.length)
          return H.ioore(color, 1);
        g = J.$mul$ns(color[1], alpha);
        if (2 >= color.length)
          return H.ioore(color, 2);
        b = J.$mul$ns(color[2], alpha);
        p1x = t2.$index(points, 0);
        p1y = t2.$index(points, 1);
        p2x = t2.$index(points, 2);
        t1 = J.getInterceptor$n(p1y);
        perpx = J.$negate$n(t1.$sub(p1y, t2.$index(points, 3)));
        t4 = J.getInterceptor$n(p1x);
        perpy = t4.$sub(p1x, p2x);
        t5 = J.getInterceptor$ns(perpx);
        t6 = J.getInterceptor$ns(perpy);
        t7 = J.$add$ns(t5.$mul(perpx, perpx), t6.$mul(perpy, perpy));
        if (typeof t7 !== "number")
          H.throwExpression(P.ArgumentError$(t7));
        dist = Math.sqrt(t7);
        perpx = t5.$div(perpx, dist);
        perpy = t6.$div(perpy, dist);
        if (typeof width !== "number")
          return H.iae(width);
        perpx *= width;
        perpy = J.$mul$ns(perpy, width);
        t3.addAll$1(verts, [t4.$sub(p1x, perpx), t1.$sub(p1y, perpy), r, g, b, alpha]);
        t3.addAll$1(verts, [t4.$add(p1x, perpx), t1.$add(p1y, perpy), r, g, b, alpha]);
        t1 = J.getInterceptor$n($length);
        i = 1;
        px = null;
        py = null;
        perp3x = null;
        perp3y = null;
        pdist = null;
        while (true) {
          t4 = t1.$sub($length, 1);
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(i < t4))
            break;
          c$0: {
            t4 = (i - 1) * 2;
            p1x = t2.$index(points, t4);
            p1y = t2.$index(points, t4 + 1);
            t4 = i * 2;
            p2x = t2.$index(points, t4);
            p2y = t2.$index(points, t4 + 1);
            ++i;
            t4 = i * 2;
            p3x = t2.$index(points, t4);
            p3y = t2.$index(points, t4 + 1);
            perpx = J.$negate$n(J.$sub$n(p1y, p2y));
            perpy = J.$sub$n(p1x, p2x);
            t4 = J.getInterceptor$ns(perpx);
            t5 = J.getInterceptor$ns(perpy);
            t6 = J.$add$ns(t4.$mul(perpx, perpx), t5.$mul(perpy, perpy));
            if (typeof t6 !== "number")
              H.throwExpression(P.ArgumentError$(t6));
            dist = Math.sqrt(t6);
            perpx = t4.$div(perpx, dist) * width;
            perpy = J.$mul$ns(t5.$div(perpy, dist), width);
            perp2x = J.$negate$n(J.$sub$n(p2y, p3y));
            perp2y = J.$sub$n(p2x, p3x);
            t4 = J.getInterceptor$ns(perp2x);
            t5 = J.getInterceptor$ns(perp2y);
            t6 = J.$add$ns(t4.$mul(perp2x, perp2x), t5.$mul(perp2y, perp2y));
            if (typeof t6 !== "number")
              H.throwExpression(P.ArgumentError$(t6));
            dist = Math.sqrt(t6);
            perp2x = t4.$div(perp2x, dist) * width;
            perp2y = J.$mul$ns(t5.$div(perp2y, dist), width);
            t4 = J.getInterceptor$n(perpy);
            t5 = t4.$negate(perpy);
            if (typeof p1y !== "number")
              return H.iae(p1y);
            t6 = t4.$negate(perpy);
            if (typeof p2y !== "number")
              return H.iae(p2y);
            a1 = t5 + p1y - (t6 + p2y);
            t6 = -perpx;
            if (typeof p2x !== "number")
              return H.iae(p2x);
            t5 = t6 + p2x;
            if (typeof p1x !== "number")
              return H.iae(p1x);
            t6 += p1x;
            b1 = t5 - t6;
            c1 = t6 * (t4.$negate(perpy) + p2y) - t5 * (t4.$negate(perpy) + p1y);
            t5 = J.getInterceptor$n(perp2y);
            t6 = t5.$negate(perp2y);
            if (typeof p3y !== "number")
              return H.iae(p3y);
            a2 = t6 + p3y - (t5.$negate(perp2y) + p2y);
            t6 = -perp2x;
            t7 = t6 + p2x;
            if (typeof p3x !== "number")
              return H.iae(p3x);
            t6 += p3x;
            b2 = t7 - t6;
            c2 = t6 * (t5.$negate(perp2y) + p2y) - t7 * (t5.$negate(perp2y) + p3y);
            denom = a1 * b2 - a2 * b1;
            if ((denom < 0 ? -denom : denom) < 0.1) {
              if (typeof perpy !== "number")
                return H.iae(perpy);
              t3.addAll$1(verts, [p2x - perpx, p2y - perpy, r, g, b, alpha]);
              t3.addAll$1(verts, [p2x + perpx, p2y + perpy, r, g, b, alpha]);
              break c$0;
            }
            px = (b1 * c2 - b2 * c1) / denom;
            py = (a2 * c1 - a1 * c2) / denom;
            t5 = px - p2x;
            t6 = py - p2y;
            pdist = t5 * t5 + t6 + t6;
            if (pdist > 19600) {
              perp3x = perpx - perp2x;
              perp3y = t4.$sub(perpy, perp2y);
              t4 = J.getInterceptor$ns(perp3y);
              t5 = t4.$mul(perp3y, perp3y);
              if (typeof t5 !== "number")
                return H.iae(t5);
              dist = Math.sqrt(perp3x * perp3x + t5);
              perp3x = perp3x / dist * width;
              perp3y = J.$mul$ns(t4.$div(perp3y, dist), width);
              t4 = p2x - perp3x;
              if (typeof perp3y !== "number")
                return H.iae(perp3y);
              t5 = p2y - perp3y;
              t3.addAll$1(verts, [t4, t5]);
              t3.addAll$1(verts, [r, g, b, alpha]);
              t3.addAll$1(verts, [p2x + perp3x, p2y + perp3y]);
              t3.addAll$1(verts, [r, g, b, alpha]);
              t3.addAll$1(verts, [t4, t5]);
              t3.addAll$1(verts, [r, g, b, alpha]);
              indexCount = J.$add$ns(indexCount, 1);
            } else {
              t3.addAll$1(verts, [px, py]);
              t3.addAll$1(verts, [r, g, b, alpha]);
              t3.addAll$1(verts, [p2x - t5, p2y - t6]);
              t3.addAll$1(verts, [r, g, b, alpha]);
            }
          }
        }
        p1x = t2.$index(points, J.$mul$ns(t1.$sub($length, 2), 2));
        p1y = t2.$index(points, J.$add$ns(J.$mul$ns(t1.$sub($length, 2), 2), 1));
        p2x = t2.$index(points, J.$mul$ns(t1.$sub($length, 1), 2));
        p2y = t2.$index(points, J.$add$ns(J.$mul$ns(t1.$sub($length, 1), 2), 1));
        perpx = J.$negate$n(J.$sub$n(p1y, p2y));
        perpy = J.$sub$n(p1x, p2x);
        t1 = J.getInterceptor$ns(perpx);
        t2 = J.getInterceptor$ns(perpy);
        t4 = J.$add$ns(t1.$mul(perpx, perpx), t2.$mul(perpy, perpy));
        if (typeof t4 !== "number")
          H.throwExpression(P.ArgumentError$(t4));
        dist = Math.sqrt(t4);
        perpx = t1.$div(perpx, dist) * width;
        perpy = J.$mul$ns(t2.$div(perpy, dist), width);
        t1 = J.getInterceptor$n(p2x);
        t2 = J.getInterceptor$n(p2y);
        t3.addAll$1(verts, [t1.$sub(p2x, perpx), t2.$sub(p2y, perpy)]);
        t3.addAll$1(verts, [r, g, b, alpha]);
        t3.addAll$1(verts, [t1.$add(p2x, perpx), t2.$add(p2y, perpy)]);
        t3.addAll$1(verts, [r, g, b, alpha]);
        t3 = J.getInterceptor$ax(indices);
        t3.add$1(indices, indexStart);
        if (typeof indexCount !== "number")
          return H.iae(indexCount);
        i = 0;
        for (; i < indexCount; ++i, indexStart = indexStart0) {
          indexStart0 = J.$add$ns(indexStart, 1);
          t3.add$1(indices, indexStart);
        }
        t3.add$1(indices, J.$sub$n(indexStart, 1));
      }, "call$2", "WebGLGraphics_buildLine$closure", 4, 0, 170, 171, [], 172, [], "buildLine"], WebGLGraphics_buildComplexPoly: [function(graphicsData, webGLData) {
        var points, indices, t1, t2, t3, minX, maxX, minY, maxY, i, x, y, $length;
        points = P.List_List$from(J.get$points$x(graphicsData), true, null);
        if (points.length < 6)
          return;
        indices = webGLData.get$indices();
        t1 = J.getInterceptor$x(webGLData);
        t1.set$points(webGLData, points);
        t1.set$alpha(webGLData, graphicsData.get$fillAlpha());
        t2 = graphicsData.get$fillColor();
        t3 = J.getInterceptor$n(t2);
        t1.set$color(webGLData, [(t3.$shr(t2, 16) & 255) / 255, (t3.$shr(t2, 8) & 255) / 255, t3.$and(t2, 255) / 255]);
        for (minX = 1 / 0, maxX = -1 / 0, minY = 1 / 0, maxY = -1 / 0, i = 0; t1 = points.length, i < t1; i += 2) {
          x = points[i];
          t2 = i + 1;
          if (t2 >= t1)
            return H.ioore(points, t2);
          y = points[t2];
          t1 = J.getInterceptor$n(x);
          if (t1.$lt(x, minX))
            minX = x;
          if (t1.$gt(x, maxX))
            maxX = x;
          t1 = J.getInterceptor$n(y);
          if (t1.$lt(y, minY))
            minY = y;
          if (t1.$gt(y, maxY))
            maxY = y;
        }
        C.JSArray_methods.addAll$1(points, [minX, minY, maxX, minY, maxX, maxY, minX, maxY]);
        $length = C.JSInt_methods._tdivFast$1(points.length, 2);
        for (t1 = J.getInterceptor$ax(indices), i = 0; i < $length; ++i)
          t1.add$1(indices, i);
      }, "call$2", "WebGLGraphics_buildComplexPoly$closure", 4, 0, 170, 171, [], 172, [], "buildComplexPoly"], WebGLGraphics_buildPoly: [function(graphicsData, webGLData) {
        var points, t1, verts, indices, $length, t2, t3, color, alpha, r, g, b, triangles, vertPos, i, t4;
        points = J.get$points$x(graphicsData);
        t1 = J.getInterceptor$asx(points);
        if (J.$lt$n(t1.get$length(points), 6))
          return;
        verts = J.get$points$x(webGLData);
        indices = webGLData.get$indices();
        $length = J.$div$n(t1.get$length(points), 2);
        t2 = graphicsData.get$fillColor();
        t3 = J.getInterceptor$n(t2);
        color = [(t3.$shr(t2, 16) & 255) / 255, (t3.$shr(t2, 8) & 255) / 255, t3.$and(t2, 255) / 255];
        alpha = graphicsData.get$fillAlpha();
        if (0 >= color.length)
          return H.ioore(color, 0);
        r = J.$mul$ns(color[0], alpha);
        if (1 >= color.length)
          return H.ioore(color, 1);
        g = J.$mul$ns(color[1], alpha);
        if (2 >= color.length)
          return H.ioore(color, 2);
        b = J.$mul$ns(color[2], alpha);
        triangles = M.PolyK_Triangulate(points);
        t2 = J.getInterceptor$asx(verts);
        vertPos = J.$div$n(t2.get$length(verts), 6);
        for (t3 = J.getInterceptor$ax(indices), i = 0; i < triangles.length; i += 3) {
          t3.add$1(indices, J.$add$ns(triangles[i], vertPos));
          if (i >= triangles.length)
            return H.ioore(triangles, i);
          t3.add$1(indices, J.$add$ns(triangles[i], vertPos));
          t4 = i + 1;
          if (t4 >= triangles.length)
            return H.ioore(triangles, t4);
          t3.add$1(indices, J.$add$ns(triangles[t4], vertPos));
          t4 = i + 2;
          if (t4 >= triangles.length)
            return H.ioore(triangles, t4);
          t3.add$1(indices, J.$add$ns(triangles[t4], vertPos));
          if (t4 >= triangles.length)
            return H.ioore(triangles, t4);
          t3.add$1(indices, J.$add$ns(triangles[t4], vertPos));
        }
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          t3 = i * 2;
          t2.addAll$1(verts, [t1.$index(points, t3), t1.$index(points, t3 + 1), r, g, b, alpha]);
        }
      }, "call$2", "WebGLGraphics_buildPoly$closure", 4, 0, 170, 171, [], 172, [], "buildPoly"]}
  },
  "+WebGLGraphics": [674],
  WebGLGraphics_quadraticBezierCurve_getPt: {
    "^": "Closure:396;",
    call$3: [function(n1, n2, perc) {
      return J.$add$ns(n1, J.$mul$ns(J.$sub$n(n2, n1), perc));
    }, "call$3", null, 6, 0, 396, 915, [], 916, [], 917, [], "call"]
  },
  WebGLMaskManager: {
    "^": "MaskManager;maskStack@-645,maskPosition*-614,gl@-877,reverse@-617,count@-614",
    reverse$0: function() {
      return this.reverse.call$0();
    },
    setContext$1: [function(gl) {
      this.gl = gl;
    }, "call$1", "get$setContext", 2, 0, 102, 160, [], "setContext"],
    pushMask$2: [function(maskData, renderSession) {
      var gl = renderSession.get$gl();
      if (maskData.get$_dirty() === true)
        M.WebGLGraphics_updateGraphics(maskData, gl);
      if (J.$eq(J.get$length$asx(J.get$data$x(J.$index$asx(maskData.get$_webGL(), gl))), 0))
        return;
      renderSession.get$stencilManager().pushStencil$3(maskData, J.$index$asx(J.get$data$x(J.$index$asx(maskData.get$_webGL(), gl)), 0), renderSession);
    }, function(maskData) {
      return this.pushMask$2(maskData, null);
    }, "pushMask$1", "call$2", "call$1", "get$pushMask", 2, 2, 890, 12, 889, [], 166, [], "pushMask"],
    popMask$2: [function(maskData, renderSession) {
      var gl = this.gl;
      if (J.$eq(J.get$length$asx(J.get$data$x(J.$index$asx(maskData.get$_webGL(), gl))), 0))
        return;
      renderSession.get$stencilManager().popStencil$3(maskData, J.$index$asx(J.get$data$x(J.$index$asx(maskData.get$_webGL(), gl)), 0), renderSession);
    }, function(maskData) {
      return this.popMask$2(maskData, null);
    }, "popMask$1", "call$2", "call$1", "get$popMask", 2, 2, 918, 12, 889, [], 166, [], "popMask"],
    destroy$0: [function() {
      this.maskStack = null;
      this.gl = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    WebGLMaskManager$1: function(gl) {
      this.gl = gl;
      this.reverse = false;
      this.count = 0;
    },
    static: {WebGLMaskManager$: [function(gl) {
        var t1 = new M.WebGLMaskManager([], 0, null, null, null);
        t1.WebGLMaskManager$1(gl);
        return t1;
      }, null, null, 2, 0, 102, 160, [], "new WebGLMaskManager"]}
  },
  "+WebGLMaskManager": [880],
  WebGLShaderManager: {
    "^": "Object;gl@-877,maxAttibs@-614,_currentId@-614,attribState@-919,tempAttribState@-919,shaderMap@-783,primitiveShader@-920,defaultShader@-907,fastShader@-921,currentShader@-894,complexPrimativeShader@-922,stripShader@-923",
    setContext$1: [function(gl) {
      var t1, t2;
      this.gl = gl;
      t1 = new M.PrimitiveShader(gl, null, ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2 = $._UID;
      $._UID = J.$add$ns(t2, 1);
      t1._UID = t2;
      t1.init$0();
      this.primitiveShader = t1;
      t1 = new M.ComplexPrimitiveShader(gl, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t1.ComplexPrimitiveShader$1(gl);
      this.complexPrimativeShader = t1;
      t1 = new M.PixiShader(gl, null, ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], null, 0, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2 = $._UID;
      $._UID = J.$add$ns(t2, 1);
      t1._UID = t2;
      t1.init$0();
      this.defaultShader = t1;
      t1 = new M.PixiFastShader(gl, null, ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2 = $._UID;
      $._UID = J.$add$ns(t2, 1);
      t1._UID = t2;
      t1.init$0();
      this.fastShader = t1;
      t1 = new M.StripShader(null, gl, ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "}"], ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2 = $._UID;
      $._UID = J.$add$ns(t2, 1);
      t1._UID = t2;
      t1.init$0();
      this.stripShader = t1;
      this.setShader$1(this.defaultShader);
    }, "call$1", "get$setContext", 2, 0, 102, 160, [], "setContext"],
    setAttribs$1: [function(attribs) {
      var t1, key, i, t2, attribId;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this.tempAttribState)); t1.moveNext$0();) {
        key = t1.get$current();
        J.$indexSet$ax(this.tempAttribState, key, false);
      }
      t1 = J.getInterceptor$asx(attribs);
      i = 0;
      while (true) {
        t2 = t1.get$length(attribs);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        attribId = t1.$index(attribs, i);
        J.$indexSet$ax(this.tempAttribState, attribId, true);
        ++i;
      }
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.attribState);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (!J.$eq(J.$index$asx(this.attribState, i), J.$index$asx(this.tempAttribState, i))) {
          J.$indexSet$ax(this.attribState, i, J.$index$asx(this.tempAttribState, i));
          t1 = J.$eq(J.$index$asx(this.tempAttribState, i), true);
          t2 = this.gl;
          if (t1)
            J.enableVertexAttribArray$1$x(t2, i);
          else
            J.disableVertexAttribArray$1$x(t2, i);
        }
        ++i;
      }
    }, "call$1", "get$setAttribs", 2, 0, 924, 925, [], "setAttribs"],
    setShader$1: [function(shader) {
      if (J.$eq(this._currentId, shader.get$_UID()))
        return false;
      this._currentId = shader.get$_UID();
      this.currentShader = shader;
      J.useProgram$1$x(this.gl, shader.get$program());
      this.setAttribs$1(J.get$attributes$x(shader));
      return true;
    }, "call$1", "get$setShader", 2, 0, 102, 926, [], "setShader"],
    destroy$0: [function() {
      this.attribState = null;
      this.tempAttribState = null;
      this.primitiveShader.destroy$0();
      this.defaultShader.destroy$0();
      this.fastShader.destroy$0();
      this.stripShader.destroy$0();
      this.gl = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    WebGLShaderManager$1: function(gl) {
      var i, t1;
      i = 0;
      while (true) {
        t1 = this.maxAttibs;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$indexSet$ax(this.attribState, i, false);
        ++i;
      }
      this.setContext$1(gl);
    },
    static: {WebGLShaderManager$: [function(gl) {
        var t1 = new M.WebGLShaderManager(null, 10, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, null, null, null, null, null);
        t1.WebGLShaderManager$1(gl);
        return t1;
      }, null, null, 2, 0, 102, 160, [], "new WebGLShaderManager"]}
  },
  "+WebGLShaderManager": [674],
  WebGLShaderUtils: {
    "^": "Object;",
    static: {WebGLShaderUtils$: [function() {
        return new M.WebGLShaderUtils();
      }, null, null, 0, 0, 54, "new WebGLShaderUtils"]}
  },
  "+WebGLShaderUtils": [674],
  WebGLSpriteBatch: {
    "^": "Object;gl@-877,vertSize@-614,maxSize@-614,size*-614,numVerts@-614,numIndices@-614,vertices@-672,indices@-714,vertexBuffer@-715,indexBuffer@-715,lastIndexCount@-614,drawing@-617,currentBatchSize@-614,currentBaseTexture@-853,renderSession@-884,shader@-907,matrix@-658,dirty@-617,textures@-927,blendModes@-928",
    size$1: function($receiver, arg0) {
      return this.size.call$1(arg0);
    },
    setContext$1: [function(gl) {
      var t1, t2;
      this.gl = gl;
      t1 = J.getInterceptor$x(gl);
      this.vertexBuffer = t1.createBuffer$0(gl);
      t2 = t1.createBuffer$0(gl);
      this.indexBuffer = t2;
      t1.bindBuffer$2(gl, 34963, t2);
      t1.bufferData$3(gl, 34963, this.indices, 35044);
      t1.bindBuffer$2(gl, 34962, this.vertexBuffer);
      t1.bufferData$3(gl, 34962, this.vertices, 35048);
    }, "call$1", "get$setContext", 2, 0, 159, 160, [], "setContext"],
    begin$1: [function(renderSession) {
      this.renderSession = renderSession;
      this.shader = renderSession.get$shaderManager().get$defaultShader();
      this.dirty = true;
    }, "call$1", "get$begin", 2, 0, 684, 166, [], "begin"],
    end$0: [function() {
      this.flush$0(0);
    }, "call$0", "get$end", 0, 0, 54, "end"],
    render$1: [function(sprite) {
      var texture, uvs, alpha, tint, verticies, aX, aY, t1, trim, w1, w0, h1, h0, index, worldTransform, a, b, c, d, tx, ty, index0, t2, t3, t4, t5, t6;
      texture = sprite.get$texture();
      if (J.$ge$n(this.currentBatchSize, this.size)) {
        this.flush$0(0);
        this.currentBaseTexture = texture.get$baseTexture();
      }
      uvs = texture.get$_uvs();
      if (uvs == null)
        return;
      alpha = sprite.get$_worldAlpha();
      tint = J.toDouble$0$n(sprite.get$tint());
      verticies = this.vertices;
      aX = J.get$x$x(sprite.get$anchor());
      aY = J.get$y$x(sprite.get$anchor());
      t1 = J.getInterceptor$s(texture);
      if (t1.get$trim(texture) != null) {
        trim = t1.get$trim(texture);
        t1 = J.getInterceptor$x(trim);
        w1 = J.$sub$n(t1.get$x(trim), J.$mul$ns(aX, t1.get$width(trim)));
        w0 = J.$add$ns(w1, J.get$width$x(texture.get$crop()));
        h1 = J.$sub$n(t1.get$y(trim), J.$mul$ns(aY, t1.get$height(trim)));
        h0 = J.$add$ns(h1, J.get$height$x(texture.get$crop()));
      } else {
        t1 = J.get$width$x(texture.get$frame());
        if (typeof aX !== "number")
          return H.iae(aX);
        w0 = J.$mul$ns(t1, 1 - aX);
        w1 = J.$mul$ns(J.get$width$x(texture.get$frame()), -aX);
        t1 = J.get$height$x(texture.get$frame());
        if (typeof aY !== "number")
          return H.iae(aY);
        h0 = J.$mul$ns(t1, 1 - aY);
        h1 = J.$mul$ns(J.get$height$x(texture.get$frame()), -aY);
      }
      index = J.$mul$ns(J.$mul$ns(this.currentBatchSize, 4), this.vertSize);
      worldTransform = sprite.get$_worldTransform();
      a = J.get$a$x(worldTransform);
      b = worldTransform.get$c();
      c = worldTransform.get$b();
      d = worldTransform.get$d();
      tx = worldTransform.get$tx();
      ty = worldTransform.get$ty();
      index0 = J.$add$ns(index, 1);
      t1 = J.getInterceptor$ns(a);
      t2 = J.getInterceptor$ns(c);
      t3 = J.getInterceptor$ax(verticies);
      t3.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h1)), tx));
      index = J.$add$ns(index0, 1);
      t4 = J.getInterceptor$ns(d);
      t5 = J.getInterceptor$ns(b);
      t3.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t4.$mul(d, h1), t5.$mul(b, w1)), ty));
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, uvs.get$x0());
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, uvs.get$y0());
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, alpha);
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, tint);
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h1)), tx));
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t4.$mul(d, h1), t5.$mul(b, w0)), ty));
      index0 = J.$add$ns(index, 1);
      t6 = J.getInterceptor$x(uvs);
      t3.$indexSet(verticies, index, t6.get$x1(uvs));
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, t6.get$y1(uvs));
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, alpha);
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, tint);
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h0)), tx));
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t4.$mul(d, h0), t5.$mul(b, w0)), ty));
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, t6.get$x2(uvs));
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, t6.get$y2(uvs));
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, alpha);
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, tint);
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h0)), tx));
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t4.$mul(d, h0), t5.$mul(b, w1)), ty));
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, uvs.get$x3());
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, uvs.get$y3());
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, alpha);
      J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, tint);
      t1 = J.$le$n(J.get$length$asx(this.textures), this.currentBatchSize);
      t2 = this.textures;
      if (t1)
        J.add$1$ax(t2, sprite.get$texture().get$baseTexture());
      else
        J.$indexSet$ax(t2, this.currentBatchSize, sprite.get$texture().get$baseTexture());
      t1 = J.$le$n(J.get$length$asx(this.blendModes), this.currentBatchSize);
      t2 = this.blendModes;
      if (t1)
        J.add$1$ax(t2, sprite.get$blendMode());
      else
        J.$indexSet$ax(t2, this.currentBatchSize, sprite.get$blendMode());
      this.currentBatchSize = J.$add$ns(this.currentBatchSize, 1);
    }, "call$1", "get$render", 2, 0, 903, 151, [], "render"],
    renderTilingSprite$1: [function(tilingSprite) {
      var texture, uvs, t1, t2, offsetX, offsetY, scaleX, scaleY, t3, t4, t5, alpha, tint, verticies, width, height, aX, aY, w0, w1, h0, h1, index, worldTransform, a, b, c, d, tx, ty, index0, t6;
      texture = tilingSprite.get$tilingTexture();
      if (J.$ge$n(this.currentBatchSize, this.size)) {
        this.flush$0(0);
        this.currentBaseTexture = texture.get$baseTexture();
      }
      if (tilingSprite.get$_uvs() == null)
        tilingSprite.set$_uvs(new M.TextureUvs(0, 0, 0, 0, 0, 0, 0, 0));
      uvs = tilingSprite.get$_uvs();
      t1 = tilingSprite.get$tilePosition();
      t2 = J.getInterceptor$x(t1);
      t2.set$x(t1, J.$mod$n(t2.get$x(t1), J.$mul$ns(J.get$width$x(texture.get$baseTexture()), J.get$x$x(tilingSprite.get$tileScaleOffset()))));
      t1 = tilingSprite.get$tilePosition();
      t2 = J.getInterceptor$x(t1);
      t2.set$y(t1, J.$mod$n(t2.get$y(t1), J.$mul$ns(J.get$height$x(texture.get$baseTexture()), J.get$y$x(tilingSprite.get$tileScaleOffset()))));
      offsetX = J.$div$n(J.get$x$x(tilingSprite.get$tilePosition()), J.$mul$ns(J.get$width$x(texture.get$baseTexture()), J.get$x$x(tilingSprite.get$tileScaleOffset())));
      offsetY = J.$div$n(J.get$y$x(tilingSprite.get$tilePosition()), J.$mul$ns(J.get$height$x(texture.get$baseTexture()), J.get$y$x(tilingSprite.get$tileScaleOffset())));
      t1 = J.getInterceptor$x(tilingSprite);
      scaleX = J.$div$n(J.$div$n(t1.get$width(tilingSprite), J.get$width$x(texture.get$baseTexture())), J.$mul$ns(J.get$x$x(tilingSprite.get$tileScale()), J.get$x$x(tilingSprite.get$tileScaleOffset())));
      scaleY = J.$div$n(J.$div$n(t1.get$height(tilingSprite), J.get$height$x(texture.get$baseTexture())), J.$mul$ns(J.get$y$x(tilingSprite.get$tileScale()), J.get$y$x(tilingSprite.get$tileScaleOffset())));
      if (typeof offsetX !== "number")
        return H.iae(offsetX);
      t2 = 0 - offsetX;
      uvs.set$x0(t2);
      if (typeof offsetY !== "number")
        return H.iae(offsetY);
      t3 = 0 - offsetY;
      uvs.set$y0(t3);
      if (typeof scaleX !== "number")
        return H.iae(scaleX);
      t4 = scaleX - offsetX;
      t5 = J.getInterceptor$x(uvs);
      t5.set$x1(uvs, t4);
      t5.set$y1(uvs, t3);
      t5.set$x2(uvs, t4);
      if (typeof scaleY !== "number")
        return H.iae(scaleY);
      t4 = scaleY - offsetY;
      t5.set$y2(uvs, t4);
      uvs.set$x3(t2);
      uvs.set$y3(t4);
      alpha = tilingSprite.get$_worldAlpha();
      tint = J.toDouble$0$n(tilingSprite.get$tint());
      verticies = this.vertices;
      width = t1.get$width(tilingSprite);
      height = t1.get$height(tilingSprite);
      aX = J.get$x$x(tilingSprite.get$anchor());
      aY = J.get$y$x(tilingSprite.get$anchor());
      if (typeof aX !== "number")
        return H.iae(aX);
      t1 = J.getInterceptor$ns(width);
      w0 = t1.$mul(width, 1 - aX);
      w1 = t1.$mul(width, -aX);
      if (typeof aY !== "number")
        return H.iae(aY);
      t1 = J.getInterceptor$ns(height);
      h0 = t1.$mul(height, 1 - aY);
      h1 = t1.$mul(height, -aY);
      index = J.$mul$ns(J.$mul$ns(this.currentBatchSize, 4), this.vertSize);
      worldTransform = tilingSprite.get$_worldTransform();
      a = J.get$a$x(worldTransform);
      b = worldTransform.get$c();
      c = worldTransform.get$b();
      d = worldTransform.get$d();
      tx = worldTransform.get$tx();
      ty = worldTransform.get$ty();
      index0 = J.$add$ns(index, 1);
      t1 = J.getInterceptor$ns(a);
      t4 = J.getInterceptor$ns(c);
      t2 = J.getInterceptor$ax(verticies);
      t2.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w1), t4.$mul(c, h1)), tx));
      index = J.$add$ns(index0, 1);
      t3 = J.getInterceptor$ns(d);
      t6 = J.getInterceptor$ns(b);
      t2.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t3.$mul(d, h1), t6.$mul(b, w1)), ty));
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, uvs.get$x0());
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, uvs.get$y0());
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, alpha);
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, tint);
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w0), t4.$mul(c, h1)), tx));
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t3.$mul(d, h1), t6.$mul(b, w0)), ty));
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, t5.get$x1(uvs));
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, t5.get$y1(uvs));
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, alpha);
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, tint);
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w0), t4.$mul(c, h0)), tx));
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t3.$mul(d, h0), t6.$mul(b, w0)), ty));
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, t5.get$x2(uvs));
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, t5.get$y2(uvs));
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, alpha);
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, tint);
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w1), t4.$mul(c, h0)), tx));
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t3.$mul(d, h0), t6.$mul(b, w1)), ty));
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, uvs.get$x3());
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, uvs.get$y3());
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, alpha);
      J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, tint);
      t1 = J.$le$n(J.get$length$asx(this.textures), this.currentBatchSize);
      t2 = this.textures;
      if (t1)
        J.add$1$ax(t2, texture.get$baseTexture());
      else
        J.$indexSet$ax(t2, this.currentBatchSize, texture.get$baseTexture());
      t1 = J.$le$n(J.get$length$asx(this.blendModes), this.currentBatchSize);
      t2 = this.blendModes;
      if (t1)
        J.add$1$ax(t2, tilingSprite.get$blendMode());
      else
        J.$indexSet$ax(t2, this.currentBatchSize, tilingSprite.get$blendMode());
      this.currentBatchSize = J.$add$ns(this.currentBatchSize, 1);
    }, "call$1", "get$renderTilingSprite", 2, 0, 929, 930, [], "renderTilingSprite"],
    flush$0: [function(_) {
      var projection, t1, stride, t2, view, currentBlendMode, j, batchSize, start, currentBaseTexture, i, nextTexture, nextBlendMode;
      if (J.$eq(this.currentBatchSize, 0))
        return;
      this.renderSession.get$shaderManager().setShader$1(this.renderSession.get$shaderManager().get$defaultShader());
      if (this.dirty === true) {
        this.dirty = false;
        J.activeTexture$1$x(this.gl, 33984);
        J.bindBuffer$2$x(this.gl, 34962, this.vertexBuffer);
        J.bindBuffer$2$x(this.gl, 34963, this.indexBuffer);
        projection = this.renderSession.get$projection();
        t1 = J.getInterceptor$x(projection);
        J.uniform2f$3$x(this.gl, this.shader.get$projectionVector(), t1.get$x(projection), t1.get$y(projection));
        stride = J.$mul$ns(this.vertSize, 4);
        J.vertexAttribPointer$6$x(this.gl, this.shader.get$aVertexPosition(), 2, 5126, false, stride, 0);
        J.vertexAttribPointer$6$x(this.gl, this.shader.get$aTextureCoord(), 2, 5126, false, stride, 8);
        J.vertexAttribPointer$6$x(this.gl, this.shader.get$colorAttribute(), 2, 5126, false, stride, 16);
      }
      t1 = J.$gt$n(this.currentBatchSize, J.$mul$ns(this.size, 0.5));
      t2 = this.vertices;
      if (t1)
        J.bufferSubData$3$x(this.gl, 34962, 0, t2);
      else {
        view = J.sublist$2$ax(t2, 0, J.$mul$ns(J.$mul$ns(this.currentBatchSize, 4), this.vertSize));
        J.bufferSubData$3$x(this.gl, 34962, 0, view);
      }
      currentBlendMode = this.renderSession.get$blendModeManager().get$currentBlendMode();
      j = this.currentBatchSize;
      if (typeof j !== "number")
        return H.iae(j);
      batchSize = 0;
      start = 0;
      currentBaseTexture = null;
      i = 0;
      for (; i < j; ++i) {
        nextTexture = J.$index$asx(this.textures, i);
        nextBlendMode = J.$index$asx(this.blendModes, i);
        if (!J.$eq(currentBaseTexture, nextTexture) || !J.$eq(currentBlendMode, nextBlendMode)) {
          this.renderBatch$3(currentBaseTexture, batchSize, start);
          this.renderSession.get$blendModeManager().setBlendMode$1(nextBlendMode);
          currentBlendMode = nextBlendMode;
          currentBaseTexture = nextTexture;
          start = i;
          batchSize = 0;
        }
        ++batchSize;
      }
      this.renderBatch$3(currentBaseTexture, batchSize, start);
      this.currentBatchSize = 0;
    }, "call$0", "get$flush", 0, 0, 54, "flush"],
    renderBatch$3: [function(texture, size, startIndex) {
      var t1, t2, t3;
      t1 = J.getInterceptor(size);
      if (t1.$eq(size, 0))
        return;
      t2 = J.$index$asx(texture.get$_glTextures(), this.gl);
      t3 = this.gl;
      if (t2 != null)
        J.bindTexture$2$x(t3, 3553, J.$index$asx(texture.get$_glTextures(), this.gl));
      else
        J.bindTexture$2$x(t3, 3553, M.createWebGLTexture(texture, t3));
      if (J.$eq(J.$index$asx(texture.get$_dirty(), this.gl), true))
        M.updateWebGLTexture(this.currentBaseTexture, this.gl);
      J.drawElements$4$x(this.gl, 4, t1.$mul(size, 6), 5123, J.$mul$ns(J.$mul$ns(startIndex, 6), 2));
      t1 = this.renderSession;
      t1.set$drawCount(J.$add$ns(t1.get$drawCount(), 1));
    }, "call$3", "get$renderBatch", 6, 0, 931, 68, [], 314, [], 430, [], "renderBatch"],
    stop$0: [function(_) {
      this.flush$0(0);
    }, "call$0", "get$stop", 0, 0, 54, "stop"],
    start$0: [function(_) {
      this.dirty = true;
    }, "call$0", "get$start", 0, 0, 54, "start"],
    destroy$0: [function() {
      this.vertices = null;
      this.indices = null;
      J.deleteBuffer$1$x(this.gl, this.vertexBuffer);
      J.deleteBuffer$1$x(this.gl, this.indexBuffer);
      this.currentBaseTexture = null;
      this.gl = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    WebGLSpriteBatch$1: function(gl) {
      var t1, i, j;
      t1 = this.maxSize;
      this.size = t1;
      this.numVerts = J.$mul$ns(J.$mul$ns(t1, 4), this.vertSize);
      this.numIndices = J.$mul$ns(this.maxSize, 6);
      this.vertices = new Float32Array(H._checkLength(this.numVerts));
      this.indices = new Uint16Array(H._checkLength(this.numIndices));
      i = 0;
      j = 0;
      while (true) {
        t1 = this.numIndices;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$indexSet$ax(this.indices, i, j);
        J.$indexSet$ax(this.indices, i + 1, j + 1);
        t1 = j + 2;
        J.$indexSet$ax(this.indices, i + 2, t1);
        J.$indexSet$ax(this.indices, i + 3, j);
        J.$indexSet$ax(this.indices, i + 4, t1);
        J.$indexSet$ax(this.indices, i + 5, j + 3);
        i += 6;
        j += 4;
      }
      this.setContext$1(gl);
      this.textures = [];
      this.blendModes = [];
      this.dirty = true;
    },
    static: {WebGLSpriteBatch$: [function(gl) {
        var t1 = new M.WebGLSpriteBatch(null, 6, 6000, null, null, null, null, null, null, null, 0, false, 0, null, null, null, null, false, null, null);
        t1.WebGLSpriteBatch$1(gl);
        return t1;
      }, null, null, 2, 0, 159, 160, [], "new WebGLSpriteBatch"]}
  },
  "+WebGLSpriteBatch": [674],
  WebGLStencilManager: {
    "^": "Object;gl@-877,stencilStack@-645,reverse@-617,count@-614,maskStack@-645,_currentGraphics@-660",
    reverse$0: function() {
      return this.reverse.call$0();
    },
    setContext$1: [function(gl) {
      this.gl = gl;
    }, "call$1", "get$setContext", 2, 0, 102, 160, [], "setContext"],
    pushStencil$3: [function(graphics, webGLData, renderSession) {
      var gl, t1, level, t2;
      gl = this.gl;
      this.bindGraphics$3(graphics, webGLData, renderSession);
      if (J.$eq(J.get$length$asx(this.stencilStack), 0)) {
        t1 = J.getInterceptor$x(gl);
        t1.enable$1(gl, 2960);
        t1.clear$1(gl, 1024);
        this.reverse = true;
        this.count = 0;
      }
      J.add$1$ax(this.stencilStack, webGLData);
      level = this.count;
      t1 = J.getInterceptor$x(gl);
      t1.colorMask$4(gl, false, false, false, false);
      t1.stencilFunc$3(gl, 519, 0, 255);
      t1.stencilOp$3(gl, 7680, 7680, 5386);
      if (J.$eq(J.get$mode$x(webGLData), 1)) {
        t1.drawElements$4(gl, 6, J.$sub$n(J.get$length$asx(webGLData.get$indices()), 4), 5123, 0);
        if (this.reverse === true) {
          if (typeof level !== "number")
            return H.iae(level);
          t1.stencilFunc$3(gl, 514, 255 - level, 255);
          t1.stencilOp$3(gl, 7680, 7680, 7683);
        } else {
          t1.stencilFunc$3(gl, 514, level, 255);
          t1.stencilOp$3(gl, 7680, 7680, 7682);
        }
        t1.drawElements$4(gl, 6, 4, 5123, J.$mul$ns(J.$sub$n(J.get$length$asx(webGLData.get$indices()), 4), 2));
        t2 = J.getInterceptor$ns(level);
        if (this.reverse === true) {
          t2 = t2.$add(level, 1);
          if (typeof t2 !== "number")
            return H.iae(t2);
          t1.stencilFunc$3(gl, 514, 255 - t2, 255);
        } else
          t1.stencilFunc$3(gl, 514, t2.$add(level, 1), 255);
        this.reverse = this.reverse !== true;
      } else {
        if (this.reverse !== true) {
          if (typeof level !== "number")
            return H.iae(level);
          t1.stencilFunc$3(gl, 514, 255 - level, 255);
          t1.stencilOp$3(gl, 7680, 7680, 7683);
        } else {
          t1.stencilFunc$3(gl, 514, level, 255);
          t1.stencilOp$3(gl, 7680, 7680, 7682);
        }
        t1.drawElements$4(gl, 5, J.get$length$asx(webGLData.get$indices()), 5123, 0);
        t2 = J.getInterceptor$ns(level);
        if (this.reverse !== true) {
          t2 = t2.$add(level, 1);
          if (typeof t2 !== "number")
            return H.iae(t2);
          t1.stencilFunc$3(gl, 514, 255 - t2, 255);
        } else
          t1.stencilFunc$3(gl, 514, t2.$add(level, 1), 255);
      }
      t1.colorMask$4(gl, true, true, true, true);
      t1.stencilOp$3(gl, 7680, 7680, 7680);
      this.count = J.$add$ns(this.count, 1);
    }, "call$3", "get$pushStencil", 6, 0, 932, 141, [], 172, [], 166, [], "pushStencil"],
    bindGraphics$3: [function(graphics, webGLData, renderSession) {
      var projection, offset, t1, t2, t3, shader;
      this._currentGraphics = graphics;
      projection = renderSession.get$projection();
      offset = J.get$offset$x(renderSession);
      t1 = J.getInterceptor$x(webGLData);
      t2 = J.getInterceptor$x(projection);
      t3 = J.getInterceptor$x(offset);
      if (J.$eq(t1.get$mode(webGLData), 1)) {
        shader = renderSession.get$shaderManager().get$complexPrimativeShader();
        renderSession.get$shaderManager().setShader$1(shader);
        J.uniformMatrix3fv$3$x(this.gl, shader.get$translationMatrix(), false, graphics.get$_worldTransform().toArray$1(true));
        J.uniform2f$3$x(this.gl, shader.get$projectionVector(), t2.get$x(projection), J.$negate$n(t2.get$y(projection)));
        J.uniform2f$3$x(this.gl, shader.get$offsetVector(), J.$negate$n(t3.get$x(offset)), J.$negate$n(t3.get$y(offset)));
        J.uniform3fv$2$x(this.gl, shader.get$tintColor(), new Float32Array(H._ensureNativeList(M.hex2rgb(graphics.get$tint()))));
        t2 = J.getInterceptor$x(shader);
        J.uniform3fv$2$x(this.gl, t2.get$color(shader), new Float32Array(H._ensureNativeList(t1.get$color(webGLData))));
        J.uniform1f$2$x(this.gl, t2.get$alpha(shader), J.$mul$ns(graphics.get$_worldAlpha(), t1.get$alpha(webGLData)));
        J.bindBuffer$2$x(this.gl, 34962, t1.get$buffer(webGLData));
        J.vertexAttribPointer$6$x(this.gl, shader.get$aVertexPosition(), 2, 5126, false, 8, 0);
        J.bindBuffer$2$x(this.gl, 34963, webGLData.get$indexBuffer());
      } else {
        shader = renderSession.get$shaderManager().get$primitiveShader();
        renderSession.get$shaderManager().setShader$1(shader);
        J.uniformMatrix3fv$3$x(this.gl, shader.get$translationMatrix(), false, graphics.get$_worldTransform().toArray$1(true));
        J.uniform2f$3$x(this.gl, shader.get$projectionVector(), t2.get$x(projection), J.$negate$n(t2.get$y(projection)));
        J.uniform2f$3$x(this.gl, shader.get$offsetVector(), J.$negate$n(t3.get$x(offset)), J.$negate$n(t3.get$y(offset)));
        J.uniform3fv$2$x(this.gl, shader.get$tintColor(), new Float32Array(H._ensureNativeList(M.hex2rgb(graphics.get$tint()))));
        J.uniform1f$2$x(this.gl, J.get$alpha$x(shader), graphics.get$_worldAlpha());
        J.bindBuffer$2$x(this.gl, 34962, t1.get$buffer(webGLData));
        J.vertexAttribPointer$6$x(this.gl, shader.get$aVertexPosition(), 2, 5126, false, 24, 0);
        J.vertexAttribPointer$6$x(this.gl, shader.get$colorAttribute(), 4, 5126, false, 24, 8);
        J.bindBuffer$2$x(this.gl, 34963, webGLData.get$indexBuffer());
      }
    }, "call$3", "get$bindGraphics", 6, 0, 932, 141, [], 172, [], 166, [], "bindGraphics"],
    popStencil$3: [function(graphics, webGLData, renderSession) {
      var gl, t1, level, t2, t3;
      gl = this.gl;
      J.removeLast$0$ax(this.stencilStack);
      this.count = J.$sub$n(this.count, 1);
      t1 = J.getInterceptor$x(gl);
      if (J.$eq(J.get$length$asx(this.stencilStack), 0))
        t1.disable$1(gl, 2960);
      else {
        level = this.count;
        this.bindGraphics$3(graphics, webGLData, renderSession);
        t1.colorMask$4(gl, false, false, false, false);
        if (J.$eq(J.get$mode$x(webGLData), 1)) {
          t2 = this.reverse !== true;
          this.reverse = t2;
          t3 = J.getInterceptor$ns(level);
          if (t2) {
            t2 = t3.$add(level, 1);
            if (typeof t2 !== "number")
              return H.iae(t2);
            t1.stencilFunc$3(gl, 514, 255 - t2, 255);
            t1.stencilOp$3(gl, 7680, 7680, 7682);
          } else {
            t1.stencilFunc$3(gl, 514, t3.$add(level, 1), 255);
            t1.stencilOp$3(gl, 7680, 7680, 7683);
          }
          t1.drawElements$4(gl, 6, 4, 5123, J.$mul$ns(J.$sub$n(J.get$length$asx(webGLData.get$indices()), 4), 2));
          t1.stencilFunc$3(gl, 519, 0, 255);
          t1.stencilOp$3(gl, 7680, 7680, 5386);
          t1.drawElements$4(gl, 6, J.$sub$n(J.get$length$asx(webGLData.get$indices()), 4), 5123, 0);
          if (this.reverse !== true) {
            if (typeof level !== "number")
              return H.iae(level);
            t1.stencilFunc$3(gl, 514, 255 - level, 255);
          } else
            t1.stencilFunc$3(gl, 514, level, 255);
        } else {
          t2 = J.getInterceptor$ns(level);
          if (this.reverse !== true) {
            t2 = t2.$add(level, 1);
            if (typeof t2 !== "number")
              return H.iae(t2);
            t1.stencilFunc$3(gl, 514, 255 - t2, 255);
            t1.stencilOp$3(gl, 7680, 7680, 7682);
          } else {
            t1.stencilFunc$3(gl, 514, t2.$add(level, 1), 255);
            t1.stencilOp$3(gl, 7680, 7680, 7683);
          }
          t1.drawElements$4(gl, 5, J.get$length$asx(webGLData.get$indices()), 5123, 0);
          if (this.reverse !== true) {
            if (typeof level !== "number")
              return H.iae(level);
            t1.stencilFunc$3(gl, 514, 255 - level, 255);
          } else
            t1.stencilFunc$3(gl, 514, level, 255);
        }
        t1.colorMask$4(gl, true, true, true, true);
        t1.stencilOp$3(gl, 7680, 7680, 7680);
      }
    }, "call$3", "get$popStencil", 6, 0, 155, 141, [], 172, [], 166, [], "popStencil"],
    destroy$0: [function() {
      this.maskStack = null;
      this.gl = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    WebGLStencilManager$1: function(gl) {
      this.stencilStack = [];
      this.gl = this.gl;
      this.reverse = true;
      this.count = 0;
    },
    static: {WebGLStencilManager$: [function(gl) {
        var t1 = new M.WebGLStencilManager(gl, null, null, null, null, null);
        t1.WebGLStencilManager$1(gl);
        return t1;
      }, null, null, 2, 0, 159, 160, [], "new WebGLStencilManager"]}
  },
  "+WebGLStencilManager": [674],
  WebGLRenderer: {
    "^": "Renderer;type-614,transparent-617,antialias-617,preserveDrawingBuffer-617,width-616,height-616,view-836,projection-652,offset-652,contextLost-617,options-783,gl-877,shaderManager-878,spriteBatch-879,maskManager-880,filterManager-881,stencilManager-882,blendModeManager-883,renderSession-884,__stage-657",
    render$1: [function(stage) {
      var t1, t2;
      if (this.contextLost === true)
        return;
      if (!J.$eq(this.__stage, stage)) {
        if (stage.get$interactive() === true)
          stage.get$interactionManager().removeEvents$0();
        this.__stage = stage;
      }
      M.WebGLRenderer_updateTextures(this.gl);
      stage.updateTransform$0();
      J.viewport$4$x(this.gl, 0, 0, this.width, this.height);
      J.bindFramebuffer$2$x(this.gl, 36160, null);
      t1 = J.$eq(this.transparent, true);
      t2 = this.gl;
      if (t1)
        J.clearColor$4$x(t2, 0, 0, 0, 0);
      else
        J.clearColor$4$x(t2, J.$index$asx(stage.get$backgroundColorSplit(), 0), J.$index$asx(stage.get$backgroundColorSplit(), 1), J.$index$asx(stage.get$backgroundColorSplit(), 2), 1);
      J.clear$1$ax(this.gl, 16384);
      this.renderDisplayObject$2(stage, this.projection);
      if (stage.get$interactive() === true) {
        if (stage.get$_interactiveEventsAdded() !== true) {
          stage.set$_interactiveEventsAdded(true);
          stage.get$interactionManager().setTarget$1(this);
        }
      } else if (stage.get$_interactiveEventsAdded() === true) {
        stage.set$_interactiveEventsAdded(false);
        stage.get$interactionManager().setTarget$1(this);
      }
    }, "call$1", "get$render", 2, 0, 131, 132, [], "render"],
    renderDisplayObject$3: [function(displayObject, projection, buffer) {
      this.renderSession.get$blendModeManager().setBlendMode$1(C.BlendModes_0);
      this.renderSession.set$drawCount(0);
      this.renderSession.set$currentBlendMode(C.BlendModes_99999);
      this.renderSession.set$projection(projection);
      J.set$offset$x(this.renderSession, this.offset);
      this.spriteBatch.begin$1(this.renderSession);
      this.filterManager.begin$2(this.renderSession, buffer);
      displayObject._renderWebGL$1(this.renderSession);
      this.spriteBatch.end$0();
    }, function(displayObject, projection) {
      return this.renderDisplayObject$3(displayObject, projection, null);
    }, "renderDisplayObject$2", function(displayObject) {
      return this.renderDisplayObject$3(displayObject, null, null);
    }, "renderDisplayObject$1", "call$3", "call$2", "call$1", "get$renderDisplayObject", 2, 4, 933, 12, 12, 833, [], 934, [], 886, [], "renderDisplayObject"],
    resize$2: [function(_, width, height) {
      var t1;
      width = J.toInt$0$n(width);
      height = J.toInt$0$n(height);
      window;
      if (typeof console != "undefined")
        console.log(width);
      this.width = width;
      this.height = height;
      J.set$width$x(this.view, width);
      J.set$height$x(this.view, height);
      t1 = this.gl;
      if (t1 != null)
        J.viewport$4$x(t1, 0, 0, this.width, this.height);
      J.set$x$x(this.projection, J.$div$n(this.width, 2));
      J.set$y$x(this.projection, J.$div$n(J.$negate$n(this.height), 2));
    }, "call$2", "get$resize", 4, 0, 149, 31, [], 52, [], "resize"],
    handleContextLost$1: [function($event) {
      J.preventDefault$0$x($event);
      this.contextLost = true;
    }, "call$1", "get$handleContextLost", 2, 0, 102, 666, [], "handleContextLost"],
    handleContextRestored$1: [function($event) {
      var exception, gl, t1, key;
      try {
        this.gl = J.getContext$2$x(this.view, "experimental-webgl", this.options);
      } catch (exception) {
        H.unwrapException(exception);
        try {
          this.gl = J.getContext$2$x(this.view, "webgl", this.options);
        } catch (exception) {
          H.unwrapException(exception);
          throw H.wrapException(P.Exception_Exception(" This browser does not support webGL. Try using the canvas renderer this"));
        }

      }

      gl = this.gl;
      this.shaderManager.setContext$1(gl);
      this.spriteBatch.setContext$1(gl);
      this.maskManager.setContext$1(gl);
      this.filterManager.setContext$1(gl);
      this.renderSession.set$gl(this.gl);
      t1 = J.getInterceptor$x(gl);
      t1.disable$1(gl, 2929);
      t1.disable$1(gl, 2884);
      t1.enable$1(gl, 3042);
      t1.colorMask$4(gl, true, true, true, this.transparent);
      J.viewport$4$x(this.gl, 0, 0, this.width, this.height);
      for (t1 = J.get$iterator$ax(J.get$keys$x($.get$TextureCache())); t1.moveNext$0();) {
        key = t1.get$current();
        J.$index$asx($.get$TextureCache(), key).get$baseTexture().set$_glTextures(P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }
      this.contextLost = false;
    }, "call$1", "get$handleContextRestored", 2, 0, 102, 666, [], "handleContextRestored"],
    destroy$0: [function() {
      J.removeEventListener$2$x(this.view, "webglcontextlost", this.get$handleContextLost());
      J.removeEventListener$2$x(this.view, "webglcontextrestored", this.get$handleContextRestored());
      J.remove$1$ax($.get$glContexts(), this.gl);
      this.projection = null;
      this.offset = null;
      this.shaderManager.destroy$0();
      this.spriteBatch.destroy$0();
      this.maskManager.destroy$0();
      this.filterManager.destroy$0();
      this.shaderManager = null;
      this.spriteBatch = null;
      this.maskManager = null;
      this.filterManager = null;
      this.gl = null;
      this.renderSession = null;
    }, "call$0", "get$destroy", 0, 0, 17, "destroy"],
    WebGLRenderer$6: function(width, height, view, transparent, antialias, preserveDrawingBuffer) {
      var t1, exception, t2;
      if ($.defaultRenderer == null)
        $.defaultRenderer = this;
      this.type = 0;
      this.width = J.toInt$0$n(width);
      this.height = J.toInt$0$n(height);
      this.transparent = transparent;
      this.antialias = antialias;
      this.preserveDrawingBuffer = preserveDrawingBuffer;
      if (view == null)
        view = W.CanvasElement_CanvasElement(null, null);
      this.view = view;
      J.set$width$x(view, this.width);
      J.set$height$x(this.view, this.height);
      t1 = J.get$onWebGlContextLost$x(this.view);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$handleContextLost()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = J.get$onWebGlContextRestored$x(this.view);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$handleContextRestored()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = P.LinkedHashMap_LinkedHashMap$_literal(["alpha", this.transparent, "antialias", this.antialias, "premultipliedAlpha", transparent, "stencil", true, "preserveDrawingBuffer", preserveDrawingBuffer], null, null);
      this.options = t1;
      try {
        this.gl = J.getContext$2$x(this.view, "experimental-webgl", t1);
      } catch (exception) {
        H.unwrapException(exception);
        try {
          this.gl = J.getContext$2$x(this.view, "webgl", this.options);
        } catch (exception) {
          H.unwrapException(exception);
          throw H.wrapException(P.Exception_Exception(" This browser does not support webGL. Try using the canvas renderer " + this.toString$0(0)));
        }

      }

      J.add$1$ax($.get$glContexts(), this.gl);
      if ($.blendModesWebGL == null) {
        t1 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        $.blendModesWebGL = t1;
        t1.$indexSet(0, C.BlendModes_0, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_1, [770, 772]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_2, [774, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_3, [770, 1]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_4, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_5, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_6, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_7, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_8, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_9, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_10, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_11, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_12, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_13, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_14, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_15, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_16, [1, 771]);
      }
      t1 = new M.Point0(null, null);
      t1.x = 0;
      t1.y = 0;
      this.projection = t1;
      t1.x = J.$div$n(this.width, 2);
      J.set$y$x(this.projection, J.$div$n(J.$negate$n(this.height), 2));
      t1 = new M.Point0(null, null);
      t1.x = 0;
      t1.y = 0;
      this.offset = t1;
      this.resize$2(0, this.width, this.height);
      this.contextLost = false;
      this.shaderManager = M.WebGLShaderManager$(this.gl);
      this.spriteBatch = M.WebGLSpriteBatch$(this.gl);
      t1 = new M.WebGLMaskManager([], 0, null, null, null);
      t1.WebGLMaskManager$1(this.gl);
      this.maskManager = t1;
      t1 = this.gl;
      t2 = new M.WebGLFilterManager(null, this.transparent, [], 0, 0, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2.setContext$1(t1);
      this.filterManager = t2;
      t2 = this.gl;
      t1 = new M.WebGLStencilManager(t2, null, null, null, null, null);
      t1.WebGLStencilManager$1(t2);
      this.stencilManager = t1;
      t1 = this.gl;
      t2 = new M.WebGLBlendModeManager(t1, null);
      t2.currentBlendMode = C.BlendModes_99999;
      this.blendModeManager = t2;
      t2 = new M.RenderSession(null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, false);
      this.renderSession = t2;
      t2.gl = t1;
      this.renderSession.set$drawCount(0);
      this.renderSession.set$shaderManager(this.shaderManager);
      this.renderSession.set$maskManager(this.maskManager);
      this.renderSession.set$filterManager(this.filterManager);
      this.renderSession.set$blendModeManager(this.blendModeManager);
      this.renderSession.set$spriteBatch(this.spriteBatch);
      this.renderSession.set$stencilManager(this.stencilManager);
      this.renderSession.set$renderer(this);
      J.useProgram$1$x(this.gl, this.shaderManager.get$defaultShader().get$program());
      J.disable$1$x(this.gl, 2929);
      J.disable$1$x(this.gl, 2884);
      J.enable$1$x(this.gl, 3042);
      J.colorMask$4$x(this.gl, true, true, true, this.transparent);
    },
    static: {WebGLRenderer$: [function(width, height, view, transparent, antialias, preserveDrawingBuffer) {
        var t1 = new M.WebGLRenderer(0, false, false, false, 100, 100, null, null, null, false, null, null, null, null, null, null, null, null, null, null);
        t1.WebGLRenderer$6(width, height, view, transparent, antialias, preserveDrawingBuffer);
        return t1;
      }, null, null, 0, 12, 187, 144, 145, 12, 19, 19, 19, 31, [], 52, [], 146, [], 147, [], 148, [], 188, [], "new WebGLRenderer"], WebGLRenderer_updateTextures: [function(gl) {
        var i, t1;
        i = 0;
        while (true) {
          t1 = J.get$length$asx($.get$Texture_frameUpdates());
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          J.$index$asx($.get$Texture_frameUpdates(), i)._updateWebGLuvs$0();
          ++i;
        }
        i = 0;
        while (true) {
          t1 = J.get$length$asx($.get$texturesToDestroy());
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          M.WebGLRenderer_destroyTexture(J.$index$asx($.get$texturesToDestroy(), i), gl);
          ++i;
        }
        J.set$length$asx($.get$texturesToUpdate(), 0);
        J.set$length$asx($.get$texturesToDestroy(), 0);
        J.set$length$asx($.get$Texture_frameUpdates(), 0);
      }, "call$1", "WebGLRenderer_updateTextures$closure", 2, 0, 189, 160, [], "updateTextures"], WebGLRenderer_destroyTexture: [function(texture, gl) {
        var t1, t2;
        for (t1 = J.get$iterator$ax(J.get$values$x(texture.get$_glTextures())), t2 = J.getInterceptor$x(gl); t1.moveNext$0();)
          t2.deleteTexture$1(gl, t1.get$current());
        J.clear$0$ax(texture.get$_glTextures());
      }, "call$2", "WebGLRenderer_destroyTexture$closure", 4, 0, 190, 68, [], 160, [], "destroyTexture"], WebGLRenderer_updateTextureFrame: [function(texture) {
        texture._updateWebGLuvs$0();
      }, "call$1", "WebGLRenderer_updateTextureFrame$closure", 2, 0, 67, 68, [], "updateTextureFrame"]}
  },
  "+WebGLRenderer": [837],
  ChartData: {
    "^": "Object;font*-644,size*-616,lineHeight*-616,chars@-783",
    size$1: function($receiver, arg0) {
      return this.size.call$1(arg0);
    },
    static: {ChartData$: [function() {
        return new M.ChartData(null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }, null, null, 0, 0, 191, "new ChartData"]}
  },
  "+ChartData": [674],
  Char: {
    "^": "Object;texture@-698,line@-614,charCode*-614,position*-652,xOffset@-614,yOffset@-614,xAdvance@-614,kernings@-783",
    line$1: function(arg0) {
      return this.line.call$1(arg0);
    },
    static: {Char$: [function() {
        return new M.Char(null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }, null, null, 0, 0, 192, "new Char"]}
  },
  "+Char": [674],
  BitmapText: {
    "^": "DisplayObjectContainer;text*-644,_style@-935,_pool@-645,_dirty:PIXI$BitmapText$_dirty@-617,tint@-614,fontName@-644,fontSize*-616,_textWidth@-616,_textHeight@-616,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.text.call$4(arg0, arg1, arg2, arg3);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return this.text.call$3(arg0, arg1, arg2);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.text.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    get$style: [function(_) {
      return this._style;
    }, null, null, 1, 0, 936, "style"],
    get$textWidth: [function() {
      return this._textWidth;
    }, null, null, 1, 0, 619, "textWidth"],
    get$textHeight: [function() {
      return this._textHeight;
    }, null, null, 1, 0, 619, "textHeight"],
    setText$1: [function(text) {
      this.set$text(0, text);
      this.PIXI$BitmapText$_dirty = true;
    }, "call$1", "get$setText", 2, 0, 102, 124, [], "setText"],
    setStyle$1: [function(style) {
      var font, t1, t2;
      this._style = style;
      font = J.split$1$s(J.get$font$x(style), " ");
      t1 = font.length;
      t2 = t1 - 1;
      if (t2 < 0)
        return H.ioore(font, t2);
      t2 = font[t2];
      this.fontName = t2;
      this.set$fontSize(0, t1 >= 2 ? H.Primitives_parseInt(J.replaceAll$2$s(font[t1 - 2], $.get$BitmapText__numReg(), ""), null, null) : J.get$size$x(J.$index$asx($.get$BitmapText_fonts(), t2)));
      this.PIXI$BitmapText$_dirty = true;
      this.set$tint(style.get$tint());
    }, "call$1", "get$setStyle", 2, 0, 937, 194, [], "setStyle"],
    updateText$0: [function() {
      var data, pos, chars, lineWidths, t1, scale, prevCharCode, maxLineWidth, line, i, t2, charCode, charData, t3, t4, t5, lineAlignOffsets, alignOffset, lenChildren, lenChars, tint, c, t6, t7, child;
      data = J.$index$asx($.get$BitmapText_fonts(), this.fontName);
      pos = new M.Point0(null, null);
      pos.x = 0;
      pos.y = 0;
      chars = [];
      lineWidths = [];
      t1 = J.getInterceptor$x(data);
      scale = J.$div$n(this.get$fontSize(this), t1.get$size(data));
      prevCharCode = null;
      maxLineWidth = 0;
      line = 0;
      i = 0;
      while (true) {
        t2 = J.get$length$asx(this.get$text(this));
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        c$0: {
          charCode = J.codeUnitAt$1$s(this.get$text(this), i);
          if (J.$eq(J.$index$asx(this.get$text(this), i), "\n") || J.$eq(J.$index$asx(this.get$text(this), i), "\r") || J.$eq(J.$index$asx(this.get$text(this), i), "\r\n")) {
            lineWidths.push(pos.x);
            maxLineWidth = P.max(maxLineWidth, pos.x);
            ++line;
            pos.x = 0;
            pos.y = J.$add$ns(pos.y, t1.get$lineHeight(data));
            prevCharCode = null;
            break c$0;
          }
          charData = J.$index$asx(data.get$chars(), charCode);
          if (charData == null)
            break c$0;
          if (prevCharCode != null && J.containsKey$1$x(charData.get$kernings(), prevCharCode) === true)
            pos.x = J.$add$ns(pos.x, J.$index$asx(charData.get$kernings(), prevCharCode));
          t2 = new M.Char(null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
          t2.texture = charData.get$texture();
          t2.line = line;
          t2.charCode = charCode;
          t3 = J.$add$ns(pos.x, charData.get$xOffset());
          t4 = J.$add$ns(pos.y, charData.get$yOffset());
          t5 = new M.Point0(null, null);
          t5.x = t3;
          t5.y = t4;
          t2.position = t5;
          chars.push(t2);
          pos.x = J.$add$ns(pos.x, charData.get$xAdvance());
          prevCharCode = charCode;
        }
        ++i;
      }
      lineWidths.push(pos.x);
      maxLineWidth = P.max(maxLineWidth, pos.x);
      lineAlignOffsets = [];
      for (i = 0; i <= line; ++i) {
        if (J.$eq(this._style.get$align(), "right")) {
          if (i >= lineWidths.length)
            return H.ioore(lineWidths, i);
          t2 = lineWidths[i];
          if (typeof t2 !== "number")
            return H.iae(t2);
          alignOffset = maxLineWidth - t2;
        } else if (J.$eq(this._style.get$align(), "center")) {
          if (i >= lineWidths.length)
            return H.ioore(lineWidths, i);
          t2 = lineWidths[i];
          if (typeof t2 !== "number")
            return H.iae(t2);
          alignOffset = (maxLineWidth - t2) / 2;
        } else
          alignOffset = 0;
        lineAlignOffsets.push(alignOffset);
      }
      lenChildren = J.get$length$asx(this.get$children(this));
      lenChars = chars.length;
      tint = this.get$tint();
      for (i = 0; i < lenChars; ++i) {
        if (typeof lenChildren !== "number")
          return H.iae(lenChildren);
        c = i < lenChildren ? J.$index$asx(this.get$children(this), i) : null;
        if (c == null && J.$gt$n(J.get$length$asx(this._pool), 0))
          c = J.removeLast$0$ax(this._pool);
        t2 = chars.length;
        t3 = chars[i];
        if (c != null) {
          if (i >= t2)
            return H.ioore(chars, i);
          c.setTexture$1(t3.texture);
        } else {
          if (i >= t2)
            return H.ioore(chars, i);
          t2 = t3.texture;
          t3 = new M.Point0(null, null);
          t3.x = 0;
          t3.y = 0;
          t4 = new M.Point0(null, null);
          t4.x = 0;
          t4.y = 0;
          t5 = new M.Point0(null, null);
          t5.x = 1;
          t5.y = 1;
          t6 = new M.Point0(null, null);
          t6.x = 0;
          t6.y = 0;
          t7 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
          c = new M.Sprite0(t3, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t4, t5, t6, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t7, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
          c.texture = t2;
          if (t2.get$baseTexture().get$hasLoaded() === true)
            c._onTextureUpdate$1(null);
          else
            J.addEventListener$2$x(t2, "update", c.get$_onTextureUpdate());
        }
        t2 = J.getInterceptor$x(c);
        t3 = t2.get$position(c);
        if (i >= chars.length)
          return H.ioore(chars, i);
        t4 = J.get$x$x(chars[i].position);
        if (i >= chars.length)
          return H.ioore(chars, i);
        t5 = chars[i].line;
        if (t5 >>> 0 !== t5 || t5 >= lineAlignOffsets.length)
          return H.ioore(lineAlignOffsets, t5);
        J.set$x$x(t3, J.$mul$ns(J.$add$ns(t4, lineAlignOffsets[t5]), scale));
        t5 = t2.get$position(c);
        if (i >= chars.length)
          return H.ioore(chars, i);
        J.set$y$x(t5, J.$mul$ns(J.get$y$x(chars[i].position), scale));
        t5 = t2.get$scale(c);
        J.set$y$x(t2.get$scale(c), scale);
        J.set$x$x(t5, scale);
        c.set$tint(tint);
        if (c.get$_parent() == null)
          this.addChildAt$2(c, J.get$length$asx(this.get$children(this)));
      }
      for (; J.$gt$n(J.get$length$asx(this.get$children(this)), lenChars);) {
        child = this.getChildAt$1(J.$sub$n(J.get$length$asx(this.get$children(this)), 1));
        J.add$1$ax(this._pool, child);
        this.removeChildAt$1(J.indexOf$1$asx(this.get$children(this), child));
      }
      if (typeof scale !== "number")
        return H.iae(scale);
      this._textWidth = maxLineWidth * scale;
      this._textHeight = J.$mul$ns(J.$add$ns(pos.y, t1.get$lineHeight(data)), scale);
    }, "call$0", "get$updateText", 0, 0, 54, "updateText"],
    updateTransform$0: [function() {
      if (this.PIXI$BitmapText$_dirty === true) {
        this.updateText$0();
        this.PIXI$BitmapText$_dirty = false;
      }
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
    }, "call$0", "get$updateTransform", 0, 0, 54, "updateTransform"],
    BitmapText$2: function(text, style) {
      this.set$text(0, text);
      if (style == null)
        style = M.TextStyle$0("left", "black", "bold 20pt Arial", "black", 0, 16777215);
      this._style = style;
      this._pool = [];
      this.set$text(0, text);
      this.PIXI$BitmapText$_dirty = true;
      this.setStyle$1(style);
      this.updateText$0();
      this.PIXI$BitmapText$_dirty = false;
    },
    static: {"^": "BitmapText_fonts@-783,BitmapText__charCodeReg@-813,BitmapText__numReg@-813", BitmapText$0: [function(text, style) {
        var t1, t2, t3;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t3 = new M.BitmapText(null, null, null, null, 16777215, null, null, null, null, [], false, 0, 0, t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t3.BitmapText$2(text, style);
        return t3;
      }, null, null, 2, 2, 193, 12, 124, [], 194, [], "new BitmapText"]}
  },
  "+BitmapText": [706],
  TextStyle0: {
    "^": "Object;fill*-644,font*-644,align@-644,stroke*-644,strokeThickness@-616,wordWrap*-617,wordWrapWidth@-616,dropShadow@-617,dropShadowAngle@-616,dropShadowDistance@-616,dropShadowColor@-644,tint@-616",
    fill$0: function($receiver) {
      return this.fill.call$0();
    },
    fill$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.fill.call$4(arg0, arg1, arg2, arg3);
    },
    fill$6: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5) {
      return this.fill.call$6(arg0, arg1, arg2, arg3, arg4, arg5);
    },
    stroke$0: function($receiver) {
      return this.stroke.call$0();
    },
    wordWrap$1: function($receiver, arg0) {
      return this.wordWrap.call$1(arg0);
    },
    TextStyle$6$align$fill$font$stroke$strokeThickness$tint: function(align, fill, font, stroke, strokeThickness, tint) {
      this.fill = fill;
      this.font = font;
      this.align = align;
      this.stroke = stroke;
      this.strokeThickness = strokeThickness;
      this.tint = tint;
    },
    static: {TextStyle$0: [function(align, fill, font, stroke, strokeThickness, tint) {
        var t1 = new M.TextStyle0("black", "bold 20pt Arial", "left", "black", 0, false, 100, false, 0.5235987755982988, 4, "black", 16777215);
        t1.TextStyle$6$align$fill$font$stroke$strokeThickness$tint(align, fill, font, stroke, strokeThickness, tint);
        return t1;
      }, null, null, 0, 13, 195, 196, 197, 198, 196, 49, 199, 200, [], 201, [], 202, [], 203, [], 204, [], 205, [], "new TextStyle"]}
  },
  "+TextStyle": [674],
  Text0: {
    "^": "Sprite0;_PIXI$_text@-644,_style@-935,_canvas@-836,_context@-876,_dirty:PIXI$Text0$_dirty@-617,_requiresUpdate@-617,anchor-652,texture-698,updateFrame-617,PIXI$Sprite0$_PIXI$_width-616,PIXI$Sprite0$_PIXI$_height-616,_uvs-699,tintedTexture-700,buffer-701,tint-614,cachedTint-614,blendMode-702,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    get$style: [function(_) {
      return this._style;
    }, null, null, 1, 0, 936, "style"],
    get$canvas: [function(_) {
      return this._canvas;
    }, null, null, 1, 0, 938, "canvas"],
    get$context: [function(_) {
      return this._context;
    }, null, null, 1, 0, 939, "context"],
    get$text: [function(_) {
      return this._PIXI$_text;
    }, null, null, 1, 0, 810, "text"],
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$text(this).call$4(arg0, arg1, arg2, arg3);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return this.get$text(this).call$3(arg0, arg1, arg2);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.get$text(this).call$5(arg0, arg1, arg2, arg3, arg4);
    },
    set$text: [function(_, value) {
      this.setText$1(value);
    }, null, null, 3, 0, 91, 138, [], "text"],
    setStyle$1: [function(style) {
      this._style = style;
      this.PIXI$Text0$_dirty = true;
    }, "call$1", "get$setStyle", 2, 0, 937, 194, [], "setStyle"],
    setText$1: [function(text) {
      this._PIXI$_text = J.toString$0(text);
      this.PIXI$Text0$_dirty = true;
    }, "call$1", "get$setText", 2, 0, 940, 124, [], "setText"],
    get$width: [function(_) {
      if (this.PIXI$Text0$_dirty === true) {
        this.updateText$0();
        this.PIXI$Text0$_dirty = false;
      }
      return J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.texture.get$frame()));
    }, null, null, 1, 0, 619, "width"],
    set$width: [function(_, value) {
      J.set$x$x(this.scale, J.$div$n(value, J.get$width$x(this.texture.get$frame())));
      this.PIXI$Sprite0$_PIXI$_width = value;
    }, null, null, 3, 0, 620, 138, [], "width"],
    get$height: [function(_) {
      if (this.PIXI$Text0$_dirty === true) {
        this.updateText$0();
        this.PIXI$Text0$_dirty = false;
      }
      return J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.texture.get$frame()));
    }, null, null, 1, 0, 619, "height"],
    set$height: [function(_, value) {
      J.set$y$x(this.scale, J.$div$n(value, J.get$height$x(this.texture.get$frame())));
      this.PIXI$Sprite0$_PIXI$_height = value;
    }, null, null, 3, 0, 620, 138, [], "height"],
    updateText$0: [function() {
      var outputText, lines, lineWidths, t1, maxLineWidth, i, lineWidth, t2, width, t3, lineHeight, height, xShadowOffset, yShadowOffset, linePositionX, linePositionY;
      J.set$font$x(this._context, J.get$font$x(this.get$style(this)));
      outputText = this.get$text(this);
      if (J.get$wordWrap$x(this.get$style(this)) === true)
        outputText = this.wordWrap$1(0, this.get$text(this));
      lines = J.split$1$s(outputText, $.get$Text_splitReg());
      lineWidths = H.setRuntimeTypeInfo(Array(lines.length), [P.num]);
      for (t1 = lineWidths.length, maxLineWidth = 0, i = 0; i < lines.length; ++i) {
        lineWidth = J.measureText$1$x(this._context, lines[i]).width;
        if (i >= t1)
          return H.ioore(lineWidths, i);
        lineWidths[i] = lineWidth;
        maxLineWidth = P.max(maxLineWidth, lineWidth);
      }
      t2 = this.get$style(this).get$strokeThickness();
      if (typeof t2 !== "number")
        return H.iae(t2);
      width = maxLineWidth + t2;
      if (this.get$style(this).get$dropShadow() === true) {
        t2 = this.get$style(this).get$dropShadowDistance();
        if (typeof t2 !== "number")
          return H.iae(t2);
        width += t2;
      }
      t2 = this._canvas;
      t3 = J.get$lineWidth$x(this._context);
      if (typeof t3 !== "number")
        return H.iae(t3);
      J.set$width$x(t2, C.JSNumber_methods.toInt$0(Math.floor(width + t3)));
      lineHeight = J.$add$ns(this.determineFontHeight$1(C.JSString_methods.$add("font: ", J.get$font$x(this.get$style(this))) + ";"), this.get$style(this).get$strokeThickness());
      height = J.$mul$ns(lineHeight, lines.length);
      if (this.get$style(this).get$dropShadow() === true)
        height = J.$add$ns(height, this.get$style(this).get$dropShadowDistance());
      J.set$height$x(this._canvas, height);
      J.set$font$x(this._context, J.get$font$x(this.get$style(this)));
      J.set$strokeStyle$x(this._context, J.get$stroke$x(this.get$style(this)));
      J.set$lineWidth$x(this._context, this.get$style(this).get$strokeThickness());
      J.set$textBaseline$x(this._context, "top");
      if (this.get$style(this).get$dropShadow() === true) {
        J.set$fillStyle$x(this._context, this.get$style(this).get$dropShadowColor());
        t2 = Math.sin(H.checkNum(this.get$style(this).get$dropShadowAngle()));
        t3 = this.get$style(this).get$dropShadowDistance();
        if (typeof t3 !== "number")
          return H.iae(t3);
        xShadowOffset = t2 * t3;
        t3 = Math.cos(H.checkNum(this.get$style(this).get$dropShadowAngle()));
        t2 = this.get$style(this).get$dropShadowDistance();
        if (typeof t2 !== "number")
          return H.iae(t2);
        yShadowOffset = t3 * t2;
        for (i = 0; i < lines.length; ++i) {
          linePositionX = J.$div$n(this.get$style(this).get$strokeThickness(), 2);
          t2 = J.$div$n(this.get$style(this).get$strokeThickness(), 2);
          if (typeof lineHeight !== "number")
            return H.iae(lineHeight);
          linePositionY = J.$add$ns(t2, i * lineHeight);
          if (J.$eq(this.get$style(this).get$align(), "right")) {
            if (i >= t1)
              return H.ioore(lineWidths, i);
            t2 = lineWidths[i];
            if (typeof t2 !== "number")
              return H.iae(t2);
            linePositionX = J.$add$ns(linePositionX, maxLineWidth - t2);
          } else if (J.$eq(this.get$style(this).get$align(), "center")) {
            if (i >= t1)
              return H.ioore(lineWidths, i);
            t2 = lineWidths[i];
            if (typeof t2 !== "number")
              return H.iae(t2);
            linePositionX = J.$add$ns(linePositionX, (maxLineWidth - t2) / 2);
          }
          if (J.get$fill$x(this.get$style(this)) != null) {
            t2 = this._context;
            if (i >= lines.length)
              return H.ioore(lines, i);
            J.fillText$3$x(t2, lines[i], J.$add$ns(linePositionX, xShadowOffset), J.$add$ns(linePositionY, yShadowOffset));
          }
        }
      }
      J.set$fillStyle$x(this._context, J.get$fill$x(this.get$style(this)));
      for (i = 0; i < lines.length; ++i) {
        linePositionX = J.$div$n(this.get$style(this).get$strokeThickness(), 2);
        t2 = J.$div$n(this.get$style(this).get$strokeThickness(), 2);
        if (typeof lineHeight !== "number")
          return H.iae(lineHeight);
        linePositionY = J.$add$ns(t2, i * lineHeight);
        if (J.$eq(this.get$style(this).get$align(), "right")) {
          if (i >= t1)
            return H.ioore(lineWidths, i);
          t2 = lineWidths[i];
          if (typeof t2 !== "number")
            return H.iae(t2);
          linePositionX = J.$add$ns(linePositionX, maxLineWidth - t2);
        } else if (J.$eq(this.get$style(this).get$align(), "center")) {
          if (i >= t1)
            return H.ioore(lineWidths, i);
          t2 = lineWidths[i];
          if (typeof t2 !== "number")
            return H.iae(t2);
          linePositionX = J.$add$ns(linePositionX, (maxLineWidth - t2) / 2);
        }
        if (J.get$stroke$x(this.get$style(this)) != null && !J.$eq(this.get$style(this).get$strokeThickness(), 0)) {
          t2 = this._context;
          if (i >= lines.length)
            return H.ioore(lines, i);
          J.strokeText$3$x(t2, lines[i], linePositionX, linePositionY);
        }
        if (J.get$fill$x(this.get$style(this)) != null) {
          t2 = this._context;
          if (i >= lines.length)
            return H.ioore(lines, i);
          J.fillText$3$x(t2, lines[i], linePositionX, linePositionY);
        }
      }
      this.updateTexture$0();
    }, "call$0", "get$updateText", 0, 0, 54, "updateText"],
    updateTexture$0: [function() {
      var t1, t2, t3;
      J.set$width$x(this.texture.get$baseTexture(), J.get$width$x(this._canvas));
      J.set$height$x(this.texture.get$baseTexture(), J.get$height$x(this._canvas));
      t1 = this.texture.get$crop();
      t2 = this.texture.get$frame();
      t3 = J.get$width$x(this._canvas);
      J.set$width$x(t2, t3);
      J.set$width$x(t1, t3);
      t3 = this.texture.get$crop();
      t1 = this.texture.get$frame();
      t2 = J.get$height$x(this._canvas);
      J.set$height$x(t1, t2);
      J.set$height$x(t3, t2);
      this.PIXI$Sprite0$_PIXI$_width = J.get$width$x(this._canvas);
      this.PIXI$Sprite0$_PIXI$_height = J.get$height$x(this._canvas);
      this._requiresUpdate = true;
    }, "call$0", "get$updateTexture", 0, 0, 54, "updateTexture"],
    _renderWebGL$1: [function(renderSession) {
      if (this._requiresUpdate === true) {
        this._requiresUpdate = false;
        M.updateWebGLTexture(this.texture.get$baseTexture(), renderSession.get$gl());
      }
      M.Sprite0.prototype._renderWebGL$1.call(this, renderSession);
    }, "call$1", "get$_renderWebGL", 2, 0, 684, 166, [], "_renderWebGL"],
    updateTransform$0: [function() {
      if (this.PIXI$Text0$_dirty === true) {
        this.updateText$0();
        this.PIXI$Text0$_dirty = false;
      }
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
    }, "call$0", "get$updateTransform", 0, 0, 54, "updateTransform"],
    determineFontHeight$1: [function(fontStyle) {
      var result, t1, body, dummy;
      result = J.$index$asx($.get$Text_heightCache(), fontStyle);
      if (result == null) {
        t1 = document.getElementsByTagName("body");
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        body = t1[0];
        dummy = document.createElement("div", null);
        dummy.textContent = "M";
        dummy.setAttribute("style", J.$add$ns(fontStyle, ";position:absolute;top:0;left:0"));
        body.appendChild(dummy);
        result = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(dummy.offsetHeight));
        J.$indexSet$ax($.get$Text_heightCache(), fontStyle, result);
        J.remove$0$ax(dummy);
      }
      return result;
    }, "call$1", "get$determineFontHeight", 2, 0, 941, 942, [], "determineFontHeight"],
    wordWrap$1: [function(_, text) {
      var lines, result, i, spaceLeft, words, j, wordWidth, t1, wordWidthWithSpace;
      lines = J.split$1$s(text, "\n");
      for (result = "", i = 0; i < lines.length; ++i) {
        spaceLeft = this.get$style(this).get$wordWrapWidth();
        if (i >= lines.length)
          return H.ioore(lines, i);
        words = J.split$1$s(lines[i], " ");
        for (j = 0; j < words.length; ++j) {
          wordWidth = J.measureText$1$x(this._context, words[j]).width;
          t1 = J.measureText$1$x(this._context, " ").width;
          if (typeof wordWidth !== "number")
            return wordWidth.$add();
          if (typeof t1 !== "number")
            return H.iae(t1);
          wordWidthWithSpace = wordWidth + t1;
          if (j !== 0) {
            if (typeof spaceLeft !== "number")
              return H.iae(spaceLeft);
            t1 = wordWidthWithSpace > spaceLeft;
          } else
            t1 = true;
          if (t1) {
            if (j > 0)
              result += "\n";
            if (j >= words.length)
              return H.ioore(words, j);
            result = C.JSString_methods.$add(result, words[j]);
            spaceLeft = J.$sub$n(this.get$style(this).get$wordWrapWidth(), wordWidth);
          } else {
            spaceLeft = J.$sub$n(spaceLeft, wordWidthWithSpace);
            if (j >= words.length)
              return H.ioore(words, j);
            result += C.JSString_methods.$add(" ", words[j]);
          }
        }
        if (i < lines.length - 1)
          result += "\n";
      }
      return result;
    }, "call$1", "get$wordWrap", 2, 0, 943, 124, [], "wordWrap"],
    destroy$1: [function(destroyBaseTexture) {
      var t1;
      this._context = null;
      this._canvas = null;
      t1 = this.texture;
      t1.destroy$1(destroyBaseTexture == null ? true : destroyBaseTexture);
    }, function() {
      return this.destroy$1(null);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 944, 12, 945, [], "destroy"],
    Text$2: function(text, style) {
      var t1;
      this._PIXI$_text = text;
      this._style = style;
      t1 = W.CanvasElement_CanvasElement(null, null);
      this._canvas = t1;
      this._context = J.getContext$1$x(t1, "2d");
      this.texture = M.Texture$(M.BaseTexture_fromCanvas(this._canvas, null), null);
      this._setupTexture$0();
      this.setText$1(text);
      this.setStyle$1(style);
    },
    static: {"^": "Text_splitReg@-813,Text_heightCache@-946", Text$0: [function(text, style) {
        var t1, t2, t3, t4;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t4 = new M.Text0(null, null, null, null, false, null, t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t4.renderable = true;
        t4.Text$2(text, style);
        return t4;
      }, null, null, 4, 0, 206, 124, [], 194, [], "new Text"]}
  },
  "+Text": [661],
  BaseTexture: {
    "^": "EventTarget0;id*-614,width*-616,height*-616,scaleMode@-891,_hasLoaded@-617,source*-12,_glTextures@-947,imageUrl@-644,_powerOf2@-617,onLoaded@-948,premultipliedAlpha@-617,_dirty@-783,listeners-848",
    get$hasLoaded: [function() {
      return this._hasLoaded;
    }, null, null, 1, 0, 247, "hasLoaded"],
    set$hasLoaded: [function(value) {
      this._hasLoaded = value;
    }, null, null, 3, 0, 596, 138, [], "hasLoaded"],
    onLoaded$0: function() {
      return this.onLoaded.call$0();
    },
    destroy$0: [function() {
      var t1, sor;
      t1 = this.imageUrl;
      if (t1 != null) {
        J.remove$1$ax($.get$BaseTextureCache(), t1);
        J.remove$1$ax($.get$TextureCache(), this.imageUrl);
        this.imageUrl = null;
        J.set$src$x(this.source, null);
      } else {
        sor = H.interceptedTypeCast(this.source, "$isHtmlElement");
        if (sor != null && sor.getAttribute("data-" + H.S(new W._DataAttributeMap(new W._ElementAttributeMap(sor))._toHyphenedName$1("_pixiId"))) != null)
          J.remove$1$ax($.get$BaseTextureCache(), sor.getAttribute("data-" + H.S(new W._DataAttributeMap(new W._ElementAttributeMap(sor))._toHyphenedName$1("_pixiId"))));
      }
      this.source = null;
      J.add$1$ax($.get$texturesToDestroy(), this);
    }, "call$0", "get$destroy", 0, 0, 17, "destroy"],
    updateSourceImage$1: [function(newSrc) {
      this._hasLoaded = false;
      J.set$src$x(this.source, null);
      J.set$src$x(this.source, newSrc);
    }, "call$1", "get$updateSourceImage", 2, 0, 91, 949, [], "updateSourceImage"],
    BaseTexture$2: function(source, scaleMode) {
      var t1, t2;
      this.premultipliedAlpha = true;
      this._dirty = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      t1 = this.source;
      if (t1 == null)
        return;
      t2 = J.getInterceptor(t1);
      if ((!!t2.$isImageElement && J.$eq(t2.get$complete(t1), true) || !!J.getInterceptor(this.source).$isCanvasElement) && !J.$eq(J.get$width$x(this.source), 0) && !J.$eq(J.get$height$x(this.source), 0)) {
        this._hasLoaded = true;
        this.set$width(0, J.get$width$x(this.source));
        this.set$height(0, J.get$height$x(this.source));
        J.add$1$ax($.get$texturesToUpdate(), this);
      } else {
        J.get$onLoad$x(this.source).listen$1(new M.BaseTexture_closure(this));
        J.get$onError$x(this.source).listen$1(new M.BaseTexture_closure0(this));
      }
    },
    $isBaseTexture: true,
    static: {BaseTexture$: [function(source, scaleMode) {
        var t1 = $.BaseTextureCacheIdGenerator;
        $.BaseTextureCacheIdGenerator = J.$add$ns(t1, 1);
        t1 = new M.BaseTexture(t1, 100, 100, scaleMode, false, source, P.LinkedHashMap_LinkedHashMap(null, null, null, P.RenderingContext, null), null, false, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.BaseTexture$2(source, scaleMode);
        return t1;
      }, null, null, 0, 4, 207, 12, 163, 208, [], 74, [], "new BaseTexture"], BaseTexture_fromImage: [function(imageUrl, crossorigin, scaleMode) {
        var baseTexture, image;
        baseTexture = J.$index$asx($.get$BaseTextureCache(), imageUrl);
        if (crossorigin == null && J.$eq(J.indexOf$1$asx(imageUrl, "data:"), -1))
          crossorigin = true;
        if (baseTexture == null) {
          image = W.ImageElement_ImageElement(null, null, null);
          if (crossorigin === true)
            J.set$crossOrigin$x(image, "");
          J.set$src$x(image, imageUrl);
          baseTexture = M.BaseTexture$(image, scaleMode);
          baseTexture.imageUrl = imageUrl;
          J.$indexSet$ax($.get$BaseTextureCache(), imageUrl, baseTexture);
        }
        return baseTexture;
      }, "call$3", "BaseTexture_fromImage$closure", 6, 0, 209, 210, [], 73, [], 74, [], "fromImage"], BaseTexture_fromCanvas: [function(canvas, scaleMode) {
        var t1, t2, t3, baseTexture;
        t1 = J.getInterceptor$x(canvas);
        t2 = t1.get$dataset(canvas);
        if (t2._attributes._element.getAttribute("data-" + H.S(t2._toHyphenedName$1("_pixiId"))) == null) {
          t2 = t1.get$dataset(canvas);
          t3 = $.TextureCacheIdGenerator;
          $.TextureCacheIdGenerator = J.$add$ns(t3, 1);
          t3 = "canvas_" + H.S(t3);
          t2._attributes._element.setAttribute("data-" + H.S(t2._toHyphenedName$1("_pixiId")), t3);
        }
        t2 = $.get$BaseTextureCache();
        t3 = t1.get$dataset(canvas);
        baseTexture = J.$index$asx(t2, t3._attributes._element.getAttribute("data-" + H.S(t3._toHyphenedName$1("_pixiId"))));
        if (baseTexture == null) {
          baseTexture = M.BaseTexture$(canvas, scaleMode);
          t2 = $.get$BaseTextureCache();
          t1 = t1.get$dataset(canvas);
          J.$indexSet$ax(t2, t1._attributes._element.getAttribute("data-" + H.S(t1._toHyphenedName$1("_pixiId"))), baseTexture);
        }
        return baseTexture;
      }, "call$2", "BaseTexture_fromCanvas$closure", 4, 0, 211, 154, [], 74, [], "fromCanvas"]}
  },
  "+BaseTexture": [850],
  BaseTexture_closure: {
    "^": "Closure:102;scope_0",
    call$1: [function(e) {
      var t1, i, t2;
      t1 = this.scope_0;
      t1._hasLoaded = true;
      t1.set$width(0, J.get$width$x(t1.source));
      t1.set$height(0, J.get$height$x(t1.source));
      i = 0;
      while (true) {
        t2 = J.get$length$asx(t1._glTextures);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        J.$indexSet$ax(t1._dirty, i, true);
        ++i;
      }
      t1.dispatchEvent$1(0, new M.PixiEvent("loaded", t1, null));
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  BaseTexture_closure0: {
    "^": "Closure:102;scope_1",
    call$1: [function(e) {
      var t1, t2;
      t1 = this.scope_1;
      t2 = new M.PixiEvent(null, null, null);
      t2.type = "error";
      t2.content = t1;
      t1.dispatchEvent$1(0, t2);
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  RenderTexture0: {
    "^": "Texture;renderer@-837,width:PIXI$RenderTexture0$width*-614,height:PIXI$RenderTexture0$height*-614,frame:PIXI$RenderTexture0$frame@-659,scaleMode:PIXI$RenderTexture0$scaleMode@-891,baseTexture:PIXI$RenderTexture0$baseTexture@-853,textureBuffer@-12,projection@-652,render@-950,valid:PIXI$RenderTexture0$valid@-617,noFrame-617,updateFrame-617,frame-659,trim-659,scope-853,_uvs-699,valid-617,baseTexture-853,PIXI$Texture$width-616,PIXI$Texture$height-616,sourceWidth-616,sourceHeight-616,tintCache-783,needsUpdate-617,isTiling-617,canvasBuffer-701,crop-659,id-614,width-616,height-616,scaleMode-891,_hasLoaded-617,source-12,_glTextures-947,imageUrl-644,_powerOf2-617,onLoaded-948,premultipliedAlpha-617,_dirty-783,listeners-848",
    render$1: function(arg0) {
      return this.render.call$1(arg0);
    },
    render$0: function() {
      return this.render.call$0();
    },
    render$3: function(arg0, arg1, arg2) {
      return this.render.call$3(arg0, arg1, arg2);
    },
    render$2: function(arg0, arg1) {
      return this.render.call$2(arg0, arg1);
    },
    clear$0: [function(_) {
      if (J.$eq(J.get$type$x(this.renderer), 0))
        J.bindFramebuffer$2$x(this.renderer.get$gl(), 36160, this.textureBuffer.get$frameBuffer());
      J.clear$0$ax(this.textureBuffer);
    }, "call$0", "get$clear", 0, 0, 54, "clear"],
    resize$3: [function(_, width, height, updateBase) {
      width = J.toInt$0$n(width);
      height = J.toInt$0$n(height);
      if (width === this.PIXI$RenderTexture0$width && height === this.PIXI$RenderTexture0$height)
        return;
      J.set$width$x(this.PIXI$RenderTexture0$frame, width);
      this.PIXI$RenderTexture0$width = width;
      J.set$height$x(this.PIXI$RenderTexture0$frame, height);
      this.PIXI$RenderTexture0$height = height;
      if (updateBase === true) {
        J.set$width$x(this.PIXI$RenderTexture0$baseTexture, this.PIXI$RenderTexture0$width);
        J.set$height$x(this.PIXI$RenderTexture0$baseTexture, this.PIXI$RenderTexture0$height);
      }
      if (J.$eq(J.get$type$x(this.renderer), 0)) {
        J.set$x$x(this.projection, J.$div$n(this.PIXI$RenderTexture0$width, 2));
        J.set$y$x(this.projection, J.$div$n(J.$negate$n(this.PIXI$RenderTexture0$height), 2));
      }
      J.resize$2$x(this.textureBuffer, this.PIXI$RenderTexture0$width, this.PIXI$RenderTexture0$height);
    }, function($receiver, width, height) {
      return this.resize$3($receiver, width, height, false);
    }, "resize$2", "call$3", "call$2", "get$resize", 4, 2, 951, 19, 31, [], 52, [], 952, [], "resize"],
    renderWebGL$3: [function(displayObject, position, clear) {
      var gl, t1, children, originalWorldTransform, t2, j, i;
      gl = this.renderer.get$gl();
      t1 = J.getInterceptor$x(gl);
      t1.colorMask$4(gl, true, true, true, true);
      t1.viewport$4(gl, 0, 0, this.PIXI$RenderTexture0$width, this.PIXI$RenderTexture0$height);
      t1.bindFramebuffer$2(gl, 36160, this.textureBuffer.get$frameBuffer());
      if (clear === true)
        J.clear$0$ax(this.textureBuffer);
      children = J.get$children$x(displayObject);
      originalWorldTransform = displayObject.get$_worldTransform();
      displayObject.set$_worldTransform($.get$RenderTexture_tempMatrix());
      displayObject.get$_worldTransform().set$d(-1);
      displayObject.get$_worldTransform().set$ty(J.$mul$ns(J.get$y$x(this.projection), -2));
      if (position != null) {
        t1 = J.getInterceptor$x(position);
        displayObject.get$_worldTransform().set$tx(J.toDouble$0$n(t1.get$x(position)));
        t2 = displayObject.get$_worldTransform();
        t2.set$ty(J.$sub$n(t2.get$ty(), J.toDouble$0$n(t1.get$y(position))));
      }
      t1 = J.getInterceptor$asx(children);
      j = t1.get$length(children);
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        t1.$index(children, i).updateTransform$0();
      M.WebGLRenderer_updateTextures(gl);
      this.renderer.get$spriteBatch().set$dirty(true);
      this.renderer.renderDisplayObject$3(displayObject, this.projection, this.textureBuffer.get$frameBuffer());
      displayObject.set$_worldTransform(originalWorldTransform);
      this.renderer.get$spriteBatch().set$dirty(true);
    }, function(displayObject, position) {
      return this.renderWebGL$3(displayObject, position, false);
    }, "renderWebGL$2", "call$3", "call$2", "get$renderWebGL", 4, 2, 953, 19, 833, [], 290, [], 954, [], "renderWebGL"],
    renderCanvas$3: [function(displayObject, position, clear) {
      var children, originalWorldTransform, t1, j, i, context;
      children = J.get$children$x(displayObject);
      originalWorldTransform = displayObject.get$_worldTransform();
      displayObject.set$_worldTransform($.get$RenderTexture_tempMatrix());
      if (position != null) {
        t1 = J.getInterceptor$x(position);
        displayObject.get$_worldTransform().set$tx(t1.get$x(position));
        displayObject.get$_worldTransform().set$ty(t1.get$y(position));
      } else {
        displayObject.get$_worldTransform().set$tx(0);
        displayObject.get$_worldTransform().set$ty(0);
      }
      t1 = J.getInterceptor$asx(children);
      j = t1.get$length(children);
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        t1.$index(children, i).updateTransform$0();
      if (clear === true)
        J.clear$0$ax(this.textureBuffer);
      context = this.textureBuffer.get$_context();
      this.renderer.renderDisplayObject$2(displayObject, context);
      J.setTransform$6$x(context, 1, 0, 0, 1, 0, 0);
      displayObject.set$_worldTransform(originalWorldTransform);
    }, function(displayObject, position) {
      return this.renderCanvas$3(displayObject, position, false);
    }, "renderCanvas$2", "call$3", "call$2", "get$renderCanvas", 4, 2, 955, 19, 833, [], 290, [], 954, [], "renderCanvas"],
    RenderTexture$4: function(width, height, renderer, scaleMode) {
      var t1, t2, gl, t3;
      if (this.renderer == null)
        this.renderer = $.defaultRenderer;
      t1 = this.PIXI$RenderTexture0$width;
      t2 = this.PIXI$RenderTexture0$height;
      this.PIXI$RenderTexture0$frame = new M.Rectangle0(0, 0, t1, t2);
      this.crop = new M.Rectangle0(0, 0, t1, t2);
      J.set$width$x(this.PIXI$RenderTexture0$baseTexture, t1);
      J.set$height$x(this.PIXI$RenderTexture0$baseTexture, this.PIXI$RenderTexture0$height);
      this.PIXI$RenderTexture0$baseTexture.set$scaleMode(this.PIXI$RenderTexture0$scaleMode);
      this.PIXI$RenderTexture0$baseTexture.set$hasLoaded(true);
      if (J.$eq(J.get$type$x(this.renderer), 0)) {
        gl = this.renderer.get$gl();
        this.textureBuffer = M.FilterTexture$(gl, this.PIXI$RenderTexture0$width, this.PIXI$RenderTexture0$height, this.PIXI$RenderTexture0$baseTexture.get$scaleMode());
        J.$indexSet$ax(this.PIXI$RenderTexture0$baseTexture.get$_glTextures(), gl, this.textureBuffer.get$texture());
        this.render = this.get$renderWebGL();
        t1 = J.$div$n(this.PIXI$RenderTexture0$width, 2);
        t2 = J.$div$n(J.$negate$n(this.PIXI$RenderTexture0$height), 2);
        t3 = new M.Point0(null, null);
        t3.x = t1;
        t3.y = t2;
        this.projection = t3;
      } else {
        this.render = this.get$renderCanvas();
        t1 = M.CanvasBuffer$(this.PIXI$RenderTexture0$width, this.PIXI$RenderTexture0$height);
        this.textureBuffer = t1;
        J.set$source$x(this.PIXI$RenderTexture0$baseTexture, t1.get$_canvas());
      }
      this.PIXI$RenderTexture0$valid = true;
      J.add$1$ax($.get$Texture_frameUpdates(), this);
    },
    $isRenderTexture0: true,
    static: {"^": "RenderTexture_tempMatrix@-658", RenderTexture$0: [function(width, height, renderer, scaleMode) {
        var t1, t2;
        t1 = M.BaseTexture$(null, C.scaleModes_0);
        t2 = $.BaseTextureCacheIdGenerator;
        $.BaseTextureCacheIdGenerator = J.$add$ns(t2, 1);
        t2 = new M.RenderTexture0(renderer, width, height, null, scaleMode, t1, null, null, null, null, false, false, null, null, null, null, false, null, 0, 0, 0, 0, null, true, null, null, null, t2, 100, 100, C.scaleModes_0, false, null, P.LinkedHashMap_LinkedHashMap(null, null, null, P.RenderingContext, null), null, false, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t2.BaseTexture$2(null, C.scaleModes_0);
        t2.scope = t2;
        t2.RenderTexture$4(width, height, renderer, scaleMode);
        return t2;
      }, null, null, 0, 8, 212, 129, 129, 12, 163, 31, [], 52, [], 213, [], 74, [], "new RenderTexture"]}
  },
  "+RenderTexture": [698],
  Texture: {
    "^": "BaseTexture;noFrame@-617,updateFrame@-617,frame@-659,trim*-659,scope@-853,_uvs@-699,valid@-617,baseTexture@-853,width:PIXI$Texture$width*-616,height:PIXI$Texture$height*-616,sourceWidth@-616,sourceHeight@-616,tintCache@-783,needsUpdate@-617,isTiling@-617,canvasBuffer@-701,crop@-659,id-614,width-616,height-616,scaleMode-891,_hasLoaded-617,source-12,_glTextures-947,imageUrl-644,_powerOf2-617,onLoaded-948,premultipliedAlpha-617,_dirty-783,listeners-848",
    trim$0: function($receiver) {
      return this.trim.call$0();
    },
    trim$1: function($receiver, arg0) {
      return this.trim.call$1(arg0);
    },
    crop$2: function(arg0, arg1) {
      return this.crop.call$2(arg0, arg1);
    },
    crop$1: function(arg0) {
      return this.crop.call$1(arg0);
    },
    onBaseTextureLoaded$0: [function() {
      var baseTexture, t1;
      baseTexture = this.get$baseTexture();
      t1 = J.getInterceptor$x(baseTexture);
      t1.removeEventListener$2(baseTexture, "loaded", this.get$onBaseTextureLoaded());
      if (this.noFrame === true)
        this.set$frame(new M.Rectangle0(0, 0, t1.get$width(baseTexture), t1.get$height(baseTexture)));
      this.setFrame$1(this.get$frame());
      J.dispatchEvent$1$x(this.scope, new M.PixiEvent("update", this, null));
    }, "call$0", "get$onBaseTextureLoaded", 0, 0, 17, "onBaseTextureLoaded"],
    destroy$1: [function(destroyBase) {
      if (destroyBase === true)
        this.get$baseTexture().destroy$0();
      this.set$valid(false);
    }, function() {
      return this.destroy$1(false);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 956, 19, 957, [], "destroy"],
    setFrame$1: [function(frame) {
      var t1, t2;
      this.noFrame = false;
      this.set$frame(frame);
      t1 = J.getInterceptor$x(frame);
      this.set$width(0, t1.get$width(frame));
      this.set$height(0, t1.get$height(frame));
      J.set$x$x(this.crop, t1.get$x(frame));
      J.set$y$x(this.crop, t1.get$y(frame));
      J.set$width$x(this.crop, t1.get$width(frame));
      J.set$height$x(this.crop, t1.get$height(frame));
      if (this.trim == null)
        t2 = J.$gt$n(J.$add$ns(t1.get$x(frame), t1.get$width(frame)), J.get$width$x(this.get$baseTexture())) || J.$gt$n(J.$add$ns(t1.get$y(frame), t1.get$height(frame)), J.get$height$x(this.get$baseTexture()));
      else
        t2 = false;
      if (t2)
        throw H.wrapException(P.Exception_Exception("Texture Error: frame does not fit inside the base Texture dimensions"));
      this.set$valid(frame != null && t1.get$width(frame) != null && !J.$eq(t1.get$width(frame), 0) && t1.get$height(frame) != null && !J.$eq(t1.get$height(frame), 0) && J.get$source$x(this.get$baseTexture()) != null && this.get$baseTexture().get$hasLoaded() === true);
      J.add$1$ax($.get$Texture_frameUpdates(), this);
    }, "call$1", "get$setFrame", 2, 0, 958, 216, [], "setFrame"],
    _updateWebGLuvs$0: [function() {
      var frame, tw, th, t1;
      if (this._uvs == null)
        this._uvs = new M.TextureUvs(0, 0, 0, 0, 0, 0, 0, 0);
      frame = this.crop;
      tw = J.get$width$x(this.get$baseTexture());
      th = J.get$height$x(this.get$baseTexture());
      t1 = J.getInterceptor$x(frame);
      this._uvs.set$x0(J.$div$n(t1.get$x(frame), tw));
      this._uvs.set$y0(J.$div$n(t1.get$y(frame), th));
      J.set$x1$x(this._uvs, J.$div$n(J.$add$ns(t1.get$x(frame), t1.get$width(frame)), tw));
      J.set$y1$x(this._uvs, J.$div$n(t1.get$y(frame), th));
      J.set$x2$x(this._uvs, J.$div$n(J.$add$ns(t1.get$x(frame), t1.get$width(frame)), tw));
      J.set$y2$x(this._uvs, J.$div$n(J.$add$ns(t1.get$y(frame), t1.get$height(frame)), th));
      this._uvs.set$x3(J.$div$n(t1.get$x(frame), tw));
      this._uvs.set$y3(J.$div$n(J.$add$ns(t1.get$y(frame), t1.get$height(frame)), th));
    }, "call$0", "get$_updateWebGLuvs", 0, 0, 17, "_updateWebGLuvs"],
    Texture$2: function(baseTexture, frame) {
      var t1;
      this.scope = this;
      if (this.get$frame() == null) {
        this.noFrame = true;
        this.set$frame(new M.Rectangle0(0, 0, 1, 1));
      }
      if (!!J.getInterceptor(baseTexture).$isTexture)
        baseTexture = baseTexture.get$baseTexture();
      this.set$baseTexture(baseTexture);
      this.crop = new M.Rectangle0(0, 0, 1, 1);
      if (baseTexture.get$hasLoaded() === true) {
        if (this.noFrame === true) {
          t1 = J.getInterceptor$x(baseTexture);
          this.set$frame(new M.Rectangle0(0, 0, t1.get$width(baseTexture), t1.get$height(baseTexture)));
        }
        this.setFrame$1(this.get$frame());
      } else
        J.addEventListener$2$x(baseTexture, "loaded", new M.Texture_closure(this));
    },
    $isTexture: true,
    static: {"^": "Texture_frameUpdates@-697", Texture$_: [function() {
        var t1 = $.BaseTextureCacheIdGenerator;
        $.BaseTextureCacheIdGenerator = J.$add$ns(t1, 1);
        t1 = new M.Texture(false, false, null, null, null, null, false, null, 0, 0, 0, 0, null, true, null, null, null, t1, 100, 100, C.scaleModes_0, false, null, P.LinkedHashMap_LinkedHashMap(null, null, null, P.RenderingContext, null), null, false, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.BaseTexture$2(null, C.scaleModes_0);
        t1.scope = t1;
        return t1;
      }, null, null, 0, 0, 54, "new Texture$_"], Texture$: [function(baseTexture, frame) {
        var t1 = $.BaseTextureCacheIdGenerator;
        $.BaseTextureCacheIdGenerator = J.$add$ns(t1, 1);
        t1 = new M.Texture(false, false, frame, null, null, null, false, null, 0, 0, 0, 0, null, true, null, null, null, t1, 100, 100, C.scaleModes_0, false, null, P.LinkedHashMap_LinkedHashMap(null, null, null, P.RenderingContext, null), null, false, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.BaseTexture$2(null, C.scaleModes_0);
        t1.Texture$2(baseTexture, frame);
        return t1;
      }, null, null, 2, 2, 214, 12, 215, [], 216, [], "new Texture"], Texture_fromImage: [function(imageUrl, crossorigin, scaleMode) {
        var texture, baseTexture, image;
        texture = J.$index$asx($.get$TextureCache(), imageUrl);
        if (texture == null) {
          baseTexture = J.$index$asx($.get$BaseTextureCache(), imageUrl);
          if (crossorigin == null && J.$eq(J.indexOf$1$asx(imageUrl, "data:"), -1))
            crossorigin = true;
          if (baseTexture == null) {
            image = W.ImageElement_ImageElement(null, null, null);
            if (crossorigin === true)
              J.set$crossOrigin$x(image, "");
            J.set$src$x(image, imageUrl);
            baseTexture = M.BaseTexture$(image, scaleMode);
            baseTexture.imageUrl = imageUrl;
            J.$indexSet$ax($.get$BaseTextureCache(), imageUrl, baseTexture);
          }
          texture = M.Texture$(baseTexture, null);
          J.$indexSet$ax($.get$TextureCache(), imageUrl, texture);
        }
        return texture;
      }, function(imageUrl) {
        return M.Texture_fromImage(imageUrl, null, null);
      }, null, function(imageUrl, crossorigin) {
        return M.Texture_fromImage(imageUrl, crossorigin, null);
      }, null, "call$3", "call$1", "call$2", "Texture_fromImage$closure", 2, 4, 217, 12, 12, 210, [], 73, [], 74, [], "fromImage"], Texture_fromFrame: [function(frameId) {
        var texture = J.$index$asx($.get$TextureCache(), frameId);
        if (texture == null)
          throw H.wrapException(P.Exception_Exception("The frameId \"" + H.S(frameId) + "\" does not exist in the texture cache"));
        return texture;
      }, "call$1", "Texture_fromFrame$closure", 2, 0, 218, 70, [], "fromFrame"], Texture_fromCanvas: [function(canvas, scaleMode) {
        return M.Texture$(M.BaseTexture_fromCanvas(canvas, scaleMode), null);
      }, function(canvas) {
        return M.Texture_fromCanvas(canvas, null);
      }, null, "call$2", "call$1", "Texture_fromCanvas$closure", 2, 2, 219, 12, 154, [], 74, [], "fromCanvas"], Texture_addTextureToCache: [function(texture, id) {
        J.$indexSet$ax($.get$TextureCache(), id, texture);
      }, "call$2", "Texture_addTextureToCache$closure", 4, 0, 220, 68, [], 221, [], "addTextureToCache"], Texture_removeTextureFromCache: [function(id) {
        var texture = J.$index$asx($.get$TextureCache(), id);
        J.remove$1$ax($.get$TextureCache(), id);
        J.remove$1$ax($.get$BaseTextureCache(), id);
        return texture;
      }, "call$1", "Texture_removeTextureFromCache$closure", 2, 0, 222, 221, [], "removeTextureFromCache"]}
  },
  "+Texture": [853],
  Texture_closure: {
    "^": "Closure:102;scope_0",
    call$1: [function(e) {
      this.scope_0.onBaseTextureLoaded$0();
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  TextureUvs: {
    "^": "Object;x0@-616,y0@-616,x1*-616,y1*-616,x2*-616,y2*-616,x3@-616,y3@-616",
    static: {TextureUvs$: [function() {
        return new M.TextureUvs(0, 0, 0, 0, 0, 0, 0, 0);
      }, null, null, 0, 0, 223, "new TextureUvs"]}
  },
  "+TextureUvs": [674],
  PixiEvent: {
    "^": "Object;type*-644,content*-12,loader@-12",
    static: {PixiEvent$: [function($content, loader, type) {
        return new M.PixiEvent(type, $content, loader);
      }, null, null, 0, 7, 225, 12, 12, 12, 137, [], 226, [], 227, [], "new PixiEvent"]}
  },
  "+PixiEvent": [674],
  EventTarget0: {
    "^": "Object;listeners@-848",
    addEventListener$2: [function(_, type, listener) {
      if (J.$index$asx(this.listeners, type) == null)
        J.$indexSet$ax(this.listeners, type, []);
      if (J.$eq(J.indexOf$1$asx(J.$index$asx(this.listeners, type), listener), -1))
        J.insert$2$ax(J.$index$asx(this.listeners, type), 0, listener);
    }, "call$2", "get$addEventListener", 4, 0, 959, 137, [], 960, [], "addEventListener"],
    dispatchEvent$1: [function(_, $event) {
      var t1, i, t2;
      t1 = J.getInterceptor$x($event);
      if (J.$index$asx(this.listeners, t1.get$type($event)) == null || J.$eq(J.get$length$asx(J.$index$asx(this.listeners, t1.get$type($event))), 0))
        return;
      for (i = J.$sub$n(J.get$length$asx(J.$index$asx(this.listeners, t1.get$type($event))), 1); t2 = J.getInterceptor$n(i), t2.$ge(i, 0); i = t2.$sub(i, 1))
        J.$index$asx(J.$index$asx(this.listeners, t1.get$type($event)), i).call$1($event);
    }, "call$1", "get$dispatchEvent", 2, 0, 705, 666, [], "dispatchEvent"],
    removeEventListener$2: [function(_, type, listener) {
      var index;
      if (J.$index$asx(this.listeners, type) == null)
        return;
      index = J.indexOf$1$asx(J.$index$asx(this.listeners, type), listener);
      if (!J.$eq(index, -1))
        J.removeAt$1$ax(J.$index$asx(this.listeners, type), index);
    }, "call$2", "get$removeEventListener", 4, 0, 959, 137, [], 960, [], "removeEventListener"],
    removeAllEventListeners$1: [function(type) {
      var a = J.$index$asx(this.listeners, type);
      if (a === true)
        J.set$length$asx(a, 0);
    }, "call$1", "get$removeAllEventListeners", 2, 0, 102, 137, [], "removeAllEventListeners"],
    static: {EventTarget$: [function() {
        return new M.EventTarget0(P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }, null, null, 0, 0, 228, "new EventTarget"]}
  },
  "+EventTarget": [674],
  PolyK: {
    "^": "Object;",
    static: {PolyK$_: [function() {
        return new M.PolyK();
      }, null, null, 0, 0, 54, "new PolyK$_"], PolyK_Triangulate: [function(p) {
        var t1, n, tgs, avl, i, al, sign, t2, t3, i0, i1, i10, t4, i2, ax, ay, bx, by, cx, cy, t5, earFound, t6, j, vi, t7, t8, v0x, v0y, v1x, v1y, v2x, v2y, dot00, dot01, dot02, dot11, dot12, t9, invDenom, u, v;
        t1 = J.getInterceptor$asx(p);
        n = J.$shr$n(t1.get$length(p), 1);
        if (n < 3)
          return [];
        tgs = [];
        avl = [];
        for (i = 0; i < n; ++i)
          avl.push(i);
        for (al = n, sign = true; al > 3;) {
          t2 = C.JSInt_methods.$mod(i, al);
          t3 = avl.length;
          if (t2 >= t3)
            return H.ioore(avl, t2);
          i0 = avl[t2];
          i1 = i + 1;
          t2 = C.JSInt_methods.$mod(i1, al);
          if (t2 >= t3)
            return H.ioore(avl, t2);
          i10 = avl[t2];
          t4 = C.JSInt_methods.$mod(i + 2, al);
          if (t4 >= t3)
            return H.ioore(avl, t4);
          i2 = avl[t4];
          t4 = 2 * i0;
          ax = t1.$index(p, t4);
          ay = t1.$index(p, t4 + 1);
          t4 = 2 * i10;
          bx = t1.$index(p, t4);
          by = t1.$index(p, t4 + 1);
          t4 = 2 * i2;
          cx = t1.$index(p, t4);
          cy = t1.$index(p, t4 + 1);
          t3 = J.getInterceptor$n(cx);
          t4 = J.getInterceptor$n(bx);
          t5 = J.getInterceptor$n(cy);
          if (J.$ge$n(J.$add$ns(J.$mul$ns(J.$sub$n(ay, by), t3.$sub(cx, bx)), J.$mul$ns(t4.$sub(bx, ax), t5.$sub(cy, by))), 0) === sign) {
            t6 = J.getInterceptor$n(by);
            j = 0;
            while (true) {
              if (!(j < al)) {
                earFound = true;
                break;
              }
              c$1: {
                if (j >= avl.length)
                  return H.ioore(avl, j);
                vi = avl[j];
                if (vi === i0 || vi === i10 || vi === i2)
                  break c$1;
                t7 = 2 * vi;
                t8 = t1.$index(p, t7);
                t7 = t1.$index(p, t7 + 1);
                v0x = t3.$sub(cx, ax);
                v0y = t5.$sub(cy, ay);
                v1x = t4.$sub(bx, ax);
                v1y = t6.$sub(by, ay);
                v2x = J.$sub$n(t8, ax);
                v2y = J.$sub$n(t7, ay);
                t7 = J.getInterceptor$ns(v0x);
                t8 = J.getInterceptor$ns(v0y);
                dot00 = J.$add$ns(t7.$mul(v0x, v0x), t8.$mul(v0y, v0y));
                dot01 = J.$add$ns(t7.$mul(v0x, v1x), t8.$mul(v0y, v1y));
                dot02 = J.$add$ns(t7.$mul(v0x, v2x), t8.$mul(v0y, v2y));
                t8 = J.getInterceptor$ns(v1x);
                t7 = J.getInterceptor$ns(v1y);
                dot11 = J.$add$ns(t8.$mul(v1x, v1x), t7.$mul(v1y, v1y));
                dot12 = J.$add$ns(t8.$mul(v1x, v2x), t7.$mul(v1y, v2y));
                t7 = J.getInterceptor$ns(dot00);
                t8 = J.getInterceptor$ns(dot01);
                t9 = J.$sub$n(t7.$mul(dot00, dot11), t8.$mul(dot01, dot01));
                if (typeof t9 !== "number")
                  return H.iae(t9);
                invDenom = 1 / t9;
                u = J.$mul$ns(J.$sub$n(J.$mul$ns(dot11, dot02), t8.$mul(dot01, dot12)), invDenom);
                v = J.$mul$ns(J.$sub$n(t7.$mul(dot00, dot12), t8.$mul(dot01, dot02)), invDenom);
                t7 = J.getInterceptor$n(u);
                if (t7.$ge(u, 0) && J.$ge$n(v, 0) && J.$lt$n(t7.$add(u, v), 1)) {
                  earFound = false;
                  break;
                }
              }
              ++j;
            }
          } else
            earFound = false;
          if (earFound) {
            C.JSArray_methods.addAll$1(tgs, [i0, i10, i2]);
            C.JSArray_methods.removeAt$1(avl, t2);
            --al;
            i = 0;
          } else if (i > 3 * al) {
            if (sign) {
              tgs = [];
              avl = [];
              for (i = 0; i < n; ++i)
                avl.push(i);
            } else {
              window;
              if (typeof console != "undefined")
                console.log("PIXI Warning: shape too complex to fill");
              return [];
            }
            al = n;
            sign = false;
            i = 0;
          } else
            i = i1;
        }
        t1 = avl.length;
        if (0 >= t1)
          return H.ioore(avl, 0);
        t2 = avl[0];
        if (1 >= t1)
          return H.ioore(avl, 1);
        t3 = avl[1];
        if (2 >= t1)
          return H.ioore(avl, 2);
        C.JSArray_methods.addAll$1(tgs, [t2, t3, avl[2]]);
        return tgs;
      }, "call$1", "PolyK_Triangulate$closure", 2, 0, 229, 230, [], "Triangulate"], PolyK__PointInTriangle: [function(px, py, ax, ay, bx, by, cx, cy) {
        var v0x, v0y, v1x, v1y, v2x, v2y, t1, t2, dot00, dot01, dot02, dot11, dot12, t3, invDenom, u, v;
        v0x = J.$sub$n(cx, ax);
        v0y = J.$sub$n(cy, ay);
        v1x = J.$sub$n(bx, ax);
        v1y = J.$sub$n(by, ay);
        v2x = J.$sub$n(px, ax);
        v2y = J.$sub$n(py, ay);
        t1 = J.getInterceptor$ns(v0x);
        t2 = J.getInterceptor$ns(v0y);
        dot00 = J.$add$ns(t1.$mul(v0x, v0x), t2.$mul(v0y, v0y));
        dot01 = J.$add$ns(t1.$mul(v0x, v1x), t2.$mul(v0y, v1y));
        dot02 = J.$add$ns(t1.$mul(v0x, v2x), t2.$mul(v0y, v2y));
        t2 = J.getInterceptor$ns(v1x);
        t1 = J.getInterceptor$ns(v1y);
        dot11 = J.$add$ns(t2.$mul(v1x, v1x), t1.$mul(v1y, v1y));
        dot12 = J.$add$ns(t2.$mul(v1x, v2x), t1.$mul(v1y, v2y));
        t1 = J.getInterceptor$ns(dot00);
        t2 = J.getInterceptor$ns(dot01);
        t3 = J.$sub$n(t1.$mul(dot00, dot11), t2.$mul(dot01, dot01));
        if (typeof t3 !== "number")
          return H.iae(t3);
        invDenom = 1 / t3;
        u = J.$mul$ns(J.$sub$n(J.$mul$ns(dot11, dot02), t2.$mul(dot01, dot12)), invDenom);
        v = J.$mul$ns(J.$sub$n(t1.$mul(dot00, dot12), t2.$mul(dot01, dot02)), invDenom);
        t1 = J.getInterceptor$n(u);
        return t1.$ge(u, 0) && J.$ge$n(v, 0) && J.$lt$n(t1.$add(u, v), 1);
      }, "call$8", "PolyK__PointInTriangle$closure", 16, 0, 231, 232, [], 233, [], 234, [], 235, [], 236, [], 237, [], 238, [], 239, [], "_PointInTriangle"], PolyK__convex: [function(ax, ay, bx, by, cx, cy, sign) {
        return J.$ge$n(J.$add$ns(J.$mul$ns(J.$sub$n(ay, by), J.$sub$n(cx, bx)), J.$mul$ns(J.$sub$n(bx, ax), J.$sub$n(cy, by))), 0) === sign;
      }, "call$7", "PolyK__convex$closure", 14, 0, 240, 234, [], 235, [], 236, [], 237, [], 238, [], 239, [], 241, [], "_convex"]}
  },
  "+PolyK": [674],
  "^": "TextureCacheIdGenerator@-614,FrameCache@-783,TextureCache@-783,BaseTextureCacheIdGenerator@-614,texturesToDestroy@-645,texturesToUpdate@-645,BaseTextureCache@-1809,glContexts@-1810,AttachmentType@-783,AnimCache@-783,EmptyRectangle@-659,Matrix2@-1090,IdentityMatrix@-658,requestAnimFrame@-0,_UID@-614,DEG_TO_RAD<-616,RAD_TO_DEG<-616,AUTO_PREVENT_DEFAULT<-617,INTERACTION_FREQUENCY<-614,VERSION0<-644,CANVAS_RENDERER<-614,WEBGL_RENDERER<-614,blendModesCanvas@-783,blendModesWebGL@-783,defaultRenderer@-837",
  InteractionHandler: {"^": ":1811;"},
  "+InteractionHandler": "",
  EventFunc: {"^": ":1812;"},
  "+EventFunc": "",
  Render: {"^": ":1813;"},
  "+Render": ""
}],
["Phaser", "package:play_phaser/phaser.dart", , R, {
  "^": "",
  Animation: {
    "^": "Object;game@-613,_Phaser$_parent@-961,name*-644,_frameData@-962,_frames@-709,delay@-616,loop*-617,loopCount@-614,killOnComplete@-617,isFinished@-617,isPlaying@-617,_isPaused@-617,_pauseStartTime@-616,_frameIndex@-614,_frameDiff@-616,_frameSkip@-616,currentFrame@-963,onStart@-964,onComplete*-964,onLoop@-964,onUpdate@-965,_timeLastFrame@-616,_timeNextFrame@-616",
    delay$1: function(arg0) {
      return this.delay.call$1(arg0);
    },
    loop$0: function($receiver) {
      return this.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return this.loop.call$3(arg0, arg1, arg2);
    },
    get$paused: [function(_) {
      return this._isPaused;
    }, null, null, 1, 0, 247, "paused"],
    paused$0: function($receiver) {
      return this.get$paused(this).call$0();
    },
    set$paused: [function(_, value) {
      this._isPaused = value;
      if (value === true)
        this._pauseStartTime = J.get$now$x(this.game.get$time());
      else if (this.isPlaying === true)
        this._timeNextFrame = J.$add$ns(J.get$now$x(this.game.get$time()), this.delay);
    }, null, null, 3, 0, 639, 138, [], "paused"],
    get$frameTotal: [function() {
      return J.get$length$asx(this._frames);
    }, null, null, 1, 0, 619, "frameTotal"],
    get$frame: [function() {
      var t1 = this.currentFrame;
      if (t1 != null)
        return J.get$index$x(t1);
      else
        return this._frameIndex;
    }, null, null, 1, 0, 412, "frame"],
    set$frame: [function(value) {
      var t1 = this._frameData.getFrame$1(J.$index$asx(this._frames, value));
      this.currentFrame = t1;
      if (t1 != null) {
        this._frameIndex = value;
        this._Phaser$_parent.setFrame$1(t1);
        t1 = this.onUpdate;
        if (t1 != null)
          t1.dispatch$1([this, this.currentFrame]);
      }
    }, null, null, 3, 0, 99, 138, [], "frame"],
    get$enableUpdate: [function() {
      return this.onUpdate != null;
    }, null, null, 1, 0, 247, "enableUpdate"],
    set$enableUpdate: [function(value) {
      var t1 = value === true;
      if (t1 && this.onUpdate == null)
        this.onUpdate = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      else if (!t1 && this.onUpdate != null) {
        this.onUpdate.dispose$0();
        this.onUpdate = null;
      }
    }, null, null, 3, 0, 639, 138, [], "enableUpdate"],
    get$speed: [function() {
      var t1 = this.delay;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(1000 / t1));
    }, null, null, 1, 0, 619, "speed"],
    set$speed: [function(value) {
      if (J.$ge$n(value, 1)) {
        if (typeof value !== "number")
          return H.iae(value);
        this.delay = 1000 / value;
      }
    }, null, null, 3, 0, 620, 138, [], "speed"],
    play$3: [function(_, frameRate, loop, killOnComplete) {
      if (typeof frameRate === "number")
        this.delay = 1000 / frameRate;
      if (typeof loop === "boolean")
        this.loop = loop;
      if (killOnComplete != null)
        this.killOnComplete = killOnComplete;
      this.isPlaying = true;
      this.isFinished = false;
      this.set$paused(0, false);
      this.loopCount = 0;
      this._timeLastFrame = J.get$now$x(this.game.get$time());
      this._timeNextFrame = J.$add$ns(J.get$now$x(this.game.get$time()), this.delay);
      this._frameIndex = 0;
      this.currentFrame = this._frameData.getFrame$1(J.$index$asx(this._frames, 0));
      if (this._Phaser$_parent.get$__tilePattern() != null) {
        this._Phaser$_parent.set$__tilePattern(null);
        this._Phaser$_parent.set$tilingTexture(null);
      }
      J.get$onAnimationStart$x(this._Phaser$_parent.get$events()).dispatch$1([this._Phaser$_parent, this]);
      this.onStart.dispatch$1([this._Phaser$_parent, this]);
      return this;
    }, function($receiver, frameRate) {
      return this.play$3($receiver, frameRate, null, false);
    }, "play$1", function($receiver) {
      return this.play$3($receiver, null, null, false);
    }, "play$0", function($receiver, frameRate, loop) {
      return this.play$3($receiver, frameRate, loop, false);
    }, "play$2", "call$3", "call$1", "call$0", "call$2", "get$play", 0, 6, 966, 12, 12, 19, 256, [], 257, [], 967, [], "play"],
    restart$0: [function() {
      this.isPlaying = true;
      this.isFinished = false;
      this.set$paused(0, false);
      this.loopCount = 0;
      this._timeLastFrame = J.get$now$x(this.game.get$time());
      this._timeNextFrame = J.$add$ns(J.get$now$x(this.game.get$time()), this.delay);
      this._frameIndex = 0;
      this.currentFrame = this._frameData.getFrame$1(J.$index$asx(this._frames, 0));
      this.onStart.dispatch$1([this._Phaser$_parent, this]);
    }, "call$0", "get$restart", 0, 0, 54, "restart"],
    setFrame$2: [function(frameId, useLocalFrameIndex) {
      var t1, frameIndex, i;
      t1 = J.getInterceptor(frameId);
      if (t1.$eq(frameId, C.Type_Ejg)) {
        frameIndex = null;
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this._frames);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$eq(J.get$name$x(this._frameData.getFrame$1(J.$index$asx(this._frames, i))), frameId))
            frameIndex = i;
          ++i;
        }
      } else if (t1.$eq(frameId, C.Type_xM7))
        if (useLocalFrameIndex === true)
          frameIndex = frameId;
        else {
          frameIndex = null;
          i = 0;
          while (true) {
            t1 = J.get$length$asx(this._frames);
            if (typeof t1 !== "number")
              return H.iae(t1);
            if (!(i < t1))
              break;
            if (J.$eq(J.$index$asx(this._frames, i), frameIndex))
              frameIndex = i;
            ++i;
          }
        }
      else
        frameIndex = null;
      if (frameIndex != null && !J.$eq(frameIndex, 0)) {
        this._frameIndex = J.$sub$n(frameIndex, 1);
        this._timeNextFrame = J.get$now$x(this.game.get$time());
        this.update$0();
      }
    }, function(frameId) {
      return this.setFrame$2(frameId, false);
    }, "setFrame$1", "call$2", "call$1", "get$setFrame", 2, 2, 968, 19, 70, [], 969, [], "setFrame"],
    stop$2: [function(_, resetFrame, dispatchComplete) {
      this.isPlaying = false;
      this.isFinished = true;
      this.set$paused(0, false);
      if (resetFrame != null)
        this.currentFrame = this._frameData.getFrame$1(J.$index$asx(this._frames, 0));
      if (dispatchComplete === true) {
        this._Phaser$_parent.get$events().get$onAnimationComplete().dispatch$1([this._Phaser$_parent, this]);
        this.onComplete.dispatch$1([this._Phaser$_parent, this]);
      }
    }, function($receiver) {
      return this.stop$2($receiver, false, false);
    }, "stop$0", function($receiver, resetFrame) {
      return this.stop$2($receiver, resetFrame, false);
    }, "stop$1", "call$2", "call$0", "call$1", "get$stop", 0, 4, 970, 19, 19, 971, [], 972, [], "stop"],
    _onPause$0: [function() {
      if (this.isPlaying === true)
        this._frameDiff = J.$sub$n(this._timeNextFrame, J.get$now$x(this.game.get$time()));
    }, "call$0", "get$_onPause", 0, 0, 54, "_onPause"],
    _onResume$0: [function() {
      if (this.isPlaying === true)
        this._timeNextFrame = J.$add$ns(J.get$now$x(this.game.get$time()), this._frameDiff);
    }, "call$0", "get$_onResume", 0, 0, 54, "_onResume"],
    update$0: [function() {
      var t1, t2, t3;
      if (this._isPaused === true)
        return false;
      if (J.$eq(this.isPlaying, true) && J.$ge$n(J.get$now$x(this.game.get$time()), this._timeNextFrame)) {
        this._frameSkip = 1;
        this._frameDiff = J.$sub$n(J.get$now$x(this.game.get$time()), this._timeNextFrame);
        this._timeLastFrame = J.get$now$x(this.game.get$time());
        if (J.$gt$n(this._frameDiff, this.delay)) {
          t1 = J.floor$0$n(J.$div$n(this._frameDiff, this.delay));
          this._frameSkip = t1;
          t2 = this._frameDiff;
          t3 = this.delay;
          if (typeof t3 !== "number")
            return H.iae(t3);
          this._frameDiff = J.$sub$n(t2, t1 * t3);
        }
        this._timeNextFrame = J.$add$ns(J.get$now$x(this.game.get$time()), J.$sub$n(this.delay, this._frameDiff));
        t1 = J.$add$ns(this._frameIndex, this._frameSkip);
        this._frameIndex = t1;
        if (J.$ge$n(t1, J.get$length$asx(this._frames)))
          if (this.loop === true) {
            t1 = J.$mod$n(this._frameIndex, J.get$length$asx(this._frames));
            this._frameIndex = t1;
            this.currentFrame = this._frameData.getFrame$1(J.$index$asx(this._frames, t1));
            this.loopCount = J.$add$ns(this.loopCount, 1);
            this._Phaser$_parent.get$events().get$onAnimationLoop().dispatch$1([this._Phaser$_parent, this]);
            this.onLoop.dispatch$1([this._Phaser$_parent, this]);
          } else {
            this.complete$0(0);
            return false;
          }
        t1 = this._frameData.getFrame$1(J.$index$asx(this._frames, this._frameIndex));
        this.currentFrame = t1;
        if (t1 != null) {
          this._Phaser$_parent.setFrame$1(t1);
          if (this._Phaser$_parent.get$__tilePattern() != null) {
            this._Phaser$_parent.set$__tilePattern(null);
            this._Phaser$_parent.set$tilingTexture(null);
          }
          t1 = this.onUpdate;
          if (t1 != null)
            t1.dispatch$1([this, this.currentFrame]);
        }
        return true;
      }
      return false;
    }, "call$0", "get$update", 0, 0, 54, "update"],
    next$1: [function(quantity) {
      var frame, t1, t2, t3;
      frame = J.$add$ns(this._frameIndex, quantity);
      t1 = J.getInterceptor$n(frame);
      if (t1.$ge(frame, J.get$length$asx(this._frames))) {
        t2 = this.loop;
        t3 = this._frames;
        frame = t2 === true ? t1.$mod(frame, J.get$length$asx(t3)) : J.$sub$n(J.get$length$asx(t3), 1);
      }
      if (!J.$eq(frame, this._frameIndex)) {
        this._frameIndex = frame;
        t1 = this._frameData.getFrame$1(J.$index$asx(this._frames, frame));
        this.currentFrame = t1;
        if (t1 != null) {
          this._Phaser$_parent.setFrame$1(t1);
          if (this._Phaser$_parent.get$__tilePattern() != null) {
            this._Phaser$_parent.set$__tilePattern(null);
            this._Phaser$_parent.set$tilingTexture(null);
          }
        }
        t1 = this.onUpdate;
        if (t1 != null)
          t1.dispatch$1([this, this.currentFrame]);
      }
    }, function() {
      return this.next$1(1);
    }, "next$0", "call$1", "call$0", "get$next", 0, 2, 973, 433, 974, [], "next"],
    previous$1: [function(quantity) {
      var frame, t1;
      frame = J.$sub$n(this._frameIndex, quantity);
      t1 = J.getInterceptor$n(frame);
      if (t1.$lt(frame, 0))
        frame = this.loop === true ? J.$add$ns(J.get$length$asx(this._frames), frame) : t1.$add(frame, 1);
      if (!J.$eq(frame, this._frameIndex)) {
        this._frameIndex = frame;
        t1 = this._frameData.getFrame$1(J.$index$asx(this._frames, frame));
        this.currentFrame = t1;
        if (t1 != null) {
          this._Phaser$_parent.setFrame$1(t1);
          if (this._Phaser$_parent.get$__tilePattern() != null) {
            this._Phaser$_parent.set$__tilePattern(null);
            this._Phaser$_parent.set$tilingTexture(null);
          }
        }
        t1 = this.onUpdate;
        if (t1 != null)
          t1.dispatch$1([this, this.currentFrame]);
      }
    }, function() {
      return this.previous$1(1);
    }, "previous$0", "call$1", "call$0", "get$previous", 0, 2, 973, 433, 974, [], "previous"],
    updateFrameData$1: [function(frameData) {
      var t1, t2;
      this._frameData = frameData;
      if (frameData != null) {
        t1 = this._frames;
        t2 = J.getInterceptor$asx(t1);
        t1 = frameData.getFrame$1(t2.$index(t1, J.$mod$n(this._frameIndex, t2.get$length(t1))));
      } else
        t1 = null;
      this.currentFrame = t1;
    }, "call$1", "get$updateFrameData", 2, 0, 975, 976, [], "updateFrameData"],
    destroy$0: [function() {
      J.remove$1$ax(J.get$onPause$x(this.game), this.get$_onPause());
      J.remove$1$ax(this.game.get$onResume(), this.get$_onResume());
      this.game = null;
      this._Phaser$_parent = null;
      this._frames = null;
      this._frameData = null;
      this.currentFrame = null;
      this.isPlaying = false;
      this.onStart.dispose$0();
      this.onLoop.dispose$0();
      this.onComplete.dispose$0();
      var t1 = this.onUpdate;
      if (t1 != null)
        t1.dispose$0();
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    complete$0: [function(_) {
      this.isPlaying = false;
      this.isFinished = true;
      this.set$paused(0, false);
      this._Phaser$_parent.get$events().get$onAnimationComplete().dispatch$1([this._Phaser$_parent, this]);
      this.onComplete.dispatch$1([this._Phaser$_parent, this]);
      if (this.killOnComplete === true)
        this._Phaser$_parent.kill$0();
    }, "call$0", "get$complete", 0, 0, 54, "complete"],
    Animation$7: function(game, _parent, $name, _frameData, _frames, frameRate, loop) {
      this.currentFrame = this._frameData.getFrame$1(J.$index$asx(this._frames, this._frameIndex));
      this.onStart = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onComplete = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onLoop = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      if (this._frames == null)
        this._frames = [];
      if (typeof frameRate === "number")
        this.delay = 1000 / frameRate;
      J.add$1$ax(J.get$onPause$x(this.game), this.get$_onPause());
      J.add$1$ax(this.game.get$onResume(), this.get$_onResume());
    },
    static: {Animation$0: [function(game, _parent, $name, _frameData, _frames, frameRate, loop) {
        var t1 = new R.Animation(game, _parent, $name, _frameData, _frames, null, loop, 0, false, false, false, false, 0, 0, 0, 1, null, null, null, null, null, null, null);
        t1.Animation$7(game, _parent, $name, _frameData, _frames, frameRate, loop);
        return t1;
      }, null, null, 8, 6, 250, 12, 251, 19, 252, [], 253, [], 83, [], 254, [], 255, [], 256, [], 257, [], "new Animation"], Animation_generateFrameNames: [function(prefix, start, $stop, suffix, zeroPad) {
        var output, t1, t2, i, t3;
        output = [];
        if (J.$lt$n(start, $stop))
          for (t1 = J.getInterceptor$ns(prefix), t2 = typeof zeroPad === "number", i = start; t3 = J.getInterceptor$n(i), t3.$le(i, $stop); i = t3.$add(i, 1))
            output.push(J.$add$ns(t1.$add(prefix, t2 ? J.padLeft$2$s(t3.toString$0(i), zeroPad, "0") : t3.toString$0(i)), suffix));
        else
          for (t1 = J.getInterceptor$ns(prefix), t2 = typeof zeroPad === "number", i = start; t3 = J.getInterceptor$n(i), t3.$ge(i, $stop); i = t3.$sub(i, 1))
            output.push(J.$add$ns(t1.$add(prefix, t2 ? J.padLeft$2$s(t3.toString$0(i), zeroPad, "0") : t3.toString$0(i)), suffix));
        return output;
      }, function(prefix) {
        return R.Animation_generateFrameNames(prefix, null, null, null, null);
      }, null, function(prefix, start) {
        return R.Animation_generateFrameNames(prefix, start, null, null, null);
      }, null, function() {
        return R.Animation_generateFrameNames("", null, null, null, null);
      }, null, function(prefix, start, stop) {
        return R.Animation_generateFrameNames(prefix, start, stop, null, null);
      }, null, function(prefix, start, stop, suffix) {
        return R.Animation_generateFrameNames(prefix, start, stop, suffix, null);
      }, null, "call$5", "call$1", "call$2", "call$0", "call$3", "call$4", "Animation_generateFrameNames$closure", 0, 10, 258, 259, 12, 12, 12, 12, 260, [], 261, [], 262, [], 263, [], 264, [], "generateFrameNames"]}
  },
  "+Animation": [674],
  AnimationManager: {
    "^": "Object;sprite@-977,game@-613,currentFrame@-963,currentAnim@-978,updateIfVisible@-617,isLoaded@-617,_frameData@-962,_anims@-979,_outputFrames@-645,_frameIndex@-614,__tilePattern@-617,tilingTexture@-617",
    sprite$3: function(arg0, arg1, arg2) {
      return this.sprite.call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.sprite.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.sprite.call$4(arg0, arg1, arg2, arg3);
    },
    get$frameData: [function() {
      return this._frameData;
    }, null, null, 1, 0, 980, "frameData"],
    get$frameTotal: [function() {
      return J.get$total$x(this._frameData);
    }, null, null, 1, 0, 412, "frameTotal"],
    get$paused: [function(_) {
      return this.currentAnim.get$_isPaused();
    }, null, null, 1, 0, 247, "paused"],
    paused$0: function($receiver) {
      return this.get$paused(this).call$0();
    },
    set$paused: [function(_, value) {
      this.currentAnim.set$_isPaused(value);
    }, null, null, 3, 0, 639, 138, [], "paused"],
    get$frame: [function() {
      if (this.currentFrame != null)
        return this._frameIndex;
      return -1;
    }, null, null, 1, 0, 412, "frame"],
    set$frame: [function(value) {
      var t1;
      if (typeof value === "number" && this._frameData.getFrame$1(value) != null) {
        t1 = this._frameData.getFrame$1(value);
        this.currentFrame = t1;
        if (t1 != null) {
          this._frameIndex = value;
          this.sprite.setFrame$1(t1);
          if (this.sprite.get$__tilePattern() != null) {
            this.__tilePattern = false;
            this.tilingTexture = false;
          }
        }
      }
    }, null, null, 3, 0, 99, 138, [], "frame"],
    get$frameName: [function() {
      var t1 = this.currentFrame;
      if (t1 != null)
        return J.get$name$x(t1);
      else
        return;
    }, null, null, 1, 0, 810, "frameName"],
    set$frameName: [function(value) {
      var t1;
      if (typeof value === "string" && this._frameData.getFrameByName$1(value) != null) {
        t1 = this._frameData.getFrameByName$1(value);
        this.currentFrame = t1;
        if (t1 != null) {
          this._frameIndex = J.get$index$x(t1);
          this.sprite.setTexture$1(J.$index$asx($.get$TextureCache(), this.currentFrame.get$uuid()));
          if (this.sprite.get$__tilePattern() != null) {
            this.__tilePattern = false;
            this.tilingTexture = false;
          }
        }
      } else {
        window;
        t1 = C.JSString_methods.$add("Cannot set frameName: ", value);
        if (typeof console != "undefined")
          console.warn(t1);
      }
    }, null, null, 3, 0, 91, 138, [], "frameName"],
    get$name: [function(_) {
      var t1 = this.currentAnim;
      if (t1 != null)
        return J.get$name$x(t1);
      return;
    }, null, null, 1, 0, 810, "name"],
    loadFrameData$2: [function(frameData, frame) {
      var t1, anim;
      if (frameData == null)
        return false;
      if (this.isLoaded === true)
        for (t1 = J.get$iterator$ax(J.get$keys$x(this._anims)); t1.moveNext$0();) {
          anim = t1.get$current();
          J.$index$asx(this._anims, anim).updateFrameData$1(frameData);
        }
      this._frameData = frameData;
      if (frame == null)
        this.set$frame(0);
      else if (typeof frame === "string")
        this.set$frameName(frame);
      else
        this.set$frame(frame);
      this.isLoaded = true;
      return true;
    }, function(frameData) {
      return this.loadFrameData$2(frameData, 0);
    }, "loadFrameData$1", function() {
      return this.loadFrameData$2(null, 0);
    }, "loadFrameData$0", "call$2", "call$1", "call$0", "get$loadFrameData", 0, 4, 981, 12, 49, 976, [], 216, [], "loadFrameData"],
    copyFrameData$2: [function(frameData, frame) {
      var t1, anim;
      this._frameData = J.clone$0$x(frameData);
      if (this.isLoaded === true)
        for (t1 = J.get$iterator$ax(this._anims); t1.moveNext$0();) {
          anim = t1.get$current();
          J.$index$asx(this._anims, anim).updateFrameData$1(this._frameData);
        }
      if (frame == null)
        this.set$frame(0);
      else if (typeof frame === "string")
        this.set$frameName(frame);
      else
        this.set$frame(frame);
      this.isLoaded = true;
      return true;
    }, "call$2", "get$copyFrameData", 4, 0, 982, 976, [], 216, [], "copyFrameData"],
    add$5: [function(_, $name, $frames, frameRate, loop, useNumericIndex) {
      var t1, t2, t3, t4, t5, t6;
      if ($frames == null) {
        $frames = [];
        useNumericIndex = true;
      }
      if (useNumericIndex == null) {
        t1 = J.$index$asx($frames, 0);
        useNumericIndex = typeof t1 === "number" && Math.floor(t1) === t1 && true;
      }
      if (J.get$onAnimationStart$x(this.sprite.get$events()) == null) {
        J.set$onAnimationStart$x(this.sprite.get$events(), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
        this.sprite.get$events().set$onAnimationComplete(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
        this.sprite.get$events().set$onAnimationLoop(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
      }
      t1 = [];
      this._outputFrames = t1;
      this._frameData.getFrameIndexes$3($frames, useNumericIndex, t1);
      t1 = this._anims;
      t2 = this.game;
      t3 = this.sprite;
      t4 = this._frameData;
      t5 = this._outputFrames;
      t6 = new R.Animation(t2, t3, $name, t4, t5, null, loop, 0, false, false, false, false, 0, 0, 0, 1, null, null, null, null, null, null, null);
      t6.Animation$7(t2, t3, $name, t4, t5, frameRate, loop);
      J.$indexSet$ax(t1, $name, t6);
      t6 = J.$index$asx(this._anims, $name);
      this.currentAnim = t6;
      this.currentFrame = t6.get$currentFrame();
      if (this.sprite.get$__tilePattern() != null) {
        this.__tilePattern = false;
        this.tilingTexture = false;
      }
      return J.$index$asx(this._anims, $name);
    }, function($receiver, name, frames) {
      return this.add$5($receiver, name, frames, 60, true, null);
    }, "add$2", function($receiver, name) {
      return this.add$5($receiver, name, null, 60, true, null);
    }, "add$1", function($receiver, name, frames, frameRate, loop) {
      return this.add$5($receiver, name, frames, frameRate, loop, null);
    }, "add$4", function($receiver, name, frames, frameRate) {
      return this.add$5($receiver, name, frames, frameRate, true, null);
    }, "add$3", "call$5", "call$2", "call$1", "call$4", "call$3", "get$add", 2, 8, 983, 12, 251, 78, 12, 83, [], 65, [], 256, [], 257, [], 984, [], "add"],
    validateFrames$2: [function($frames, useNumericIndex) {
      var t1, t2, i, t3;
      t1 = J.getInterceptor$asx($frames);
      t2 = J.getInterceptor(useNumericIndex);
      i = 0;
      while (true) {
        t3 = t1.get$length($frames);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        if (t2.$eq(useNumericIndex, true)) {
          if (J.$gt$n(t1.$index($frames, i), J.get$total$x(this._frameData)))
            return false;
        } else if (!this._frameData.checkFrameName$1(t1.$index($frames, i)))
          return false;
        ++i;
      }
      return true;
    }, function(frames) {
      return this.validateFrames$2(frames, true);
    }, "validateFrames$1", "call$2", "call$1", "get$validateFrames", 2, 2, 985, 78, 65, [], 984, [], "validateFrames"],
    play$4: [function(_, $name, frameRate, loop, killOnComplete) {
      var t1;
      if (J.$index$asx(this._anims, $name) != null)
        if (J.$eq(this.currentAnim, J.$index$asx(this._anims, $name))) {
          if (J.$eq(this.currentAnim.get$isPlaying(), false)) {
            J.set$paused$x(this.currentAnim, false);
            return J.play$3$x(this.currentAnim, frameRate, loop, killOnComplete);
          }
        } else {
          t1 = this.currentAnim;
          if (t1 != null && t1.get$isPlaying() === true)
            J.stop$0$x(this.currentAnim);
          t1 = J.$index$asx(this._anims, $name);
          this.currentAnim = t1;
          J.set$paused$x(t1, false);
          return J.play$3$x(this.currentAnim, frameRate, loop, killOnComplete);
        }
    }, function($receiver, name) {
      return this.play$4($receiver, name, null, null, false);
    }, "play$1", function($receiver, name, frameRate, loop) {
      return this.play$4($receiver, name, frameRate, loop, false);
    }, "play$3", function($receiver, name, frameRate) {
      return this.play$4($receiver, name, frameRate, null, false);
    }, "play$2", "call$4", "call$1", "call$3", "call$2", "get$play", 2, 6, 986, 12, 12, 19, 83, [], 256, [], 257, [], 967, [], "play"],
    stop$2: [function(_, $name, resetFrame) {
      var t1;
      if (typeof $name === "string") {
        if (J.$index$asx(this._anims, $name) != null) {
          t1 = J.$index$asx(this._anims, $name);
          this.currentAnim = t1;
          J.stop$1$x(t1, resetFrame);
        }
      } else {
        t1 = this.currentAnim;
        if (t1 != null)
          J.stop$1$x(t1, resetFrame);
      }
    }, function($receiver) {
      return this.stop$2($receiver, null, false);
    }, "stop$0", function($receiver, name) {
      return this.stop$2($receiver, name, false);
    }, "stop$1", "call$2", "call$0", "call$1", "get$stop", 0, 4, 987, 12, 19, 83, [], 971, [], "stop"],
    update$0: [function() {
      if (this.updateIfVisible === true && this.sprite.get$visible() !== true)
        return false;
      var t1 = this.currentAnim;
      if (t1 != null && J.$eq(t1.update$0(), true)) {
        this.currentFrame = this.currentAnim.get$currentFrame();
        return true;
      }
      return false;
    }, "call$0", "get$update", 0, 0, 247, "update"],
    next$1: [function(quantity) {
      var t1 = this.currentAnim;
      if (t1 != null) {
        t1.next$1(quantity);
        this.currentFrame = this.currentAnim.get$currentFrame();
      }
    }, "call$1", "get$next", 2, 0, 99, 974, [], "next"],
    previous$1: [function(quantity) {
      var t1 = this.currentAnim;
      if (t1 != null) {
        t1.previous$1(quantity);
        this.currentFrame = this.currentAnim.get$currentFrame();
      }
    }, "call$1", "get$previous", 2, 0, 99, 974, [], "previous"],
    getAnimation$1: [function($name) {
      if (typeof $name === "string")
        if (J.$index$asx(this._anims, $name) != null)
          return J.$index$asx(this._anims, $name);
      return;
    }, "call$1", "get$getAnimation", 2, 0, 988, 83, [], "getAnimation"],
    refreshFrame$0: [function() {
      this.sprite.setTexture$1(J.$index$asx($.get$TextureCache(), this.currentFrame.get$uuid()));
      if (this.sprite.get$__tilePattern() != null) {
        this.__tilePattern = false;
        this.tilingTexture = false;
      }
    }, "call$0", "get$refreshFrame", 0, 0, 54, "refreshFrame"],
    destroy$0: [function() {
      var t1, anim;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._anims)); t1.moveNext$0();) {
        anim = t1.get$current();
        J.$index$asx(this._anims, anim).destroy$0();
      }
      this._anims = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._frameData = null;
      this._frameIndex = 0;
      this.currentAnim = null;
      this.currentFrame = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    static: {AnimationManager$: [function(sprite) {
        var t1 = new R.AnimationManager(sprite, null, null, null, true, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), [], 0, null, null);
        t1.game = sprite.get$game();
        return t1;
      }, null, null, 2, 0, 265, 151, [], "new AnimationManager"]}
  },
  "+AnimationManager": [674],
  AnimationParser: {
    "^": "Object;",
    static: {AnimationParser$: [function() {
        return new R.AnimationParser();
      }, null, null, 0, 0, 266, "new AnimationParser"], AnimationParser_spriteSheet: [function(game, key, frameWidth, frameHeight, frameMax, margin, spacing) {
        var img, t1, width, height, t2, total, data, y, x, i, uuid, dx, dy, t3;
        img = game.get$cache().getImage$1(key);
        if (img == null)
          return;
        t1 = J.getInterceptor$x(img);
        width = t1.get$width(img);
        height = t1.get$height(img);
        if (J.$le$n(frameWidth, 0))
          frameWidth = C.JSNumber_methods.floor$0(J.$div$n(J.$negate$n(width), P.min(-1, frameWidth)));
        if (J.$le$n(frameHeight, 0))
          frameHeight = C.JSNumber_methods.floor$0(J.$div$n(J.$negate$n(height), P.min(-1, frameHeight)));
        t1 = J.getInterceptor$n(width);
        t2 = J.getInterceptor$n(height);
        total = J.floor$0$n(J.$div$n(t1.$sub(width, margin), J.$add$ns(frameWidth, spacing))) * J.floor$0$n(J.$div$n(t2.$sub(height, margin), J.$add$ns(frameHeight, spacing)));
        if (!J.$eq(frameMax, -1))
          total = frameMax;
        if (t1.$eq(width, 0) || t2.$eq(height, 0) || t1.$lt(width, frameWidth) || t2.$lt(height, frameHeight) || J.$eq(total, 0)) {
          window;
          if (typeof console != "undefined")
            console.warn("Phaser.AnimationParser.spriteSheet: width/height zero or width/height < given frameWidth/frameHeight");
          return;
        }
        data = new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        if (typeof total !== "number")
          return H.iae(total);
        y = margin;
        x = y;
        i = 0;
        for (; i < total; ++i) {
          uuid = game.get$rnd().uuid$0();
          t1 = new R.Frame(i, x, y, frameWidth, frameHeight, "", uuid, null, null, null, false, "cw", false, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          t1.centerX = J.floor$0$n(J.$div$n(frameWidth, 2));
          t1.centerY = J.floor$0$n(J.$div$n(frameHeight, 2));
          t1.sourceSizeW = frameWidth;
          t1.sourceSizeH = frameHeight;
          if (typeof frameWidth !== "number")
            return H.iae(frameWidth);
          dx = 0 - frameWidth;
          if (typeof frameHeight !== "number")
            return H.iae(frameHeight);
          dy = 0 - frameHeight;
          t1.distance = Math.sqrt(dx * dx + dy * dy);
          data.addFrame$1(t1);
          t1 = $.get$TextureCache();
          t2 = J.$index$asx($.get$BaseTextureCache(), key);
          t3 = new M.Rectangle0(0, 0, 0, 0);
          t3.x = x;
          t3.y = y;
          t3.width = frameWidth;
          t3.height = frameHeight;
          J.$indexSet$ax(t1, uuid, M.Texture$(t2, t3));
          if (typeof spacing !== "number")
            return H.iae(spacing);
          x = J.$add$ns(x, frameWidth + spacing);
          if (J.$gt$n(J.$add$ns(x, frameWidth), width)) {
            y = J.$add$ns(y, frameHeight + spacing);
            x = margin;
          }
        }
        return data;
      }, function(game, key, frameWidth, frameHeight) {
        return R.AnimationParser_spriteSheet(game, key, frameWidth, frameHeight, -1, 0, 0);
      }, null, function(game, key, frameWidth, frameHeight, frameMax, margin) {
        return R.AnimationParser_spriteSheet(game, key, frameWidth, frameHeight, frameMax, margin, 0);
      }, null, function(game, key, frameWidth, frameHeight, frameMax) {
        return R.AnimationParser_spriteSheet(game, key, frameWidth, frameHeight, frameMax, 0, 0);
      }, null, "call$7", "call$4", "call$6", "call$5", "AnimationParser_spriteSheet$closure", 8, 6, 267, 268, 49, 49, 252, [], 269, [], 270, [], 271, [], 272, [], 273, [], 274, [], "spriteSheet"], AnimationParser_JSONData: [function(game, json, cacheKey) {
        var t1, data, $frames, i, t2, uuid, t3, t4, t5, dx, dy, newFrame;
        t1 = J.getInterceptor$asx(json);
        if (t1.$index(json, "frames") == null) {
          window;
          if (typeof console != "undefined")
            console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array");
          window;
          if (typeof console != "undefined")
            console.log(json);
          return;
        }
        data = new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        $frames = t1.$index(json, "frames");
        t1 = J.getInterceptor$asx($frames);
        i = 0;
        while (true) {
          t2 = t1.get$length($frames);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          uuid = game.get$rnd().uuid$0();
          t2 = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "x");
          t3 = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "y");
          t4 = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "w");
          t5 = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "h");
          t3 = new R.Frame(i, t2, t3, t4, t5, J.$index$asx(t1.$index($frames, i), "filename"), uuid, null, null, null, false, "cw", false, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          t3.centerX = J.floor$0$n(J.$div$n(t4, 2));
          t3.centerY = J.floor$0$n(J.$div$n(t5, 2));
          t3.sourceSizeW = t4;
          t3.sourceSizeH = t5;
          if (typeof t4 !== "number")
            return H.iae(t4);
          dx = 0 - t4;
          if (typeof t5 !== "number")
            return H.iae(t5);
          dy = 0 - t5;
          t3.distance = Math.sqrt(dx * dx + dy * dy);
          newFrame = data.addFrame$1(t3);
          t2 = $.get$TextureCache();
          t3 = J.$index$asx($.get$BaseTextureCache(), cacheKey);
          t4 = new M.Rectangle0(0, 0, 0, 0);
          t4.x = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "x");
          t4.y = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "y");
          t4.width = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "w");
          t4.height = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "h");
          J.$indexSet$ax(t2, uuid, M.Texture$(t3, t4));
          if (J.$index$asx(t1.$index($frames, i), "trimmed") === true)
            newFrame.setTrim$7(J.$index$asx(t1.$index($frames, i), "trimmed"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "sourceSize"), "w"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "sourceSize"), "h"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "spriteSourceSize"), "x"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "spriteSourceSize"), "y"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "spriteSourceSize"), "w"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "spriteSourceSize"), "h"));
          ++i;
        }
        return data;
      }, "call$3", "AnimationParser_JSONData$closure", 6, 0, 275, 252, [], 276, [], 277, [], "JSONData"], AnimationParser_JSONDataHash: [function(game, json, cacheKey) {
        var t1, data, $frames, t2, i, key, uuid, t3, t4, t5, t6, dx, dy, newFrame;
        t1 = J.getInterceptor$asx(json);
        if (t1.$index(json, "frames") == null) {
          window;
          if (typeof console != "undefined")
            console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object");
          window;
          if (typeof console != "undefined")
            console.log(json);
          return;
        }
        data = new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        $frames = t1.$index(json, "frames");
        for (t1 = J.getInterceptor$x($frames), t2 = J.get$iterator$ax(t1.get$keys($frames)), i = 0; t2.moveNext$0();) {
          key = t2.get$current();
          uuid = game.get$rnd().uuid$0();
          t3 = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "x");
          t4 = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "y");
          t5 = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "w");
          t6 = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "h");
          t4 = new R.Frame(i, t3, t4, t5, t6, key, uuid, null, null, null, false, "cw", false, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          t4.centerX = J.floor$0$n(J.$div$n(t5, 2));
          t4.centerY = J.floor$0$n(J.$div$n(t6, 2));
          t4.sourceSizeW = t5;
          t4.sourceSizeH = t6;
          if (typeof t5 !== "number")
            return H.iae(t5);
          dx = 0 - t5;
          if (typeof t6 !== "number")
            return H.iae(t6);
          dy = 0 - t6;
          t4.distance = Math.sqrt(dx * dx + dy * dy);
          newFrame = data.addFrame$1(t4);
          t3 = $.get$TextureCache();
          t4 = J.$index$asx($.get$BaseTextureCache(), cacheKey);
          t5 = new M.Rectangle0(0, 0, 0, 0);
          t5.x = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "x");
          t5.y = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "y");
          t5.width = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "w");
          t5.height = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "h");
          J.$indexSet$ax(t3, uuid, M.Texture$(t4, t5));
          if (J.$index$asx(t1.$index($frames, key), "trimmed") === true)
            newFrame.setTrim$7(J.$index$asx(t1.$index($frames, key), "trimmed"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "sourceSize"), "w"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "sourceSize"), "h"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "spriteSourceSize"), "x"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "spriteSourceSize"), "y"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "spriteSourceSize"), "w"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "spriteSourceSize"), "h"));
          ++i;
        }
        return data;
      }, "call$3", "AnimationParser_JSONDataHash$closure", 6, 0, 275, 252, [], 276, [], 277, [], "JSONDataHash"], AnimationParser_XMLData: [function(game, xml, cacheKey) {
        var t1, data, $frames, frameWidth, frameHeight, i, uuid, $name, x, y, width, height, frameX, frameY, dx, dy, newFrame, t2, t3;
        t1 = J.getInterceptor$x(xml);
        t1.getElementsByTagName$1(xml, "TextureAtlas");
        data = new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        $frames = t1.getElementsByTagName$1(xml, "SubTexture");
        for (frameWidth = null, frameHeight = null, i = 0; i < $frames.length; ++i) {
          uuid = game.get$rnd().uuid$0();
          if (i >= $frames.length)
            return H.ioore($frames, i);
          t1 = J.get$attributes$x($frames[i])._element;
          $name = t1.getAttribute("name");
          x = H.Primitives_parseInt(t1.getAttribute("x"), null, null);
          y = H.Primitives_parseInt(t1.getAttribute("y"), null, null);
          width = H.Primitives_parseInt(t1.getAttribute("width"), null, null);
          height = H.Primitives_parseInt(t1.getAttribute("height"), null, null);
          if (t1.hasAttribute("frameX") === true) {
            frameX = J.abs$0$n(H.Primitives_parseInt(t1.getAttribute("frameX"), null, null));
            frameY = J.abs$0$n(H.Primitives_parseInt(t1.getAttribute("frameY"), null, null));
            frameWidth = J.abs$0$n(H.Primitives_parseInt(t1.getAttribute("frameWidth"), null, null));
            frameHeight = J.abs$0$n(H.Primitives_parseInt(t1.getAttribute("frameHeight"), null, null));
          } else {
            frameX = null;
            frameY = null;
          }
          t1 = new R.Frame(i, x, y, width, height, $name, uuid, null, null, null, false, "cw", false, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          t1.centerX = J.floor$0$n(J.$div$n(width, 2));
          t1.centerY = J.floor$0$n(J.$div$n(height, 2));
          t1.sourceSizeW = width;
          t1.sourceSizeH = height;
          if (typeof width !== "number")
            return H.iae(width);
          dx = 0 - width;
          if (typeof height !== "number")
            return H.iae(height);
          dy = 0 - height;
          t1.distance = Math.sqrt(dx * dx + dy * dy);
          newFrame = data.addFrame$1(t1);
          t1 = $.get$TextureCache();
          t2 = J.$index$asx($.get$BaseTextureCache(), cacheKey);
          t3 = new M.Rectangle0(0, 0, 0, 0);
          t3.x = x;
          t3.y = y;
          t3.width = width;
          t3.height = height;
          J.$indexSet$ax(t1, uuid, M.Texture$(t2, t3));
          if (frameX != null || frameY != null) {
            newFrame.setTrim$7(true, width, height, frameX, frameY, frameWidth, frameHeight);
            J.set$trim$s(J.$index$asx($.get$TextureCache(), uuid), new R.Rectangle1(frameX, frameY, width, height, 0, 0, 0, 0));
          }
        }
        return data;
      }, "call$3", "AnimationParser_XMLData$closure", 6, 0, 278, 252, [], 279, [], 277, [], "XMLData"]}
  },
  "+AnimationParser": [674],
  Frame: {
    "^": "Rectangle1;index*-614,x:Phaser$Frame$x*-616,y:Phaser$Frame$y*-616,width:Phaser$Frame$width*-616,height:Phaser$Frame$height*-616,name*-644,uuid@-644,centerX@-616,centerY@-616,distance@-616,rotate*-617,rotationDirection@-644,trimmed@-617,sourceSizeW@-616,sourceSizeH@-616,spriteSourceSizeX@-616,spriteSourceSizeY@-616,spriteSourceSizeW@-616,spriteSourceSizeH@-616,Phaser$Rectangle1$x-616,Phaser$Rectangle1$y-616,Phaser$Rectangle1$width-616,Phaser$Rectangle1$height-616,x-616,y-616,width-616,height-616",
    uuid$0: function() {
      return this.uuid.call$0();
    },
    distance$2: function(arg0, arg1) {
      return this.distance.call$2(arg0, arg1);
    },
    rotate$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.rotate.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    setTrim$7: [function(trimmed, actualWidth, actualHeight, destX, destY, destWidth, destHeight) {
      this.trimmed = trimmed;
      if (trimmed === true) {
        this.sourceSizeW = actualWidth;
        this.sourceSizeH = actualHeight;
        this.centerX = J.floor$0$n(J.$div$n(actualWidth, 2));
        this.centerY = J.floor$0$n(J.$div$n(actualHeight, 2));
        this.spriteSourceSizeX = destX;
        this.spriteSourceSizeY = destY;
        this.spriteSourceSizeW = destWidth;
        this.spriteSourceSizeH = destHeight;
      }
    }, "call$7", "get$setTrim", 14, 0, 989, 990, [], 991, [], 992, [], 993, [], 994, [], 995, [], 996, [], "setTrim"],
    getRect$1: [function(out) {
      var t1, t2, t3, t4;
      t1 = this.Phaser$Frame$x;
      t2 = this.Phaser$Frame$y;
      t3 = this.Phaser$Frame$width;
      t4 = this.Phaser$Frame$height;
      if (out == null)
        out = new R.Rectangle1(t1, t2, t3, t4, 0, 0, 0, 0);
      else
        out.setTo$4(t1, t2, t3, t4);
      return out;
    }, function() {
      return this.getRect$1(null);
    }, "getRect$0", "call$1", "call$0", "get$getRect", 0, 2, 997, 12, 361, [], "getRect"],
    clone$1: [function(_, output) {
      var t1;
      if (output != null) {
        t1 = J.getInterceptor$x(output);
        t1.set$index(output, this.index);
        t1.set$x(output, this.Phaser$Frame$x);
        t1.set$y(output, this.Phaser$Frame$y);
        t1.set$width(output, this.Phaser$Frame$width);
        t1.set$height(output, this.Phaser$Frame$height);
        t1.set$name(output, this.name);
        output.set$uuid(this.uuid);
        return output;
      }
      return R.Frame$(this.index, this.Phaser$Frame$x, this.Phaser$Frame$y, this.Phaser$Frame$width, this.Phaser$Frame$height, this.name, this.uuid);
    }, function($receiver) {
      return this.clone$1($receiver, null);
    }, "clone$0", "call$1", "call$0", "get$clone", 0, 2, 998, 12, 999, [], "clone"],
    Frame$7: function(index, x, y, width, height, $name, uuid) {
      var t1, t2;
      this.centerX = J.floor$0$n(J.$div$n(this.Phaser$Frame$width, 2));
      this.centerY = J.floor$0$n(J.$div$n(this.Phaser$Frame$height, 2));
      t1 = this.Phaser$Frame$width;
      this.sourceSizeW = t1;
      t2 = this.Phaser$Frame$height;
      this.sourceSizeH = t2;
      this.distance = R.Math_distance(0, 0, t1, t2);
    },
    static: {Frame$: [function(index, x, y, width, height, $name, uuid) {
        var t1 = new R.Frame(index, x, y, width, height, $name, uuid, null, null, null, false, "cw", false, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        t1.Frame$7(index, x, y, width, height, $name, uuid);
        return t1;
      }, null, null, 14, 0, 280, 281, [], 9, [], 10, [], 31, [], 52, [], 83, [], 282, [], "new Frame"]}
  },
  "+Frame": [649],
  FrameData: {
    "^": "Object;_frames@-1000,_frameNames@-946",
    get$total: [function(_) {
      return J.get$length$asx(this._frames);
    }, null, null, 1, 0, 412, "total"],
    addFrame$1: [function(frame) {
      var t1 = J.getInterceptor$x(frame);
      t1.set$index(frame, J.get$length$asx(this._frames));
      J.add$1$ax(this._frames, frame);
      if (!J.$eq(t1.get$name(frame), ""))
        J.$indexSet$ax(this._frameNames, t1.get$name(frame), t1.get$index(frame));
      return frame;
    }, "call$1", "get$addFrame", 2, 0, 1001, 216, [], "addFrame"],
    getFrame$1: [function(index) {
      if (J.$gt$n(index, J.get$length$asx(this._frames)))
        index = 0;
      return J.$index$asx(this._frames, index);
    }, "call$1", "get$getFrame", 2, 0, 1002, 281, [], "getFrame"],
    getFrameByName$1: [function($name) {
      var t1 = J.$index$asx(this._frameNames, $name);
      if (typeof t1 === "number")
        return J.$index$asx(this._frames, J.$index$asx(this._frameNames, $name));
      return;
    }, "call$1", "get$getFrameByName", 2, 0, 1003, 83, [], "getFrameByName"],
    checkFrameName$1: [function($name) {
      if (J.$index$asx(this._frameNames, $name) == null)
        return false;
      return true;
    }, "call$1", "get$checkFrameName", 2, 0, 1004, 83, [], "checkFrameName"],
    clone$0: [function(_) {
      var output, i, t1;
      output = new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._frames);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.add$1$ax(output._frames, J.clone$0$x(J.$index$asx(this._frames, i)));
        ++i;
      }
      J.forEach$1$ax(this._frameNames, new R.FrameData_clone_closure(output));
      return output;
    }, "call$0", "get$clone", 0, 0, 980, "clone"],
    getFrameRange$3: [function(start, end, output) {
      var t1, i, t2;
      if (output == null)
        output = [];
      for (t1 = J.getInterceptor$ax(output), i = start; t2 = J.getInterceptor$n(i), t2.$le(i, end); i = t2.$add(i, 1))
        t1.add$1(output, J.$index$asx(this._frames, i));
      return output;
    }, function(start, end) {
      return this.getFrameRange$3(start, end, null);
    }, "getFrameRange$2", "call$3", "call$2", "get$getFrameRange", 4, 2, 1005, 12, 261, [], 694, [], 999, [], "getFrameRange"],
    getFrames$3: [function($frames, useNumericIndex, output) {
      var t1, i, t2, len, t3, index;
      if (useNumericIndex == null)
        useNumericIndex = true;
      if (output == null)
        output = [];
      if ($frames == null || J.$eq(J.get$length$asx($frames), 0)) {
        t1 = J.getInterceptor$ax(output);
        i = 0;
        while (true) {
          t2 = J.get$length$asx(this._frames);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t1.add$1(output, J.$index$asx(this._frames, i));
          ++i;
        }
      } else {
        t1 = J.getInterceptor$asx($frames);
        len = t1.get$length($frames);
        if (typeof len !== "number")
          return H.iae(len);
        t2 = J.getInterceptor$ax(output);
        t3 = useNumericIndex === true;
        i = 0;
        for (; i < len; ++i)
          if (t3) {
            index = t1.$index($frames, i);
            if (J.$gt$n(index, J.get$length$asx(this._frames)))
              index = 0;
            t2.add$1(output, J.$index$asx(this._frames, index));
          } else
            t2.add$1(output, this.getFrameByName$1(t1.$index($frames, i)));
      }
      return output;
    }, function() {
      return this.getFrames$3(null, null, null);
    }, "getFrames$0", function(frames) {
      return this.getFrames$3(frames, null, null);
    }, "getFrames$1", function(frames, useNumericIndex) {
      return this.getFrames$3(frames, useNumericIndex, null);
    }, "getFrames$2", "call$3", "call$0", "call$1", "call$2", "get$getFrames", 0, 6, 1006, 12, 12, 12, 65, [], 984, [], 999, [], "getFrames"],
    getFrameIndexes$3: [function($frames, useNumericIndex, output) {
      var len, t1, i, t2, t3;
      if (useNumericIndex == null)
        useNumericIndex = true;
      if (output == null)
        output = [];
      if ($frames == null || J.$eq(J.get$length$asx($frames), 0)) {
        len = J.get$length$asx(this._frames);
        if (typeof len !== "number")
          return H.iae(len);
        t1 = J.getInterceptor$ax(output);
        i = 0;
        for (; i < len; ++i)
          t1.add$1(output, J.get$index$x(J.$index$asx(this._frames, i)));
      } else {
        t1 = J.getInterceptor$asx($frames);
        len = t1.get$length($frames);
        if (typeof len !== "number")
          return H.iae(len);
        t2 = useNumericIndex === true;
        t3 = J.getInterceptor$ax(output);
        i = 0;
        for (; i < len; ++i)
          if (t2)
            t3.add$1(output, t1.$index($frames, i));
          else if (this.getFrameByName$1(t1.$index($frames, i)) != null)
            t3.add$1(output, J.get$index$x(this.getFrameByName$1(t1.$index($frames, i))));
      }
      return output;
    }, function(frames) {
      return this.getFrameIndexes$3(frames, null, null);
    }, "getFrameIndexes$1", function(frames, useNumericIndex) {
      return this.getFrameIndexes$3(frames, useNumericIndex, null);
    }, "getFrameIndexes$2", function() {
      return this.getFrameIndexes$3(null, null, null);
    }, "getFrameIndexes$0", "call$3", "call$1", "call$2", "call$0", "get$getFrameIndexes", 0, 6, 1007, 12, 12, 12, 65, [], 984, [], 999, [], "getFrameIndexes"],
    static: {FrameData$: [function() {
        return new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }, null, null, 0, 0, 54, "new FrameData"]}
  },
  "+FrameData": [674],
  FrameData_clone_closure: {
    "^": "Closure:959;output_0",
    call$2: [function(k, v) {
      J.$indexSet$ax(this.output_0._frameNames, k, v);
    }, "call$2", null, 4, 0, 959, 420, [], 37, [], "call"]
  },
  AtLimit: {
    "^": "Object;x*-617,y*-617",
    static: {AtLimit$: [function() {
        return new R.AtLimit(false, false);
      }, null, null, 0, 0, 283, "new AtLimit"]}
  },
  "+AtLimit": [674],
  Camera: {
    "^": "Object;game@-613,world@-1008,id*-614,view*-649,screenView@-649,bounds@-649,deadzone@-649,roundPx@-617,visible@-617,atLimit@-1009,target*-961,_edge@-616,_Phaser$_position@-615,_targetPosition@-615,displayObject@-696,scale*-615",
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    get$position: [function(_) {
      this._Phaser$_position.set$2(this.view.get$centerX(), this.view.get$centerY());
      return this._Phaser$_position;
    }, null, null, 1, 0, 1010, "position"],
    set$position: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      if (t1.get$x(value) != null)
        J.set$x$x(this.view, t1.get$x(value));
      if (t1.get$y(value) != null)
        J.set$y$x(this.view, t1.get$y(value));
      if (this.bounds != null)
        this.checkBounds$0();
    }, null, null, 3, 0, 1011, 138, [], "position"],
    get$x: [function(_) {
      return J.get$x$x(this.view);
    }, null, null, 1, 0, 619, "x"],
    set$x: [function(_, value) {
      J.set$x$x(this.view, value);
      if (this.bounds != null)
        this.checkBounds$0();
    }, null, null, 3, 0, 620, 138, [], "x"],
    get$y: [function(_) {
      return J.get$y$x(this.view);
    }, null, null, 1, 0, 619, "y"],
    set$y: [function(_, value) {
      J.set$y$x(this.view, value);
      if (this.bounds != null)
        this.checkBounds$0();
    }, null, null, 3, 0, 620, 138, [], "y"],
    get$width: [function(_) {
      return J.get$width$x(this.view);
    }, null, null, 1, 0, 619, "width"],
    set$width: [function(_, value) {
      J.set$width$x(this.view, value);
    }, null, null, 3, 0, 620, 138, [], "width"],
    get$height: [function(_) {
      return J.get$height$x(this.view);
    }, null, null, 1, 0, 619, "height"],
    set$height: [function(_, value) {
      J.set$height$x(this.view, value);
    }, null, null, 3, 0, 620, 138, [], "height"],
    follow$2: [function(target, style) {
      var w, h, helper;
      this.target = target;
      switch (style) {
        case 1:
          w = J.$div$n(J.get$width$x(this.view), 8);
          h = J.$div$n(J.get$height$x(this.view), 3);
          this.deadzone = new R.Rectangle1(J.$div$n(J.$sub$n(J.get$width$x(this.view), w), 2), J.$sub$n(J.$div$n(J.$sub$n(J.get$height$x(this.view), h), 2), J.$mul$ns(h, 0.25)), w, h, 0, 0, 0, 0);
          break;
        case 2:
          helper = P.max(J.get$width$x(this.view), J.get$height$x(this.view)) / 4;
          this.deadzone = new R.Rectangle1(J.$div$n(J.$sub$n(J.get$width$x(this.view), helper), 2), J.$div$n(J.$sub$n(J.get$height$x(this.view), helper), 2), helper, helper, 0, 0, 0, 0);
          break;
        case 3:
          helper = P.max(J.get$width$x(this.view), J.get$height$x(this.view)) / 8;
          this.deadzone = new R.Rectangle1(J.$div$n(J.$sub$n(J.get$width$x(this.view), helper), 2), J.$div$n(J.$sub$n(J.get$height$x(this.view), helper), 2), helper, helper, 0, 0, 0, 0);
          break;
        case 0:
          this.deadzone = null;
          break;
        default:
          this.deadzone = null;
          break;
      }
    }, function(target) {
      return this.follow$2(target, 0);
    }, "follow$1", "call$2", "call$1", "get$follow", 2, 2, 1012, 49, 97, [], 194, [], "follow"],
    unfollow$0: [function() {
      this.target = null;
    }, "call$0", "get$unfollow", 0, 0, 54, "unfollow"],
    focusOn$1: [function(displayObject) {
      var t1 = J.getInterceptor$x(displayObject);
      this.setPosition$2(J.round$0$n(J.$sub$n(t1.get$x(displayObject), this.view.get$halfWidth())), J.round$0$n(J.$sub$n(t1.get$y(displayObject), this.view.get$halfHeight())));
    }, "call$1", "get$focusOn", 2, 0, 320, 833, [], "focusOn"],
    focusOnXY$2: [function(x, y) {
      this.setPosition$2(J.round$0$n(J.$sub$n(x, this.view.get$halfWidth())), J.round$0$n(J.$sub$n(y, this.view.get$halfHeight())));
    }, "call$2", "get$focusOnXY", 4, 0, 149, 9, [], 10, [], "focusOnXY"],
    update$0: [function() {
      var t1, t2;
      t1 = this.target;
      if (t1 != null) {
        t1 = this._targetPosition.copyFrom$1(t1);
        t2 = J.get$parent$x(this.target) != null ? J.get$a$x(J.get$parent$x(this.target).get$worldTransform()) : 1;
        t1.multiply$2(t2, J.get$parent$x(this.target) != null ? J.get$parent$x(this.target).get$worldTransform().get$d() : 1);
        t1 = this.deadzone;
        t2 = this._targetPosition;
        if (t1 != null) {
          t1 = J.$sub$n(J.get$x$x(t2), J.get$x$x(this.view));
          this._edge = t1;
          if (J.$lt$n(t1, J.get$left$x(this.deadzone)))
            J.set$x$x(this.view, J.$sub$n(J.get$x$x(this._targetPosition), J.get$left$x(this.deadzone)));
          else if (J.$gt$n(this._edge, J.get$right$x(this.deadzone)))
            J.set$x$x(this.view, J.$sub$n(J.get$x$x(this._targetPosition), J.get$right$x(this.deadzone)));
          t1 = J.$sub$n(J.get$y$x(this._targetPosition), J.get$y$x(this.view));
          this._edge = t1;
          if (J.$lt$n(t1, J.get$top$x(this.deadzone)))
            J.set$y$x(this.view, J.$sub$n(J.get$y$x(this._targetPosition), J.get$top$x(this.deadzone)));
          else if (J.$gt$n(this._edge, J.get$bottom$x(this.deadzone)))
            J.set$y$x(this.view, J.$sub$n(J.get$y$x(this._targetPosition), J.get$bottom$x(this.deadzone)));
        } else {
          J.set$x$x(this.view, J.$sub$n(J.get$x$x(t2), this.view.get$halfWidth()));
          J.set$y$x(this.view, J.$sub$n(J.get$y$x(this._targetPosition), this.view.get$halfHeight()));
        }
      }
      if (this.bounds != null)
        this.checkBounds$0();
      if (this.roundPx === true)
        J.floor$0$n(this.view);
      J.set$x$x(J.get$position$x(this.displayObject), J.$negate$n(J.get$x$x(this.view)));
      J.set$y$x(J.get$position$x(this.displayObject), J.$negate$n(J.get$y$x(this.view)));
    }, "call$0", "get$update", 0, 0, 54, "update"],
    updateTarget$0: [function() {
      var t1, t2;
      t1 = this._targetPosition.copyFrom$1(this.target);
      t2 = J.get$parent$x(this.target) != null ? J.get$a$x(J.get$parent$x(this.target).get$worldTransform()) : 1;
      t1.multiply$2(t2, J.get$parent$x(this.target) != null ? J.get$parent$x(this.target).get$worldTransform().get$d() : 1);
      t1 = this.deadzone;
      t2 = this._targetPosition;
      if (t1 != null) {
        t1 = J.$sub$n(J.get$x$x(t2), J.get$x$x(this.view));
        this._edge = t1;
        if (J.$lt$n(t1, J.get$left$x(this.deadzone)))
          J.set$x$x(this.view, J.$sub$n(J.get$x$x(this._targetPosition), J.get$left$x(this.deadzone)));
        else if (J.$gt$n(this._edge, J.get$right$x(this.deadzone)))
          J.set$x$x(this.view, J.$sub$n(J.get$x$x(this._targetPosition), J.get$right$x(this.deadzone)));
        t1 = J.$sub$n(J.get$y$x(this._targetPosition), J.get$y$x(this.view));
        this._edge = t1;
        if (J.$lt$n(t1, J.get$top$x(this.deadzone)))
          J.set$y$x(this.view, J.$sub$n(J.get$y$x(this._targetPosition), J.get$top$x(this.deadzone)));
        else if (J.$gt$n(this._edge, J.get$bottom$x(this.deadzone)))
          J.set$y$x(this.view, J.$sub$n(J.get$y$x(this._targetPosition), J.get$bottom$x(this.deadzone)));
      } else {
        J.set$x$x(this.view, J.$sub$n(J.get$x$x(t2), this.view.get$halfWidth()));
        J.set$y$x(this.view, J.$sub$n(J.get$y$x(this._targetPosition), this.view.get$halfHeight()));
      }
    }, "call$0", "get$updateTarget", 0, 0, 54, "updateTarget"],
    setBoundsToWorld$0: [function() {
      var t1 = this.bounds;
      if (t1 != null)
        t1.setTo$4(J.get$x$x(this.game.get$world().get$bounds()), J.get$y$x(this.game.get$world().get$bounds()), J.get$width$x(this.game.get$world().get$bounds()), J.get$height$x(this.game.get$world().get$bounds()));
    }, "call$0", "get$setBoundsToWorld", 0, 0, 54, "setBoundsToWorld"],
    checkBounds$0: [function() {
      J.set$x$x(this.atLimit, false);
      J.set$y$x(this.atLimit, false);
      if (J.$le$n(J.get$x$x(this.view), J.get$x$x(this.bounds))) {
        J.set$x$x(this.atLimit, true);
        J.set$x$x(this.view, J.get$x$x(this.bounds));
      }
      if (J.$ge$n(J.get$right$x(this.view), J.get$right$x(this.bounds))) {
        J.set$x$x(this.atLimit, true);
        J.set$x$x(this.view, J.$sub$n(J.get$right$x(this.bounds), J.get$width$x(this.view)));
      }
      if (J.$le$n(J.get$y$x(this.view), J.get$top$x(this.bounds))) {
        J.set$y$x(this.atLimit, true);
        J.set$y$x(this.view, J.get$top$x(this.bounds));
      }
      if (J.$ge$n(J.get$bottom$x(this.view), J.get$bottom$x(this.bounds))) {
        J.set$y$x(this.atLimit, true);
        J.set$y$x(this.view, J.$sub$n(J.get$bottom$x(this.bounds), J.get$height$x(this.view)));
      }
    }, "call$0", "get$checkBounds", 0, 0, 54, "checkBounds"],
    setPosition$2: [function(x, y) {
      J.set$x$x(this.view, x);
      J.set$y$x(this.view, y);
      if (this.bounds != null)
        this.checkBounds$0();
    }, "call$2", "get$setPosition", 4, 0, 149, 9, [], 10, [], "setPosition"],
    setSize$2: [function(width, height) {
      J.set$width$x(this.view, width);
      J.set$height$x(this.view, height);
    }, "call$2", "get$setSize", 4, 0, 149, 31, [], 52, [], "setSize"],
    reset$0: [function(_) {
      this.target = null;
      J.set$x$x(this.view, 0);
      J.set$y$x(this.view, 0);
    }, "call$0", "get$reset", 0, 0, 54, "reset"],
    Camera$6: function(game, id, x, y, width, height) {
      var t1;
      this.world = this.game.get$world();
      this.id = 0;
      this.view = new R.Rectangle1(x, y, width, height, 0, 0, 0, 0);
      this.screenView = new R.Rectangle1(x, y, width, height, 0, 0, 0, 0);
      this.bounds = new R.Rectangle1(x, y, width, height, 0, 0, 0, 0);
      this.deadzone = null;
      this.visible = true;
      this.roundPx = true;
      this.atLimit = new R.AtLimit(false, false);
      this.target = null;
      this._edge = 0;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this._Phaser$_position = t1;
      this.displayObject = null;
      this.scale = null;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this._targetPosition = t1;
    },
    static: {"^": "Camera_FOLLOW_LOCKON<-614,Camera_FOLLOW_PLATFORMER<-614,Camera_FOLLOW_TOPDOWN<-614,Camera_FOLLOW_TOPDOWN_TIGHT<-614", Camera$: [function(game, id, x, y, width, height) {
        var t1 = new R.Camera(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Camera$6(game, id, x, y, width, height);
        return t1;
      }, null, null, 12, 0, 284, 252, [], 221, [], 9, [], 10, [], 31, [], 52, [], "new Camera"]}
  },
  "+Camera": [674],
  Signal: {
    "^": "Object;_bindings@-1013,_prevParams@-12,memorize@-617,_shouldPropagate@-617,active@-617",
    _validateListener$2: [function(listener, fnName) {
      var t1 = H.checkSubtypeOfRuntimeType(listener, H.getTypeArgumentByIndex(this, 0));
      if (!t1)
        throw H.wrapException(P.Exception_Exception(C.JSString_methods.replaceFirst$2("listener is a required param of {fn}() and should be a Function.", "{fn}", fnName)));
    }, "call$2", "get$_validateListener", 4, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T_String", args: [T, P.String]};
      }, this.$receiver, "Signal");
    }, 960, [], 1014, [], "_validateListener"],
    _registerListener$3: [function(listener, isOnce, priority) {
      var prevIndex, binding, t1, t2;
      prevIndex = this._indexOfListener$1(listener);
      if (!J.$eq(prevIndex, -1)) {
        binding = J.$index$asx(this._bindings, prevIndex);
        if (!J.$eq(binding.isOnce$0(), isOnce)) {
          t1 = isOnce === true;
          t2 = "You cannot add" + (t1 ? "" : "Once") + "() then add";
          throw H.wrapException(P.Exception_Exception(t2 + (!t1 ? "" : "Once") + "() the same listener without removing the relationship first."));
        }
      } else {
        binding = new R.SignalBinding(listener, isOnce, priority, this, true, null);
        if (priority == null)
          binding._priority = 0;
        this._addBinding$1(binding);
      }
      if (this.memorize === true && this._prevParams === true)
        binding.execute$1(this._prevParams);
      return binding;
    }, function(listener, isOnce) {
      return this._registerListener$3(listener, isOnce, null);
    }, "_registerListener$2", "call$3", "call$2", "get$_registerListener", 4, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "SignalBinding__T_bool__int", ret: R.SignalBinding, args: [T, P.bool], opt: [P.$int]};
      }, this.$receiver, "Signal");
    }, 12, 960, [], 1015, [], 1016, [], "_registerListener"],
    _addBinding$1: [function(binding) {
      var n, t1;
      n = J.get$length$asx(this._bindings);
      do {
        n = J.$sub$n(n, 1);
        t1 = J.getInterceptor$n(n);
      } while (t1.$ge(n, 0) && J.$index$asx(this._bindings, n) != null && J.$le$n(binding.get$_priority(), J.$index$asx(this._bindings, n).get$_priority()));
      J.insert$2$ax(this._bindings, t1.$add(n, 1), binding);
    }, "call$1", "get$_addBinding", 2, 0, 1017, 1018, [], "_addBinding"],
    _indexOfListener$1: [function(listener) {
      var n, t1, n0;
      n = J.get$length$asx(this._bindings);
      for (; t1 = J.getInterceptor$n(n), n0 = t1.$sub(n, 1), !t1.$eq(n, 0); n = n0)
        if (J.$eq(J.$index$asx(this._bindings, n0).get$_listener(), listener))
          return n0;
      return -1;
    }, "call$1", "get$_indexOfListener", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "int__T", ret: P.$int, args: [T]};
      }, this.$receiver, "Signal");
    }, 960, [], "_indexOfListener"],
    has$1: [function(listener) {
      return !J.$eq(this._indexOfListener$1(listener), -1);
    }, "call$1", "get$has", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "bool__T", ret: P.bool, args: [T]};
      }, this.$receiver, "Signal");
    }, 960, [], "has"],
    add$2: [function(_, listener, priority) {
      this._validateListener$2(listener, "add");
      return this._registerListener$3(listener, false, priority);
    }, function($receiver, listener) {
      return this.add$2($receiver, listener, null);
    }, "add$1", "call$2", "call$1", "get$add", 2, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "SignalBinding__T__int", ret: R.SignalBinding, args: [T], opt: [P.$int]};
      }, this.$receiver, "Signal");
    }, 12, 960, [], 1016, [], "add"],
    addOnce$2: [function(listener, priority) {
      this._validateListener$2(listener, "addOnce");
      return this._registerListener$3(listener, true, priority);
    }, function(listener) {
      return this.addOnce$2(listener, null);
    }, "addOnce$1", "call$2", "call$1", "get$addOnce", 2, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "SignalBinding__T__int", ret: R.SignalBinding, args: [T], opt: [P.$int]};
      }, this.$receiver, "Signal");
    }, 12, 960, [], 1016, [], "addOnce"],
    remove$1: [function(_, listener) {
      var i;
      this._validateListener$2(listener, "remove");
      i = this._indexOfListener$1(listener);
      if (!J.$eq(i, -1)) {
        J.$index$asx(this._bindings, i)._destroy$0();
        J.removeAt$1$ax(this._bindings, i);
      }
      return listener;
    }, "call$1", "get$remove", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T__T", ret: T, args: [T]};
      }, this.$receiver, "Signal");
    }, 960, [], "remove"],
    removeAll$0: [function() {
      var n, t1, n0;
      n = J.get$length$asx(this._bindings);
      for (; t1 = J.getInterceptor$n(n), n0 = t1.$sub(n, 1), t1.$gt(n, 0); n = n0)
        J.$index$asx(this._bindings, n0)._destroy$0();
      J.clear$0$ax(this._bindings);
    }, "call$0", "get$removeAll", 0, 0, 54, "removeAll"],
    getNumListeners$0: [function() {
      return J.get$length$asx(this._bindings);
    }, "call$0", "get$getNumListeners", 0, 0, 412, "getNumListeners"],
    halt$0: [function() {
      this._shouldPropagate = false;
    }, "call$0", "get$halt", 0, 0, 54, "halt"],
    dispatch$1: [function($arguments) {
      var paramsArr, n, bindings, t1;
      if (this.active !== true)
        return;
      paramsArr = !!J.getInterceptor($arguments).$isList || $arguments == null ? $arguments : [$arguments];
      n = J.get$length$asx(this._bindings);
      if (this.memorize === true)
        this._prevParams = paramsArr;
      if (J.$eq(n, 0))
        return;
      bindings = P.List_List$from(this._bindings, true, null);
      this._shouldPropagate = true;
      do {
        n = J.$sub$n(n, 1);
        if (J.$ge$n(n, 0)) {
          if (n >>> 0 !== n || n >= bindings.length)
            return H.ioore(bindings, n);
          t1 = bindings[n];
          t1 = t1 != null && this._shouldPropagate === true && !J.$eq(t1.execute$1(paramsArr), false);
        } else
          t1 = false;
      } while (t1);
    }, function() {
      return this.dispatch$1(null);
    }, "dispatch$0", "call$1", "call$0", "get$dispatch", 0, 2, 944, 12, 607, [], "dispatch"],
    forget$0: [function() {
      this._prevParams = null;
    }, "call$0", "get$forget", 0, 0, 54, "forget"],
    dispose$0: [function() {
      this.removeAll$0();
      this._bindings = null;
      this._prevParams = null;
    }, "call$0", "get$dispose", 0, 0, 54, "dispose"],
    toString$0: [function(_) {
      return "[Phaser.Signal active:" + ("[Phaser.Signal active:" + this.toString$0(0) + ".active numListeners:" + H.S(J.get$length$asx(this._bindings)) + "]") + ".active numListeners:" + H.S(J.get$length$asx(this._bindings)) + "]";
    }, "call$0", "get$toString", 0, 0, 810, "toString"],
    "<>": [1],
    static: {Signal$: [function($T) {
        return H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [$T]);
      }, null, null, 0, 0, function() {
        return H.computeSignature(function(T) {
          return {func: "Signal_", ret: [R.Signal, T]};
        }, this.$receiver, "Signal");
      }, "new Signal"]}
  },
  "+Signal": [674],
  Filter: {
    "^": "Object;game@-613,type*-614,passes@-1019,shaders@-645,dirty@-617,padding*-614,uniforms@-783,fragmentSrc@-847",
    get$width: [function(_) {
      return J.$index$asx(J.$index$asx(J.$index$asx(this.uniforms, "resolution"), "value"), "x");
    }, null, null, 1, 0, 619, "width"],
    set$width: [function(_, value) {
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "resolution"), "value"), "x", value);
    }, null, null, 3, 0, 620, 138, [], "width"],
    get$height: [function(_) {
      return J.$index$asx(J.$index$asx(J.$index$asx(this.uniforms, "resolution"), "value"), "y");
    }, null, null, 1, 0, 619, "height"],
    set$height: [function(_, value) {
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "resolution"), "value"), "y", value);
    }, null, null, 3, 0, 620, 138, [], "height"],
    init$0: [function() {
    }, "call$0", "get$init", 0, 0, 54, "init"],
    setResolution$2: [function(width, height) {
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "resolution"), "value"), "x", width);
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "resolution"), "value"), "y", height);
    }, "call$2", "get$setResolution", 4, 0, 149, 31, [], 52, [], "setResolution"],
    update$1: [function(pointer) {
      var t1;
      if (pointer != null) {
        t1 = J.getInterceptor$x(pointer);
        if (J.$gt$n(t1.get$x(pointer), 0))
          J.$indexSet$ax(J.$index$asx(this.uniforms, "mouse"), "x", J.toStringAsFixed$1$n(t1.get$x(pointer), 2));
        if (J.$gt$n(t1.get$y(pointer), 0))
          J.$indexSet$ax(J.$index$asx(this.uniforms, "mouse"), "y", J.toStringAsFixed$1$n(t1.get$y(pointer), 2));
      }
      J.$indexSet$ax(J.$index$asx(this.uniforms, "time"), "value", this.game.get$time().totalElapsedSeconds$0());
    }, function() {
      return this.update$1(null);
    }, "update$0", "call$1", "call$0", "get$update", 0, 2, 1020, 12, 1021, [], "update"],
    destroy$0: [function() {
      this.game = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    Filter$3: function(game, uniforms, fragmentSrc) {
      this.type = 15;
      this.passes = [this];
      this.shaders = [];
      this.dirty = true;
      this.padding = 0;
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["time", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 0], null, null), "resolution", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 256, "y", 256], null, null)], null, null), "mouse", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 0, "y", 0], null, null)], null, null)], null, null);
      this.fragmentSrc = fragmentSrc;
      if (fragmentSrc == null)
        this.fragmentSrc = [];
    },
    static: {Filter$: [function(game, uniforms, fragmentSrc) {
        var t1 = new R.Filter(game, null, null, null, null, null, null, null);
        t1.Filter$3(game, uniforms, fragmentSrc);
        return t1;
      }, null, null, 2, 4, 285, 12, 12, 252, [], 286, [], 186, [], "new Filter"]}
  },
  "+Filter": [674],
  FlexGrid: {
    "^": "Object;game@-613,manager@-1022,width*-616,height*-616,boundsCustom@-649,boundsFluid@-649,boundsFull@-649,boundsNone@-649,positionCustom@-615,positionFluid@-615,positionFull@-615,positionNone@-615,scaleCustom@-615,scaleFluid@-615,scaleFluidInversed@-615,scaleFull@-615,scaleNone@-615,customWidth@-616,customHeight@-616,customOffsetX@-616,customOffsetY@-616,ratioH@-616,ratioV@-616,multiplier@-616,layers@-1023",
    createCustomLayer$4: [function(width, height, children, addToWorld) {
      var layer;
      if (addToWorld == null)
        addToWorld = true;
      this.customWidth = width;
      this.customHeight = height;
      J.set$width$x(this.boundsCustom, width);
      J.set$height$x(this.boundsCustom, height);
      layer = R.FlexLayer$(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
      if (addToWorld === true)
        J.add$1$ax(this.game.get$world(), layer);
      J.add$1$ax(this.layers, layer);
      if (children != null)
        layer.addMultiple$1(children);
      return layer;
    }, function(width, height, children) {
      return this.createCustomLayer$4(width, height, children, null);
    }, "createCustomLayer$3", "call$4", "call$3", "get$createCustomLayer", 6, 2, 1024, 12, 31, [], 52, [], 1025, [], 1026, [], "createCustomLayer"],
    setSize$2: [function(width, height) {
      var t1;
      this.width = width;
      this.height = height;
      this.ratioH = J.$div$n(width, height);
      this.ratioV = J.$div$n(height, width);
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this.scaleNone = t1;
      J.set$width$x(this.boundsNone, this.width);
      J.set$height$x(this.boundsNone, this.height);
      this.refresh$0();
    }, "call$2", "get$setSize", 4, 0, 149, 31, [], 52, [], "setSize"],
    createFluidLayer$2: [function(children, addToWorld) {
      var layer;
      if (addToWorld == null)
        addToWorld = true;
      layer = R.FlexLayer$(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
      if (addToWorld === true)
        J.add$1$ax(this.game.get$world(), layer);
      J.add$1$ax(this.layers, layer);
      if (children != null)
        layer.addMultiple$1(children);
      return layer;
    }, function(children) {
      return this.createFluidLayer$2(children, true);
    }, "createFluidLayer$1", "call$2", "call$1", "get$createFluidLayer", 2, 2, 1027, 78, 1025, [], 1026, [], "createFluidLayer"],
    createFullLayer$1: [function(children) {
      var layer = R.FlexLayer$(this, this.positionFull, this.boundsFull, this.scaleFluid);
      J.add$1$ax(this.game.get$world(), layer);
      J.add$1$ax(this.layers, layer);
      if (children != null)
        layer.addMultiple$1(children);
      return layer;
    }, "call$1", "get$createFullLayer", 2, 0, 102, 1025, [], "createFullLayer"],
    createFixedLayer$1: [function(children) {
      var layer = R.FlexLayer$(this, this.positionNone, this.boundsNone, this.scaleNone);
      J.add$1$ax(this.game.get$world(), layer);
      J.add$1$ax(this.layers, layer);
      if (children != null)
        layer.addMultiple$1(children);
      return layer;
    }, "call$1", "get$createFixedLayer", 2, 0, 102, 1025, [], "createFixedLayer"],
    reset$0: [function(_) {
      var i, t1, i0;
      i = J.get$length$asx(this.layers);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        if (J.$index$asx(this.layers, i0).get$persist() !== true) {
          J.set$position$x(J.$index$asx(this.layers, i0), null);
          J.set$scale$x(J.$index$asx(this.layers, i0), null);
          J.removeAt$1$ax(this.layers, i0);
        }
    }, "call$0", "get$reset", 0, 0, 54, "reset"],
    onResize$2: [function(_, width, height) {
      this.refresh$2(width, height);
    }, "call$2", "get$onResize", 4, 0, 149, 31, [], 52, [], "onResize"],
    refresh$2: [function(width, height) {
      var t1 = P.min(J.$div$n(J.get$height$x(this.manager), this.height), J.$div$n(J.get$width$x(this.manager), this.width));
      this.multiplier = t1;
      J.set$width$x(this.boundsFluid, J.round$0$n(J.$mul$ns(this.width, t1)));
      J.set$height$x(this.boundsFluid, J.round$0$n(J.$mul$ns(this.height, this.multiplier)));
      this.scaleFluid.set$2(J.$div$n(J.get$width$x(this.boundsFluid), this.width), J.$div$n(J.get$height$x(this.boundsFluid), this.height));
      this.scaleFluidInversed.set$2(J.$div$n(this.width, J.get$width$x(this.boundsFluid)), J.$div$n(this.height, J.get$height$x(this.boundsFluid)));
      this.scaleFull.set$2(J.$div$n(J.get$width$x(this.boundsFull), this.width), J.$div$n(J.get$height$x(this.boundsFull), this.height));
      J.set$width$x(this.boundsFull, J.$mul$ns(J.get$width$x(this.manager), J.get$x$x(this.scaleFluidInversed)));
      J.set$height$x(this.boundsFull, J.$mul$ns(J.get$height$x(this.manager), J.get$y$x(this.scaleFluidInversed)));
      this.boundsFluid.centerOn$2(this.manager.get$bounds().get$centerX(), this.manager.get$bounds().get$centerY());
      this.boundsNone.centerOn$2(this.manager.get$bounds().get$centerX(), this.manager.get$bounds().get$centerY());
      this.positionFluid.set$2(J.get$x$x(this.boundsFluid), J.get$y$x(this.boundsFluid));
      this.positionNone.set$2(J.get$x$x(this.boundsNone), J.get$y$x(this.boundsNone));
    }, function() {
      return this.refresh$2(null, null);
    }, "refresh$0", function(width) {
      return this.refresh$2(width, null);
    }, "refresh$1", "call$2", "call$0", "call$1", "get$refresh", 0, 4, 56, 12, 12, 31, [], 52, [], "refresh"],
    debug$0: [function() {
      J.text$3$x(this.game.get$debug(), J.$add$ns(J.$add$ns(J.toString$0(J.get$width$x(this.boundsFluid)), " x "), J.toString$0(J.get$height$x(this.boundsFluid))), J.$add$ns(J.get$x$x(this.boundsFluid), 4), J.$add$ns(J.get$y$x(this.boundsFluid), 16));
      this.game.get$debug().geom$3(this.boundsFluid, "rgba(255,0,0,0.9", false);
    }, "call$0", "get$debug", 0, 0, 54, "debug"],
    FlexGrid$3: function(manager, width, height) {
      var t1;
      this.game = manager.get$game();
      this.manager = manager;
      this.width = width;
      this.height = height;
      this.boundsCustom = new R.Rectangle1(0, 0, width, height, 0, 0, 0, 0);
      this.boundsFluid = new R.Rectangle1(0, 0, width, height, 0, 0, 0, 0);
      this.boundsFull = new R.Rectangle1(0, 0, width, height, 0, 0, 0, 0);
      this.boundsNone = new R.Rectangle1(0, 0, width, height, 0, 0, 0, 0);
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.positionCustom = t1;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.positionFluid = t1;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.positionFull = t1;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.positionNone = t1;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this.scaleCustom = t1;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this.scaleFluid = t1;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this.scaleFluidInversed = t1;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this.scaleFull = t1;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this.scaleNone = t1;
      this.customWidth = 0;
      this.customHeight = 0;
      this.customOffsetX = 0;
      this.customOffsetY = 0;
      this.ratioH = J.$div$n(width, height);
      this.ratioV = J.$div$n(height, width);
      this.multiplier = 0;
      this.layers = [];
    },
    static: {FlexGrid$: [function(manager, width, height) {
        var t1 = new R.FlexGrid(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, []);
        t1.FlexGrid$3(manager, width, height);
        return t1;
      }, null, null, 6, 0, 287, 288, [], 31, [], 52, [], "new FlexGrid"]}
  },
  "+FlexGrid": [674],
  FlexLayer: {
    "^": "Group;manager@-1022,persist@-617,grid*-1028,bounds@-649,scale:Phaser$FlexLayer$scale*-615,topLeft*-615,topMiddle@-615,topRight*-615,bottomLeft*-615,bottomMiddle@-615,bottomRight*-615,game-613,name-644,addToStage-617,enableBody-617,physicsBodyType-616,z-614,type-614,alive-617,exists-617,ignoreDestroy-617,_Phaser$_dirty-617,cursor-12,cameraOffset-615,_sortProperty-644,enableBodyDebug-617,_cache-645,creator-646,renderOrderID-614,Phaser$Group$children-647,autoCull-617,events-648,_anchor-615,_Phaser$_currentBounds-649,Phaser$Group$position-615,onDestroy-650,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    scale$2: function($receiver, arg0, arg1) {
      return this.Phaser$FlexLayer$scale.call$2(arg0, arg1);
    },
    resize$0: [function(_) {
    }, "call$0", "get$resize", 0, 0, 54, "resize"],
    debug$0: [function() {
      J.text$3$x(this.game.get$debug(), J.$add$ns(J.$add$ns(J.toString$0(J.get$width$x(this.bounds)), " x "), J.toString$0(J.get$height$x(this.bounds))), J.$add$ns(J.get$x$x(this.bounds), 4), J.$add$ns(J.get$y$x(this.bounds), 16));
      this.game.get$debug().geom$3(this.bounds, "rgba(0,0,255,0.9", false);
      this.game.get$debug().geom$2(this.topLeft, "rgba(255,255,255,0.9");
      this.game.get$debug().geom$2(this.topMiddle, "rgba(255,255,255,0.9");
      this.game.get$debug().geom$2(this.topRight, "rgba(255,255,255,0.9");
    }, "call$0", "get$debug", 0, 0, 54, "debug"],
    FlexLayer$4: function(manager, position, bounds, scale) {
      var t1, t2, t3, t4;
      this.manager = manager.get$manager();
      this.grid = manager;
      this.persist = false;
      this.Phaser$Group$position = position;
      this.bounds = bounds;
      this.Phaser$FlexLayer$scale = scale;
      t1 = J.getInterceptor$x(bounds);
      this.topLeft = t1.get$topLeft(bounds);
      t2 = new R.Point(null, null);
      t2.x = bounds.get$halfWidth();
      t2.y = 0;
      this.topMiddle = t2;
      this.topRight = t1.get$topRight(bounds);
      this.bottomLeft = t1.get$bottomLeft(bounds);
      t2 = bounds.get$halfWidth();
      t3 = t1.get$bottom(bounds);
      t4 = new R.Point(null, null);
      t4.x = t2;
      t4.y = t3;
      this.bottomMiddle = t4;
      this.bottomRight = t1.get$bottomRight(bounds);
    },
    $asGroup: function() {
      return [null];
    },
    $asGroup: function() {
      return [null];
    },
    "<>": [],
    static: {FlexLayer$: [function(manager, position, bounds, scale) {
        var t1, t2, t3, t4, t5, t6, t7;
        t1 = manager.get$game();
        t2 = C.JSString_methods.$add("__flexLayer", manager.get$game().get$rnd().uuid$0());
        t3 = new R.Point(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new R.Point(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = new M.Point0(null, null);
        t6.x = 1;
        t6.y = 1;
        t7 = new M.Point0(null, null);
        t7.x = 0;
        t7.y = 0;
        t7 = new R.FlexLayer(null, null, null, null, null, null, null, null, null, null, null, null, t2, false, false, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, t3, null, t4, null, [], false, 0, 0, t5, t6, t7, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t7.Group$6(t1, null, t2, false, false, 0, null);
        t7.FlexLayer$4(manager, position, bounds, scale);
        return t7;
      }, null, null, 8, 0, 289, 288, [], 290, [], 291, [], 292, [], "new FlexLayer"]}
  },
  "+FlexLayer": [1029],
  Game: {
    "^": "Object;width*-616,height*-616,renderer@-837,parent*-12,state*-1030,transparent@-617,antialias@-617,physicsConfig@-783,id*-614,config@-783,renderType@-614,isBooted@-617,isRunning@-617,raf@-1031,add*-1032,make@-1033,world@-1008,cache@-1034,input@-1035,load*-1036,net@-1037,scale*-1022,sound@-1038,plugins@-1039,stage@-1040,time@-1041,physics@-1042,tweens@-1043,rnd@-1044,device@-1045,camera@-1046,canvas*-836,context*-876,debug@-1047,particles@-1048,stepping@-617,pendingStep@-617,stepCount@-616,onPause*-1049,onResume@-1049,onBlur*-1049,onFocus*-1049,_paused@-617,_codePaused@-617,preserveDrawingBuffer@-617,_onBoot@-0",
    add$2: function($receiver, arg0, arg1) {
      return this.add.call$2(arg0, arg1);
    },
    add$1: function($receiver, arg0) {
      return this.add.call$1(arg0);
    },
    add$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.add.call$4(arg0, arg1, arg2, arg3);
    },
    add$3: function($receiver, arg0, arg1, arg2) {
      return this.add.call$3(arg0, arg1, arg2);
    },
    add$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.add.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    load$0: function($receiver) {
      return this.load.call$0();
    },
    load$1: function($receiver, arg0) {
      return this.load.call$1(arg0);
    },
    load$2: function($receiver, arg0, arg1) {
      return this.load.call$2(arg0, arg1);
    },
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    sound$2: function(arg0, arg1) {
      return this.sound.call$2(arg0, arg1);
    },
    sound$3: function(arg0, arg1, arg2) {
      return this.sound.call$3(arg0, arg1, arg2);
    },
    sound$4: function(arg0, arg1, arg2, arg3) {
      return this.sound.call$4(arg0, arg1, arg2, arg3);
    },
    sound$1: function(arg0) {
      return this.sound.call$1(arg0);
    },
    physics$4: function(arg0, arg1, arg2, arg3) {
      return this.physics.call$4(arg0, arg1, arg2, arg3);
    },
    rnd$0: function() {
      return this.rnd.call$0();
    },
    debug$0: function() {
      return this.debug.call$0();
    },
    get$paused: [function(_) {
      return this._paused;
    }, null, null, 1, 0, 247, "paused"],
    paused$0: function($receiver) {
      return this.get$paused(this).call$0();
    },
    set$paused: [function(_, value) {
      if (J.$eq(value, true)) {
        if (J.$eq(this._paused, false)) {
          this._paused = true;
          this._codePaused = true;
          this.sound.setMute$0();
          this.time.gamePaused$0();
          this.onPause.dispatch$0();
        }
      } else if (this._paused === true) {
        this._paused = false;
        this._codePaused = false;
        J.reset$0$x(this.input);
        this.sound.unsetMute$0();
        this.time.gameResumed$0();
        this.onResume.dispatch$0();
      }
    }, null, null, 3, 0, 639, 138, [], "paused"],
    parseConfig$1: [function(config) {
      var t1, t2, t3;
      this.config = config;
      t1 = J.getInterceptor$asx(config);
      if (t1.$index(config, "width") != null)
        this.width = R.Utils_parseDimension(t1.$index(config, "width"), 0);
      if (t1.$index(config, "height") != null)
        this.height = R.Utils_parseDimension(t1.$index(config, "height"), 1);
      if (t1.$index(config, "renderer") != null)
        this.renderType = t1.$index(config, "renderer");
      if (t1.$index(config, "parent") != null)
        this.parent = t1.$index(config, "parent");
      if (t1.$index(config, "transparent") != null)
        this.transparent = t1.$index(config, "transparent");
      if (t1.$index(config, "antialias") != null)
        this.antialias = t1.$index(config, "antialias");
      if (t1.$index(config, "preserveDrawingBuffer") != null)
        this.preserveDrawingBuffer = t1.$index(config, "preserveDrawingBuffer");
      if (t1.$index(config, "physicsConfig") != null)
        this.physicsConfig = t1.$index(config, "physicsConfig");
      t2 = Date.now();
      t3 = $.get$Math_random().call$0();
      if (typeof t3 !== "number")
        return H.iae(t3);
      C.JSNumber_methods.toString$0(t2 * t3);
      if (t1.$index(config, "seed") != null)
        t1.$index(config, "seed");
      this.rnd = new R.RandomDataGenerator(1, 0, 0, 0);
      this.state = R.StateManager$(this, t1.$index(config, "state") != null ? t1.$index(config, "state") : null);
    }, "call$1", "get$parseConfig", 2, 0, 102, 466, [], "parseConfig"],
    boot$0: [function() {
      var t1, t2, t3, t4, t5;
      P.print("boot start");
      if (this.isBooted === true)
        return;
      this.onPause = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onResume = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onBlur = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onFocus = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.isBooted = true;
      t1 = new R.Device(this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t1.Device$1(this);
      this.device = t1;
      t1 = new R.ScaleManager(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, 1, null, null, null, null, null, false, 0, false, null, null, null, null, null, null, null, null, null, null, null, null, true, null);
      t1.ScaleManager$3(this, this.width, this.height);
      this.scale = t1;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      t2 = new Float32Array(H._checkLength(9));
      t3 = new M.Point0(null, null);
      t3.x = 0;
      t3.y = 0;
      t4 = new M.Point0(null, null);
      t4.x = 1;
      t4.y = 1;
      t5 = new M.Point0(null, null);
      t5.x = 0;
      t5.y = 0;
      t5 = new R.Stage(this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t1, null, null, null, null, null, null, null, null, null, false, [], null, false, new M.Rectangle0(0, 0, 100000, 100000), 0, [], null, new M.Matrix(1, 0, 0, 1, 0, 0, t2), null, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
      t5.Stage$2(0, true);
      t5.Stage$1(this);
      this.stage = t5;
      this.setUpRenderer$0();
      this.device.checkFullScreenSupport$0();
      t5 = new R.Point(null, null);
      t5.x = 0;
      t5.y = 0;
      t4 = new R.Point(null, null);
      t4.x = 0;
      t4.y = 0;
      t3 = new M.Point0(null, null);
      t3.x = 0;
      t3.y = 0;
      t2 = new M.Point0(null, null);
      t2.x = 1;
      t2.y = 1;
      t1 = new M.Point0(null, null);
      t1.x = 0;
      t1.y = 0;
      t1 = new R.World(null, null, null, null, null, null, null, "__world", false, false, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, t5, null, t4, null, [], false, 0, 0, t3, t2, t1, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
      t1.Group$6(this, null, "__world", false, false, 0, null);
      t1.World$1(this);
      this.world = t1;
      t1 = new R.GameObjectFactory(this, null);
      t1.world = this.world;
      this.add = t1;
      t1 = new R.GameObjectCreator(this, null);
      t1.world = this.world;
      this.make = t1;
      t1 = new R.Cache(this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), null);
      t1.Cache$1(this);
      this.cache = t1;
      t1 = new R.Loader(this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t1.Loader$1(this);
      this.load = t1;
      t1 = new R.Time(this, 0, 0, 0, 0, false, 0, 1000, 0, 1000, 0, 0, 0, 16.666666666666668, 0, 0, 0, 0, null, 0, 0, 0, false, [], 0, 0);
      t1.events = new R.Timer(this, true, false, false, 0, [], H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), 0, 1000, false, false, 0, 0, 0, Date.now(), 0, 0, 0, 0, 0);
      this.time = t1;
      t1 = new R.TweenManager(this, [], []);
      t1.TweenManager$1(this);
      this.tweens = t1;
      t1 = Array(11);
      t1.fixed$length = init;
      t1 = new R.Input(this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo(t1, [R.Pointer]), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0);
      t1.Input$1(this);
      this.input = t1;
      t1 = new R.SoundManager(this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t1.SoundManager$1(this);
      this.sound = t1;
      t1 = new R.Physics(null, null, null, null, null, null, null);
      t1.Physics$2(this, this.physicsConfig);
      this.physics = t1;
      t1 = new R.Particles(P.LinkedHashMap_LinkedHashMap$_empty(null, null), this, null);
      t1.emitters = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this.particles = t1;
      t1 = new R.PluginManager(this, null, null, null);
      t1.PluginManager$1(this);
      this.plugins = t1;
      this.net = new R.Net(this);
      this.time.boot$0();
      this.stage.boot$0();
      this.world.boot$0();
      this.input.boot$0();
      this.sound.boot$0();
      this.state.boot$0();
      if (J.$index$asx(this.config, "enableDebug") != null) {
        t1 = new R.Debug(this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Debug$1(this);
        this.debug = t1;
        t1.boot$0();
      }
      this.showDebugHeader$0();
      this.isRunning = true;
      t1 = this.config;
      if (t1 != null && !!J.getInterceptor(J.$index$asx(t1, "forceSetTimeOut")).$isFunction) {
        t1 = R.RequestAnimationFrame$(this, J.$index$asx(this.config, "forceSetTimeOut"));
        this.raf = t1;
      } else {
        t1 = R.RequestAnimationFrame$(this, false);
        this.raf = t1;
      }
      t1.start$0(0);
      P.print("boot end");
    }, "call$0", "get$boot", 0, 0, 54, "boot"],
    showDebugHeader$0: [function() {
      var r, c, a, args, i;
      if (J.$eq(this.renderType, 2)) {
        r = "WebGL";
        c = 2;
      } else {
        r = J.$eq(this.renderType, 3) ? "Headless" : "Canvas";
        c = 1;
      }
      if (this.device.get$webAudio() === true) {
        ++c;
        a = "WebAudio";
      } else
        a = "HTML Audio";
      if (this.device.get$chrome() === true) {
        args = ["%c %c %c Phaser v2.1.2 | Pixi.js v1.6.\uff11 | " + r + " | " + a + "  %c %c  http://phaser.io  %c %c \u2665%c\u2665%c\u2665 ", "background: #0cf300", "background: #00bc17", "color: #ffffff; background: #00711f;", "background: #00bc17", "background: #0cf300", "background: #00bc17"];
        for (i = 0; i < 3; ++i)
          if (i < c)
            args.push("color: #ff2424; background: #fff");
          else
            args.push("color: #959595; background: #fff");
      }
    }, "call$0", "get$showDebugHeader", 0, 0, 54, "showDebugHeader"],
    setUpRenderer$0: [function() {
      var t1, t2, t3, exception, target;
      if (this.device.get$trident() === true)
        this.renderType = 1;
      t1 = J.$index$asx(this.config, "canvasID");
      t2 = this.width;
      t3 = this.height;
      if (t1 != null)
        this.canvas = R.Canvas_create(t2, t3, J.$index$asx(this.config, "canvasID"));
      else
        this.canvas = R.Canvas_create(t2, t3, null);
      if (this.device.get$cocoonJS() === true) {
        t1 = J.get$dataset$x(this.canvas);
        t1._attributes._element.setAttribute("data-" + H.S(t1._toHyphenedName$1("screencanvas")), "true");
      }
      if (!J.$eq(this.renderType, 3))
        if (!J.$eq(this.renderType, 1))
          t1 = J.$eq(this.renderType, 0) && J.$eq(this.device.get$webGL(), false);
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        if (J.get$canvas$x(this.device) === true) {
          if (J.$eq(this.renderType, 0))
            this.renderType = 1;
          t1 = M.CanvasRenderer$(this.width, this.height, this.canvas, this.transparent, false);
          this.renderer = t1;
          this.context = t1.context;
        } else
          throw H.wrapException(P.Exception_Exception("Phaser.Game - cannot create Canvas or WebGL context, aborting."));
      else
        try {
          this.renderType = 2;
          this.renderer = M.WebGLRenderer$(this.width, this.height, this.canvas, this.transparent, this.antialias, this.preserveDrawingBuffer);
          this.context = null;
        } catch (exception) {
          H.unwrapException(exception);
          this.renderType = 1;
          t1 = M.CanvasRenderer$(this.width, this.height, this.canvas, this.transparent, false);
          this.renderer = t1;
          this.context = t1.context;
        }

      if (this.device.get$cocoonJS() === true)
        if (J.$eq(this.renderType, 1))
          ;
      if (!J.$eq(this.renderType, 3)) {
        this.stage.set$smoothed(this.antialias);
        t1 = this.canvas;
        target = this.parent;
        if (target != null)
          if (typeof target === "string")
            target = document.getElementById(target);
          else
            target = !!J.getInterceptor(target).$isHtmlElement ? target : null;
        else
          target = null;
        if (target == null)
          target = document.body;
        J.append$1$x(target, t1);
      }
    }, "call$0", "get$setUpRenderer", 0, 0, 54, "setUpRenderer"],
    update$1: [function(time) {
      this.time.update$1(time);
      if (this._paused !== true && this.pendingStep !== true) {
        if (this.stepping === true)
          this.pendingStep = true;
        this.scale.preUpdate$0();
        this.debug.preUpdate$0();
        this.physics.preUpdate$0();
        this.state.preUpdate$0();
        this.plugins.preUpdate$0();
        this.stage.preUpdate$0();
        this.state.update$0();
        this.stage.update$0();
        this.tweens.update$0();
        this.sound.update$0();
        this.input.update$0();
        this.physics.update$0();
        this.particles.update$0();
        this.plugins.update$0();
        this.stage.postUpdate$0();
        this.plugins.postUpdate$0();
      } else {
        this.state.pauseUpdate$0();
        this.debug.preUpdate$0();
      }
      if (!J.$eq(this.renderType, 3)) {
        this.state.preRender$0();
        this.renderer.render$1(this.stage);
        this.plugins.render$0();
        this.state.render$0();
        this.plugins.postRender$0();
        if (this.device.get$cocoonJS() === true && J.$eq(this.renderType, 1) && J.$eq(this.stage.get$currentRenderOrderID(), 1))
          J.fillRect$4$x(this.context, 0, 0, 0, 0);
      }
    }, "call$1", "get$update", 2, 0, 620, 727, [], "update"],
    enableStep$0: [function() {
      this.stepping = true;
      this.pendingStep = false;
      this.stepCount = 0;
    }, "call$0", "get$enableStep", 0, 0, 54, "enableStep"],
    disableStep$0: [function() {
      this.stepping = false;
      this.pendingStep = false;
    }, "call$0", "get$disableStep", 0, 0, 54, "disableStep"],
    step$0: [function(_) {
      this.pendingStep = false;
      this.stepCount = J.$add$ns(this.stepCount, 1);
    }, "call$0", "get$step", 0, 0, 54, "step"],
    destroy$0: [function() {
      J.stop$0$x(this.raf);
      this.state.destroy$0();
      this.sound.destroy$0();
      this.scale.destroy$0();
      this.stage.destroy$0();
      this.input.destroy$0();
      this.physics.destroy$0();
      this.state = null;
      this.cache = null;
      this.input = null;
      this.load = null;
      this.sound = null;
      this.stage = null;
      this.time = null;
      this.world = null;
      this.isBooted = false;
      J.remove$0$ax(this.canvas);
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    gamePaused$1: [function($event) {
      if (this._paused !== true) {
        this._paused = true;
        this.time.gamePaused$0();
        this.sound.setMute$0();
        this.onPause.dispatch$0();
      }
    }, "call$1", "get$gamePaused", 2, 0, 102, 666, [], "gamePaused"],
    gameResumed$1: [function($event) {
      if (this._paused === true && this._codePaused !== true) {
        this._paused = false;
        this.time.gameResumed$0();
        J.reset$0$x(this.input);
        this.sound.unsetMute$0();
        this.onResume.dispatch$0();
      }
    }, "call$1", "get$gameResumed", 2, 0, 102, 666, [], "gameResumed"],
    focusLoss$1: [function($event) {
      this.onBlur.dispatch$1($event);
      if (this.stage.get$disableVisibilityChange() !== true)
        this.gamePaused$1($event);
    }, "call$1", "get$focusLoss", 2, 0, 102, 666, [], "focusLoss"],
    focusGain$1: [function($event) {
      this.onFocus.dispatch$1($event);
      if (this.stage.get$disableVisibilityChange() !== true)
        this.gameResumed$1($event);
    }, "call$1", "get$focusGain", 2, 0, 102, 666, [], "focusGain"],
    Game$8: function(width, height, renderer, $parent, state, transparent, antialias, physicsConfig) {
      var t1, t2;
      t1 = $.get$GAMES();
      t1.push(this);
      this.id = t1.length - 1;
      this.config = null;
      this.physicsConfig = this.physicsConfig;
      this.parent = "";
      this.width = J.toInt$0$n(width);
      this.height = J.toInt$0$n(height);
      this.transparent = false;
      this.antialias = true;
      this.preserveDrawingBuffer = false;
      this.renderer = null;
      this.renderType = renderer;
      this.state = null;
      this.isBooted = false;
      this.isRunning = false;
      this.raf = null;
      this.add = null;
      this.make = null;
      this.cache = null;
      this.input = null;
      this.load = null;
      this.net = null;
      this.scale = null;
      this.sound = null;
      this.stage = null;
      this.time = null;
      this.tweens = null;
      this.world = null;
      this.physics = null;
      this.rnd = null;
      this.device = null;
      this.camera = null;
      this.canvas = null;
      this.context = null;
      this.debug = null;
      this.particles = null;
      this.stepping = false;
      this.pendingStep = false;
      this.stepCount = 0;
      this.onPause = null;
      this.onResume = null;
      this.onBlur = null;
      this.onFocus = null;
      this._paused = false;
      this._codePaused = false;
      this.config = P.LinkedHashMap_LinkedHashMap$_literal(["enableDebug", true], null, null);
      if (width != null)
        this.width = width;
      if (height != null)
        this.height = height;
      if (renderer != null)
        this.renderType = renderer;
      if ($parent != null)
        this.parent = $parent;
      t1 = this.transparent;
      if (t1 != null)
        this.transparent = t1;
      t1 = this.antialias;
      if (t1 != null)
        this.antialias = t1;
      t1 = Date.now();
      t2 = $.get$Math_random().call$0();
      if (typeof t2 !== "number")
        return H.iae(t2);
      C.JSNumber_methods.toString$0(t1 * t2);
      this.rnd = new R.RandomDataGenerator(1, 0, 0, 0);
      this.state = R.StateManager$(this, state);
      this._onBoot = new R.Game_closure(this);
      t2 = C.EventStreamProvider_load.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t2._target, t2._eventType, W._wrapZone(this._onBoot), t2._useCapture), [H.getTypeArgumentByIndex(t2, 0)])._tryResume$0();
      t2 = window;
      t1 = this._onBoot;
      if (t1 != null)
        C.Window_methods._addEventListener$3(t2, "load", t1, false);
      this.boot$0();
    },
    static: {Game$: [function(width, height, renderer, $parent, state, transparent, antialias, physicsConfig) {
        var t1 = new R.Game(null, null, null, null, null, transparent, antialias, physicsConfig, null, null, 0, false, false, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Game$8(width, height, renderer, $parent, state, transparent, antialias, physicsConfig);
        return t1;
      }, null, null, 0, 16, 293, 144, 145, 49, 259, 12, 12, 12, 12, 31, [], 52, [], 213, [], 84, [], 294, [], 147, [], 148, [], 295, [], "new Game"]}
  },
  "+Game": [674],
  Game_closure: {
    "^": "Closure:102;_this_0",
    call$1: [function(e) {
      return this._this_0.boot$0();
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  Group: {
    "^": "DisplayObjectContainer;game@-613,name*-644,addToStage@-617,enableBody@-617,physicsBodyType@-616,z*-614,type*-614,alive@-617,exists@-617,ignoreDestroy@-617,_Phaser$_dirty@-617,cursor*-12,cameraOffset@-615,_sortProperty@-644,enableBodyDebug@-617,_cache@-645,creator@-646,renderOrderID@-614,children:Phaser$Group$children*-647,autoCull@-617,events@-648,_anchor@-615,_Phaser$_currentBounds@-649,position:Phaser$Group$position*-615,onDestroy@-650,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 324, "parent"],
    creator$0: function() {
      return this.creator.call$0();
    },
    get$destroyPhase: [function() {
      return false;
    }, null, null, 1, 0, 247, "destroyPhase"],
    get$anchor: [function() {
      return this._anchor;
    }, null, null, 1, 0, 1010, "anchor"],
    set$anchor: [function(value) {
    }, null, null, 3, 0, 1011, 138, [], "anchor"],
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(this.get$x(this), J.$div$n(this.get$width(this), 2));
      t2 = J.$add$ns(this.get$y(this), J.$div$n(this.get$height(this), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1010, "center"],
    get$world: [function() {
      var t1, t2;
      t1 = M.DisplayObject.prototype.get$parent.call(this, this) == null || J.$eq(M.DisplayObject.prototype.get$parent.call(this, this), this);
      t2 = this.Phaser$Group$position;
      if (t1)
        return t2;
      else
        return J.$add$ns(t2, M.DisplayObject.prototype.get$parent.call(this, this).get$world());
    }, null, null, 1, 0, 1010, "world"],
    get$total: [function(_) {
      var t1 = J.where$1$ax(this.Phaser$Group$children, new R.Group_total_closure(this));
      return t1.get$length(t1);
    }, null, null, 1, 0, 412, "total"],
    get$length: [function(_) {
      return J.get$length$asx(this.Phaser$Group$children);
    }, null, null, 1, 0, 412, "length"],
    get$angle: [function(_) {
      return J.$mul$ns(this.rotation, 57.29577951308232);
    }, null, null, 1, 0, 619, "angle"],
    angle$0: function($receiver) {
      return this.get$angle(this).call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.get$angle(this).call$2(arg0, arg1);
    },
    set$angle: [function(_, value) {
      this.rotation = J.$mul$ns(value, 0.017453292519943295);
    }, null, null, 3, 0, 620, 138, [], "angle"],
    get$fixedToCamera: [function() {
      return J.$index$asx(this._cache, 7) == null ? false : J.$index$asx(this._cache, 7);
    }, null, null, 1, 0, 247, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.cameraOffset.set$2(this.get$x(this), this.get$y(this));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 639, 138, [], "fixedToCamera"],
    add$2: [function(_, child, silent) {
      var t1 = J.getInterceptor$x(child);
      if (!J.$eq(t1.get$parent(child), this)) {
        if (this.enableBody === true)
          J.enable$2$x(this.get$game().get$physics(), child, this.physicsBodyType);
        this.addChildAt$2(child, J.get$length$asx(this.Phaser$Group$children));
        t1.set$z(child, J.get$length$asx(this.Phaser$Group$children));
        if (silent !== true && child.get$events() != null)
          child.get$events().get$onAddedToGroup().dispatch$1([child, this]);
        if (this.cursor == null)
          this.cursor = child;
      }
      return child;
    }, function($receiver, child) {
      return this.add$2($receiver, child, false);
    }, "add$1", "call$2", "call$1", "get$add", 2, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "T__T__bool", ret: T, args: [T], opt: [P.bool]};
      }, this.$receiver, "Group");
    }, 19, 687, [], 1050, [], "add"],
    filter$2: [function(_, predicate, checkExists) {
      var $length, result, t1, index, child, t2;
      $length = J.get$length$asx(this.Phaser$Group$children);
      result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "Group", 0)]);
      t1 = checkExists === true;
      index = -1;
      while (true) {
        ++index;
        if (typeof $length !== "number")
          return H.iae($length);
        if (!(index < $length))
          break;
        child = J.$index$asx(this.Phaser$Group$children, index);
        if (t1)
          t2 = child.get$exists() === true;
        else
          t2 = true;
        if (t2)
          if (predicate.call$3(child, index, this.Phaser$Group$children) === true)
            result.push(child);
      }
      return result;
    }, function($receiver, predicate) {
      return this.filter$2($receiver, predicate, false);
    }, "filter$1", "call$2", "call$1", "get$filter", 2, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "List__Function__bool", ret: [P.List, T], args: [P.Function], opt: [P.bool]};
      }, this.$receiver, "Group");
    }, 19, 1051, [], 1052, [], "filter"],
    addMultiple$2: [function(children, silent) {
      var t1, i, t2;
      t1 = J.getInterceptor(children);
      if (!!t1.$isList) {
        i = 0;
        while (true) {
          t2 = t1.get$length(children);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          this.add$2(0, t1.$index(children, i), silent);
          ++i;
        }
      }
      return children;
    }, function(children) {
      return this.addMultiple$2(children, false);
    }, "addMultiple$1", "call$2", "call$1", "get$addMultiple", 2, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "List__List__bool", ret: [P.List, T], args: [[P.List, T]], opt: [P.bool]};
      }, this.$receiver, "Group");
    }, 19, 1025, [], 1050, [], "addMultiple"],
    addAt$3: [function(child, index, silent) {
      if (!J.$eq(J.get$parent$x(child), this)) {
        if (this.enableBody === true)
          J.enable$2$x(this.get$game().get$physics(), child, this.physicsBodyType);
        this.addChildAt$2(child, index);
        this.updateZ$0();
        if (silent !== true && child.get$events() != null)
          child.get$events().get$onAddedToGroup().dispatch$1([child, this]);
        if (this.cursor == null)
          this.cursor = child;
      }
      return child;
    }, function(child, index) {
      return this.addAt$3(child, index, false);
    }, "addAt$2", "call$3", "call$2", "get$addAt", 4, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "T__T_int__bool", ret: T, args: [T, P.$int], opt: [P.bool]};
      }, this.$receiver, "Group");
    }, 19, 687, [], 281, [], 1050, [], "addAt"],
    getAt$1: [function(index) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$ge(index, J.get$length$asx(this.Phaser$Group$children)))
        return;
      else
        return M.DisplayObjectContainer.prototype.getChildAt$1.call(this, index);
    }, "call$1", "get$getAt", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T__int", ret: T, args: [P.$int]};
      }, this.$receiver, "Group");
    }, 281, [], "getAt"],
    create$5: [function(x, y, key, frame, exists) {
      var child, t1;
      child = this.creator$0();
      t1 = J.getInterceptor$x(child);
      t1.set$x(child, x);
      t1.set$y(child, y);
      if (!!t1.$isSprite)
        child.loadTexture$2(key, frame);
      if (this.enableBody === true)
        J.enable$2$x(this.get$game().get$physics(), child, this.physicsBodyType);
      child.set$exists(exists);
      child.set$visible(exists);
      child.set$alive(exists);
      this.addChildAt$2(child, J.get$length$asx(this.Phaser$Group$children));
      t1.set$z(child, J.get$length$asx(this.Phaser$Group$children));
      if (child.get$events() != null)
        child.get$events().get$onAddedToGroup().dispatch$1([child, this]);
      if (this.cursor == null)
        this.cursor = child;
      return child;
    }, function(x) {
      return this.create$5(x, 0, null, 0, true);
    }, "create$1", function() {
      return this.create$5(0, 0, null, 0, true);
    }, "create$0", function(x, y, key, frame) {
      return this.create$5(x, y, key, frame, true);
    }, "create$4", function(x, y) {
      return this.create$5(x, y, null, 0, true);
    }, "create$2", function(x, y, key) {
      return this.create$5(x, y, key, 0, true);
    }, "create$3", "call$5", "call$1", "call$0", "call$4", "call$2", "call$3", "get$create", 0, 10, function() {
      return H.computeSignature(function(T) {
        return {func: "T___num_num_Object_dynamic_bool", ret: T, opt: [P.num, P.num, P.Object, null, P.bool]};
      }, this.$receiver, "Group");
    }, 49, 49, 12, 49, 78, 9, [], 10, [], 269, [], 216, [], 1053, [], "create"],
    createMultiple$4: [function(quantity, key, frame, exists) {
      var i;
      if (typeof quantity !== "number")
        return H.iae(quantity);
      i = 0;
      for (; i < quantity; ++i)
        this.create$5(0, 0, key, frame, exists);
    }, function(quantity) {
      return this.createMultiple$4(quantity, null, null, false);
    }, "createMultiple$1", function(quantity, key) {
      return this.createMultiple$4(quantity, key, null, false);
    }, "createMultiple$2", function(quantity, key, frame) {
      return this.createMultiple$4(quantity, key, frame, false);
    }, "createMultiple$3", "call$4", "call$1", "call$2", "call$3", "get$createMultiple", 2, 6, 1054, 12, 12, 19, 974, [], 269, [], 216, [], 1053, [], "createMultiple"],
    updateZ$0: [function() {
      var i, t1, i0;
      i = J.get$length$asx(this.Phaser$Group$children);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), !t1.$eq(i, 0); i = i0)
        J.set$z$x(J.$index$asx(this.Phaser$Group$children, i0), i0);
    }, "call$0", "get$updateZ", 0, 0, 54, "updateZ"],
    resetCursor$1: [function(index) {
      var t1;
      if (J.$gt$n(index, J.$sub$n(J.get$length$asx(this.Phaser$Group$children), 1)))
        index = 0;
      if (this.cursor != null) {
        J.$indexSet$ax(this._cache, 8, index);
        t1 = J.$index$asx(this.Phaser$Group$children, J.$index$asx(this._cache, 8));
        this.cursor = t1;
        return t1;
      }
    }, function() {
      return this.resetCursor$1(0);
    }, "resetCursor$0", "call$1", "call$0", "get$resetCursor", 0, 2, 973, 49, 281, [], "resetCursor"],
    next$0: [function() {
      var t1, t2;
      if (this.cursor != null) {
        t1 = J.$ge$n(J.$index$asx(this._cache, 8), J.$sub$n(J.get$length$asx(this.Phaser$Group$children), 1));
        t2 = this._cache;
        if (t1)
          J.$indexSet$ax(t2, 8, 0);
        else {
          t1 = J.getInterceptor$asx(t2);
          t1.$indexSet(t2, 8, J.$add$ns(t1.$index(t2, 8), 1));
        }
        t1 = J.$index$asx(this.Phaser$Group$children, J.$index$asx(this._cache, 8));
        this.cursor = t1;
        return t1;
      }
    }, "call$0", "get$next", 0, 0, 54, "next"],
    previous$0: [function() {
      var t1, t2;
      if (this.cursor != null) {
        t1 = J.$eq(J.$index$asx(this._cache, 8), 0);
        t2 = this._cache;
        if (t1)
          J.$indexSet$ax(t2, 8, J.$sub$n(J.get$length$asx(this.Phaser$Group$children), 1));
        else {
          t1 = J.getInterceptor$asx(t2);
          t1.$indexSet(t2, 8, J.$sub$n(t1.$index(t2, 8), 1));
        }
        t1 = J.$index$asx(this.Phaser$Group$children, J.$index$asx(this._cache, 8));
        this.cursor = t1;
        return t1;
      }
    }, "call$0", "get$previous", 0, 0, 54, "previous"],
    swap$2: [function(child1, child2) {
      this.swapChildren$2(child1, child2);
      this.updateZ$0();
    }, "call$2", "get$swap", 4, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T_T", args: [T, T]};
      }, this.$receiver, "Group");
    }, 1055, [], 690, [], "swap"],
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return H.subtypeOfRuntimeTypeCast(this, H.getRuntimeTypeArgument(this, "Group", 0));
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Group$children, child), J.get$length$asx(this.Phaser$Group$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Group$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$Group$children));
        }
        return child;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "T___T", ret: T, opt: [T]};
      }, this.$receiver, "Group");
    }, 12, 687, [], "bringToTop"],
    sendToBack$1: [function(child) {
      if (J.$eq(J.get$parent$x(child), this) && J.$gt$n(J.indexOf$1$asx(this.Phaser$Group$children, child), 0)) {
        this.remove$3(0, child, false, true);
        this.addAt$3(child, 0, true);
      }
      return child;
    }, "call$1", "get$sendToBack", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 687, [], "sendToBack"],
    moveUp$1: [function(child) {
      var b;
      if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Group$children, child), J.$sub$n(J.get$length$asx(this.Phaser$Group$children), 1))) {
        b = this.getAt$1(J.$add$ns(J.indexOf$1$asx(this.Phaser$Group$children, child), 1));
        if (b === true) {
          this.swapChildren$2(child, b);
          this.updateZ$0();
        }
      }
      return child;
    }, "call$1", "get$moveUp", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 687, [], "moveUp"],
    moveDown$1: [function(child) {
      var b;
      if (J.$eq(J.get$parent$x(child), this) && J.$gt$n(J.indexOf$1$asx(this.Phaser$Group$children, child), 0)) {
        b = this.getAt$1(J.$sub$n(J.indexOf$1$asx(this.Phaser$Group$children, child), 1));
        if (b === true) {
          this.swapChildren$2(child, b);
          this.updateZ$0();
        }
      }
      return child;
    }, "call$1", "get$moveDown", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 687, [], "moveDown"],
    xy$3: [function(index, x, y) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$gt(index, J.get$length$asx(this.Phaser$Group$children)))
        return -1;
      else {
        J.set$x$x(M.DisplayObjectContainer.prototype.getChildAt$1.call(this, index), x);
        J.set$y$x(M.DisplayObjectContainer.prototype.getChildAt$1.call(this, index), y);
      }
    }, "call$3", "get$xy", 6, 0, 1056, 281, [], 9, [], 10, [], "xy"],
    getChildAt$1: [function(index) {
      return M.DisplayObjectContainer.prototype.getChildAt$1.call(this, index);
    }, "call$1", "get$getChildAt", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T__int", ret: T, args: [P.$int]};
      }, this.$receiver, "Group");
    }, 281, [], "getChildAt"],
    reverse$0: [function() {
      this.Phaser$Group$children = J.toList$0$ax(J.get$reversed$ax(this.Phaser$Group$children));
      this.updateZ$0();
    }, "call$0", "get$reverse", 0, 0, 54, "reverse"],
    getIndex$1: [function(child) {
      return J.indexOf$1$asx(this.Phaser$Group$children, child);
    }, "call$1", "get$getIndex", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "int__T0", ret: P.$int, args: [T]};
      }, this.$receiver, "Group");
    }, 687, [], "getIndex"],
    replace$2: [function(_, oldChild, newChild) {
      var index, t1;
      index = J.indexOf$1$asx(this.Phaser$Group$children, oldChild);
      if (!J.$eq(index, -1)) {
        t1 = J.getInterceptor$x(newChild);
        if (t1.get$parent(newChild) != null) {
          newChild.get$events().get$onRemovedFromGroup().dispatch$1([newChild, this]);
          t1.get$parent(newChild).removeChild$1(newChild);
          if (!!J.getInterceptor(t1.get$parent(newChild)).$isGroup)
            H.interceptedTypeCast(t1.get$parent(newChild), "$isGroup").updateZ$0();
        }
        this.remove$1(0, oldChild);
        this.addAt$2(newChild, index);
        return oldChild;
      }
    }, "call$2", "get$replace", 4, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T_T", args: [T, T]};
      }, this.$receiver, "Group");
    }, 1057, [], 1058, [], "replace"],
    preUpdate$0: [function() {
      var i, t1, i0;
      if (this.exists !== true || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        this.renderOrderID = -1;
        return false;
      }
      i = J.get$length$asx(this.Phaser$Group$children);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this.Phaser$Group$children, i0).preUpdate$0();
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    update$0: [function() {
      var i, t1, i0;
      i = J.get$length$asx(this.Phaser$Group$children);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this.Phaser$Group$children, i0).update$0();
    }, "call$0", "get$update", 0, 0, 54, "update"],
    postUpdate$0: [function() {
      var i, t1, i0;
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        this.set$x(0, J.$add$ns(J.get$x$x(J.get$view$x(this.get$game().get$camera())), J.get$x$x(this.cameraOffset)));
        this.set$y(0, J.$add$ns(J.get$y$x(J.get$view$x(this.get$game().get$camera())), J.get$y$x(this.cameraOffset)));
      }
      i = J.get$length$asx(this.Phaser$Group$children);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this.Phaser$Group$children, i0).postUpdate$0();
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    forEach$2: [function(_, callback, checkExists) {
      var len, t1, i;
      len = J.get$length$asx(this.Phaser$Group$children);
      if (typeof len !== "number")
        return H.iae(len);
      t1 = J.getInterceptor(checkExists);
      i = 0;
      for (; i < len; ++i)
        if (t1.$eq(checkExists, false))
          callback.call$1(J.$index$asx(this.Phaser$Group$children, i));
        else if (J.$index$asx(this.Phaser$Group$children, i).get$exists() === true)
          callback.call$1(J.$index$asx(this.Phaser$Group$children, i));
    }, function($receiver, callback) {
      return this.forEach$2($receiver, callback, false);
    }, "forEach$1", "call$2", "call$1", "get$forEach", 2, 2, 1059, 19, 26, [], 1052, [], "forEach"],
    forEachExists$1: [function(callback) {
      J.where$1$ax(this.Phaser$Group$children, new R.Group_forEachExists_closure(this)).forEach$1(0, callback);
    }, "call$1", "get$forEachExists", 2, 0, 1060, 26, [], "forEachExists"],
    forEachAlive$1: [function(callback) {
      J.where$1$ax(this.Phaser$Group$children, new R.Group_forEachAlive_closure(this)).forEach$1(0, callback);
    }, "call$1", "get$forEachAlive", 2, 0, 1060, 26, [], "forEachAlive"],
    forEachDead$1: [function(callback) {
      J.where$1$ax(this.Phaser$Group$children, new R.Group_forEachDead_closure(this)).forEach$1(0, callback);
    }, "call$1", "get$forEachDead", 2, 0, 1060, 26, [], "forEachDead"],
    sort$2: [function(_, index, order) {
      var t1, t2;
      if (J.$lt$n(J.get$length$asx(this.Phaser$Group$children), 2))
        return;
      if (index == null)
        index = "z";
      if (order == null)
        order = $.Group_SORT_ASCENDING;
      this._sortProperty = index;
      t1 = J.$eq(order, $.Group_SORT_ASCENDING);
      t2 = this.Phaser$Group$children;
      if (t1)
        J.sort$1$ax(t2, this.get$ascendingSortHandler());
      else
        J.sort$1$ax(t2, this.get$descendingSortHandler());
      this.updateZ$0();
    }, function($receiver, index) {
      return this.sort$2($receiver, index, null);
    }, "sort$1", function($receiver) {
      return this.sort$2($receiver, null, null);
    }, "sort$0", "call$2", "call$1", "call$0", "get$sort", 0, 4, 1061, 12, 12, 281, [], 1062, [], "sort"],
    customSort$1: [function(sortHandler) {
      if (J.$lt$n(J.get$length$asx(this.Phaser$Group$children), 2))
        return;
      J.sort$1$ax(this.Phaser$Group$children, sortHandler);
      this.updateZ$0();
    }, "call$1", "get$customSort", 2, 0, 1060, 1063, [], "customSort"],
    ascendingSortHandler$2: [function(a, b) {
      var va, vb, t1;
      va = H.reflect(a).getField$1(new H.Symbol(H.Symbol_validatePublicSymbol(this._sortProperty))).get$reflectee();
      vb = H.reflect(b).getField$1(new H.Symbol(H.Symbol_validatePublicSymbol(this._sortProperty))).get$reflectee();
      t1 = J.getInterceptor$n(va);
      if (t1.$lt(va, vb))
        return -1;
      else if (t1.$gt(va, vb))
        return 1;
      else
        return 0;
    }, "call$2", "get$ascendingSortHandler", 4, 0, 1064, 348, [], 349, [], "ascendingSortHandler"],
    descendingSortHandler$2: [function(a, b) {
      var va, vb, t1;
      va = H.reflect(a).getField$1(new H.Symbol(H.Symbol_validatePublicSymbol(this._sortProperty))).get$reflectee();
      vb = H.reflect(b).getField$1(new H.Symbol(H.Symbol_validatePublicSymbol(this._sortProperty))).get$reflectee();
      t1 = J.getInterceptor$n(va);
      if (t1.$lt(va, vb))
        return 1;
      else if (t1.$gt(va, vb))
        return -1;
      else
        return 0;
    }, "call$2", "get$descendingSortHandler", 4, 0, 1064, 348, [], 349, [], "descendingSortHandler"],
    getFirst$1: [function(where) {
      return J.firstWhere$2$orElse$ax(this.Phaser$Group$children, where, new R.Group_getFirst_closure());
    }, function() {
      return this.getFirst$1(null);
    }, "getFirst$0", "call$1", "call$0", "get$getFirst", 0, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "T___SelectWhere", ret: T, opt: [{func: "bool__dynamic", ret: P.bool, args: [null]}]};
      }, this.$receiver, "Group");
    }, 12, 1065, [], "getFirst"],
    getFirstExists$1: [function(state) {
      return J.firstWhere$2$orElse$ax(this.Phaser$Group$children, new R.Group_getFirstExists_closure(this, state), new R.Group_getFirstExists_closure0());
    }, function() {
      return this.getFirstExists$1(true);
    }, "getFirstExists$0", "call$1", "call$0", "get$getFirstExists", 0, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "T___bool", ret: T, opt: [P.bool]};
      }, this.$receiver, "Group");
    }, 78, 294, [], "getFirstExists"],
    getFirstAlive$0: [function() {
      return J.firstWhere$2$orElse$ax(this.Phaser$Group$children, new R.Group_getFirstAlive_closure(this), new R.Group_getFirstAlive_closure0());
    }, "call$0", "get$getFirstAlive", 0, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T_", ret: T};
      }, this.$receiver, "Group");
    }, "getFirstAlive"],
    getFirstDead$0: [function() {
      return J.firstWhere$2$orElse$ax(this.Phaser$Group$children, new R.Group_getFirstDead_closure(this), new R.Group_getFirstDead_closure0());
    }, "call$0", "get$getFirstDead", 0, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T_", ret: T};
      }, this.$receiver, "Group");
    }, "getFirstDead"],
    getTop$0: [function() {
      var t1, t2;
      if (J.$gt$n(J.get$length$asx(this.Phaser$Group$children), 0)) {
        t1 = this.Phaser$Group$children;
        t2 = J.getInterceptor$asx(t1);
        return t2.$index(t1, J.$sub$n(t2.get$length(t1), 1));
      }
      return;
    }, "call$0", "get$getTop", 0, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T_", ret: T};
      }, this.$receiver, "Group");
    }, "getTop"],
    getBottom$0: [function() {
      if (J.$gt$n(J.get$length$asx(this.Phaser$Group$children), 0))
        return J.$index$asx(this.Phaser$Group$children, 0);
      return;
    }, "call$0", "get$getBottom", 0, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T_", ret: T};
      }, this.$receiver, "Group");
    }, "getBottom"],
    countLiving$0: [function() {
      var t1 = J.where$1$ax(this.Phaser$Group$children, new R.Group_countLiving_closure(this));
      return t1.get$length(t1);
    }, "call$0", "get$countLiving", 0, 0, 412, "countLiving"],
    countDead$0: [function() {
      var t1 = J.where$1$ax(this.Phaser$Group$children, new R.Group_countDead_closure(this));
      return t1.get$length(t1);
    }, "call$0", "get$countDead", 0, 0, 412, "countDead"],
    getRandom$2: [function(startIndex, $length) {
      if (J.$eq(J.get$length$asx(this.Phaser$Group$children), 0))
        return;
      if ($length == null)
        $length = J.get$length$asx(this.Phaser$Group$children);
      return R.Math_getRandom(this.Phaser$Group$children, startIndex, $length);
    }, function(startIndex) {
      return this.getRandom$2(startIndex, null);
    }, "getRandom$1", function() {
      return this.getRandom$2(0, null);
    }, "getRandom$0", "call$2", "call$1", "call$0", "get$getRandom", 0, 4, function() {
      return H.computeSignature(function(T) {
        return {func: "T___int_int", ret: T, opt: [P.$int, P.$int]};
      }, this.$receiver, "Group");
    }, 49, 12, 430, [], 431, [], "getRandom"],
    remove$3: [function(_, child, destroy, silent) {
      var removed;
      if (J.$eq(J.get$length$asx(this.Phaser$Group$children), 0) || J.$eq(J.indexOf$1$asx(this.Phaser$Group$children, child), -1))
        return false;
      if (silent !== true && child.get$events() != null && !child.get$destroyPhase())
        child.get$events().get$onRemovedFromGroup().dispatch$1([child, this]);
      removed = this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Group$children, child));
      this.updateZ$0();
      if (J.$eq(this.cursor, child))
        this.next$0();
      if (destroy === true && removed != null)
        removed.destroy$1(true);
      return true;
    }, function($receiver, child) {
      return this.remove$3($receiver, child, false, false);
    }, "remove$1", function($receiver, child, destroy) {
      return this.remove$3($receiver, child, destroy, false);
    }, "remove$2", "call$3", "call$1", "call$2", "get$remove", 2, 4, function() {
      return H.computeSignature(function(T) {
        return {func: "bool__T__bool_bool", ret: P.bool, args: [T], opt: [P.bool, P.bool]};
      }, this.$receiver, "Group");
    }, 19, 19, 687, [], 1066, [], 1050, [], "remove"],
    removeAll$2: [function(destroy, silent) {
      var t1, t2, t3, removed;
      if (J.$eq(J.get$length$asx(this.Phaser$Group$children), 0))
        return;
      t1 = destroy === true;
      t2 = silent !== true;
      do {
        if (t2 && J.$index$asx(this.Phaser$Group$children, 0).get$events() != null)
          J.$index$asx(this.Phaser$Group$children, 0).get$events().get$onRemovedFromGroup().dispatch$1([J.$index$asx(this.Phaser$Group$children, 0), this]);
        t3 = J.$index$asx(this.Phaser$Group$children, 0);
        removed = this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Group$children, t3));
        if (t1 && removed != null)
          removed.destroy$1(true);
      } while (J.$gt$n(J.get$length$asx(this.Phaser$Group$children), 0));
      this.cursor = null;
    }, function() {
      return this.removeAll$2(false, false);
    }, "removeAll$0", function(destroy) {
      return this.removeAll$2(destroy, false);
    }, "removeAll$1", "call$2", "call$0", "call$1", "get$removeAll", 0, 4, 970, 19, 19, 1066, [], 1050, [], "removeAll"],
    removeBetween$4: [function(startIndex, endIndex, destroy, silent) {
      var t1, t2, i, t3, t4, removed;
      if (endIndex == null)
        endIndex = J.$sub$n(J.get$length$asx(this.Phaser$Group$children), 1);
      if (J.$eq(J.get$length$asx(this.Phaser$Group$children), 0))
        return;
      t1 = J.getInterceptor$n(startIndex);
      if (t1.$gt(startIndex, endIndex) || t1.$lt(startIndex, 0) || J.$gt$n(endIndex, J.get$length$asx(this.Phaser$Group$children)))
        return;
      for (t1 = destroy === true, t2 = silent !== true, i = endIndex; t3 = J.getInterceptor$n(i), t3.$ge(i, startIndex);) {
        if (t2 && J.$index$asx(this.Phaser$Group$children, i).get$events() != null)
          J.$index$asx(this.Phaser$Group$children, i).get$events().get$onRemovedFromGroup().dispatch$1([J.$index$asx(this.Phaser$Group$children, i), this]);
        t4 = J.$index$asx(this.Phaser$Group$children, i);
        removed = this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Group$children, t4));
        if (t1 && removed != null)
          removed.destroy$1(true);
        if (J.$eq(this.cursor, J.$index$asx(this.Phaser$Group$children, i)))
          this.cursor = null;
        i = t3.$sub(i, 1);
      }
      this.updateZ$0();
    }, function(startIndex) {
      return this.removeBetween$4(startIndex, null, false, false);
    }, "removeBetween$1", function(startIndex, endIndex) {
      return this.removeBetween$4(startIndex, endIndex, false, false);
    }, "removeBetween$2", function(startIndex, endIndex, destroy) {
      return this.removeBetween$4(startIndex, endIndex, destroy, false);
    }, "removeBetween$3", "call$4", "call$1", "call$2", "call$3", "get$removeBetween", 2, 6, 1067, 12, 19, 19, 430, [], 1068, [], 1066, [], 1050, [], "removeBetween"],
    destroy$2: [function(destroyChildren, soft) {
      if (this.get$game() == null || this.ignoreDestroy === true)
        return;
      this.onDestroy.dispatch$1([destroyChildren, soft]);
      this.removeAll$1(destroyChildren);
      this.cursor = null;
      this.set$filters(null);
      if (soft !== true) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).removeChild$1(this);
        this.set$game(null);
        this.exists = false;
      }
    }, function() {
      return this.destroy$2(true, false);
    }, "destroy$0", function(destroyChildren) {
      return this.destroy$2(destroyChildren, false);
    }, "destroy$1", "call$2", "call$0", "call$1", "get$destroy", 0, 4, 970, 78, 19, 1069, [], 1070, [], "destroy"],
    getBounds$1: [function(matrix) {
      return new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.DisplayObjectContainer.prototype.getBounds$1.call(this, null));
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 1071, 12, 580, [], "getBounds"],
    Group$6: function(game, $parent, $name, addToStage, enableBody, physicsBodyType, $T) {
      var t1;
      this.set$game(game);
      if (this.addToStage === true)
        this.get$game().get$stage().addChild$1(this);
      else if ($parent != null)
        J.add$1$ax($parent, this);
      else if (this.get$game().get$world() != null)
        this.get$game().get$world().addChild$1(this);
      this.z = 0;
      this.type = 7;
      this.alive = true;
      this.exists = true;
      this.ignoreDestroy = false;
      this.creator = new R.Group_closure(this);
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this.set$scale(0, t1);
      this.cursor = null;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.cameraOffset = t1;
      this.enableBody = this.enableBody;
      this.enableBodyDebug = false;
      this.physicsBodyType = this.physicsBodyType;
      this.onDestroy = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [{func: "dynamic__bool_bool", args: [P.bool, P.bool]}]);
      this._sortProperty = "z";
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0, 0];
    },
    $isGroup: true,
    $isGameObject: true,
    "<>": [3],
    static: {"^": "Group_RETURN_NONE@-614,Group_RETURN_TOTAL@-614,Group_RETURN_CHILD@-614,Group_SORT_ASCENDING@-614,Group_SORT_DESCENDING@-614", Group$: [function(game, $parent, $name, addToStage, enableBody, physicsBodyType, $T) {
        var t1, t2, t3, t4, t5;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = H.setRuntimeTypeInfo(new R.Group(null, $name, addToStage, enableBody, physicsBodyType, null, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, t1, null, t2, null, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0), [$T]);
        t5.Group$6(game, $parent, $name, addToStage, enableBody, physicsBodyType, $T);
        return t5;
      }, null, null, 2, 10, 296, 12, 297, 19, 19, 49, 252, [], 84, [], 83, [], 298, [], 299, [], 300, [], "new Group"]}
  },
  "+Group": [706, 2],
  Group_closure: {
    "^": "Closure:54;this_0",
    call$0: [function() {
      return R.Sprite$(this.this_0.get$game(), 0, 0, null, 0, null);
    }, "call$0", null, 0, 0, 54, "call"]
  },
  Group_total_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$exists();
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 687, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_forEachExists_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$exists();
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 687, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_forEachAlive_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$alive();
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 687, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_forEachDead_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$alive() !== true;
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 687, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_getFirst_closure: {
    "^": "Closure:54;",
    call$0: [function() {
      return;
    }, "call$0", null, 0, 0, 54, "call"]
  },
  Group_getFirstExists_closure: {
    "^": "Closure;this_0,state_1",
    call$1: [function(child) {
      return J.$eq(child.get$exists(), this.state_1);
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 687, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_getFirstExists_closure0: {
    "^": "Closure:54;",
    call$0: [function() {
      return;
    }, "call$0", null, 0, 0, 54, "call"]
  },
  Group_getFirstAlive_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$alive();
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 687, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_getFirstAlive_closure0: {
    "^": "Closure:54;",
    call$0: [function() {
      return;
    }, "call$0", null, 0, 0, 54, "call"]
  },
  Group_getFirstDead_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$alive() !== true;
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 687, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_getFirstDead_closure0: {
    "^": "Closure:54;",
    call$0: [function() {
      return;
    }, "call$0", null, 0, 0, 54, "call"]
  },
  Group_countLiving_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$alive();
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 687, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_countDead_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$alive() !== true;
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 687, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Plugin: {
    "^": "Object;game@-613,parent*-1039,active@-617,visible@-617,hasPreUpdate@-617,hasUpdate@-617,hasPostUpdate@-617,hasRender@-617,hasPostRender@-617",
    preUpdate$0: [function() {
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 54, "update"],
    render$0: [function() {
    }, "call$0", "get$render", 0, 0, 54, "render"],
    postRender$0: [function() {
    }, "call$0", "get$postRender", 0, 0, 54, "postRender"],
    postUpdate$0: [function() {
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    destroy$0: [function() {
      this.game = null;
      this.parent = null;
      this.active = false;
      this.visible = false;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    Plugin$2: function(game, $parent) {
      this.active = false;
      this.visible = false;
      this.hasPreUpdate = false;
      this.hasUpdate = false;
      this.hasPostUpdate = false;
      this.hasRender = false;
      this.hasPostRender = false;
    },
    static: {Plugin$: [function(game, $parent) {
        var t1 = new R.Plugin(game, $parent, null, null, null, null, null, null, null);
        t1.Plugin$2(game, $parent);
        return t1;
      }, null, null, 4, 0, 301, 252, [], 84, [], "new Plugin"]}
  },
  "+Plugin": [674],
  PluginManager: {
    "^": "Object;game@-613,plugins@-1072,_len@-614,_i@-614",
    add$2: [function(_, plugin, args) {
      plugin.set$game(this.game);
      J.set$parent$x(plugin, this);
      if (plugin.get$hasPreUpdate() === true || plugin.get$hasUpdate() === true || plugin.get$hasPostUpdate() === true)
        plugin.set$active(true);
      if (plugin.get$hasRender() === true || plugin.get$hasPostRender() === true)
        plugin.set$visible(true);
      J.add$1$ax(this.plugins, plugin);
      this._len = J.get$length$asx(this.plugins);
      return plugin;
    }, function($receiver, plugin) {
      return this.add$2($receiver, plugin, null);
    }, "add$1", "call$2", "call$1", "get$add", 2, 2, 1073, 12, 1074, [], 383, [], "add"],
    remove$1: [function(_, plugin) {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$eq(J.$index$asx(this.plugins, this._i), plugin)) {
          plugin.destroy$0();
          J.removeAt$1$ax(this.plugins, this._i);
          this._len = J.$sub$n(this._len, 1);
          return;
        }
    }, "call$1", "get$remove", 2, 0, 1075, 1074, [], "remove"],
    removeAll$0: [function() {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        J.$index$asx(this.plugins, this._i).destroy$0();
      J.clear$0$ax(this.plugins);
      this._len = 0;
    }, "call$0", "get$removeAll", 0, 0, 54, "removeAll"],
    preUpdate$0: [function() {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this.plugins, this._i).get$active() === true && J.$index$asx(this.plugins, this._i).get$hasPreUpdate() === true)
          J.$index$asx(this.plugins, this._i).preUpdate$0();
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    update$0: [function() {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this.plugins, this._i).get$active() === true && J.$index$asx(this.plugins, this._i).get$hasUpdate() === true)
          J.$index$asx(this.plugins, this._i).update$0();
    }, "call$0", "get$update", 0, 0, 54, "update"],
    postUpdate$0: [function() {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this.plugins, this._i).get$active() === true && J.$index$asx(this.plugins, this._i).get$hasPostUpdate() === true)
          J.$index$asx(this.plugins, this._i).postUpdate$0();
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    render$0: [function() {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this.plugins, this._i).get$visible() === true && J.$index$asx(this.plugins, this._i).get$hasRender() === true)
          J.$index$asx(this.plugins, this._i).render$0();
    }, "call$0", "get$render", 0, 0, 54, "render"],
    postRender$0: [function() {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this.plugins, this._i).get$visible() === true && J.$index$asx(this.plugins, this._i).get$hasPostRender() === true)
          J.$index$asx(this.plugins, this._i).postRender$0();
    }, "call$0", "get$postRender", 0, 0, 54, "postRender"],
    destroy$0: [function() {
      this.removeAll$0();
      this.game = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    PluginManager$1: function(game) {
      this.plugins = [];
      this._len = 0;
      this._i = 0;
    },
    static: {PluginManager$: [function(game) {
        var t1 = new R.PluginManager(game, null, null, null);
        t1.PluginManager$1(game);
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new PluginManager"]}
  },
  "+PluginManager": [674],
  ScaleManager: {
    "^": "Object;game@-613,width*-616,height*-616,minWidth*-616,maxWidth*-616,minHeight*-616,maxHeight*-616,forceLandscape@-617,forcePortrait@-617,incorrectOrientation@-617,pageAlignHorizontally@-617,pageAlignVertically@-617,maxIterations@-614,enterLandscape@-1076,enterPortrait@-1076,enterIncorrectOrientation@-1049,leaveIncorrectOrientation@-1049,fullScreenTarget@-1077,enterFullScreen@-1076,leaveFullScreen@-1076,orientation*-614,scaleFactor@-615,scaleFactorInversed@-615,margin*-615,bounds@-649,aspectRatio*-671,sourceAspectRatio@-671,event@-12,fullScreenScaleMode@-614,_startHeight@-616,_width@-616,_height@-616,_check@-1078,offset*-615,isFullScreen@-617,_iterations@-614,isLandscape@-617,parentIsWindow@-617,parentNode*-12,parentScaleFactor@-615,trackParentInterval@-616,onResize*-0,_scaleMode@-614,scaleMode@-616,_nextParentCheck@-616,_parentBounds@-12,_checkOrientation@-0,_checkResize@-0,_fullScreenChange@-0,isPortrait@-617,grid*-12",
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    onResize$2: function($receiver, arg0, arg1) {
      return this.onResize.call$2(arg0, arg1);
    },
    parseConfig$1: [function(config) {
      var t1 = J.getInterceptor$x(config);
      if (t1.containsKey$1(config, "scaleMode") === true)
        this.scaleMode = t1.$index(config, "scaleMode");
      if (t1.containsKey$1(config, "fullScreenScaleMode") === true)
        this.fullScreenScaleMode = t1.$index(config, "fullScreenScaleMode");
      if (t1.containsKey$1(config, "fullScreenTarget") === true)
        this.fullScreenTarget = t1.$index(config, "fullScreenTarget");
    }, "call$1", "get$parseConfig", 2, 0, 665, 466, [], "parseConfig"],
    setupScale$2: [function(width, height) {
      var rect, t1, target;
      rect = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      if (!J.$eq(J.get$parent$x(this.game), "")) {
        t1 = J.get$parent$x(this.game);
        if (typeof t1 === "string")
          target = document.getElementById(J.get$parent$x(this.game));
        else
          target = !!J.getInterceptor(J.get$parent$x(this.game)).$isHtmlElement && H.interceptedTypeCast(J.get$parent$x(this.game), "$isHtmlElement").nodeType === 1 ? J.get$parent$x(this.game) : null;
      } else
        target = null;
      if (target == null) {
        this.parentNode = null;
        this.parentIsWindow = true;
        rect.Phaser$Rectangle1$width = window.innerWidth;
        rect.Phaser$Rectangle1$height = window.innerHeight;
      } else {
        this.parentNode = target;
        this.parentIsWindow = false;
        t1 = J.getBoundingClientRect$0$x(target);
        this._parentBounds = t1;
        rect.Phaser$Rectangle1$width = J.get$width$x(t1);
        rect.Phaser$Rectangle1$height = J.get$height$x(this._parentBounds);
        this.offset.set$2(J.get$left$x(this._parentBounds), J.get$top$x(this._parentBounds));
      }
      t1 = new R.FlexGrid(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, []);
      t1.FlexGrid$3(this, width, height);
      this.grid = t1;
      this.updateDimensions$3(width, height, false);
    }, "call$2", "get$setupScale", 4, 0, 149, 31, [], 52, [], "setupScale"],
    boot$0: [function() {
      var t1, t2;
      this.fullScreenTarget = J.get$canvas$x(this.game);
      t1 = new R.ScaleManager_boot_closure(this);
      this._checkOrientation = t1;
      this._checkResize = new R.ScaleManager_boot_closure0(this);
      this._fullScreenChange = new R.ScaleManager_boot_closure1(this);
      t2 = window;
      C.Window_methods._addEventListener$3(t2, "orientationchange", t1, false);
      t1 = window;
      t2 = this._checkResize;
      if (t2 != null)
        C.Window_methods._addEventListener$3(t1, "resize", t2, false);
      if (this.game.get$device().get$cocoonJS() !== true) {
        t1 = document;
        t2 = this._fullScreenChange;
        if (t2 != null)
          C.HtmlDocument_methods._addEventListener$3(t1, "webkitfullscreenchange", t2, false);
        t1 = document;
        t2 = this._fullScreenChange;
        if (t2 != null)
          C.HtmlDocument_methods._addEventListener$3(t1, "mozfullscreenchange", t2, false);
        t1 = document;
        t2 = this._fullScreenChange;
        if (t2 != null)
          C.HtmlDocument_methods._addEventListener$3(t1, "fullscreenchange", t2, false);
      }
      this.updateDimensions$3(this.width, this.height, true);
      R.Canvas_getOffset(J.get$canvas$x(this.game), this.offset);
      this.bounds.setTo$4(J.get$x$x(this.offset), J.get$y$x(this.offset), this.width, this.height);
    }, "call$0", "get$boot", 0, 0, 54, "boot"],
    setResizeCallback$1: [function(callback) {
      this.onResize = callback;
    }, "call$1", "get$setResizeCallback", 2, 0, 102, 26, [], "setResizeCallback"],
    setMinMax$4: [function(minWidth, minHeight, maxWidth, maxHeight) {
      this.minWidth = minWidth;
      this.minHeight = minHeight;
      if (maxWidth != null)
        this.maxWidth = maxWidth;
      if (maxHeight != null)
        this.maxHeight = maxHeight;
    }, function(minWidth, minHeight) {
      return this.setMinMax$4(minWidth, minHeight, null, null);
    }, "setMinMax$2", function(minWidth, minHeight, maxWidth) {
      return this.setMinMax$4(minWidth, minHeight, maxWidth, null);
    }, "setMinMax$3", "call$4", "call$2", "call$3", "get$setMinMax", 4, 4, 625, 12, 12, 1079, [], 1080, [], 1081, [], 1082, [], "setMinMax"],
    preUpdate$0: [function() {
      var t1, t2;
      if (J.$lt$n(J.get$now$x(this.game.get$time()), this._nextParentCheck))
        return;
      if (this.parentIsWindow !== true) {
        R.Canvas_getOffset(J.get$canvas$x(this.game), this.offset);
        if (J.$eq(this._scaleMode, 3)) {
          t1 = J.getBoundingClientRect$0$x(this.parentNode);
          this._parentBounds = t1;
          t1 = J.get$width$x(t1);
          t2 = this.width;
          if ((t1 == null ? t2 != null : t1 !== t2) || !J.$eq(J.get$height$x(this._parentBounds), this.height))
            this.updateDimensions$3(J.get$width$x(this._parentBounds), J.get$height$x(this._parentBounds), true);
        }
      }
      this._nextParentCheck = J.$add$ns(J.get$now$x(this.game.get$time()), this.trackParentInterval);
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    updateDimensions$3: [function(width, height, resize) {
      this.width = J.$mul$ns(width, J.get$x$x(this.parentScaleFactor));
      this.height = J.$mul$ns(height, J.get$y$x(this.parentScaleFactor));
      J.set$width$x(this.game, this.width);
      J.set$height$x(this.game, this.height);
      this.sourceAspectRatio = J.$div$n(this.width, this.height);
      J.set$width$x(this.bounds, this.width);
      J.set$height$x(this.bounds, this.height);
      if (resize === true) {
        J.resize$2$x(this.game.get$renderer(), this.width, this.height);
        this.game.get$camera().setSize$2(this.width, this.height);
        J.resize$2$x(this.game.get$world(), this.width, this.height);
      }
      J.onResize$2$x(this.grid, width, height);
      if (this.onResize != null)
        this.onResize$2(0, this.width, this.height);
      J.resize$2$x(J.get$state$x(this.game), width, height);
    }, "call$3", "get$updateDimensions", 6, 0, 155, 31, [], 52, [], 1083, [], "updateDimensions"],
    forceOrientation$2: [function(forceLandscape, forcePortrait) {
      if (forcePortrait == null)
        forcePortrait = false;
      this.forceLandscape = forceLandscape;
      this.forcePortrait = forcePortrait;
    }, "call$2", "get$forceOrientation", 4, 0, 959, 1084, [], 1085, [], "forceOrientation"],
    checkOrientationState$0: [function() {
      var t1, t2;
      if (this.incorrectOrientation === true) {
        if (this.forceLandscape === true) {
          t1 = window.innerWidth;
          t2 = window.innerHeight;
          if (typeof t1 !== "number")
            return t1.$gt();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = t1 > t2;
          t1 = t2;
        } else
          t1 = false;
        if (!t1)
          if (this.forcePortrait === true) {
            t1 = window.innerHeight;
            t2 = window.innerWidth;
            if (typeof t1 !== "number")
              return t1.$gt();
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t1 > t2;
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = true;
        if (t1) {
          this.incorrectOrientation = false;
          this.leaveIncorrectOrientation.dispatch$0();
          if (!J.$eq(this.scaleMode, 1))
            this.refresh$0();
        }
      } else {
        if (this.forceLandscape === true) {
          t1 = window.innerWidth;
          t2 = window.innerHeight;
          if (typeof t1 !== "number")
            return t1.$lt();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = t1 < t2;
          t1 = t2;
        } else
          t1 = false;
        if (!t1)
          if (this.forcePortrait === true) {
            t1 = window.innerHeight;
            t2 = window.innerWidth;
            if (typeof t1 !== "number")
              return t1.$lt();
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t1 < t2;
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = true;
        if (t1) {
          this.incorrectOrientation = true;
          this.enterIncorrectOrientation.dispatch$0();
          if (!J.$eq(this.scaleMode, 1))
            this.refresh$0();
        }
      }
    }, "call$0", "get$checkOrientationState", 0, 0, 54, "checkOrientationState"],
    checkOrientation$1: [function($event) {
      var t1;
      this.event = $event;
      t1 = window.orientation;
      this.orientation = t1;
      if (this.isLandscape === true)
        this.enterLandscape.dispatch$1([t1, true, false]);
      else
        this.enterPortrait.dispatch$1([t1, false, true]);
      if (!J.$eq(this.scaleMode, 1))
        this.refresh$0();
    }, "call$1", "get$checkOrientation", 2, 0, 102, 666, [], "checkOrientation"],
    checkResize$1: [function($event) {
      var t1;
      this.event = $event;
      t1 = this.isLandscape === true;
      if (t1 && this.isPortrait === true) {
        this.enterPortrait.dispatch$1([this.orientation, false, true]);
        if (this.forceLandscape === true)
          this.enterIncorrectOrientation.dispatch$0();
        else if (this.forcePortrait === true)
          this.leaveIncorrectOrientation.dispatch$0();
      } else if (!t1 && t1) {
        this.enterLandscape.dispatch$1([this.orientation, true, false]);
        if (this.forceLandscape === true)
          this.leaveIncorrectOrientation.dispatch$0();
        else if (this.forcePortrait === true)
          this.enterIncorrectOrientation.dispatch$0();
      }
      if (J.$eq(this._scaleMode, 3) && this.parentIsWindow === true)
        this.updateDimensions$3(window.innerWidth, window.innerHeight, true);
      else if (J.$eq(this._scaleMode, 0) || J.$eq(this._scaleMode, 2)) {
        this.refresh$0();
        this.checkOrientationState$0();
        if (this.onResize != null)
          this.onResize$2(0, this.width, this.height);
      }
    }, function() {
      return this.checkResize$1(null);
    }, "checkResize$0", "call$1", "call$0", "get$checkResize", 0, 2, 944, 12, 666, [], "checkResize"],
    refresh$0: [function() {
      if (J.$eq(this.scaleMode, 3))
        return;
      if (this.game.get$device().get$iPad() !== true && this.game.get$device().get$webApp() !== true && this.game.get$device().get$desktop() !== true)
        if (this.game.get$device().get$android() === true && this.game.get$device().get$chrome() !== true)
          C.Window_methods.scrollTo$2(window, 0, 1);
        else
          C.Window_methods.scrollTo$2(window, 0, 0);
      if (this._check == null && J.$gt$n(this.maxIterations, 0)) {
        this._iterations = this.maxIterations;
        this._check = P.Timer_Timer$periodic(C.Duration_10000, new R.ScaleManager_refresh_closure(this));
        this.setScreenSize$0();
      }
    }, "call$0", "get$refresh", 0, 0, 54, "refresh"],
    setScreenSize$1: [function(force) {
      var t1, t2, t3;
      if (J.$eq(this.scaleMode, 3))
        return;
      if (this.game.get$device().get$iPad() !== true && this.game.get$device().get$webApp() !== true && this.game.get$device().get$desktop() !== true)
        if (this.game.get$device().get$android() === true && this.game.get$device().get$chrome() !== true)
          C.Window_methods.scrollTo$2(window, 0, 1);
        else
          C.Window_methods.scrollTo$2(window, 0, 0);
      t1 = J.$sub$n(this._iterations, 1);
      this._iterations = t1;
      if (force === true || J.$lt$n(t1, 0)) {
        J.set$minHeight$x(document.documentElement.style, J.toString$0(window.innerHeight) + "px");
        if (this.incorrectOrientation === true) {
          this.width = window.innerWidth;
          this.height = window.innerHeight;
        } else if (this.isFullScreen !== true) {
          if (J.$eq(this.scaleMode, 0))
            this.setExactFit$0();
          else if (J.$eq(this.scaleMode, 2))
            this.setShowAll$0();
        } else if (J.$eq(this.fullScreenScaleMode, 0))
          this.setExactFit$0();
        else if (J.$eq(this.fullScreenScaleMode, 2))
          this.setShowAll$0();
        if (this.incorrectOrientation !== true) {
          t1 = this.maxWidth;
          if (t1 != null && J.$gt$n(this.width, t1))
            this.width = this.maxWidth;
          t1 = this.maxHeight;
          if (t1 != null && J.$gt$n(this.height, t1))
            this.height = this.maxHeight;
          t1 = this.minWidth;
          if (t1 != null && J.$lt$n(this.width, t1))
            this.width = this.minWidth;
          t1 = this.minHeight;
          if (t1 != null && J.$lt$n(this.height, t1))
            this.height = this.minHeight;
        }
        J.set$width$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(this.width), "px"));
        J.set$height$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(this.height), "px"));
        J.get$scale$x(this.game.get$input()).setTo$2(J.$div$n(J.get$width$x(this.game), this.width), J.$div$n(J.get$height$x(this.game), this.height));
        if (this.pageAlignHorizontally === true) {
          t1 = J.$lt$n(this.width, window.innerWidth) && this.incorrectOrientation !== true;
          t2 = this.margin;
          if (t1) {
            t1 = window.innerWidth;
            t3 = this.width;
            if (typeof t1 !== "number")
              return t1.$sub();
            if (typeof t3 !== "number")
              return H.iae(t3);
            J.set$x$x(t2, C.JSNumber_methods.round$0((t1 - t3) / 2));
            J.set$marginLeft$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(J.get$x$x(this.margin)), "px"));
          } else {
            J.set$x$x(t2, 0);
            J.set$marginLeft$x(J.get$style$x(J.get$canvas$x(this.game)), "0px");
          }
        }
        if (this.pageAlignVertically === true) {
          t1 = J.$lt$n(this.height, window.innerHeight) && this.incorrectOrientation !== true;
          t2 = this.margin;
          if (t1) {
            t1 = window.innerHeight;
            t3 = this.height;
            if (typeof t1 !== "number")
              return t1.$sub();
            if (typeof t3 !== "number")
              return H.iae(t3);
            J.set$y$x(t2, C.JSNumber_methods.round$0((t1 - t3) / 2));
            J.set$marginTop$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(J.get$y$x(this.margin)), "px"));
          } else {
            J.set$y$x(t2, 0);
            J.set$marginTop$x(J.get$style$x(J.get$canvas$x(this.game)), "0px");
          }
        }
        R.Canvas_getOffset(J.get$canvas$x(this.game), this.offset);
        this.bounds.setTo$4(J.get$x$x(this.offset), J.get$y$x(this.offset), this.width, this.height);
        this.aspectRatio = J.$div$n(this.width, this.height);
        J.set$x$x(this.scaleFactor, J.$div$n(J.get$width$x(this.game), this.width));
        J.set$y$x(this.scaleFactor, J.$div$n(J.get$height$x(this.game), this.height));
        J.set$x$x(this.scaleFactorInversed, J.$div$n(this.width, J.get$width$x(this.game)));
        J.set$y$x(this.scaleFactorInversed, J.$div$n(this.height, J.get$height$x(this.game)));
        this.checkOrientationState$0();
        t1 = this._check;
        if (t1 != null) {
          t1.cancel$0();
          this._check = null;
        }
      }
    }, function() {
      return this.setScreenSize$1(false);
    }, "setScreenSize$0", "call$1", "call$0", "get$setScreenSize", 0, 2, 956, 19, 1086, [], "setScreenSize"],
    setSize$0: [function() {
      var t1, t2, t3;
      if (this.incorrectOrientation !== true) {
        t1 = this.maxWidth;
        if (t1 != null && J.$gt$n(this.width, t1))
          this.width = this.maxWidth;
        t1 = this.maxHeight;
        if (t1 != null && J.$gt$n(this.height, t1))
          this.height = this.maxHeight;
        t1 = this.minWidth;
        if (t1 != null && J.$lt$n(this.width, t1))
          this.width = this.minWidth;
        t1 = this.minHeight;
        if (t1 != null && J.$lt$n(this.height, t1))
          this.height = this.minHeight;
      }
      J.set$width$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(this.width), "px"));
      J.set$height$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(this.height), "px"));
      J.get$scale$x(this.game.get$input()).setTo$2(J.$div$n(J.get$width$x(this.game), this.width), J.$div$n(J.get$height$x(this.game), this.height));
      if (this.pageAlignHorizontally === true) {
        t1 = J.$lt$n(this.width, window.innerWidth) && this.incorrectOrientation !== true;
        t2 = this.margin;
        if (t1) {
          t1 = window.innerWidth;
          t3 = this.width;
          if (typeof t1 !== "number")
            return t1.$sub();
          if (typeof t3 !== "number")
            return H.iae(t3);
          J.set$x$x(t2, C.JSNumber_methods.round$0((t1 - t3) / 2));
          J.set$marginLeft$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(J.get$x$x(this.margin)), "px"));
        } else {
          J.set$x$x(t2, 0);
          J.set$marginLeft$x(J.get$style$x(J.get$canvas$x(this.game)), "0px");
        }
      }
      if (this.pageAlignVertically === true) {
        t1 = J.$lt$n(this.height, window.innerHeight) && this.incorrectOrientation !== true;
        t2 = this.margin;
        if (t1) {
          t1 = window.innerHeight;
          t3 = this.height;
          if (typeof t1 !== "number")
            return t1.$sub();
          if (typeof t3 !== "number")
            return H.iae(t3);
          J.set$y$x(t2, C.JSNumber_methods.round$0((t1 - t3) / 2));
          J.set$marginTop$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(J.get$y$x(this.margin)), "px"));
        } else {
          J.set$y$x(t2, 0);
          J.set$marginTop$x(J.get$style$x(J.get$canvas$x(this.game)), "0px");
        }
      }
      R.Canvas_getOffset(J.get$canvas$x(this.game), this.offset);
      this.bounds.setTo$4(J.get$x$x(this.offset), J.get$y$x(this.offset), this.width, this.height);
      this.aspectRatio = J.$div$n(this.width, this.height);
      J.set$x$x(this.scaleFactor, J.$div$n(J.get$width$x(this.game), this.width));
      J.set$y$x(this.scaleFactor, J.$div$n(J.get$height$x(this.game), this.height));
      J.set$x$x(this.scaleFactorInversed, J.$div$n(this.width, J.get$width$x(this.game)));
      J.set$y$x(this.scaleFactorInversed, J.$div$n(this.height, J.get$height$x(this.game)));
      this.checkOrientationState$0();
    }, "call$0", "get$setSize", 0, 0, 54, "setSize"],
    reset$1: [function(_, clearWorld) {
      if (clearWorld === true)
        J.reset$0$x(this.grid);
    }, "call$1", "get$reset", 2, 0, 639, 1087, [], "reset"],
    setMaximum$0: [function() {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
    }, "call$0", "get$setMaximum", 0, 0, 54, "setMaximum"],
    setShowAll$0: [function() {
      var t1, t2, t3, t4, multiplier;
      t1 = window.innerHeight;
      t2 = J.get$height$x(this.game);
      if (typeof t1 !== "number")
        return t1.$div();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = window.innerWidth;
      t4 = J.get$width$x(this.game);
      if (typeof t3 !== "number")
        return t3.$div();
      if (typeof t4 !== "number")
        return H.iae(t4);
      multiplier = P.min(t1 / t2, t3 / t4);
      this.width = J.round$0$n(J.$mul$ns(J.get$width$x(this.game), multiplier));
      this.height = J.round$0$n(J.$mul$ns(J.get$height$x(this.game), multiplier));
    }, "call$0", "get$setShowAll", 0, 0, 54, "setShowAll"],
    setExactFit$0: [function() {
      var availableWidth, availableHeight, t1, t2;
      availableWidth = window.innerWidth;
      availableHeight = window.innerHeight;
      t1 = this.maxWidth;
      if (t1 != null) {
        if (typeof availableWidth !== "number")
          return availableWidth.$gt();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = availableWidth > t1;
      } else
        t2 = false;
      if (t2)
        this.width = t1;
      else
        this.width = availableWidth;
      t1 = this.maxHeight;
      if (t1 != null) {
        if (typeof availableHeight !== "number")
          return availableHeight.$gt();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = availableHeight > t1;
      } else
        t2 = false;
      if (t2)
        this.height = t1;
      else
        this.height = availableHeight;
    }, "call$0", "get$setExactFit", 0, 0, 54, "setExactFit"],
    startFullScreen$1: [function(antialias) {
      if (this.isFullScreen === true || this.game.get$device().get$fullscreen() !== true)
        return;
      if (antialias != null && J.$eq(this.game.get$renderType(), 1))
        this.game.get$stage().set$smoothed(antialias);
      this._width = this.width;
      this._height = this.height;
      J.requestFullscreen$0$x(this.fullScreenTarget);
    }, function() {
      return this.startFullScreen$1(null);
    }, "startFullScreen$0", "call$1", "call$0", "get$startFullScreen", 0, 2, 956, 12, 148, [], "startFullScreen"],
    stopFullScreen$0: [function() {
      document.webkitExitFullscreen();
    }, "call$0", "get$stopFullScreen", 0, 0, 54, "stopFullScreen"],
    fullScreenChange$1: [function($event) {
      this.event = $event;
      if (this.isFullScreen === true) {
        if (J.$eq(this.fullScreenScaleMode, 0)) {
          J.set$width$x(J.get$style$x(this.fullScreenTarget), "100%");
          J.set$height$x(J.get$style$x(this.fullScreenTarget), "100%");
          this.width = window.outerWidth;
          this.height = window.outerHeight;
          J.get$scale$x(this.game.get$input()).setTo$2(J.$div$n(J.get$width$x(this.game), this.width), J.$div$n(J.get$height$x(this.game), this.height));
          this.aspectRatio = J.$div$n(this.width, this.height);
          J.set$x$x(this.scaleFactor, J.$div$n(J.get$width$x(this.game), this.width));
          J.set$y$x(this.scaleFactor, J.$div$n(J.get$height$x(this.game), this.height));
          this.checkResize$0();
        } else if (J.$eq(this.fullScreenScaleMode, 2)) {
          this.setShowAll$0();
          this.refresh$0();
        }
        this.enterFullScreen.dispatch$1([this.width, this.height]);
      } else {
        J.set$width$x(J.get$style$x(this.fullScreenTarget), J.$add$ns(J.toString$0(J.get$width$x(this.game)), "px"));
        J.set$height$x(J.get$style$x(this.fullScreenTarget), J.$add$ns(J.toString$0(J.get$height$x(this.game)), "px"));
        this.width = this._width;
        this.height = this._height;
        J.get$scale$x(this.game.get$input()).setTo$2(J.$div$n(J.get$width$x(this.game), this.width), J.$div$n(J.get$height$x(this.game), this.height));
        this.aspectRatio = J.$div$n(this.width, this.height);
        J.set$x$x(this.scaleFactor, J.$div$n(J.get$width$x(this.game), this.width));
        J.set$y$x(this.scaleFactor, J.$div$n(J.get$height$x(this.game), this.height));
        this.leaveFullScreen.dispatch$1([this.width, this.height]);
      }
    }, "call$1", "get$fullScreenChange", 2, 0, 102, 666, [], "fullScreenChange"],
    destroy$0: [function() {
      var t1, t2;
      t1 = window;
      t2 = this._checkOrientation;
      if (t2 != null)
        C.Window_methods._removeEventListener$3(t1, "orientationchange", t2, false);
      t1 = window;
      t2 = this._checkResize;
      if (t2 != null)
        C.Window_methods._removeEventListener$3(t1, "resize", t2, false);
      if (this.game.get$device().get$cocoonJS() !== true) {
        t1 = document;
        t2 = this._fullScreenChange;
        if (t2 != null)
          C.HtmlDocument_methods._removeEventListener$3(t1, "webkitfullscreenchange", t2, false);
        t1 = document;
        t2 = this._fullScreenChange;
        if (t2 != null)
          C.HtmlDocument_methods._removeEventListener$3(t1, "mozfullscreenchange", t2, false);
        t1 = document;
        t2 = this._fullScreenChange;
        if (t2 != null)
          C.HtmlDocument_methods._removeEventListener$3(t1, "fullscreenchange", t2, false);
      }
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    ScaleManager$3: function(game, width, height) {
      var t1, t2, rect, target;
      this.game = game;
      this.grid = null;
      this.width = 0;
      this.height = 0;
      this.minWidth = null;
      this.maxWidth = null;
      this.minHeight = null;
      this.maxHeight = null;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.offset = t1;
      this.forceLandscape = false;
      this.forcePortrait = false;
      this.incorrectOrientation = false;
      this.pageAlignHorizontally = false;
      this.pageAlignVertically = false;
      this.maxIterations = 5;
      this.enterLandscape = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.enterPortrait = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.enterIncorrectOrientation = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.leaveIncorrectOrientation = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.fullScreenTarget = null;
      this.enterFullScreen = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.leaveFullScreen = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.orientation = 0;
      this.orientation = window.orientation;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this.scaleFactor = t1;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this.scaleFactorInversed = t1;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.margin = t1;
      this.bounds = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      this.aspectRatio = 0;
      this.sourceAspectRatio = 0;
      this.event = null;
      this.fullScreenScaleMode = 1;
      this.parentIsWindow = false;
      this.parentNode = null;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this.parentScaleFactor = t1;
      this.trackParentInterval = 2000;
      this.onResize = null;
      this._scaleMode = 1;
      this._width = 0;
      this._height = 0;
      this._check = null;
      this._nextParentCheck = 0;
      this._parentBounds = null;
      if (game.get$config() != null) {
        t1 = game.get$config();
        t2 = J.getInterceptor$x(t1);
        if (t2.containsKey$1(t1, "scaleMode") === true)
          this.scaleMode = t2.$index(t1, "scaleMode");
        if (t2.containsKey$1(t1, "fullScreenScaleMode") === true)
          this.fullScreenScaleMode = t2.$index(t1, "fullScreenScaleMode");
        if (t2.containsKey$1(t1, "fullScreenTarget") === true)
          this.fullScreenTarget = t2.$index(t1, "fullScreenTarget");
      }
      rect = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      if (!J.$eq(J.get$parent$x(this.game), "")) {
        t1 = J.get$parent$x(this.game);
        if (typeof t1 === "string")
          target = document.getElementById(J.get$parent$x(this.game));
        else
          target = !!J.getInterceptor(J.get$parent$x(this.game)).$isHtmlElement && H.interceptedTypeCast(J.get$parent$x(this.game), "$isHtmlElement").nodeType === 1 ? J.get$parent$x(this.game) : null;
      } else
        target = null;
      if (target == null) {
        this.parentNode = null;
        this.parentIsWindow = true;
        rect.Phaser$Rectangle1$width = window.innerWidth;
        rect.Phaser$Rectangle1$height = window.innerHeight;
      } else {
        this.parentNode = target;
        this.parentIsWindow = false;
        t1 = J.getBoundingClientRect$0$x(target);
        this._parentBounds = t1;
        rect.Phaser$Rectangle1$width = J.get$width$x(t1);
        rect.Phaser$Rectangle1$height = J.get$height$x(this._parentBounds);
        this.offset.set$2(J.get$left$x(this._parentBounds), J.get$top$x(this._parentBounds));
      }
      t1 = new R.FlexGrid(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, []);
      t1.FlexGrid$3(this, width, height);
      this.grid = t1;
      this.updateDimensions$3(width, height, false);
    },
    static: {"^": "ScaleManager_EXACT_FIT<-614,ScaleManager_NO_SCALE<-614,ScaleManager_SHOW_ALL<-614,ScaleManager_RESIZE<-614", ScaleManager$: [function(game, width, height) {
        var t1 = new R.ScaleManager(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, 1, null, null, null, null, null, false, 0, false, null, null, null, null, null, null, null, null, null, null, null, null, true, null);
        t1.ScaleManager$3(game, width, height);
        return t1;
      }, null, null, 6, 0, 303, 252, [], 31, [], 52, [], "new ScaleManager"]}
  },
  "+ScaleManager": [674],
  ScaleManager_boot_closure: {
    "^": "Closure:102;_this_0",
    call$1: [function($event) {
      var t1, t2;
      t1 = this._this_0;
      t1.event = $event;
      t2 = window.orientation;
      t1.orientation = t2;
      if (t1.isLandscape === true)
        t1.enterLandscape.dispatch$1([t2, true, false]);
      else
        t1.enterPortrait.dispatch$1([t2, false, true]);
      if (!J.$eq(t1.scaleMode, 1))
        t1.refresh$0();
      return;
    }, "call$1", null, 2, 0, 102, 666, [], "call"]
  },
  ScaleManager_boot_closure0: {
    "^": "Closure:102;_this_1",
    call$1: [function($event) {
      return this._this_1.checkResize$1($event);
    }, "call$1", null, 2, 0, 102, 666, [], "call"]
  },
  ScaleManager_boot_closure1: {
    "^": "Closure:102;_this_2",
    call$1: [function($event) {
      var t1 = this._this_2;
      t1.event = $event;
      if (t1.isFullScreen === true) {
        if (J.$eq(t1.fullScreenScaleMode, 0)) {
          J.set$width$x(J.get$style$x(t1.fullScreenTarget), "100%");
          J.set$height$x(J.get$style$x(t1.fullScreenTarget), "100%");
          t1.width = window.outerWidth;
          t1.height = window.outerHeight;
          J.get$scale$x(t1.game.get$input()).setTo$2(J.$div$n(J.get$width$x(t1.game), t1.width), J.$div$n(J.get$height$x(t1.game), t1.height));
          t1.aspectRatio = J.$div$n(t1.width, t1.height);
          J.set$x$x(t1.scaleFactor, J.$div$n(J.get$width$x(t1.game), t1.width));
          J.set$y$x(t1.scaleFactor, J.$div$n(J.get$height$x(t1.game), t1.height));
          t1.checkResize$0();
        } else if (J.$eq(t1.fullScreenScaleMode, 2)) {
          t1.setShowAll$0();
          t1.refresh$0();
        }
        t1.enterFullScreen.dispatch$1([t1.width, t1.height]);
      } else {
        J.set$width$x(J.get$style$x(t1.fullScreenTarget), J.$add$ns(J.toString$0(J.get$width$x(t1.game)), "px"));
        J.set$height$x(J.get$style$x(t1.fullScreenTarget), J.$add$ns(J.toString$0(J.get$height$x(t1.game)), "px"));
        t1.width = t1._width;
        t1.height = t1._height;
        J.get$scale$x(t1.game.get$input()).setTo$2(J.$div$n(J.get$width$x(t1.game), t1.width), J.$div$n(J.get$height$x(t1.game), t1.height));
        t1.aspectRatio = J.$div$n(t1.width, t1.height);
        J.set$x$x(t1.scaleFactor, J.$div$n(J.get$width$x(t1.game), t1.width));
        J.set$y$x(t1.scaleFactor, J.$div$n(J.get$height$x(t1.game), t1.height));
        t1.leaveFullScreen.dispatch$1([t1.width, t1.height]);
      }
      return;
    }, "call$1", null, 2, 0, 102, 666, [], "call"]
  },
  ScaleManager_refresh_closure: {
    "^": "Closure:102;_this_0",
    call$1: [function(t) {
      return this._this_0.setScreenSize$0();
    }, "call$1", null, 2, 0, 102, 423, [], "call"]
  },
  SignalBinding: {
    "^": "Object;_listener@-0,_isOnce@-617,_priority@-614,_signal@-1088,active@-617,params@-645",
    _listener$0: function() {
      return this._listener.call$0();
    },
    execute$1: [function(params) {
      var t1, handlerReturn;
      if (this.active === true && this._listener != null) {
        t1 = this.params;
        if (t1 == null)
          this.params = params;
        else
          J.addAll$1$ax(t1, params);
        handlerReturn = params != null && !J.$eq(J.get$length$asx(params), 0) ? H.Primitives_applyFunction(this._listener, params, P.Function__toMangledNames(null)) : this._listener$0();
        if (this._isOnce === true)
          if (this.isBound$0())
            J.remove$1$ax(this._signal, this._listener);
      } else
        handlerReturn = null;
      return handlerReturn;
    }, "call$1", "get$execute", 2, 0, 55, 1089, [], "execute"],
    detach$0: [function() {
      return this.isBound$0() ? J.remove$1$ax(this._signal, this._listener) : null;
    }, "call$0", "get$detach", 0, 0, 54, "detach"],
    isBound$0: [function() {
      return this._signal != null && this._listener != null;
    }, "call$0", "get$isBound", 0, 0, 54, "isBound"],
    isOnce$0: [function() {
      return this._isOnce;
    }, "call$0", "get$isOnce", 0, 0, 54, "isOnce"],
    getListener$0: [function() {
      return this._listener;
    }, "call$0", "get$getListener", 0, 0, 54, "getListener"],
    getSignal$0: [function() {
      return this._signal;
    }, "call$0", "get$getSignal", 0, 0, 54, "getSignal"],
    _destroy$0: [function() {
      this._signal = null;
      this._listener = null;
    }, "call$0", "get$_destroy", 0, 0, 54, "_destroy"],
    toString$0: [function(_) {
      return "[Phaser.SignalBinding isOnce: " + H.S(this._isOnce) + ", isBound:" + this.isBound$0() + ", active:" + H.S(this.active) + "]";
    }, "call$0", "get$toString", 0, 0, 810, "toString"],
    $isSignalBinding: true,
    static: {SignalBinding$_: [function(_signal, _listener, _isOnce, _priority) {
        var t1 = new R.SignalBinding(_listener, _isOnce, _priority, _signal, true, null);
        if (_priority == null)
          t1._priority = 0;
        return t1;
      }, null, null, 4, 4, 304, 19, 49, 305, [], 306, [], 307, [], 308, [], "new SignalBinding$_"]}
  },
  "+SignalBinding": [674],
  Stage: {
    "^": "Stage0;game@-613,offset*-615,bounds@-649,name*-644,disableVisibilityChange@-617,checkOffsetInterval@-616,exists@-617,currentRenderOrderID@-616,_hiddenVar@-644,_nextOffsetCheck@-616,_backgroundColor@-614,_onChange@-0,scaleModel@-891,fullScreenScaleMode@-617,scaleMode@-891,parent*-2,z*-614,fixedToCamera@-617,anchor@-615,world@-615,_Phaser$_currentBounds@-649,type*-614,_cache@-645,events@-648,classType@-1090,renderOrderID@-614,cameraOffset@-615,autoCull@-617,alive@-617,_Phaser$_dirty@-617,children:Phaser$Stage$children*-1091,PIXI$Stage0$_dirty-617,_interactiveEventsAdded-617,PIXI$Stage0$hitArea-659,backgroundColor-614,backgroundColorSplit-709,backgroundColorString-644,PIXI$Stage0$_worldTransform-658,interactionManager-710,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.position), J.$div$n(J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.getLocalBounds$0())), 2));
      t2 = J.$add$ns(J.get$y$x(this.position), J.$div$n(J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.getLocalBounds$0())), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1010, "center"],
    get$destroyPhase: [function() {
      return false;
    }, null, null, 1, 0, 247, "destroyPhase"],
    bringToTop$1: [function(child) {
      var t1;
      if (child == null) {
        t1 = this.parent;
        if (t1 != null)
          t1.bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Stage$children, child), J.get$length$asx(this.Phaser$Stage$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Stage$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$Stage$children));
        }
        return child;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1092, 12, 687, [], "bringToTop"],
    get$backgroundColor: [function(_) {
      return this._backgroundColor;
    }, null, null, 1, 0, 412, "backgroundColor"],
    set$backgroundColor: [function(_, value) {
      if (this.game.get$transparent() !== true)
        this.setBackgroundColor$1(value);
    }, null, null, 3, 0, 99, 138, [], "backgroundColor"],
    get$smoothed: [function() {
      return true;
    }, null, null, 1, 0, 247, "smoothed"],
    set$smoothed: [function(value) {
    }, null, null, 3, 0, 639, 138, [], "smoothed"],
    parseConfig$1: [function(config) {
      var t1 = J.getInterceptor$x(config);
      if (t1.containsKey$1(config, "disableVisibilityChange") === true)
        this.disableVisibilityChange = t1.$index(config, "disableVisibilityChange");
      if (t1.containsKey$1(config, "backgroundColor") === true) {
        t1 = t1.$index(config, "backgroundColor");
        if (this.game.get$transparent() !== true)
          this.setBackgroundColor$1(t1);
      }
    }, "call$1", "get$parseConfig", 2, 0, 665, 466, [], "parseConfig"],
    boot$0: [function() {
      var t1, t2;
      R.Canvas_getOffset(J.get$canvas$x(this.game), this.offset);
      this._onChange = new R.Stage_boot_closure(this);
      t1 = J.get$canvas$x(this.game);
      t2 = J.getInterceptor$x(t1);
      J.set$userSelect$x(t2.get$style(t1), "none");
      J.set$tapHighlightColor$x(t2.get$style(t1), "rgba(0, 0, 0, 0)");
      J.set$touchAction$x(J.get$style$x(J.get$canvas$x(this.game)), "none");
      if (this.game.get$device().get$cocoonJS() === true)
        ;
      this._hiddenVar = "visibilitychange";
      t1 = document;
      t2 = this._onChange;
      if (t2 != null)
        C.HtmlDocument_methods._addEventListener$3(t1, "visibilitychange", t2, false);
      t1 = C.EventStreamProvider_pagehide.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = C.EventStreamProvider_pageshow.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = C.EventStreamProvider_blur.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = C.EventStreamProvider_focus.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    }, "call$0", "get$boot", 0, 0, 54, "boot"],
    preUpdate$0: [function() {
      var len, i;
      this.currentRenderOrderID = 0;
      len = J.get$length$asx(this.Phaser$Stage$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Stage$children, i).preUpdate$0();
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    update$0: [function() {
      var i, t1, i0;
      i = J.get$length$asx(this.Phaser$Stage$children);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this.Phaser$Stage$children, i0).update$0();
    }, "call$0", "get$update", 0, 0, 54, "update"],
    postUpdate$0: [function() {
      var t1, t2, i, i0;
      t1 = J.get$target$x(this.game.get$world().get$camera());
      t2 = this.game;
      if (t1 != null) {
        J.get$target$x(t2.get$world().get$camera()).postUpdate$0();
        this.game.get$world().get$camera().update$0();
        i = J.get$length$asx(this.Phaser$Stage$children);
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          if (!J.$eq(J.$index$asx(this.Phaser$Stage$children, i0), J.get$target$x(this.game.get$world().get$camera())))
            J.$index$asx(this.Phaser$Stage$children, i0).postUpdate$0();
      } else {
        t2.get$world().get$camera().update$0();
        i = J.get$length$asx(this.Phaser$Stage$children);
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          J.$index$asx(this.Phaser$Stage$children, i0).postUpdate$0();
      }
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    checkVisibility$0: [function() {
      var t1, t2;
      if (this.game.get$device().get$cocoonJS() === true)
        ;
      this._hiddenVar = "visibilitychange";
      t1 = document;
      t2 = this._onChange;
      if (t2 != null)
        C.HtmlDocument_methods._addEventListener$3(t1, "visibilitychange", t2, false);
      t1 = C.EventStreamProvider_pagehide.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = C.EventStreamProvider_pageshow.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = C.EventStreamProvider_blur.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = C.EventStreamProvider_focus.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    }, "call$0", "get$checkVisibility", 0, 0, 54, "checkVisibility"],
    visibilityChange$1: [function($event) {
      var t1, t2;
      t1 = J.getInterceptor$x($event);
      if (J.$eq(t1.get$type($event), "pagehide") || J.$eq(t1.get$type($event), "blur") || J.$eq(t1.get$type($event), "pageshow") || J.$eq(t1.get$type($event), "focus")) {
        if (J.$eq(t1.get$type($event), "pagehide") || J.$eq(t1.get$type($event), "blur"))
          this.game.focusLoss$1($event);
        else if (J.$eq(t1.get$type($event), "pageshow") || J.$eq(t1.get$type($event), "focus"))
          this.game.focusGain$1($event);
        return;
      }
      if (this.disableVisibilityChange === true)
        return;
      t1 = document.webkitHidden;
      t2 = this.game;
      if (t1 === true)
        t2.gamePaused$1($event);
      else
        t2.gameResumed$1($event);
    }, "call$1", "get$visibilityChange", 2, 0, 102, 666, [], "visibilityChange"],
    setBackgroundColor$1: [function(backgroundColor) {
      var rgb, t1, t2, t3;
      if (typeof backgroundColor === "string") {
        rgb = R.Color_hexToColor(backgroundColor, null);
        t1 = J.get$r$x(rgb);
        t2 = rgb.get$g();
        t3 = rgb.get$b();
        t1 = J.$shl$n(t1, 16);
        t2 = J.$shl$n(t2, 8);
        if (typeof t3 !== "number")
          return H.iae(t3);
        this._backgroundColor = (t1 | t2 | t3) >>> 0;
      } else {
        rgb = R.Color_getRGB(backgroundColor);
        this._backgroundColor = backgroundColor;
      }
      t1 = J.getInterceptor$x(rgb);
      this.backgroundColorSplit = [J.$div$n(t1.get$r(rgb), 255), J.$div$n(rgb.get$g(), 255), J.$div$n(rgb.get$b(), 255)];
      this.backgroundColorString = R.Color_RGBtoString(t1.get$r(rgb), rgb.get$g(), rgb.get$b(), 255, "#");
    }, "call$1", "get$setBackgroundColor", 2, 0, 102, 79, [], "setBackgroundColor"],
    destroy$1: [function(destroyChildren) {
      var t1, t2, t3;
      t1 = this._hiddenVar;
      if (t1 != null) {
        t2 = document;
        t3 = this._onChange;
        if (t3 != null)
          C.HtmlDocument_methods._removeEventListener$3(t2, t1, t3, false);
      }
    }, function() {
      return this.destroy$1(true);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 956, 78, 1069, [], "destroy"],
    Stage$1: function(game) {
      var t1, t2;
      this.name = "_stage_root";
      this.set$interactive(false);
      this.disableVisibilityChange = false;
      this.exists = true;
      this.currentRenderOrderID = 0;
      this._hiddenVar = "hidden";
      this._backgroundColor = 0;
      if (this.game.get$config() != null) {
        t1 = this.game.get$config();
        t2 = J.getInterceptor$x(t1);
        if (t2.containsKey$1(t1, "disableVisibilityChange") === true)
          this.disableVisibilityChange = t2.$index(t1, "disableVisibilityChange");
        if (t2.containsKey$1(t1, "backgroundColor") === true) {
          t1 = t2.$index(t1, "backgroundColor");
          if (this.game.get$transparent() !== true)
            this.setBackgroundColor$1(t1);
        }
      }
    },
    $isGameObject: true,
    static: {Stage$0: [function(game) {
        var t1, t2, t3, t4, t5;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new Float32Array(H._checkLength(9));
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = new R.Stage(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t1, null, null, null, null, null, null, null, null, null, false, [], null, false, new M.Rectangle0(0, 0, 100000, 100000), 0, [], null, new M.Matrix(1, 0, 0, 1, 0, 0, t2), null, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t5.Stage$2(0, true);
        t5.Stage$1(game);
        return t5;
      }, null, null, 2, 0, 302, 252, [], "new Stage"]}
  },
  "+Stage": [657, 2],
  Stage_boot_closure: {
    "^": "Closure:102;this_0",
    call$1: [function($event) {
      return this.this_0.visibilityChange$1($event);
    }, "call$1", null, 2, 0, 102, 666, [], "call"]
  },
  State: {
    "^": "Object;game@-613,add*-1032,make@-1033,camera@-1046,cache@-1034,input@-1035,math@-1093,load*-1036,sound@-1038,scale*-1022,stage@-1040,time@-1041,tweens@-1043,world@-1008,particles@-1048,physics@-1042,rnd@-1044,state*-1030",
    add$2: function($receiver, arg0, arg1) {
      return this.add.call$2(arg0, arg1);
    },
    add$1: function($receiver, arg0) {
      return this.add.call$1(arg0);
    },
    add$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.add.call$4(arg0, arg1, arg2, arg3);
    },
    add$3: function($receiver, arg0, arg1, arg2) {
      return this.add.call$3(arg0, arg1, arg2);
    },
    add$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.add.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    load$0: function($receiver) {
      return this.load.call$0();
    },
    load$1: function($receiver, arg0) {
      return this.load.call$1(arg0);
    },
    load$2: function($receiver, arg0, arg1) {
      return this.load.call$2(arg0, arg1);
    },
    sound$2: function(arg0, arg1) {
      return this.sound.call$2(arg0, arg1);
    },
    sound$3: function(arg0, arg1, arg2) {
      return this.sound.call$3(arg0, arg1, arg2);
    },
    sound$4: function(arg0, arg1, arg2, arg3) {
      return this.sound.call$4(arg0, arg1, arg2, arg3);
    },
    sound$1: function(arg0) {
      return this.sound.call$1(arg0);
    },
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    physics$4: function(arg0, arg1, arg2, arg3) {
      return this.physics.call$4(arg0, arg1, arg2, arg3);
    },
    rnd$0: function() {
      return this.rnd.call$0();
    },
    preload$0: [function(_) {
    }, "call$0", "get$preload", 0, 0, 54, "preload"],
    loadUpdate$0: [function() {
    }, "call$0", "get$loadUpdate", 0, 0, 54, "loadUpdate"],
    loadRender$0: [function() {
    }, "call$0", "get$loadRender", 0, 0, 54, "loadRender"],
    create$0: [function() {
    }, "call$0", "get$create", 0, 0, 54, "create"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 54, "update"],
    render$0: [function() {
    }, "call$0", "get$render", 0, 0, 54, "render"],
    resize$0: [function(_) {
    }, "call$0", "get$resize", 0, 0, 54, "resize"],
    paused$0: [function(_) {
    }, "call$0", "get$paused", 0, 0, 54, "paused"],
    pauseUpdate$0: [function() {
    }, "call$0", "get$pauseUpdate", 0, 0, 54, "pauseUpdate"],
    shutdown$0: [function() {
    }, "call$0", "get$shutdown", 0, 0, 54, "shutdown"],
    preRender$0: [function() {
    }, "call$0", "get$preRender", 0, 0, 54, "preRender"],
    resumed$0: [function() {
    }, "call$0", "get$resumed", 0, 0, 54, "resumed"],
    init$1: [function(args) {
    }, function() {
      return this.init$1(null);
    }, "init$0", "call$1", "call$0", "get$init", 0, 2, 944, 12, 383, [], "init"],
    State$0: function() {
      this.game = null;
      this.add = null;
      this.make = null;
      this.camera = null;
      this.cache = null;
      this.input = null;
      this.load = null;
      this.math = null;
      this.sound = null;
      this.scale = null;
      this.stage = null;
      this.time = null;
      this.tweens = null;
      this.world = null;
      this.particles = null;
      this.physics = null;
      this.rnd = null;
    },
    static: {State$: [function() {
        var t1 = new R.State(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.State$0();
        return t1;
      }, null, null, 0, 0, 54, "new State"]}
  },
  "+State": [674],
  StateManager: {
    "^": "Object;game@-613,states@-1094,_clearWorld@-617,_clearCache@-617,_created*-617,_args@-645,_pendingStateKey@-644,_pendingState@-1095,current@-1095,onInitCallback@-0,onPreloadCallback@-0,onCreateCallback@-0,onUpdateCallback@-0,onRenderCallback@-0,onResizeCallback@-0,onPreRenderCallback@-0,onLoadUpdateCallback@-0,onLoadRenderCallback@-0,onPausedCallback@-0,onResumedCallback@-0,onPauseUpdateCallback@-0,onShutDownCallback@-0",
    onInitCallback$1: function(arg0) {
      return this.onInitCallback.call$1(arg0);
    },
    onPreloadCallback$0: function() {
      return this.onPreloadCallback.call$0();
    },
    onCreateCallback$0: function() {
      return this.onCreateCallback.call$0();
    },
    onUpdateCallback$0: function() {
      return this.onUpdateCallback.call$0();
    },
    onUpdateCallback$2: function(arg0, arg1) {
      return this.onUpdateCallback.call$2(arg0, arg1);
    },
    onRenderCallback$0: function() {
      return this.onRenderCallback.call$0();
    },
    onResizeCallback$2: function(arg0, arg1) {
      return this.onResizeCallback.call$2(arg0, arg1);
    },
    onPreRenderCallback$0: function() {
      return this.onPreRenderCallback.call$0();
    },
    onLoadUpdateCallback$0: function() {
      return this.onLoadUpdateCallback.call$0();
    },
    onLoadRenderCallback$0: function() {
      return this.onLoadRenderCallback.call$0();
    },
    onPausedCallback$0: function() {
      return this.onPausedCallback.call$0();
    },
    onResumedCallback$0: function() {
      return this.onResumedCallback.call$0();
    },
    onPauseUpdateCallback$0: function() {
      return this.onPauseUpdateCallback.call$0();
    },
    onShutDownCallback$0: function() {
      return this.onShutDownCallback.call$0();
    },
    boot$0: [function() {
      J.add$1$ax(J.get$onPause$x(this.game), this.get$pause(this));
      J.add$1$ax(this.game.get$onResume(), this.get$resume());
      J.add$1$ax(J.get$load$x(this.game).get$onLoadComplete(), this.get$loadComplete());
      var t1 = this._pendingState;
      if (t1 != null)
        this.add$3(0, "default", t1, true);
    }, "call$0", "get$boot", 0, 0, 54, "boot"],
    add$3: [function(_, key, state, autoStart) {
      J.$indexSet$ax(this.states, key, state);
      if (autoStart === true)
        if (this.game.get$isBooted() === true)
          this.start$1(0, key);
        else
          this._pendingState = state;
      return state;
    }, function($receiver, key, state) {
      return this.add$3($receiver, key, state, false);
    }, "add$2", "call$3", "call$2", "get$add", 4, 2, 1096, 19, 269, [], 294, [], 1097, [], "add"],
    remove$1: [function(_, key) {
      if (J.$eq(this.current, J.$index$asx(this.states, key))) {
        this.onInitCallback = null;
        this.onShutDownCallback = null;
        this.onPreloadCallback = null;
        this.onLoadRenderCallback = null;
        this.onLoadUpdateCallback = null;
        this.onCreateCallback = null;
        this.onUpdateCallback = null;
        this.onRenderCallback = null;
        this.onPausedCallback = null;
        this.onResumedCallback = null;
        this.onPauseUpdateCallback = null;
      }
      J.remove$1$ax(this.states, key);
    }, "call$1", "get$remove", 2, 0, 91, 269, [], "remove"],
    start$4: [function(_, key, clearWorld, clearCache, args) {
      if (this.checkState$1(key)) {
        this._pendingStateKey = key;
        this._pendingState = J.$index$asx(this.states, key);
        this._clearWorld = clearWorld;
        this._clearCache = clearCache;
        this._args = args;
      }
    }, function($receiver, key) {
      return this.start$4($receiver, key, true, false, null);
    }, "start$1", function($receiver, key, clearWorld) {
      return this.start$4($receiver, key, clearWorld, false, null);
    }, "start$2", function($receiver, key, clearWorld, clearCache) {
      return this.start$4($receiver, key, clearWorld, clearCache, null);
    }, "start$3", "call$4", "call$1", "call$2", "call$3", "get$start", 2, 6, 1098, 78, 19, 12, 269, [], 1087, [], 1099, [], 383, [], "start"],
    restart$3: [function(clearWorld, clearCache, args) {
      this._pendingState = this.current;
      this._clearWorld = clearWorld;
      this._clearCache = clearCache;
      this._args = args;
    }, function() {
      return this.restart$3(true, false, null);
    }, "restart$0", function(clearWorld) {
      return this.restart$3(clearWorld, false, null);
    }, "restart$1", function(clearWorld, clearCache) {
      return this.restart$3(clearWorld, clearCache, null);
    }, "restart$2", "call$3", "call$0", "call$1", "call$2", "get$restart", 0, 6, 1100, 78, 19, 12, 1087, [], 1099, [], 383, [], "restart"],
    preUpdate$0: [function() {
      if (this._pendingState != null && this.game.get$isBooted() === true) {
        this.clearCurrentState$0();
        var t1 = this._pendingStateKey;
        J.$index$asx(this.states, t1).set$game(this.game);
        J.set$add$ax(J.$index$asx(this.states, t1), J.get$add$ax(this.game));
        J.$index$asx(this.states, t1).set$make(this.game.get$make());
        J.$index$asx(this.states, t1).set$camera(this.game.get$camera());
        J.$index$asx(this.states, t1).set$cache(this.game.get$cache());
        J.$index$asx(this.states, t1).set$input(this.game.get$input());
        J.set$load$x(J.$index$asx(this.states, t1), J.get$load$x(this.game));
        J.$index$asx(this.states, t1).set$sound(this.game.get$sound());
        J.set$scale$x(J.$index$asx(this.states, t1), J.get$scale$x(this.game));
        J.set$state$x(J.$index$asx(this.states, t1), this);
        J.$index$asx(this.states, t1).set$stage(this.game.get$stage());
        J.$index$asx(this.states, t1).set$time(this.game.get$time());
        J.$index$asx(this.states, t1).set$tweens(this.game.get$tweens());
        J.$index$asx(this.states, t1).set$world(this.game.get$world());
        J.$index$asx(this.states, t1).set$particles(this.game.get$particles());
        J.$index$asx(this.states, t1).set$rnd(this.game.get$rnd());
        J.$index$asx(this.states, t1).set$physics(this.game.get$physics());
        this.onInitCallback = J.$index$asx(this.states, t1).get$init();
        this.onPreloadCallback = J.get$preload$x(J.$index$asx(this.states, t1));
        this.onLoadRenderCallback = J.$index$asx(this.states, t1).get$loadRender();
        this.onLoadUpdateCallback = J.$index$asx(this.states, t1).get$loadUpdate();
        this.onCreateCallback = J.$index$asx(this.states, t1).get$create();
        this.onUpdateCallback = J.$index$asx(this.states, t1).get$update();
        this.onPreRenderCallback = J.$index$asx(this.states, t1).get$preRender();
        this.onRenderCallback = J.$index$asx(this.states, t1).get$render();
        this.onResizeCallback = J.get$resize$x(J.$index$asx(this.states, t1));
        this.onPausedCallback = J.get$paused$x(J.$index$asx(this.states, t1));
        this.onResumedCallback = J.$index$asx(this.states, t1).get$resumed();
        this.onPauseUpdateCallback = J.$index$asx(this.states, t1).get$pauseUpdate();
        this.onShutDownCallback = J.$index$asx(this.states, t1).get$shutdown();
        this.current = J.$index$asx(this.states, t1);
        this._created = false;
        this.onInitCallback$1(this._args);
        if (J.$eq(J.$index$asx(this.states, t1), this._pendingState))
          this._args = [];
        if (!J.$eq(this.current, this._pendingState))
          return;
        else
          this._pendingState = null;
        if (this.onPreloadCallback != null) {
          J.reset$0$x(J.get$load$x(this.game));
          this.onPreloadCallback$0();
          if (J.get$load$x(this.game).totalQueuedFiles$0() === 0 && J.get$load$x(this.game).totalQueuedPacks$0() === 0)
            this.loadComplete$0();
          else
            J.start$0$x(J.get$load$x(this.game));
        } else
          this.loadComplete$0();
      }
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    unlink$1: [function(key) {
      if (J.$index$asx(this.states, key) != null) {
        J.$index$asx(this.states, key).set$game(null);
        J.set$add$ax(J.$index$asx(this.states, key), null);
        J.$index$asx(this.states, key).set$make(null);
        J.$index$asx(this.states, key).set$camera(null);
        J.$index$asx(this.states, key).set$cache(null);
        J.$index$asx(this.states, key).set$input(null);
        J.set$load$x(J.$index$asx(this.states, key), null);
        J.$index$asx(this.states, key).set$math(null);
        J.$index$asx(this.states, key).set$sound(null);
        J.set$scale$x(J.$index$asx(this.states, key), null);
        J.set$state$x(J.$index$asx(this.states, key), null);
        J.$index$asx(this.states, key).set$stage(null);
        J.$index$asx(this.states, key).set$time(null);
        J.$index$asx(this.states, key).set$tweens(null);
        J.$index$asx(this.states, key).set$world(null);
        J.$index$asx(this.states, key).set$particles(null);
        J.$index$asx(this.states, key).set$rnd(null);
        J.$index$asx(this.states, key).set$physics(null);
      }
    }, "call$1", "get$unlink", 2, 0, 91, 269, [], "unlink"],
    clearCurrentState$0: [function() {
      if (this.current != null) {
        if (this.onShutDownCallback != null)
          this.onShutDownCallback$0();
        this.game.get$tweens().removeAll$0();
        J.reset$0$x(this.game.get$camera());
        J.reset$1$x(this.game.get$input(), true);
        J.clear$0$ax(this.game.get$physics());
        if (J.$eq(this.current, this._pendingState))
          this.game.get$time().removeAll$0();
        J.reset$1$x(J.get$scale$x(this.game), this._clearWorld);
        if (this.game.get$debug() != null)
          J.reset$0$x(this.game.get$debug());
        if (this._clearWorld === true) {
          this.game.get$world().shutdown$0();
          if (J.$eq(this._clearCache, true))
            this.game.get$cache().destroy$0();
        }
      }
    }, "call$0", "get$clearCurrentState", 0, 0, 54, "clearCurrentState"],
    checkState$1: [function(key) {
      var t1;
      if (J.$index$asx(this.states, key) != null)
        return true;
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.StateManager - No state found with the key: ", key);
        if (typeof console != "undefined")
          console.warn(t1);
        return false;
      }
    }, "call$1", "get$checkState", 2, 0, 91, 269, [], "checkState"],
    link$1: [function(key) {
      J.$index$asx(this.states, key).set$game(this.game);
      J.set$add$ax(J.$index$asx(this.states, key), J.get$add$ax(this.game));
      J.$index$asx(this.states, key).set$make(this.game.get$make());
      J.$index$asx(this.states, key).set$camera(this.game.get$camera());
      J.$index$asx(this.states, key).set$cache(this.game.get$cache());
      J.$index$asx(this.states, key).set$input(this.game.get$input());
      J.set$load$x(J.$index$asx(this.states, key), J.get$load$x(this.game));
      J.$index$asx(this.states, key).set$sound(this.game.get$sound());
      J.set$scale$x(J.$index$asx(this.states, key), J.get$scale$x(this.game));
      J.set$state$x(J.$index$asx(this.states, key), this);
      J.$index$asx(this.states, key).set$stage(this.game.get$stage());
      J.$index$asx(this.states, key).set$time(this.game.get$time());
      J.$index$asx(this.states, key).set$tweens(this.game.get$tweens());
      J.$index$asx(this.states, key).set$world(this.game.get$world());
      J.$index$asx(this.states, key).set$particles(this.game.get$particles());
      J.$index$asx(this.states, key).set$rnd(this.game.get$rnd());
      J.$index$asx(this.states, key).set$physics(this.game.get$physics());
    }, "call$1", "get$link", 2, 0, 91, 269, [], "link"],
    setCurrentState$1: [function(key) {
      J.$index$asx(this.states, key).set$game(this.game);
      J.set$add$ax(J.$index$asx(this.states, key), J.get$add$ax(this.game));
      J.$index$asx(this.states, key).set$make(this.game.get$make());
      J.$index$asx(this.states, key).set$camera(this.game.get$camera());
      J.$index$asx(this.states, key).set$cache(this.game.get$cache());
      J.$index$asx(this.states, key).set$input(this.game.get$input());
      J.set$load$x(J.$index$asx(this.states, key), J.get$load$x(this.game));
      J.$index$asx(this.states, key).set$sound(this.game.get$sound());
      J.set$scale$x(J.$index$asx(this.states, key), J.get$scale$x(this.game));
      J.set$state$x(J.$index$asx(this.states, key), this);
      J.$index$asx(this.states, key).set$stage(this.game.get$stage());
      J.$index$asx(this.states, key).set$time(this.game.get$time());
      J.$index$asx(this.states, key).set$tweens(this.game.get$tweens());
      J.$index$asx(this.states, key).set$world(this.game.get$world());
      J.$index$asx(this.states, key).set$particles(this.game.get$particles());
      J.$index$asx(this.states, key).set$rnd(this.game.get$rnd());
      J.$index$asx(this.states, key).set$physics(this.game.get$physics());
      this.onInitCallback = J.$index$asx(this.states, key).get$init();
      this.onPreloadCallback = J.get$preload$x(J.$index$asx(this.states, key));
      this.onLoadRenderCallback = J.$index$asx(this.states, key).get$loadRender();
      this.onLoadUpdateCallback = J.$index$asx(this.states, key).get$loadUpdate();
      this.onCreateCallback = J.$index$asx(this.states, key).get$create();
      this.onUpdateCallback = J.$index$asx(this.states, key).get$update();
      this.onPreRenderCallback = J.$index$asx(this.states, key).get$preRender();
      this.onRenderCallback = J.$index$asx(this.states, key).get$render();
      this.onResizeCallback = J.get$resize$x(J.$index$asx(this.states, key));
      this.onPausedCallback = J.get$paused$x(J.$index$asx(this.states, key));
      this.onResumedCallback = J.$index$asx(this.states, key).get$resumed();
      this.onPauseUpdateCallback = J.$index$asx(this.states, key).get$pauseUpdate();
      this.onShutDownCallback = J.$index$asx(this.states, key).get$shutdown();
      this.current = J.$index$asx(this.states, key);
      this._created = false;
      this.onInitCallback$1(this._args);
      if (J.$eq(J.$index$asx(this.states, key), this._pendingState))
        this._args = [];
    }, "call$1", "get$setCurrentState", 2, 0, 91, 269, [], "setCurrentState"],
    resize$2: [function(_, width, height) {
      if (this.onResizeCallback != null)
        this.onResizeCallback$2(width, height);
    }, "call$2", "get$resize", 4, 0, 149, 31, [], 52, [], "resize"],
    getCurrentState$0: [function() {
      return this.current;
    }, "call$0", "get$getCurrentState", 0, 0, 54, "getCurrentState"],
    loadComplete$0: [function() {
      if (J.$eq(this._created, false) && this.onCreateCallback != null) {
        this._created = true;
        this.onCreateCallback$0();
      } else
        this._created = true;
    }, "call$0", "get$loadComplete", 0, 0, 54, "loadComplete"],
    pause$0: [function(_) {
      if (this._created === true && this.onPausedCallback != null)
        this.onPausedCallback$0();
    }, "call$0", "get$pause", 0, 0, 54, "pause"],
    resume$0: [function() {
      if (this._created === true && this.onResumedCallback != null)
        this.onResumedCallback$0();
    }, "call$0", "get$resume", 0, 0, 54, "resume"],
    update$0: [function() {
      if (this._created === true && this.onUpdateCallback != null)
        this.onUpdateCallback$0();
      else if (this.onLoadUpdateCallback != null)
        this.onLoadUpdateCallback$0();
    }, "call$0", "get$update", 0, 0, 54, "update"],
    pauseUpdate$0: [function() {
      if (this._created === true && this.onPauseUpdateCallback != null)
        this.onPauseUpdateCallback$0();
      else if (this.onLoadUpdateCallback != null)
        this.onLoadUpdateCallback$0();
    }, "call$0", "get$pauseUpdate", 0, 0, 54, "pauseUpdate"],
    preRender$0: [function() {
      if (this.onPreRenderCallback != null)
        this.onPreRenderCallback$0();
    }, "call$0", "get$preRender", 0, 0, 54, "preRender"],
    render$0: [function() {
      if (this._created === true && this.onRenderCallback != null) {
        if (J.$eq(this.game.get$renderType(), 1)) {
          J.save$0$x(J.get$context$x(this.game));
          J.setTransform$6$x(J.get$context$x(this.game), 1, 0, 0, 1, 0, 0);
        }
        this.onRenderCallback$0();
        if (J.$eq(this.game.get$renderType(), 1))
          J.restore$0$x(J.get$context$x(this.game));
      } else if (this.onLoadRenderCallback != null)
        this.onLoadRenderCallback$0();
    }, "call$0", "get$render", 0, 0, 54, "render"],
    destroy$0: [function() {
      this.clearCurrentState$0();
      this.onInitCallback = null;
      this.onShutDownCallback = null;
      this.onPreloadCallback = null;
      this.onLoadRenderCallback = null;
      this.onLoadUpdateCallback = null;
      this.onCreateCallback = null;
      this.onUpdateCallback = null;
      this.onRenderCallback = null;
      this.onPausedCallback = null;
      this.onResumedCallback = null;
      this.onPauseUpdateCallback = null;
      this.game = null;
      this.states = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._pendingState = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    StateManager$2: function(game, pendingState) {
      this.states = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._pendingState = pendingState;
      this._clearWorld = false;
      this._clearCache = false;
      this._created = false;
      this._args = [];
      this.current = null;
      this.onInitCallback = null;
      this.onPreloadCallback = null;
      this.onCreateCallback = null;
      this.onUpdateCallback = null;
      this.onRenderCallback = null;
      this.onPreRenderCallback = null;
      this.onLoadUpdateCallback = null;
      this.onLoadRenderCallback = null;
      this.onPausedCallback = null;
      this.onResumedCallback = null;
      this.onPauseUpdateCallback = null;
      this.onShutDownCallback = null;
    },
    static: {StateManager$: [function(game, pendingState) {
        var t1 = new R.StateManager(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.StateManager$2(game, pendingState);
        return t1;
      }, null, null, 2, 2, 309, 12, 252, [], 310, [], "new StateManager"]}
  },
  "+StateManager": [674],
  World: {
    "^": "Group;game:Phaser$World$game@-613,bounds@-649,camera@-1046,_definedSize@-617,_width@-616,_height@-616,game-613,name-644,addToStage-617,enableBody-617,physicsBodyType-616,z-614,type-614,alive-617,exists-617,ignoreDestroy-617,_Phaser$_dirty-617,cursor-12,cameraOffset-615,_sortProperty-644,enableBodyDebug-617,_cache-645,creator-646,renderOrderID-614,Phaser$Group$children-647,autoCull-617,events-648,_anchor-615,_Phaser$_currentBounds-649,Phaser$Group$position-615,onDestroy-650,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    get$width: [function(_) {
      return J.get$width$x(this.bounds);
    }, null, null, 1, 0, 619, "width"],
    set$width: [function(_, value) {
      if (J.$lt$n(value, J.get$width$x(this.Phaser$World$game)))
        value = J.get$width$x(this.Phaser$World$game);
      J.set$width$x(this.bounds, value);
      this._width = value;
      this._definedSize = true;
    }, null, null, 3, 0, 620, 138, [], "width"],
    get$height: [function(_) {
      return J.get$height$x(this.bounds);
    }, null, null, 1, 0, 619, "height"],
    set$height: [function(_, value) {
      if (J.$lt$n(value, J.get$height$x(this.Phaser$World$game)))
        value = J.get$height$x(this.Phaser$World$game);
      J.set$height$x(this.bounds, value);
      this._height = value;
      this._definedSize = true;
    }, null, null, 3, 0, 620, 138, [], "height"],
    get$centerX: [function() {
      return this.bounds.get$halfWidth();
    }, null, null, 1, 0, 619, "centerX"],
    get$centerY: [function() {
      return this.bounds.get$halfHeight();
    }, null, null, 1, 0, 619, "centerY"],
    get$randomX: [function() {
      var t1, t2;
      t1 = J.$lt$n(J.get$x$x(this.bounds), 0);
      t2 = this.Phaser$World$game;
      if (t1)
        return t2.get$rnd().integerInRange$2(J.get$x$x(this.bounds), J.$sub$n(J.get$width$x(this.bounds), J.abs$0$n(J.get$x$x(this.bounds))));
      else
        return t2.get$rnd().integerInRange$2(J.get$x$x(this.bounds), J.get$width$x(this.bounds));
    }, null, null, 1, 0, 619, "randomX"],
    get$randomY: [function() {
      var t1, t2;
      t1 = J.$lt$n(J.get$y$x(this.bounds), 0);
      t2 = this.Phaser$World$game;
      if (t1)
        return t2.get$rnd().integerInRange$2(J.get$y$x(this.bounds), J.$sub$n(J.get$height$x(this.bounds), J.abs$0$n(J.get$y$x(this.bounds))));
      else
        return t2.get$rnd().integerInRange$2(J.get$y$x(this.bounds), J.get$height$x(this.bounds));
    }, null, null, 1, 0, 619, "randomY"],
    boot$0: [function() {
      var t1, t2;
      t1 = this.Phaser$World$game;
      t2 = new R.Camera(t1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2.Camera$6(t1, 0, 0, 0, J.get$width$x(t1), J.get$height$x(this.Phaser$World$game));
      this.camera = t2;
      t2.displayObject = this;
      J.set$scale$x(this.camera, this.scale);
      this.Phaser$World$game.set$camera(this.camera);
      this.Phaser$World$game.get$stage().addChild$1(this);
    }, "call$0", "get$boot", 0, 0, 54, "boot"],
    setBounds$4: [function(x, y, width, height) {
      this._definedSize = true;
      this._width = width;
      this._height = height;
      this.bounds.setTo$4(x, y, width, height);
      if (this.camera.get$bounds() != null)
        this.camera.get$bounds().setTo$4(x, y, P.max(width, J.get$width$x(this.Phaser$World$game)), P.max(height, J.get$height$x(this.Phaser$World$game)));
      this.Phaser$World$game.get$physics().setBoundsToWorld$0();
    }, "call$4", "get$setBounds", 8, 0, 350, 9, [], 10, [], 31, [], 52, [], "setBounds"],
    resize$2: [function(_, width, height) {
      if (this._definedSize === true) {
        if (J.$lt$n(width, this._width))
          width = this._width;
        if (J.$lt$n(height, this._height))
          height = this._height;
      }
      J.set$width$x(this.bounds, width);
      J.set$height$x(this.bounds, height);
      this.Phaser$World$game.get$camera().setBoundsToWorld$0();
      this.Phaser$World$game.get$physics().setBoundsToWorld$0();
    }, "call$2", "get$resize", 4, 0, 149, 31, [], 52, [], "resize"],
    shutdown$0: [function() {
      this.destroy$2(true, true);
    }, "call$0", "get$shutdown", 0, 0, 54, "shutdown"],
    wrap$5: [function(_, sprite, padding, useBounds, horizontal, vertical) {
      var t1;
      if (useBounds !== true) {
        t1 = horizontal === true;
        if (t1 && J.$lt$n(J.$add$ns(J.get$x$x(sprite), padding), J.get$x$x(this.bounds)))
          J.set$x$x(sprite, J.$add$ns(J.get$right$x(this.bounds), padding));
        else if (t1 && J.$gt$n(J.$sub$n(J.get$x$x(sprite), padding), J.get$right$x(this.bounds)))
          J.set$x$x(sprite, J.$sub$n(J.get$left$x(this.bounds), padding));
        t1 = vertical === true;
        if (t1 && J.$lt$n(J.$add$ns(J.get$y$x(sprite), padding), J.get$top$x(this.bounds)))
          J.set$y$x(sprite, J.$add$ns(J.get$bottom$x(this.bounds), padding));
        else if (t1 && J.$gt$n(J.$sub$n(J.get$y$x(sprite), padding), J.get$bottom$x(this.bounds)))
          J.set$y$x(sprite, J.$sub$n(J.get$top$x(this.bounds), padding));
      } else {
        sprite.getBounds$0();
        t1 = horizontal === true;
        if (t1 && J.$lt$n(J.get$right$x(sprite.get$_Phaser$_currentBounds()), J.get$x$x(this.bounds)))
          J.set$x$x(sprite, J.get$right$x(this.bounds));
        else if (t1 && J.$gt$n(J.get$x$x(sprite.get$_Phaser$_currentBounds()), J.get$right$x(this.bounds)))
          J.set$x$x(sprite, J.get$left$x(this.bounds));
        t1 = vertical === true;
        if (t1 && J.$lt$n(J.get$bottom$x(sprite.get$_Phaser$_currentBounds()), J.get$top$x(this.bounds)))
          J.set$y$x(sprite, J.get$bottom$x(this.bounds));
        else if (t1 && J.$gt$n(J.get$top$x(sprite.get$_Phaser$_currentBounds()), J.get$bottom$x(this.bounds)))
          J.set$y$x(sprite, J.get$top$x(this.bounds));
      }
    }, function($receiver, sprite) {
      return this.wrap$5($receiver, sprite, 0, false, true, true);
    }, "wrap$1", function($receiver, sprite, padding) {
      return this.wrap$5($receiver, sprite, padding, false, true, true);
    }, "wrap$2", function($receiver, sprite, padding, useBounds) {
      return this.wrap$5($receiver, sprite, padding, useBounds, true, true);
    }, "wrap$3", function($receiver, sprite, padding, useBounds, horizontal) {
      return this.wrap$5($receiver, sprite, padding, useBounds, horizontal, true);
    }, "wrap$4", "call$5", "call$1", "call$2", "call$3", "call$4", "get$wrap", 2, 8, 1101, 49, 19, 78, 78, 151, [], 1102, [], 1103, [], 1104, [], 1105, [], "wrap"],
    World$1: function(game) {
      var t1;
      this.Phaser$World$game = game;
      t1 = J.getInterceptor$x(game);
      this.bounds = new R.Rectangle1(0, 0, t1.get$width(game), t1.get$height(game), 0, 0, 0, 0);
      this.camera = null;
      this._definedSize = false;
      this._width = t1.get$width(game);
      this._height = t1.get$height(game);
    },
    $asGroup: function() {
      return [null];
    },
    $asGroup: function() {
      return [null];
    },
    "<>": [],
    static: {World$0: [function(game) {
        var t1, t2, t3, t4, t5;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = new R.World(null, null, null, null, null, null, null, "__world", false, false, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, t1, null, t2, null, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t5.Group$6(game, null, "__world", false, false, 0, null);
        t5.World$1(game);
        return t5;
      }, null, null, 2, 0, 302, 252, [], "new World"]}
  },
  "+World": [1029],
  BitmapData: {
    "^": "Object;game@-613,key*-644,width*-614,height*-614,canvas*-836,context*-876,ctx@-876,imageData@-1106,data*-745,pixels@-1107,baseTexture@-853,texture@-698,textureFrame@-963,type*-614,disableTextureUpload@-617,dirty@-617,_tempR@-614,_tempG@-614,_tempB@-614,cls@-0,update@-0",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    cls$0: function() {
      return this.cls.call$0();
    },
    update$1: function(arg0) {
      return this.update.call$1(arg0);
    },
    update$0: function() {
      return this.update.call$0();
    },
    add$1: [function(_, object) {
      var t1, i, t2;
      t1 = J.getInterceptor(object);
      if (!!t1.$isList) {
        i = 0;
        while (true) {
          t2 = t1.get$length(object);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t1.$index(object, i).loadTexture$1(this);
          ++i;
        }
      } else
        object.loadTexture$1(this);
    }, "call$1", "get$add", 2, 0, 102, 584, [], "add"],
    load$1: [function(_, source) {
      var t1;
      if (typeof source === "string")
        source = this.game.get$cache().getImage$1(source);
      t1 = J.getInterceptor$x(source);
      this.resize$2(0, t1.get$width(source), t1.get$height(source));
      this.cls$0();
      if (!!t1.$isImage || !!t1.$isSprite)
        this.draw$3(source, 0, 0);
      else
        this.draw$3(source, 0, 0);
      this.update$0();
    }, "call$1", "get$load", 2, 0, 102, 208, [], "load"],
    clear$0: [function(_) {
      J.clearRect$4$x(this.context, 0, 0, this.width, this.height);
      this.dirty = true;
    }, "call$0", "get$clear", 0, 0, 54, "clear"],
    fill$4: [function(_, r, g, b, a) {
      if (a == null)
        a = 1;
      J.set$fillStyle$x(this.context, "rgba(" + H.S(r) + "," + H.S(g) + "," + H.S(b) + "," + H.S(a) + ")");
      J.fillRect$4$x(this.context, 0, 0, this.width, this.height);
      this.dirty = true;
    }, function($receiver, r, g, b) {
      return this.fill$4($receiver, r, g, b, 1);
    }, "fill$3", "call$4", "call$3", "get$fill", 6, 2, 1108, 433, 346, [], 536, [], 349, [], 348, [], "fill"],
    resize$2: [function(_, width, height) {
      width = J.toInt$0$n(width);
      height = J.toInt$0$n(height);
      if (width !== this.width || height !== this.height) {
        this.width = width;
        this.height = height;
        J.set$width$x(this.canvas, width);
        J.set$height$x(this.canvas, height);
        J.set$width$x(this.baseTexture, width);
        J.set$height$x(this.baseTexture, height);
        J.set$width$x(this.textureFrame, width);
        J.set$height$x(this.textureFrame, height);
        J.set$width$x(this.texture, width);
        J.set$height$x(this.texture, height);
        this.refreshBuffer$0();
        this.dirty = true;
      }
    }, "call$2", "get$resize", 4, 0, 149, 31, [], 52, [], "resize"],
    refreshBuffer$4: [function(x, y, width, height) {
      var t1, index, i, index0, t2, t3, t4, t5;
      if (x == null)
        x = 0;
      if (y == null)
        y = 0;
      if (width == null)
        width = this.width;
      if (height == null)
        height = this.height;
      t1 = J.getImageData$4$x(this.context, x, y, width, height);
      this.imageData = t1;
      t1 = J.get$data$x(t1);
      this.data = t1;
      this.pixels = new Uint32Array(H._checkLength(C.JSInt_methods._tdivFast$1(t1.length, 4)));
      index = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.data);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        t1 = this.pixels;
        index0 = index + 1;
        t2 = J.$shl$n(J.$index$asx(this.data, i), 24);
        t3 = J.$shl$n(J.$index$asx(this.data, i + 1), 16);
        t4 = J.$shl$n(J.$index$asx(this.data, i + 2), 8);
        t5 = J.$index$asx(this.data, i + 3);
        if (typeof t5 !== "number")
          return H.iae(t5);
        J.$indexSet$ax(t1, index, t2 + t3 + t4 + t5);
        i += 4;
        index = index0;
      }
    }, function() {
      return this.refreshBuffer$4(0, 0, null, null);
    }, "refreshBuffer$0", function(x) {
      return this.refreshBuffer$4(x, 0, null, null);
    }, "refreshBuffer$1", function(x, y) {
      return this.refreshBuffer$4(x, y, null, null);
    }, "refreshBuffer$2", function(x, y, width) {
      return this.refreshBuffer$4(x, y, width, null);
    }, "refreshBuffer$3", "call$4", "call$0", "call$1", "call$2", "call$3", "get$refreshBuffer", 0, 8, 1109, 49, 49, 12, 12, 9, [], 10, [], 31, [], 52, [], "refreshBuffer"],
    processPixelRGB$5: [function(callback, x, y, width, height) {
      var w, h, pixel, result, ty, dirty, t1, tx, t2, t3;
      if (x == null)
        x = 0;
      if (y == null)
        y = 0;
      if (width == null)
        width = this.width;
      if (height == null)
        height = this.height;
      w = J.$add$ns(x, width);
      h = J.$add$ns(y, height);
      pixel = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
      result = P.LinkedHashMap_LinkedHashMap$_literal(["r", 0, "g", 0, "b", 0, "a", 0], null, null);
      for (ty = y, dirty = false; t1 = J.getInterceptor$n(ty), t1.$lt(ty, h); ty = t1.$add(ty, 1))
        for (tx = x; t2 = J.getInterceptor$n(tx), t2.$lt(tx, w); tx = t2.$add(tx, 1)) {
          R.Color_unpackPixel(this.getPixel32$2(tx, ty), pixel, false, false);
          result = callback.call$3(pixel, tx, ty);
          t3 = J.getInterceptor(result);
          if (!t3.$eq(result, false) && result != null) {
            this.setPixel32$7(tx, ty, t3.$index(result, "r"), t3.$index(result, "g"), t3.$index(result, "b"), t3.$index(result, "a"), false);
            dirty = true;
          }
        }
      if (dirty) {
        J.putImageData$3$x(this.context, this.imageData, 0, 0);
        this.dirty = true;
      }
    }, function(callback) {
      return this.processPixelRGB$5(callback, 0, 0, null, null);
    }, "processPixelRGB$1", function(callback, x) {
      return this.processPixelRGB$5(callback, x, 0, null, null);
    }, "processPixelRGB$2", function(callback, x, y) {
      return this.processPixelRGB$5(callback, x, y, null, null);
    }, "processPixelRGB$3", function(callback, x, y, width) {
      return this.processPixelRGB$5(callback, x, y, width, null);
    }, "processPixelRGB$4", "call$5", "call$1", "call$2", "call$3", "call$4", "get$processPixelRGB", 2, 8, 1110, 49, 49, 12, 12, 26, [], 9, [], 10, [], 31, [], 52, [], "processPixelRGB"],
    processPixel$5: [function(callback, x, y, width, height) {
      var w, h, ty, pixel, result, dirty, t1, tx, t2;
      if (x == null)
        x = 0;
      if (y == null)
        y = 0;
      if (width == null)
        width = this.width;
      if (height == null)
        height = this.height;
      w = J.$add$ns(x, width);
      h = J.$add$ns(y, height);
      for (ty = y, pixel = 0, result = 0, dirty = false; t1 = J.getInterceptor$n(ty), t1.$lt(ty, h); ty = t1.$add(ty, 1))
        for (tx = x; t2 = J.getInterceptor$n(tx), t2.$lt(tx, w); tx = t2.$add(tx, 1)) {
          pixel = this.getPixel32$2(tx, ty);
          result = callback.call$3(pixel, tx, ty);
          if (!J.$eq(result, pixel)) {
            J.$indexSet$ax(this.pixels, J.$add$ns(t1.$mul(ty, this.width), tx), result);
            dirty = true;
          }
        }
      if (dirty) {
        J.putImageData$3$x(this.context, this.imageData, 0, 0);
        this.dirty = true;
      }
    }, "call$5", "get$processPixel", 10, 0, 1111, 26, [], 9, [], 10, [], 31, [], 52, [], "processPixel"],
    replaceRGB$9: [function(r1, g1, b1, a1, r2, g2, b2, a2, region) {
      var w, h, source, t1, sx, sy, t2, y, x;
      w = this.width;
      h = this.height;
      source = R.Color_packPixel(r1, g1, b1, a1);
      if (region != null && !!J.getInterceptor(region).$isRectangle1) {
        t1 = J.getInterceptor$x(region);
        sx = t1.get$x(region);
        sy = t1.get$y(region);
        w = t1.get$width(region);
        h = t1.get$height(region);
      } else {
        sx = 0;
        sy = 0;
      }
      if (typeof h !== "number")
        return H.iae(h);
      t1 = J.getInterceptor$ns(sx);
      t2 = J.getInterceptor$ns(sy);
      y = 0;
      for (; y < h; ++y) {
        if (typeof w !== "number")
          return H.iae(w);
        x = 0;
        for (; x < w; ++x)
          if (J.$eq(this.getPixel32$2(t1.$add(sx, x), t2.$add(sy, y)), source))
            this.setPixel32$7(t1.$add(sx, x), t2.$add(sy, y), r2, g2, b2, a2, false);
      }
      J.putImageData$3$x(this.context, this.imageData, 0, 0);
      this.dirty = true;
    }, function(r1, g1, b1, a1, r2, g2, b2, a2) {
      return this.replaceRGB$9(r1, g1, b1, a1, r2, g2, b2, a2, null);
    }, "replaceRGB$8", "call$9", "call$8", "get$replaceRGB", 16, 2, 1112, 12, 570, [], 571, [], 447, [], 445, [], 572, [], 573, [], 448, [], 446, [], 1113, [], "replaceRGB"],
    setHSL$4: [function(h, s, l, region) {
      var t1, pixel, t2, y, t3, t4, t5, x, t6;
      t1 = h == null;
      if (t1 && s == null && l == null)
        return;
      if (region == null)
        region = new R.Rectangle1(0, 0, this.width, this.height, 0, 0, 0, 0);
      pixel = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
      for (t2 = J.getInterceptor$x(region), y = t2.get$y(region), t3 = l != null, t4 = s != null, t1 = !t1; t5 = J.getInterceptor$n(y), t5.$lt(y, t2.get$bottom(region)); y = t5.$add(y, 1))
        for (x = t2.get$x(region); t6 = J.getInterceptor$n(x), t6.$lt(x, t2.get$right(region)); x = t6.$add(x, 1)) {
          R.Color_unpackPixel(this.getPixel32$2(x, y), pixel, true, false);
          if (t1)
            pixel.h = h;
          if (t4)
            pixel.s = s;
          if (t3)
            pixel.l = l;
          R.Color_HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);
          this.setPixel32$7(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);
        }
      J.putImageData$3$x(this.context, this.imageData, 0, 0);
      this.dirty = true;
    }, function(h) {
      return this.setHSL$4(h, null, null, null);
    }, "setHSL$1", function(h, s) {
      return this.setHSL$4(h, s, null, null);
    }, "setHSL$2", function() {
      return this.setHSL$4(null, null, null, null);
    }, "setHSL$0", function(h, s, l) {
      return this.setHSL$4(h, s, l, null);
    }, "setHSL$3", "call$4", "call$1", "call$2", "call$0", "call$3", "get$setHSL", 0, 8, 1114, 12, 12, 12, 12, 544, [], 545, [], 546, [], 1113, [], "setHSL"],
    shiftHSL$4: [function(h, s, l, region) {
      var t1, pixel, t2, y, t3, t4, t5, x, t6, t7, t8;
      t1 = h == null;
      if (t1 && s == null && l == null)
        return;
      if (region == null)
        region = new R.Rectangle1(0, 0, this.width, this.height, 0, 0, 0, 0);
      pixel = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
      for (t2 = J.getInterceptor$x(region), y = t2.get$y(region), t3 = l != null, t4 = s != null, t1 = !t1; t5 = J.getInterceptor$n(y), t5.$lt(y, t2.get$bottom(region)); y = t5.$add(y, 1))
        for (x = t2.get$x(region); t6 = J.getInterceptor$n(x), t6.$lt(x, t2.get$right(region)); x = t6.$add(x, 1)) {
          R.Color_unpackPixel(this.getPixel32$2(x, y), pixel, true, false);
          if (t1)
            pixel.h = R.Math_wrap(J.$add$ns(pixel.h, h), 0, 1);
          if (t4) {
            t7 = J.$add$ns(pixel.s, s);
            t8 = J.getInterceptor$n(t7);
            if (t8.$lt(t7, 0))
              t7 = 0;
            else if (t8.$gt(t7, 1))
              t7 = 1;
            pixel.s = t7;
          }
          if (t3) {
            t7 = J.$add$ns(pixel.l, l);
            t8 = J.getInterceptor$n(t7);
            if (t8.$lt(t7, 0))
              t7 = 0;
            else if (t8.$gt(t7, 1))
              t7 = 1;
            pixel.l = t7;
          }
          R.Color_HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);
          this.setPixel32$7(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);
        }
      J.putImageData$3$x(this.context, this.imageData, 0, 0);
      this.dirty = true;
    }, function(h) {
      return this.shiftHSL$4(h, null, null, null);
    }, "shiftHSL$1", function(h, s) {
      return this.shiftHSL$4(h, s, null, null);
    }, "shiftHSL$2", function() {
      return this.shiftHSL$4(null, null, null, null);
    }, "shiftHSL$0", function(h, s, l) {
      return this.shiftHSL$4(h, s, l, null);
    }, "shiftHSL$3", "call$4", "call$1", "call$2", "call$0", "call$3", "get$shiftHSL", 0, 8, 1114, 12, 12, 12, 12, 544, [], 545, [], 546, [], 1113, [], "shiftHSL"],
    setPixel32$7: [function(x, y, red, green, blue, alpha, immediate) {
      var t1, index, t2, t3, t4, i, i0;
      t1 = J.getInterceptor$ns(y);
      index = J.$add$ns(t1.$mul(y, this.width), x);
      t2 = J.getInterceptor$n(x);
      if (t2.$ge(x, 0) && t2.$le(x, this.width) && t1.$ge(y, 0) && t1.$le(y, this.height)) {
        t1 = $.Device_LITTLE_ENDIAN;
        t2 = J.getInterceptor$n(blue);
        t3 = this.pixels;
        t4 = J.getInterceptor$n(green);
        if (t1 === true) {
          t1 = J.$shl$n(alpha, 24);
          t2 = t2.$shl(blue, 16);
          t4 = t4.$shl(green, 8);
          if (typeof red !== "number")
            return H.iae(red);
          J.$indexSet$ax(t3, index, (t1 | t2 | t4 | red) >>> 0);
        } else {
          t1 = J.$shl$n(red, 24);
          t4 = t4.$shl(green, 16);
          t2 = t2.$shl(blue, 8);
          if (typeof alpha !== "number")
            return H.iae(alpha);
          J.$indexSet$ax(t3, index, (t1 | t4 | t2 | alpha) >>> 0);
        }
        i = J.$mul$ns(index, 4);
        t1 = J.get$data$x(this.imageData);
        i0 = J.$add$ns(i, 1);
        J.$indexSet$ax(t1, i, red);
        t1 = J.get$data$x(this.imageData);
        i = J.$add$ns(i0, 1);
        J.$indexSet$ax(t1, i0, green);
        t1 = J.get$data$x(this.imageData);
        i0 = J.$add$ns(i, 1);
        J.$indexSet$ax(t1, i, blue);
        J.$indexSet$ax(J.get$data$x(this.imageData), i0, alpha);
        if (immediate === true) {
          J.putImageData$3$x(this.context, this.imageData, 0, 0);
          this.dirty = true;
        }
      }
    }, function(x, y, red, green, blue, alpha) {
      return this.setPixel32$7(x, y, red, green, blue, alpha, true);
    }, "setPixel32$6", "call$7", "call$6", "get$setPixel32", 12, 2, 1115, 78, 9, [], 10, [], 1116, [], 1117, [], 1118, [], 567, [], 1119, [], "setPixel32"],
    setPixel$6: [function(x, y, red, green, blue, immediate) {
      this.setPixel32$7(x, y, red, green, blue, 255, immediate);
    }, function(x, y, red, green, blue) {
      return this.setPixel$6(x, y, red, green, blue, true);
    }, "setPixel$5", "call$6", "call$5", "get$setPixel", 10, 2, 1120, 78, 9, [], 10, [], 1116, [], 1117, [], 1118, [], 1119, [], "setPixel"],
    getPixel$3: [function(x, y, out) {
      var index, t1;
      if (out == null)
        out = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
      index = (~J.$not$i(J.$add$ns(x, J.$mul$ns(y, this.width))) >>> 0) * 4;
      t1 = J.getInterceptor$x(out);
      t1.set$r(out, J.$index$asx(this.data, index));
      ++index;
      out.set$g(J.$index$asx(this.data, index));
      ++index;
      out.set$b(J.$index$asx(this.data, index));
      t1.set$a(out, J.$index$asx(this.data, index + 1));
      return out;
    }, "call$3", "get$getPixel", 6, 0, 1121, 9, [], 10, [], 361, [], "getPixel"],
    getPixel32$2: [function(x, y) {
      var t1 = J.getInterceptor$n(x);
      if (t1.$ge(x, 0))
        if (t1.$le(x, this.width)) {
          t1 = J.getInterceptor$n(y);
          t1 = t1.$ge(y, 0) && t1.$le(y, this.height);
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        return J.$index$asx(this.pixels, J.$add$ns(J.$mul$ns(y, this.width), x));
      return;
    }, "call$2", "get$getPixel32", 4, 0, 1122, 9, [], 10, [], "getPixel32"],
    getPixelRGB$5: [function(x, y, out, hsl, hsv) {
      return R.Color_unpackPixel(this.getPixel32$2(x, y), out, hsl, hsv);
    }, function(x, y) {
      return this.getPixelRGB$5(x, y, null, false, false);
    }, "getPixelRGB$2", function(x, y, out) {
      return this.getPixelRGB$5(x, y, out, false, false);
    }, "getPixelRGB$3", function(x, y, out, hsl) {
      return this.getPixelRGB$5(x, y, out, hsl, false);
    }, "getPixelRGB$4", "call$5", "call$2", "call$3", "call$4", "get$getPixelRGB", 4, 6, 1123, 12, 19, 19, 9, [], 10, [], 361, [], 539, [], 540, [], "getPixelRGB"],
    getPixels$1: [function(rect) {
      var t1 = J.getInterceptor$x(rect);
      return J.getImageData$4$x(this.context, t1.get$x(rect), t1.get$y(rect), t1.get$width(rect), t1.get$height(rect));
    }, "call$1", "get$getPixels", 2, 0, 1124, 1125, [], "getPixels"],
    addToWorld$2: [function(x, y) {
      return J.get$add$ax(this.game).image$3(x, y, this);
    }, function() {
      return this.addToWorld$2(0, 0);
    }, "addToWorld$0", function(x) {
      return this.addToWorld$2(x, 0);
    }, "addToWorld$1", "call$2", "call$0", "call$1", "get$addToWorld", 0, 4, 1126, 49, 49, 9, [], 10, [], "addToWorld"],
    copyPixels$4: [function(source, area, x, y) {
      var t1, src, frame, sx, sy;
      if (typeof source === "string")
        source = this.game.get$cache().getImage$1(source);
      t1 = J.getInterceptor(source);
      if (!!t1.$isSpriteInterface) {
        src = J.get$source$x(source.get$texture().get$baseTexture());
        frame = source.get$texture().get$frame();
        t1 = J.getInterceptor$x(frame);
        sx = t1.get$x(frame);
        sy = t1.get$y(frame);
      } else {
        src = !!t1.$isBitmapData ? source.canvas : source;
        sx = 0;
        sy = 0;
      }
      t1 = J.getInterceptor$x(area);
      J.drawImageScaledFromSource$9$x(this.context, src, J.$add$ns(sx, t1.get$x(area)), J.$add$ns(sy, t1.get$y(area)), t1.get$width(area), t1.get$height(area), x, y, t1.get$width(area), t1.get$height(area));
      this.dirty = true;
    }, "call$4", "get$copyPixels", 8, 0, 1127, 208, [], 1128, [], 9, [], 10, [], "copyPixels"],
    draw$5: [function(source, x, y, width, height) {
      var t1, src, frame, sx, sy, sw, sh;
      if (x == null)
        x = 0;
      if (y == null)
        y = 0;
      if (typeof source === "string")
        source = this.game.get$cache().getImage$1(source);
      t1 = J.getInterceptor(source);
      if (!!t1.$isSpriteInterface) {
        src = J.get$source$x(source.get$texture().get$baseTexture());
        frame = source.get$texture().get$frame();
        t1 = J.getInterceptor$x(frame);
        sx = t1.get$x(frame);
        sy = t1.get$y(frame);
        sw = t1.get$width(frame);
        sh = t1.get$height(frame);
      } else {
        src = !!t1.$isBitmapData ? source.canvas : source;
        sw = t1.get$width(source);
        sh = t1.get$height(source);
        sx = 0;
        sy = 0;
      }
      if (width == null)
        width = sw;
      if (height == null)
        height = sh;
      J.drawImageScaledFromSource$9$x(this.context, src, sx, sy, sw, sh, x, y, width, height);
      this.dirty = true;
    }, function(source) {
      return this.draw$5(source, 0, 0, null, null);
    }, "draw$1", function(source, x, y) {
      return this.draw$5(source, x, y, null, null);
    }, "draw$3", function(source, x, y, width) {
      return this.draw$5(source, x, y, width, null);
    }, "draw$4", function(source, x) {
      return this.draw$5(source, x, 0, null, null);
    }, "draw$2", "call$5", "call$1", "call$3", "call$4", "call$2", "get$draw", 2, 8, 1129, 49, 49, 12, 12, 208, [], 9, [], 10, [], 31, [], 52, [], "draw"],
    drawSprite$3: [function(sprite, x, y) {
      if (x == null)
        x = 0;
      this.draw$3(sprite, x, y == null ? 0 : y);
    }, function(sprite) {
      return this.drawSprite$3(sprite, null, null);
    }, "drawSprite$1", function(sprite, x) {
      return this.drawSprite$3(sprite, x, null);
    }, "drawSprite$2", "call$3", "call$1", "call$2", "get$drawSprite", 2, 4, 1130, 12, 12, 151, [], 9, [], 10, [], "drawSprite"],
    alphaMask$4: [function(source, mask, sourceRect, maskRect) {
      var temp, t1;
      if (mask == null)
        mask = this;
      temp = J.get$globalCompositeOperation$x(this.context);
      if (maskRect == null || false)
        this.draw$1(mask);
      else {
        t1 = J.getInterceptor$x(maskRect);
        this.draw$5(mask, t1.get$x(maskRect), t1.get$y(maskRect), t1.get$width(maskRect), t1.get$height(maskRect));
      }
      J.set$globalCompositeOperation$x(this.context, "source-atop");
      if (sourceRect == null || false)
        this.draw$1(source);
      else {
        t1 = J.getInterceptor$x(sourceRect);
        this.draw$5(source, t1.get$x(sourceRect), t1.get$y(sourceRect), t1.get$width(sourceRect), t1.get$height(sourceRect));
      }
      J.set$globalCompositeOperation$x(this.context, temp);
      this.update$0();
      this.dirty = true;
    }, function(source, mask) {
      return this.alphaMask$4(source, mask, null, null);
    }, "alphaMask$2", function(source, mask, sourceRect) {
      return this.alphaMask$4(source, mask, sourceRect, null);
    }, "alphaMask$3", "call$4", "call$2", "call$3", "get$alphaMask", 4, 4, 1131, 12, 12, 208, [], 1132, [], 1133, [], 1134, [], "alphaMask"],
    extract$9: [function(destination, r, g, b, a, resize, r2, g2, b2) {
      var t1 = {};
      t1.a_0 = a;
      t1.r2_1 = r2;
      t1.g2_2 = g2;
      t1.b2_3 = b2;
      if (a == null)
        t1.a_0 = 255;
      if (resize == null)
        resize = false;
      if (r2 == null)
        t1.r2_1 = r;
      if (g2 == null)
        t1.g2_2 = g;
      if (b2 == null)
        t1.b2_3 = b;
      if (resize === true)
        J.resize$2$x(destination, this.width, this.height);
      this.processPixelRGB$1(new R.BitmapData_extract_closure(t1, destination, r, g, b));
      J.putImageData$3$x(J.get$context$x(destination), destination.get$imageData(), 0, 0);
      destination.set$dirty(true);
      return destination;
    }, function(destination, r, g, b) {
      return this.extract$9(destination, r, g, b, 255, null, null, null, null);
    }, "extract$4", function(destination, r, g, b, a, resize) {
      return this.extract$9(destination, r, g, b, a, resize, null, null, null);
    }, "extract$6", function(destination, r, g, b, a) {
      return this.extract$9(destination, r, g, b, a, null, null, null, null);
    }, "extract$5", function(destination, r, g, b, a, resize, r2) {
      return this.extract$9(destination, r, g, b, a, resize, r2, null, null);
    }, "extract$7", function(destination, r, g, b, a, resize, r2, g2) {
      return this.extract$9(destination, r, g, b, a, resize, r2, g2, null);
    }, "extract$8", "call$9", "call$4", "call$6", "call$5", "call$7", "call$8", "get$extract", 8, 10, 1135, 551, 12, 12, 12, 12, 1136, [], 346, [], 536, [], 349, [], 348, [], 1083, [], 572, [], 573, [], 448, [], "extract"],
    rect$5: [function(_, x, y, width, height, fillStyle) {
      if (fillStyle != null)
        J.set$fillStyle$x(this.context, fillStyle);
      J.fillRect$4$x(this.context, x, y, width, height);
    }, function($receiver, x, y, width, height) {
      return this.rect$5($receiver, x, y, width, height, null);
    }, "rect$4", "call$5", "call$4", "get$rect", 8, 2, 1137, 12, 9, [], 10, [], 31, [], 52, [], 1138, [], "rect"],
    circle$4: [function(x, y, radius, fillStyle) {
      if (fillStyle != null)
        J.set$fillStyle$x(this.context, fillStyle);
      J.beginPath$0$x(this.context);
      J.arc$6$x(this.context, x, y, radius, 0, 6.283185307179586, false);
      J.closePath$0$x(this.context);
      J.fill$0$x(this.context);
    }, function(x, y, radius) {
      return this.circle$4(x, y, radius, null);
    }, "circle$3", "call$4", "call$3", "get$circle", 6, 2, 1139, 12, 9, [], 10, [], 50, [], 1138, [], "circle"],
    render$0: [function() {
      if (this.disableTextureUpload !== true && J.$eq(this.game.get$renderType(), 2) && this.dirty === true) {
        M.updateWebGLTexture(this.baseTexture, this.game.get$renderer().get$gl());
        this.dirty = false;
      }
    }, "call$0", "get$render", 0, 0, 54, "render"],
    BitmapData$4: function(game, key, width, height) {
      var t1, index, i, index0, t2, t3, t4, t5;
      t1 = R.Canvas_create(this.width, this.height, "");
      this.canvas = t1;
      t1 = J.getContext$1$x(t1, "2d");
      this.context = t1;
      this.ctx = t1;
      t1 = J.getImageData$4$x(t1, 0, 0, this.width, this.height);
      this.imageData = t1;
      this.data = J.get$data$x(t1);
      this.pixels = null;
      this.pixels = new Uint32Array(H._checkLength(J.$tdiv$n(J.get$length$asx(J.get$data$x(this.imageData)), 4)));
      index = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(J.get$data$x(this.imageData));
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        t1 = this.pixels;
        index0 = index + 1;
        t2 = J.$shl$n(J.$index$asx(J.get$data$x(this.imageData), i), 24);
        t3 = J.$shl$n(J.$index$asx(J.get$data$x(this.imageData), i + 1), 16);
        t4 = J.$shl$n(J.$index$asx(J.get$data$x(this.imageData), i + 2), 8);
        t5 = J.$index$asx(J.get$data$x(this.imageData), i + 3);
        if (typeof t5 !== "number")
          return H.iae(t5);
        J.$indexSet$ax(t1, index, t2 + t3 + t4 + t5);
        i += 4;
        index = index0;
      }
      t1 = M.BaseTexture$(this.canvas, C.scaleModes_0);
      this.baseTexture = t1;
      this.texture = M.Texture$(t1, null);
      t1 = R.Frame$(0, 0, 0, this.width, this.height, "bitmapData", this.game.get$rnd().uuid$0());
      this.textureFrame = t1;
      this.texture.set$frame(t1);
      this.type = 13;
      this.disableTextureUpload = false;
      this.dirty = false;
      this.cls = this.get$clear(this);
      this.update = this.get$refreshBuffer();
      this._tempR = 0;
      this._tempG = 0;
      this._tempB = 0;
    },
    $isBitmapData: true,
    static: {BitmapData$: [function(game, key, width, height) {
        var t1 = new R.BitmapData(game, key, width, height, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.BitmapData$4(game, key, width, height);
        return t1;
      }, null, null, 8, 0, 311, 252, [], 269, [], 31, [], 52, [], "new BitmapData"]}
  },
  "+BitmapData": [674],
  BitmapData_extract_closure: {
    "^": "Closure:155;box_0,destination_1,r_2,g_3,b_4",
    call$3: [function(pixel, x, y) {
      var t1;
      if (J.$eq(J.get$r$x(pixel), this.r_2) && J.$eq(pixel.get$g(), this.g_3) && J.$eq(pixel.get$b(), this.b_4)) {
        t1 = this.box_0;
        this.destination_1.setPixel32$7(x, y, t1.r2_1, t1.g2_2, t1.b2_3, t1.a_0, false);
      }
      return false;
    }, "call$3", null, 6, 0, 155, 1140, [], 9, [], 10, [], "call"]
  },
  BitmapText0: {
    "^": "BitmapText;game@-613,exists@-617,name*-644,type*-614,z*-614,world@-615,_text@-644,_font@-644,_fontSize@-614,_align@-644,_tint@-614,_Phaser$_dirty@-617,events@-648,input@-1141,cameraOffset@-615,_cache@-645,renderOrderID@-614,autoCull@-617,alive@-617,anchor@-615,children:Phaser$BitmapText0$children*-1091,_Phaser$_currentBounds@-649,text-644,_style-935,_pool-645,PIXI$BitmapText$_dirty-617,tint-614,fontName-644,fontSize-616,_textWidth-616,_textHeight-616,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    get$x: [function(_) {
      return J.get$x$x(this.position);
    }, null, null, 1, 0, 619, "x"],
    set$x: [function(_, value) {
      J.set$x$x(this.position, value);
    }, null, null, 3, 0, 620, 138, [], "x"],
    get$y: [function(_) {
      return J.get$y$x(this.position);
    }, null, null, 1, 0, 619, "y"],
    set$y: [function(_, value) {
      J.set$y$x(this.position, value);
    }, null, null, 3, 0, 620, 138, [], "y"],
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.position), J.$div$n(J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.getLocalBounds$0())), 2));
      t2 = J.$add$ns(J.get$y$x(this.position), J.$div$n(J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.getLocalBounds$0())), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1010, "center"],
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 324, "parent"],
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$BitmapText0$children, child), J.get$length$asx(this.Phaser$BitmapText0$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$BitmapText0$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$BitmapText0$children));
        }
        return this;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1092, 12, 687, [], "bringToTop"],
    get$align: [function() {
      return this._align;
    }, null, null, 1, 0, 810, "align"],
    set$align: [function(value) {
      if (!J.$eq(value, this._align)) {
        this._align = value;
        this.setStyle$0();
      }
    }, null, null, 3, 0, 91, 138, [], "align"],
    get$tint: [function() {
      return this._tint;
    }, null, null, 1, 0, 619, "tint"],
    set$tint: [function(value) {
      if (!J.$eq(value, this._tint)) {
        this._tint = value;
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 620, 138, [], "tint"],
    get$angle: [function(_) {
      return J.$mul$ns(this.rotation, 57.29577951308232);
    }, null, null, 1, 0, 619, "angle"],
    angle$0: function($receiver) {
      return this.get$angle(this).call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.get$angle(this).call$2(arg0, arg1);
    },
    set$angle: [function(_, value) {
      this.rotation = J.$mul$ns(value, 0.017453292519943295);
    }, null, null, 3, 0, 620, 138, [], "angle"],
    get$font: [function(_) {
      return this._font;
    }, null, null, 1, 0, 810, "font"],
    set$font: [function(_, value) {
      var t1 = J.getInterceptor(value);
      if (!t1.$eq(value, this._font)) {
        this._font = t1.trim$0(value);
        J.set$font$x(this._style, J.$add$ns(J.$add$ns(J.$add$ns(J.toString$0(this._fontSize), "px '"), this._font), "'"));
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 91, 138, [], "font"],
    get$fontSize: [function(_) {
      return this._fontSize;
    }, null, null, 1, 0, 412, "fontSize"],
    set$fontSize: [function(_, value) {
      if (!J.$eq(value, this._fontSize)) {
        this._fontSize = value;
        J.set$font$x(this._style, J.$add$ns(J.$add$ns(J.$add$ns(J.toString$0(value), "px '"), J.toString$0(this._font)), "'"));
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 99, 138, [], "fontSize"],
    get$text: [function(_) {
      return this._text;
    }, null, null, 1, 0, 810, "text"],
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$text(this).call$4(arg0, arg1, arg2, arg3);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return this.get$text(this).call$3(arg0, arg1, arg2);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.get$text(this).call$5(arg0, arg1, arg2, arg3, arg4);
    },
    set$text: [function(_, value) {
      if (!J.$eq(value, this._text)) {
        this._text = value;
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 91, 138, [], "text"],
    get$inputEnabled: [function() {
      var t1 = this.input;
      return t1 != null && t1.get$enabled() === true;
    }, null, null, 1, 0, 247, "inputEnabled"],
    set$inputEnabled: [function(value) {
      var t1;
      if (value === true) {
        t1 = this.input;
        if (t1 == null) {
          t1 = R.InputHandler$(this);
          this.input = t1;
          t1.start$0(0);
        } else if (t1.get$enabled() !== true)
          J.start$0$x(this.input);
      } else {
        t1 = this.input;
        if (t1 != null && t1.get$enabled() === true)
          J.stop$0$x(this.input);
      }
    }, null, null, 3, 0, 639, 138, [], "inputEnabled"],
    get$fixedToCamera: [function() {
      return J.$eq(J.$index$asx(this._cache, 7), 1);
    }, null, null, 1, 0, 247, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.cameraOffset.set$2(J.get$x$x(this.position), J.get$y$x(this.position));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 639, 138, [], "fixedToCamera"],
    get$destroyPhase: [function() {
      return J.$eq(J.$index$asx(this._cache, 8), 1);
    }, null, null, 1, 0, 247, "destroyPhase"],
    setStyle$1: [function(style) {
      M.BitmapText.prototype.setStyle$1.call(this, style);
      this._style.set$align(this._align);
      this._font = this.fontName;
      this._fontSize = this._fontSize;
    }, function() {
      return this.setStyle$1(null);
    }, "setStyle$0", "call$1", "call$0", "get$setStyle", 0, 2, 1142, 12, 194, [], "setStyle"],
    preUpdate$0: [function() {
      var t1, t2, t3;
      J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
      J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
      J.$indexSet$ax(this._cache, 2, this.rotation);
      if (this.exists !== true || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        this.renderOrderID = -1;
        return false;
      }
      if (J.$eq(this.autoCull, true))
        this.renderable = J.intersects$1$x(this.game.get$world().get$camera().get$screenView(), this.getBounds$0());
      this.world.setTo$2(J.$add$ns(J.get$x$x(this.game.get$camera()), J.$index$asx(this._worldTransform, 2)), J.$add$ns(J.get$y$x(this.game.get$camera()), J.$index$asx(this._worldTransform, 5)));
      if (this.visible === true) {
        t1 = this._cache;
        t2 = this.game.get$stage();
        t3 = t2.get$currentRenderOrderID();
        t2.set$currentRenderOrderID(J.$add$ns(t3, 1));
        J.$indexSet$ax(t1, 3, t3);
      }
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 54, "update"],
    postUpdate$0: [function() {
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.position, J.$div$n(J.$add$ns(J.get$x$x(J.get$view$x(this.game.get$camera())), J.get$x$x(this.cameraOffset)), J.get$x$x(J.get$scale$x(this.game.get$camera()))));
        J.set$y$x(this.position, J.$div$n(J.$add$ns(J.get$y$x(J.get$view$x(this.game.get$camera())), J.get$y$x(this.cameraOffset)), J.get$y$x(J.get$scale$x(this.game.get$camera()))));
      }
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    destroy$1: [function(destroyChildren) {
      var i, t1, i0;
      if (this.game == null || J.$eq(J.$index$asx(this._cache, 8), 1))
        return;
      if (destroyChildren == null)
        destroyChildren = true;
      J.$indexSet$ax(this._cache, 8, 1);
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        if (!!J.getInterceptor(M.DisplayObject.prototype.get$parent.call(this, this)).$isGroup)
          H.interceptedTypeCast(M.DisplayObject.prototype.get$parent.call(this, this), "$isGroup").remove$1(0, this);
        else
          M.DisplayObject.prototype.get$parent.call(this, this).removeChild$1(this);
      i = J.get$length$asx(this.Phaser$BitmapText0$children);
      if (destroyChildren === true) {
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          if (!!J.getInterceptor(J.$index$asx(this.Phaser$BitmapText0$children, i0)).$isGameObject)
            J.$index$asx(this.Phaser$BitmapText0$children, i0).destroy$1(destroyChildren);
      } else
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0) {
          t1 = J.$index$asx(this.Phaser$BitmapText0$children, i0);
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$BitmapText0$children, t1));
        }
      this.exists = false;
      this.visible = false;
      this.set$filters(null);
      this.set$mask(0, null);
      this.game = null;
      J.$indexSet$ax(this._cache, 8, 0);
    }, "call$1", "get$destroy", 2, 0, 102, 1069, [], "destroy"],
    BitmapText$6: function(game, x, y, font, text, size) {
      var t1;
      this.game = game;
      this.exists = true;
      this.name = "";
      this.type = 6;
      this.z = 0;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.world = t1;
      this._text = text;
      this._align = "left";
      this._tint = 16777215;
      this.events = R.Events$(this);
      this.input = null;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.cameraOffset = t1;
      this.position.set$2(x, y);
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
    },
    $isGameObject: true,
    static: {BitmapText$: [function(game, x, y, font, text, size) {
        var t1, t2, t3, t4;
        t1 = M.TextStyle$0("left", "black", "bold 20pt Arial", "black", 0, 16777215);
        t1.font = font;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t4 = new R.BitmapText0(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, null, null, null, 16777215, null, null, null, null, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t4.BitmapText$2(text, t1);
        t4.BitmapText$6(game, x, y, font, text, size);
        return t4;
      }, null, null, 2, 10, 312, 12, 12, 12, 259, 313, 252, [], 9, [], 10, [], 201, [], 124, [], 314, [], "new BitmapText"]}
  },
  "+BitmapText": [1143, 2],
  Button: {
    "^": "Image;_onOverFrameName@-644,_onOutFrameName@-644,_onDownFrameName@-644,_onUpFrameName@-644,_onOverFrameID@-614,_onOutFrameID@-614,_onDownFrameID@-614,_onUpFrameID@-614,onOverMouseOnly@-617,onOverSound@-1144,onOutSound@-1144,onDownSound@-1144,onUpSound@-1144,onOverSoundMarker@-644,onOutSoundMarker@-644,onDownSoundMarker@-644,onUpSoundMarker@-644,onInputOver@-1145,onInputOut@-1145,onInputDown@-1145,onInputUp@-1146,freezeFrames@-617,forceOut@-617,game-613,exists-617,name-644,type-614,z-614,events-648,key-12,world-615,autoCull-617,input-1141,body-4,cameraOffset-615,Phaser$Image$anchor-615,cropRect-649,_frame-649,_cache-645,_crop-649,_Phaser$_bounds-649,_Phaser$_dirty-617,_frameName-644,alive-617,debug-617,Phaser$Image$children-1091,animations-1147,__tilePattern-822,_Phaser$_currentBounds-649,anchor-652,texture-698,updateFrame-617,PIXI$Sprite0$_PIXI$_width-616,PIXI$Sprite0$_PIXI$_height-616,_uvs-699,tintedTexture-700,buffer-701,tint-614,cachedTint-614,blendMode-702,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    clearFrames$0: [function() {
      this._onOverFrameName = null;
      this._onOverFrameID = null;
      this._onOutFrameName = null;
      this._onOutFrameID = null;
      this._onDownFrameName = null;
      this._onDownFrameID = null;
      this._onUpFrameName = null;
      this._onUpFrameID = null;
    }, "call$0", "get$clearFrames", 0, 0, 54, "clearFrames"],
    setFrames$4: [function(overFrame, outFrame, downFrame, upFrame) {
      this._onOverFrameName = null;
      this._onOverFrameID = null;
      this._onOutFrameName = null;
      this._onOutFrameID = null;
      this._onDownFrameName = null;
      this._onDownFrameID = null;
      this._onUpFrameName = null;
      this._onUpFrameID = null;
      if (overFrame != null)
        if (typeof overFrame === "string") {
          this._onOverFrameName = overFrame;
          if (this.input.pointerOver$0() === true)
            this.set$frameName(overFrame);
        } else {
          this._onOverFrameID = overFrame;
          if (this.input.pointerOver$0() === true)
            this.animations.set$frame(overFrame);
        }
      if (outFrame != null)
        if (typeof outFrame === "string") {
          this._onOutFrameName = outFrame;
          if (J.$eq(this.input.pointerOver$0(), false))
            this.set$frameName(outFrame);
        } else {
          this._onOutFrameID = outFrame;
          if (J.$eq(this.input.pointerOver$0(), false))
            this.animations.set$frame(outFrame);
        }
      if (downFrame != null)
        if (typeof downFrame === "string") {
          this._onDownFrameName = downFrame;
          if (this.input.pointerDown$0() === true)
            this.set$frameName(downFrame);
        } else {
          this._onDownFrameID = downFrame;
          if (this.input.pointerDown$0() === true)
            this.animations.set$frame(downFrame);
        }
      if (upFrame != null)
        if (typeof upFrame === "string") {
          this._onUpFrameName = upFrame;
          if (this.input.pointerUp$0() === true)
            this.set$frameName(upFrame);
        } else {
          this._onUpFrameID = upFrame;
          if (this.input.pointerUp$0() === true)
            this.animations.set$frame(upFrame);
        }
    }, "call$4", "get$setFrames", 8, 0, 1148, 316, [], 317, [], 318, [], 319, [], "setFrames"],
    setSounds$8: [function(overSound, overMarker, downSound, downMarker, outSound, outMarker, upSound, upMarker) {
      this.onOverSound = overSound;
      this.onOverSoundMarker = overMarker;
      this.onOutSound = outSound;
      this.onOutSoundMarker = outMarker;
      this.onDownSound = downSound;
      this.onDownSoundMarker = downMarker;
      this.onUpSound = upSound;
      this.onUpSoundMarker = upMarker;
    }, function(overSound) {
      return this.setSounds$8(overSound, null, null, null, null, null, null, null);
    }, "setSounds$1", function(overSound, overMarker) {
      return this.setSounds$8(overSound, overMarker, null, null, null, null, null, null);
    }, "setSounds$2", function() {
      return this.setSounds$8(null, null, null, null, null, null, null, null);
    }, "setSounds$0", function(overSound, overMarker, downSound) {
      return this.setSounds$8(overSound, overMarker, downSound, null, null, null, null, null);
    }, "setSounds$3", function(overSound, overMarker, downSound, downMarker) {
      return this.setSounds$8(overSound, overMarker, downSound, downMarker, null, null, null, null);
    }, "setSounds$4", function(overSound, overMarker, downSound, downMarker, outSound, outMarker) {
      return this.setSounds$8(overSound, overMarker, downSound, downMarker, outSound, outMarker, null, null);
    }, "setSounds$6", function(overSound, overMarker, downSound, downMarker, outSound) {
      return this.setSounds$8(overSound, overMarker, downSound, downMarker, outSound, null, null, null);
    }, "setSounds$5", function(overSound, overMarker, downSound, downMarker, outSound, outMarker, upSound) {
      return this.setSounds$8(overSound, overMarker, downSound, downMarker, outSound, outMarker, upSound, null);
    }, "setSounds$7", "call$8", "call$1", "call$2", "call$0", "call$3", "call$4", "call$6", "call$5", "call$7", "get$setSounds", 0, 16, 1149, 12, 12, 12, 12, 12, 12, 12, 12, 1150, [], 1151, [], 1152, [], 1153, [], 1154, [], 1155, [], 1156, [], 1157, [], "setSounds"],
    setOverSound$2: [function(sound, marker) {
      this.onOverSound = sound;
      this.onOverSoundMarker = marker;
    }, function(sound) {
      return this.setOverSound$2(sound, "");
    }, "setOverSound$1", function() {
      return this.setOverSound$2(null, "");
    }, "setOverSound$0", "call$2", "call$1", "call$0", "get$setOverSound", 0, 4, 1158, 12, 259, 1159, [], 1160, [], "setOverSound"],
    setOutSound$2: [function(sound, marker) {
      this.onOutSound = sound;
      this.onOutSoundMarker = marker;
    }, function(sound) {
      return this.setOutSound$2(sound, "");
    }, "setOutSound$1", function() {
      return this.setOutSound$2(null, "");
    }, "setOutSound$0", "call$2", "call$1", "call$0", "get$setOutSound", 0, 4, 1158, 12, 259, 1159, [], 1160, [], "setOutSound"],
    setDownSound$2: [function(sound, marker) {
      this.onDownSound = sound;
      this.onDownSoundMarker = marker;
    }, function(sound) {
      return this.setDownSound$2(sound, "");
    }, "setDownSound$1", function() {
      return this.setDownSound$2(null, "");
    }, "setDownSound$0", "call$2", "call$1", "call$0", "get$setDownSound", 0, 4, 1158, 12, 259, 1159, [], 1160, [], "setDownSound"],
    setUpSound$2: [function(sound, marker) {
      this.onUpSound = sound;
      this.onUpSoundMarker = marker;
    }, function(sound) {
      return this.setUpSound$2(sound, "");
    }, "setUpSound$1", function() {
      return this.setUpSound$2(null, "");
    }, "setUpSound$0", "call$2", "call$1", "call$0", "get$setUpSound", 0, 4, 1158, 12, 259, 1159, [], 1160, [], "setUpSound"],
    onInputOverHandler$2: [function(sprite, pointer) {
      var t1;
      if (J.$eq(this.freezeFrames, false))
        this.setState$1(1);
      if (this.onOverMouseOnly != null && pointer.get$isMouse() !== true)
        return;
      t1 = this.onOverSound;
      if (t1 != null)
        J.play$1$x(t1, this.onOverSoundMarker);
      t1 = this.onInputOver;
      if (t1 != null)
        t1.dispatch$1([this, pointer]);
    }, "call$2", "get$onInputOverHandler", 4, 0, 1161, 151, [], 1021, [], "onInputOverHandler"],
    onInputOutHandler$2: [function(sprite, pointer) {
      var t1;
      if (J.$eq(this.freezeFrames, false))
        this.setState$1(2);
      t1 = this.onOutSound;
      if (t1 != null)
        J.play$1$x(t1, this.onOutSoundMarker);
      t1 = this.onInputOut;
      if (t1 != null)
        t1.dispatch$1([this, pointer]);
    }, "call$2", "get$onInputOutHandler", 4, 0, 1161, 151, [], 1021, [], "onInputOutHandler"],
    onInputDownHandler$2: [function(sprite, pointer) {
      var t1;
      if (J.$eq(this.freezeFrames, false))
        this.setState$1(3);
      t1 = this.onDownSound;
      if (t1 != null)
        J.play$1$x(t1, this.onDownSoundMarker);
      t1 = this.onInputDown;
      if (t1 != null)
        t1.dispatch$1([this, pointer]);
    }, "call$2", "get$onInputDownHandler", 4, 0, 1161, 151, [], 1021, [], "onInputDownHandler"],
    onInputUpHandler$3: [function(sprite, pointer, isOver) {
      var t1 = this.onUpSound;
      if (t1 != null)
        J.play$1$x(t1, this.onUpSoundMarker);
      t1 = this.onInputUp;
      if (t1 != null)
        t1.dispatch$1([this, pointer, isOver]);
      if (this.freezeFrames === true)
        return;
      if (this.forceOut === true)
        this.setState$1(2);
      else if (this._onUpFrameName != null || this._onUpFrameID != null)
        this.setState$1(4);
      else if (isOver === true)
        this.setState$1(1);
      else
        this.setState$1(2);
    }, "call$3", "get$onInputUpHandler", 6, 0, 1162, 151, [], 1021, [], 1163, [], "onInputUpHandler"],
    setState$1: [function(newState) {
      var t1 = J.getInterceptor(newState);
      if (t1.$eq(newState, 1)) {
        t1 = this._onOverFrameName;
        if (t1 != null)
          this.set$frameName(t1);
        else {
          t1 = this._onOverFrameID;
          if (t1 != null)
            this.animations.set$frame(t1);
        }
      } else if (t1.$eq(newState, 2)) {
        t1 = this._onOutFrameName;
        if (t1 != null)
          this.set$frameName(t1);
        else {
          t1 = this._onOutFrameID;
          if (t1 != null)
            this.animations.set$frame(t1);
        }
      } else if (t1.$eq(newState, 3)) {
        t1 = this._onDownFrameName;
        if (t1 != null)
          this.set$frameName(t1);
        else {
          t1 = this._onDownFrameID;
          if (t1 != null)
            this.animations.set$frame(t1);
        }
      } else if (t1.$eq(newState, 4)) {
        t1 = this._onUpFrameName;
        if (t1 != null)
          this.set$frameName(t1);
        else {
          t1 = this._onUpFrameID;
          if (t1 != null)
            this.animations.set$frame(t1);
        }
      }
    }, "call$1", "get$setState", 2, 0, 99, 1164, [], "setState"],
    Button$9: function(game, x, y, key, callback, overFrame, outFrame, downFrame, upFrame) {
      this.type = 1;
      this._onOverFrameName = null;
      this._onOutFrameName = null;
      this._onDownFrameName = null;
      this._onUpFrameName = null;
      this._onOverFrameID = null;
      this._onOutFrameID = null;
      this._onDownFrameID = null;
      this._onUpFrameID = null;
      this.onOverMouseOnly = false;
      this.onOverSound = null;
      this.onOutSound = null;
      this.onDownSound = null;
      this.onUpSound = null;
      this.onOverSoundMarker = "";
      this.onOutSoundMarker = "";
      this.onDownSoundMarker = "";
      this.onUpSoundMarker = "";
      this.onInputOver = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onInputOut = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onInputDown = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onInputUp = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.freezeFrames = false;
      this.forceOut = false;
      this.set$inputEnabled(true);
      J.start$2$x(this.input, 0, true);
      this._onOverFrameName = null;
      this._onOverFrameID = null;
      this._onOutFrameName = null;
      this._onOutFrameID = null;
      this._onDownFrameName = null;
      this._onDownFrameID = null;
      this._onUpFrameName = null;
      this._onUpFrameID = null;
      if (overFrame != null)
        if (typeof overFrame === "string") {
          this._onOverFrameName = overFrame;
          if (this.input.pointerOver$0() === true)
            this.set$frameName(overFrame);
        } else {
          this._onOverFrameID = overFrame;
          if (this.input.pointerOver$0() === true)
            this.animations.set$frame(overFrame);
        }
      if (outFrame != null)
        if (typeof outFrame === "string") {
          this._onOutFrameName = outFrame;
          if (J.$eq(this.input.pointerOver$0(), false))
            this.set$frameName(outFrame);
        } else {
          this._onOutFrameID = outFrame;
          if (J.$eq(this.input.pointerOver$0(), false))
            this.animations.set$frame(outFrame);
        }
      if (downFrame != null)
        if (typeof downFrame === "string") {
          this._onDownFrameName = downFrame;
          if (this.input.pointerDown$0() === true)
            this.set$frameName(downFrame);
        } else {
          this._onDownFrameID = downFrame;
          if (this.input.pointerDown$0() === true)
            this.animations.set$frame(downFrame);
        }
      if (upFrame != null)
        if (typeof upFrame === "string") {
          this._onUpFrameName = upFrame;
          if (this.input.pointerUp$0() === true)
            this.set$frameName(upFrame);
        } else {
          this._onUpFrameID = upFrame;
          if (this.input.pointerUp$0() === true)
            this.animations.set$frame(upFrame);
        }
      if (callback != null)
        J.add$1$ax(this.onInputUp, callback);
      J.add$1$ax(this.events.get$onInputOver(), this.get$onInputOverHandler());
      J.add$1$ax(this.events.get$onInputOut(), this.get$onInputOutHandler());
      J.add$1$ax(this.events.get$onInputDown(), this.get$onInputDownHandler());
      J.add$1$ax(this.events.get$onInputUp(), this.get$onInputUpHandler());
    },
    static: {Button$: [function(game, x, y, key, callback, overFrame, outFrame, downFrame, upFrame) {
        var t1, t2, t3, t4, t5;
        t1 = J.$index$asx($.get$TextureCache(), "__default");
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = new R.Button(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, true, false, [], null, null, null, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t5.texture = t1;
        t5._setupTexture$0();
        t5.Image$5(game, x, y, key, outFrame);
        t5.Button$9(game, x, y, key, callback, overFrame, outFrame, downFrame, upFrame);
        return t5;
      }, null, null, 2, 16, 315, 49, 49, 12, 12, 12, 12, 12, 12, 252, [], 9, [], 10, [], 269, [], 26, [], 316, [], 317, [], 318, [], 319, [], "new Button"]}
  },
  "+Button": [1165],
  Events: {
    "^": "Object;onAddedToGroup@-1166,onRemovedFromGroup@-1166,onDestroy@-1167,onKilled@-1167,onRevived@-1167,onOutOfBounds@-1167,onEnterBounds@-1167,onInputOver@-1145,onInputOut@-1145,onInputDown@-1145,onInputUp@-1146,onDragStart*-1145,onDragStop@-1145,onAnimationStart*-964,onAnimationComplete@-964,onAnimationLoop@-964,parent*-2",
    destroy$0: [function() {
      this.parent = null;
      this.onDestroy.dispose$0();
      this.onAddedToGroup.dispose$0();
      this.onRemovedFromGroup.dispose$0();
      this.onKilled.dispose$0();
      this.onRevived.dispose$0();
      this.onOutOfBounds.dispose$0();
      var t1 = this.onInputOver;
      if (t1 != null) {
        t1.dispose$0();
        this.onInputOut.dispose$0();
        this.onInputDown.dispose$0();
        this.onInputUp.dispose$0();
        this.onDragStart.dispose$0();
        this.onDragStop.dispose$0();
      }
      t1 = this.onAnimationStart;
      if (t1 != null) {
        t1.dispose$0();
        this.onAnimationComplete.dispose$0();
        this.onAnimationLoop.dispose$0();
      }
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    Events$1: function(sprite) {
      this.parent = sprite;
      this.onAddedToGroup = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onRemovedFromGroup = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onDestroy = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onKilled = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onRevived = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onOutOfBounds = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onEnterBounds = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onInputOver = null;
      this.onInputOut = null;
      this.onInputDown = null;
      this.onInputUp = null;
      this.onDragStart = null;
      this.onDragStop = null;
      this.onAnimationStart = null;
      this.onAnimationComplete = null;
      this.onAnimationLoop = null;
    },
    static: {Events$: [function(sprite) {
        var t1 = new R.Events(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Events$1(sprite);
        return t1;
      }, null, null, 2, 0, 320, 151, [], "new Events"]}
  },
  "+Events": [674],
  CoreInterfact: {
    "^": "Object;game@-613,events@-648,visible@-617",
    static: {CoreInterfact$: [function() {
        return new R.CoreInterfact(null, null, null);
      }, null, null, 0, 0, 321, "new CoreInterfact"]}
  },
  "+CoreInterfact": [674],
  SpriteInterface: {
    "^": "Object;texture@-698,body*-4,anchor@-615,width*-616,height*-616,rotation@-616",
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.body.call$3(arg0, arg1, arg2);
    },
    $isSpriteInterface: true,
    static: {SpriteInterface$: [function() {
        return new R.SpriteInterface(null, null, null, null, null, null);
      }, null, null, 0, 0, 322, "new SpriteInterface"]}
  },
  "+SpriteInterface": [674, 1168],
  AnimationInterface: {
    "^": "Object;__tilePattern@-822",
    $isSpriteInterface: true,
    static: {AnimationInterface$: [function() {
        return new R.AnimationInterface(null);
      }, null, null, 0, 0, 323, "new AnimationInterface"]}
  },
  "+AnimationInterface": [674, 1169],
  GameObject: {
    "^": "Object;exists@-617,alive@-617,type*-614,name*-644,_Phaser$_currentBounds@-649,scale*-615,_cache@-709,_Phaser$_dirty@-617,anchor@-615,position*-615,x*-616,y*-616,z*-614,alpha*-616,rotation@-616,fixedToCamera@-617,cameraOffset@-615,width*-616,height*-616,autoCull@-617,children*-1091",
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    $isGameObject: true,
    static: {GameObject$: [function() {
        return new R.GameObject(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 324, "new GameObject"]}
  },
  "+GameObject": [674, 1168, 654],
  GameObjectCreator: {
    "^": "Object;game@-613,world@-1008",
    image$4: [function(x, y, key, frame) {
      return R.Image$(this.game, x, y, key, frame);
    }, function(x, y, key) {
      return this.image$4(x, y, key, null);
    }, "image$3", "call$4", "call$3", "get$image", 6, 2, 1170, 12, 9, [], 10, [], 269, [], 216, [], "image"],
    sprite$4: [function(x, y, key, frame) {
      return R.Sprite$(this.game, x, y, key, frame, null);
    }, function(x, y, key) {
      return this.sprite$4(x, y, key, null);
    }, "sprite$3", function(x, y) {
      return this.sprite$4(x, y, null, null);
    }, "sprite$2", "call$4", "call$3", "call$2", "get$sprite", 4, 4, 1171, 12, 12, 9, [], 10, [], 269, [], 216, [], "sprite"],
    tween$1: [function(obj) {
      return new R.Tween(obj, this.game, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), 1000, 0, false, false, 0, null, $.get$Easing_Default(), R.Math_linearInterpolation$closure(), [], false, null, null, false, 0, false, false, H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), false, null, null);
    }, "call$1", "get$tween", 2, 0, 1172, 630, [], "tween"],
    group$4: [function($name, addToStage, enableBody, physicsBodyType) {
      return R.Group$(this.game, null, $name, addToStage, enableBody, physicsBodyType, null);
    }, function(name) {
      return this.group$4(name, false, false, 0);
    }, "group$1", function(name, addToStage) {
      return this.group$4(name, addToStage, false, 0);
    }, "group$2", function() {
      return this.group$4(null, false, false, 0);
    }, "group$0", function(name, addToStage, enableBody) {
      return this.group$4(name, addToStage, enableBody, 0);
    }, "group$3", "call$4", "call$1", "call$2", "call$0", "call$3", "get$group", 0, 8, 1173, 12, 19, 19, 49, 83, [], 298, [], 299, [], 300, [], "group"],
    spriteBatch$3: [function($parent, $name, addToStage) {
      if ($name == null)
        $name = "group";
      if (addToStage == null)
        addToStage = false;
      return R.SpriteBatch$(this.game, $parent, $name, addToStage);
    }, function(parent) {
      return this.spriteBatch$3(parent, null, null);
    }, "spriteBatch$1", function(parent, name) {
      return this.spriteBatch$3(parent, name, null);
    }, "spriteBatch$2", "call$3", "call$1", "call$2", "get$spriteBatch", 2, 4, 1174, 12, 12, 84, [], 83, [], 298, [], "spriteBatch"],
    audio$4: [function(_, key, volume, loop, connect) {
      return J.add$4$ax(this.game.get$sound(), key, volume, loop, connect);
    }, function($receiver, key, volume, loop) {
      return this.audio$4($receiver, key, volume, loop, true);
    }, "audio$3", function($receiver, key, volume) {
      return this.audio$4($receiver, key, volume, false, true);
    }, "audio$2", function($receiver, key) {
      return this.audio$4($receiver, key, null, false, true);
    }, "audio$1", "call$4", "call$3", "call$2", "call$1", "get$audio", 2, 6, 1175, 12, 19, 78, 269, [], 470, [], 257, [], 471, [], "audio"],
    audioSprite$1: [function(key) {
      return this.game.get$sound().addSprite$1(key);
    }, "call$1", "get$audioSprite", 2, 0, 91, 269, [], "audioSprite"],
    sound$4: [function(key, volume, loop, connect) {
      return J.add$4$ax(this.game.get$sound(), key, volume, loop, connect);
    }, function(key, volume) {
      return this.sound$4(key, volume, false, true);
    }, "sound$2", function(key, volume, loop) {
      return this.sound$4(key, volume, loop, true);
    }, "sound$3", function(key) {
      return this.sound$4(key, null, false, true);
    }, "sound$1", "call$4", "call$2", "call$3", "call$1", "get$sound", 2, 6, 1175, 12, 19, 78, 269, [], 470, [], 257, [], 471, [], "sound"],
    tileSprite$6: [function(x, y, width, height, key, frame) {
      return R.TileSprite$(this.game, x, y, width, height, key, frame);
    }, "call$6", "get$tileSprite", 12, 0, 1176, 9, [], 10, [], 31, [], 52, [], 269, [], 216, [], "tileSprite"],
    rope$5: [function(x, y, key, frame, points) {
      return R.Rope$(this.game, x, y, key, frame, points);
    }, "call$5", "get$rope", 10, 0, 1177, 9, [], 10, [], 269, [], 216, [], 57, [], "rope"],
    text$4: [function(_, x, y, text, style) {
      return R.Text$(this.game, x, y, text, style);
    }, "call$4", "get$text", 8, 0, 1178, 9, [], 10, [], 124, [], 194, [], "text"],
    button$8: [function(_, x, y, key, callback, overFrame, outFrame, downFrame, upFrame) {
      return R.Button$(this.game, x, y, key, callback, overFrame, outFrame, downFrame, upFrame);
    }, function($receiver, x) {
      return this.button$8($receiver, x, 0, null, null, null, null, null, null);
    }, "button$1", function($receiver, x, y) {
      return this.button$8($receiver, x, y, null, null, null, null, null, null);
    }, "button$2", function($receiver) {
      return this.button$8($receiver, 0, 0, null, null, null, null, null, null);
    }, "button$0", function($receiver, x, y, key) {
      return this.button$8($receiver, x, y, key, null, null, null, null, null);
    }, "button$3", function($receiver, x, y, key, callback) {
      return this.button$8($receiver, x, y, key, callback, null, null, null, null);
    }, "button$4", function($receiver, x, y, key, callback, overFrame, outFrame) {
      return this.button$8($receiver, x, y, key, callback, overFrame, outFrame, null, null);
    }, "button$6", function($receiver, x, y, key, callback, overFrame) {
      return this.button$8($receiver, x, y, key, callback, overFrame, null, null, null);
    }, "button$5", function($receiver, x, y, key, callback, overFrame, outFrame, downFrame) {
      return this.button$8($receiver, x, y, key, callback, overFrame, outFrame, downFrame, null);
    }, "button$7", "call$8", "call$1", "call$2", "call$0", "call$3", "call$4", "call$6", "call$5", "call$7", "get$button", 0, 16, 1179, 49, 49, 12, 12, 12, 12, 12, 12, 9, [], 10, [], 269, [], 26, [], 316, [], 317, [], 318, [], 319, [], "button"],
    graphics$2: [function(x, y) {
      return R.Graphics$(this.game, x, y);
    }, function(x) {
      return this.graphics$2(x, 0);
    }, "graphics$1", function() {
      return this.graphics$2(0, 0);
    }, "graphics$0", "call$2", "call$1", "call$0", "get$graphics", 0, 4, 1180, 49, 49, 9, [], 10, [], "graphics"],
    emitter$3: [function(x, y, maxParticles) {
      return R.Emitter$(this.game, x, y, maxParticles);
    }, function(x) {
      return this.emitter$3(x, null, 50);
    }, "emitter$1", function(x, y) {
      return this.emitter$3(x, y, 50);
    }, "emitter$2", function() {
      return this.emitter$3(null, null, 50);
    }, "emitter$0", "call$3", "call$1", "call$2", "call$0", "get$emitter", 0, 6, 1181, 12, 12, 406, 9, [], 10, [], 458, [], "emitter"],
    retroFont$9: [function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
      return R.RetroFont$(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
    }, function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, 0, 0, 0);
    }, "retroFont$6", function(font, characterWidth, characterHeight, chars, charsPerRow) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, 0, 0, 0, 0);
    }, "retroFont$5", function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, 0, 0);
    }, "retroFont$7", function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, 0);
    }, "retroFont$8", "call$9", "call$6", "call$5", "call$7", "call$8", "get$retroFont", 10, 8, 1182, 49, 49, 49, 49, 201, [], 330, [], 331, [], 332, [], 333, [], 334, [], 335, [], 336, [], 337, [], "retroFont"],
    bitmapText$5: [function(x, y, font, text, size) {
      return R.BitmapText$(this.game, x, y, font, text, size);
    }, function(x, y, font) {
      return this.bitmapText$5(x, y, font, null, null);
    }, "bitmapText$3", function(x, y, font, text) {
      return this.bitmapText$5(x, y, font, text, null);
    }, "bitmapText$4", "call$5", "call$3", "call$4", "get$bitmapText", 6, 4, 1183, 12, 12, 9, [], 10, [], 201, [], 124, [], 314, [], "bitmapText"],
    tilemap$5: [function(key, tileWidth, tileHeight, width, height) {
      return R.Tilemap$(this.game, key, tileWidth, tileHeight, width, height);
    }, function(key, tileWidth, tileHeight, width) {
      return this.tilemap$5(key, tileWidth, tileHeight, width, 10);
    }, "tilemap$4", function(key) {
      return this.tilemap$5(key, 32, 32, 10, 10);
    }, "tilemap$1", function(key, tileWidth) {
      return this.tilemap$5(key, tileWidth, 32, 10, 10);
    }, "tilemap$2", function(key, tileWidth, tileHeight) {
      return this.tilemap$5(key, tileWidth, tileHeight, 10, 10);
    }, "tilemap$3", "call$5", "call$4", "call$1", "call$2", "call$3", "get$tilemap", 2, 8, 1184, 313, 313, 393, 393, 269, [], 498, [], 499, [], 31, [], 52, [], "tilemap"],
    renderTexture$4: [function(width, height, key, addToCache) {
      var texture;
      if (key == null)
        key = this.game.get$rnd().uuid$0();
      texture = R.RenderTexture$(this.game, width, height, key, null);
      if (addToCache === true)
        this.game.get$cache().addRenderTexture$2(key, texture);
      return texture;
    }, function(width) {
      return this.renderTexture$4(width, 100, null, false);
    }, "renderTexture$1", function(width, height) {
      return this.renderTexture$4(width, height, null, false);
    }, "renderTexture$2", function() {
      return this.renderTexture$4(100, 100, null, false);
    }, "renderTexture$0", function(width, height, key) {
      return this.renderTexture$4(width, height, key, false);
    }, "renderTexture$3", "call$4", "call$1", "call$2", "call$0", "call$3", "get$renderTexture", 0, 8, 1185, 129, 129, 12, 19, 31, [], 52, [], 269, [], 1186, [], "renderTexture"],
    bitmapData$4: [function(width, height, key, addToCache) {
      var texture;
      if (key == null)
        key = this.game.get$rnd().uuid$0();
      texture = R.BitmapData$(this.game, key, width, height);
      if (addToCache === true)
        this.game.get$cache().addBitmapData$2(key, texture);
      return texture;
    }, function(width, height) {
      return this.bitmapData$4(width, height, null, false);
    }, "bitmapData$2", function(width) {
      return this.bitmapData$4(width, 256, null, false);
    }, "bitmapData$1", function() {
      return this.bitmapData$4(256, 256, null, false);
    }, "bitmapData$0", function(width, height, key) {
      return this.bitmapData$4(width, height, key, false);
    }, "bitmapData$3", "call$4", "call$2", "call$1", "call$0", "call$3", "get$bitmapData", 0, 8, 1187, 342, 342, 12, 19, 31, [], 52, [], 269, [], 1186, [], "bitmapData"],
    filter$1: [function(_, filter) {
      return filter;
    }, "call$1", "get$filter", 2, 0, 1188, 912, [], "filter"],
    static: {GameObjectCreator$: [function(game) {
        var t1 = new R.GameObjectCreator(game, null);
        t1.world = game.get$world();
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new GameObjectCreator"]}
  },
  "+GameObjectCreator": [674],
  GameObjectFactory: {
    "^": "Object;game@-613,world@-1008",
    existing$1: [function(object) {
      return J.add$1$ax(this.world, object);
    }, "call$1", "get$existing", 2, 0, 102, 584, [], "existing"],
    image$5: [function(x, y, key, frame, group) {
      if (group == null)
        group = this.world;
      return J.add$1$ax(group, R.Image$(this.game, x, y, key, frame));
    }, function(x, y, key) {
      return this.image$5(x, y, key, null, null);
    }, "image$3", function(x, y, key, frame) {
      return this.image$5(x, y, key, frame, null);
    }, "image$4", "call$5", "call$3", "call$4", "get$image", 6, 4, 1189, 12, 12, 9, [], 10, [], 269, [], 216, [], 297, [], "image"],
    sprite$5: [function(x, y, key, frame, group) {
      return (group == null ? this.world : group).create$4(x, y, key, frame);
    }, function(x, y, key) {
      return this.sprite$5(x, y, key, null, null);
    }, "sprite$3", function(x, y, key, frame) {
      return this.sprite$5(x, y, key, frame, null);
    }, "sprite$4", function(x, y) {
      return this.sprite$5(x, y, null, null, null);
    }, "sprite$2", "call$5", "call$3", "call$4", "call$2", "get$sprite", 4, 6, 1190, 12, 12, 12, 9, [], 10, [], 269, [], 216, [], 297, [], "sprite"],
    tween$1: [function(obj) {
      return this.game.get$tweens().create$1(obj);
    }, "call$1", "get$tween", 2, 0, 1191, 630, [], "tween"],
    group$5: [function($parent, $name, addToStage, enableBody, physicsBodyType) {
      return R.Group$(this.game, $parent, $name, addToStage, enableBody, physicsBodyType, null);
    }, function(parent, name, addToStage, enableBody) {
      return this.group$5(parent, name, addToStage, enableBody, 0);
    }, "group$4", function(parent) {
      return this.group$5(parent, null, false, false, 0);
    }, "group$1", function(parent, name) {
      return this.group$5(parent, name, false, false, 0);
    }, "group$2", function() {
      return this.group$5(null, null, false, false, 0);
    }, "group$0", function(parent, name, addToStage) {
      return this.group$5(parent, name, addToStage, false, 0);
    }, "group$3", "call$5", "call$4", "call$1", "call$2", "call$0", "call$3", "get$group", 0, 10, 1192, 12, 12, 19, 19, 49, 84, [], 83, [], 298, [], 299, [], 300, [], "group"],
    physicsGroup$4: [function(physicsBodyType, $parent, $name, addToStage) {
      return R.Group$(this.game, $parent, $name, addToStage, true, physicsBodyType, null);
    }, function(physicsBodyType) {
      return this.physicsGroup$4(physicsBodyType, null, "group", false);
    }, "physicsGroup$1", function(physicsBodyType, parent) {
      return this.physicsGroup$4(physicsBodyType, parent, "group", false);
    }, "physicsGroup$2", function() {
      return this.physicsGroup$4(0, null, "group", false);
    }, "physicsGroup$0", function(physicsBodyType, parent, name) {
      return this.physicsGroup$4(physicsBodyType, parent, name, false);
    }, "physicsGroup$3", "call$4", "call$1", "call$2", "call$0", "call$3", "get$physicsGroup", 0, 8, 1193, 49, 12, 297, 19, 300, [], 84, [], 83, [], 298, [], "physicsGroup"],
    spriteBatch$3: [function($parent, $name, addToStage) {
      if ($parent == null)
        $parent = null;
      if ($name == null)
        $name = "group";
      if (addToStage == null)
        addToStage = false;
      return R.SpriteBatch$(this.game, $parent, $name, addToStage);
    }, function(parent) {
      return this.spriteBatch$3(parent, null, false);
    }, "spriteBatch$1", function(parent, name) {
      return this.spriteBatch$3(parent, name, false);
    }, "spriteBatch$2", function() {
      return this.spriteBatch$3(null, null, false);
    }, "spriteBatch$0", "call$3", "call$1", "call$2", "call$0", "get$spriteBatch", 0, 6, 1194, 12, 12, 19, 84, [], 83, [], 298, [], "spriteBatch"],
    audio$4: [function(_, key, volume, loop, connect) {
      return J.add$4$ax(this.game.get$sound(), key, volume, loop, connect);
    }, function($receiver, key, volume, loop) {
      return this.audio$4($receiver, key, volume, loop, true);
    }, "audio$3", function($receiver, key, volume) {
      return this.audio$4($receiver, key, volume, false, true);
    }, "audio$2", function($receiver, key) {
      return this.audio$4($receiver, key, 1, false, true);
    }, "audio$1", "call$4", "call$3", "call$2", "call$1", "get$audio", 2, 6, 1195, 433, 19, 78, 269, [], 470, [], 257, [], 471, [], "audio"],
    audioSprite$1: [function(key) {
      return this.game.get$sound().addSprite$1(key);
    }, "call$1", "get$audioSprite", 2, 0, 91, 269, [], "audioSprite"],
    sound$4: [function(key, volume, loop, connect) {
      return J.add$4$ax(this.game.get$sound(), key, volume, loop, connect);
    }, function(key, volume) {
      return this.sound$4(key, volume, false, true);
    }, "sound$2", function(key, volume, loop) {
      return this.sound$4(key, volume, loop, true);
    }, "sound$3", function(key) {
      return this.sound$4(key, 1, false, true);
    }, "sound$1", "call$4", "call$2", "call$3", "call$1", "get$sound", 2, 6, 1195, 433, 19, 78, 269, [], 470, [], 257, [], 471, [], "sound"],
    tileSprite$7: [function(x, y, width, height, key, frame, group) {
      if (group == null)
        group = this.world;
      return J.add$1$ax(group, R.TileSprite$(this.game, x, y, width, height, key, frame));
    }, function(x, y, width, height, key, frame) {
      return this.tileSprite$7(x, y, width, height, key, frame, null);
    }, "tileSprite$6", function(x, y, width, height, key) {
      return this.tileSprite$7(x, y, width, height, key, 0, null);
    }, "tileSprite$5", "call$7", "call$6", "call$5", "get$tileSprite", 10, 4, 1196, 49, 12, 9, [], 10, [], 31, [], 52, [], 269, [], 216, [], 297, [], "tileSprite"],
    rope$6: [function(x, y, key, frame, points, group) {
      if (group == null)
        group = this.world;
      return J.add$1$ax(group, R.Rope$(this.game, x, y, key, frame, points));
    }, function(x, y, key, frame, points) {
      return this.rope$6(x, y, key, frame, points, null);
    }, "rope$5", "call$6", "call$5", "get$rope", 10, 2, 1197, 12, 9, [], 10, [], 269, [], 216, [], 57, [], 297, [], "rope"],
    text$5: [function(_, x, y, text, style, group) {
      if (group == null)
        group = this.world;
      return J.add$1$ax(group, R.Text$(this.game, x, y, text, style));
    }, function($receiver, x, y, text, style) {
      return this.text$5($receiver, x, y, text, style, null);
    }, "text$4", "call$5", "call$4", "get$text", 8, 2, 1198, 12, 9, [], 10, [], 124, [], 194, [], 297, [], "text"],
    button$9: [function(_, x, y, key, callback, overFrame, outFrame, downFrame, upFrame, group) {
      if (group == null)
        group = this.world;
      return J.add$1$ax(group, R.Button$(this.game, x, y, key, callback, overFrame, outFrame, downFrame, upFrame));
    }, function($receiver, x, y, key, callback, overFrame, outFrame, downFrame, upFrame) {
      return this.button$9($receiver, x, y, key, callback, overFrame, outFrame, downFrame, upFrame, null);
    }, "button$8", function($receiver, x) {
      return this.button$9($receiver, x, null, null, null, null, null, null, null, null);
    }, "button$1", function($receiver, x, y) {
      return this.button$9($receiver, x, y, null, null, null, null, null, null, null);
    }, "button$2", function($receiver) {
      return this.button$9($receiver, null, null, null, null, null, null, null, null, null);
    }, "button$0", function($receiver, x, y, key) {
      return this.button$9($receiver, x, y, key, null, null, null, null, null, null);
    }, "button$3", function($receiver, x, y, key, callback) {
      return this.button$9($receiver, x, y, key, callback, null, null, null, null, null);
    }, "button$4", function($receiver, x, y, key, callback, overFrame, outFrame) {
      return this.button$9($receiver, x, y, key, callback, overFrame, outFrame, null, null, null);
    }, "button$6", function($receiver, x, y, key, callback, overFrame) {
      return this.button$9($receiver, x, y, key, callback, overFrame, null, null, null, null);
    }, "button$5", function($receiver, x, y, key, callback, overFrame, outFrame, downFrame) {
      return this.button$9($receiver, x, y, key, callback, overFrame, outFrame, downFrame, null, null);
    }, "button$7", "call$9", "call$8", "call$1", "call$2", "call$0", "call$3", "call$4", "call$6", "call$5", "call$7", "get$button", 0, 18, 1199, 12, 12, 12, 12, 12, 12, 12, 12, 12, 9, [], 10, [], 269, [], 26, [], 316, [], 317, [], 318, [], 319, [], 297, [], "button"],
    graphics$3: [function(x, y, group) {
      if (group == null)
        group = this.world;
      return J.add$1$ax(group, R.Graphics$(this.game, x, y));
    }, function(x, y) {
      return this.graphics$3(x, y, null);
    }, "graphics$2", function(x) {
      return this.graphics$3(x, 0, null);
    }, "graphics$1", function() {
      return this.graphics$3(0, 0, null);
    }, "graphics$0", "call$3", "call$2", "call$1", "call$0", "get$graphics", 0, 6, 1200, 49, 49, 12, 9, [], 10, [], 297, [], "graphics"],
    emitter$3: [function(x, y, maxParticles) {
      return J.add$1$ax(this.game.get$particles(), R.Emitter$(this.game, x, y, maxParticles));
    }, function(x) {
      return this.emitter$3(x, null, 50);
    }, "emitter$1", function(x, y) {
      return this.emitter$3(x, y, 50);
    }, "emitter$2", function() {
      return this.emitter$3(null, null, 50);
    }, "emitter$0", "call$3", "call$1", "call$2", "call$0", "get$emitter", 0, 6, 1201, 12, 12, 406, 9, [], 10, [], 458, [], "emitter"],
    retroFont$9: [function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
      return R.RetroFont$(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
    }, function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, 0, 0, 0);
    }, "retroFont$6", function(font, characterWidth, characterHeight, chars, charsPerRow) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, 0, 0, 0, 0);
    }, "retroFont$5", function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, 0, 0);
    }, "retroFont$7", function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, 0);
    }, "retroFont$8", "call$9", "call$6", "call$5", "call$7", "call$8", "get$retroFont", 10, 8, 1202, 49, 49, 49, 49, 201, [], 330, [], 331, [], 332, [], 333, [], 334, [], 335, [], 336, [], 337, [], "retroFont"],
    bitmapText$6: [function(x, y, font, text, size, group) {
      if (group == null)
        group = this.world;
      return J.add$1$ax(group, R.BitmapText$(this.game, x, y, font, text, size));
    }, function(x, y, font, text, size) {
      return this.bitmapText$6(x, y, font, text, size, null);
    }, "bitmapText$5", function(x, y, font) {
      return this.bitmapText$6(x, y, font, null, null, null);
    }, "bitmapText$3", function(x, y, font, text) {
      return this.bitmapText$6(x, y, font, text, null, null);
    }, "bitmapText$4", "call$6", "call$5", "call$3", "call$4", "get$bitmapText", 6, 6, 1203, 12, 12, 12, 9, [], 10, [], 201, [], 124, [], 314, [], 297, [], "bitmapText"],
    tilemap$5: [function(key, tileWidth, tileHeight, width, height) {
      return R.Tilemap$(this.game, key, tileWidth, tileHeight, width, height);
    }, function(key, tileWidth, tileHeight, width) {
      return this.tilemap$5(key, tileWidth, tileHeight, width, 10);
    }, "tilemap$4", function(key) {
      return this.tilemap$5(key, 32, 32, 10, 10);
    }, "tilemap$1", function(key, tileWidth) {
      return this.tilemap$5(key, tileWidth, 32, 10, 10);
    }, "tilemap$2", function() {
      return this.tilemap$5(null, 32, 32, 10, 10);
    }, "tilemap$0", function(key, tileWidth, tileHeight) {
      return this.tilemap$5(key, tileWidth, tileHeight, 10, 10);
    }, "tilemap$3", "call$5", "call$4", "call$1", "call$2", "call$0", "call$3", "get$tilemap", 0, 10, 1204, 12, 313, 313, 393, 393, 269, [], 498, [], 499, [], 31, [], 52, [], "tilemap"],
    renderTexture$4: [function(width, height, key, addToCache) {
      var texture;
      if (key == null)
        key = this.game.get$rnd().uuid$0();
      texture = R.RenderTexture$(this.game, width, height, key, null);
      if (addToCache === true)
        this.game.get$cache().addRenderTexture$2(key, texture);
      return texture;
    }, function(width) {
      return this.renderTexture$4(width, null, null, false);
    }, "renderTexture$1", function(width, height) {
      return this.renderTexture$4(width, height, null, false);
    }, "renderTexture$2", function() {
      return this.renderTexture$4(null, null, null, false);
    }, "renderTexture$0", function(width, height, key) {
      return this.renderTexture$4(width, height, key, false);
    }, "renderTexture$3", "call$4", "call$1", "call$2", "call$0", "call$3", "get$renderTexture", 0, 8, 1185, 12, 12, 12, 19, 31, [], 52, [], 269, [], 1186, [], "renderTexture"],
    bitmapData$4: [function(width, height, key, addToCache) {
      var texture;
      if (key == null)
        key = this.game.get$rnd().uuid$0();
      texture = R.BitmapData$(this.game, key, width, height);
      if (addToCache === true)
        this.game.get$cache().addBitmapData$2(key, texture);
      return texture;
    }, function(width, height) {
      return this.bitmapData$4(width, height, null, false);
    }, "bitmapData$2", function(width) {
      return this.bitmapData$4(width, 256, null, false);
    }, "bitmapData$1", function() {
      return this.bitmapData$4(256, 256, null, false);
    }, "bitmapData$0", function(width, height, key) {
      return this.bitmapData$4(width, height, key, false);
    }, "bitmapData$3", "call$4", "call$2", "call$1", "call$0", "call$3", "get$bitmapData", 0, 8, 1187, 342, 342, 12, 19, 31, [], 52, [], 269, [], 1186, [], "bitmapData"],
    filter$2: [function(_, filterType, args) {
      var filter;
      J.insert$2$ax(args, 0, this.game);
      filter = P.reflectClass(filterType).newInstance$2(null, args).reflectee;
      filter.init$0();
      return filter;
    }, function($receiver, filterType) {
      return this.filter$2($receiver, filterType, null);
    }, "filter$1", "call$2", "call$1", "get$filter", 2, 2, 1205, 12, 1206, [], 383, [], "filter"],
    plugin$1: [function(plugin) {
      return J.add$1$ax(this.game.get$plugins(), plugin);
    }, "call$1", "get$plugin", 2, 0, 1207, 1074, [], "plugin"],
    static: {GameObjectFactory$: [function(game) {
        var t1 = new R.GameObjectFactory(game, null);
        t1.world = game.get$world();
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new GameObjectFactory"]}
  },
  "+GameObjectFactory": [674],
  Graphics: {
    "^": "Graphics0;game@-613,position:Phaser$Graphics$position*-615,world@-615,cameraOffset@-615,_cache@-645,children:Phaser$Graphics$children*-1091,exists@-617,alive@-617,autoCull@-617,_Phaser$_dirty@-617,events@-648,type*-614,name*-644,_Phaser$_currentBounds@-649,anchor@-615,z*-614,fillAlpha-616,lineWidth-616,lineColor-616,fillColor-616,filling-617,lineAlpha-616,_graphicsData-856,tint-614,blendMode-702,_currentPath-857,_webGL-858,_isMask-617,bounds-659,boundsPadding-614,clearDirty-617,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 324, "parent"],
    get$renderOrderID: [function() {
      return J.$index$asx(this._cache, 3);
    }, null, null, 1, 0, 412, "renderOrderID"],
    set$renderOrderID: [function(value) {
      J.$indexSet$ax(this._cache, 3, value);
    }, null, null, 3, 0, 99, 138, [], "renderOrderID"],
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.Phaser$Graphics$position), J.$div$n(J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.getLocalBounds$0())), 2));
      t2 = J.$add$ns(J.get$y$x(this.Phaser$Graphics$position), J.$div$n(J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.getLocalBounds$0())), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1010, "center"],
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Graphics$children, child), J.get$length$asx(this.Phaser$Graphics$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Graphics$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$Graphics$children));
        }
        return this;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1092, 12, 687, [], "bringToTop"],
    get$angle: [function(_) {
      return J.$mul$ns(this.rotation, 57.29577951308232);
    }, null, null, 1, 0, 619, "angle"],
    angle$0: function($receiver) {
      return this.get$angle(this).call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.get$angle(this).call$2(arg0, arg1);
    },
    set$angle: [function(_, value) {
      this.rotation = J.$mul$ns(value, 0.017453292519943295);
    }, null, null, 3, 0, 620, 138, [], "angle"],
    get$fixedToCamera: [function() {
      return J.$eq(J.$index$asx(this._cache, 7), 1);
    }, null, null, 1, 0, 247, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.cameraOffset.set$2(J.get$x$x(this.Phaser$Graphics$position), J.get$y$x(this.Phaser$Graphics$position));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 639, 138, [], "fixedToCamera"],
    get$destroyPhase: [function() {
      return J.$eq(J.$index$asx(this._cache, 8), 1);
    }, null, null, 1, 0, 247, "destroyPhase"],
    preUpdate$0: [function() {
      var t1, t2, t3;
      J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
      J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
      J.$indexSet$ax(this._cache, 2, this.rotation);
      if (this.exists !== true || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        J.$indexSet$ax(this._cache, 3, -1);
        return false;
      }
      if (this.autoCull === true)
        this.renderable = J.intersects$1$x(this.game.get$world().get$camera().get$screenView(), new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Graphics0.prototype.getBounds$1.call(this, null)));
      this.world.setTo$2(J.$add$ns(J.get$x$x(this.game.get$camera()), J.$index$asx(this._worldTransform, 2)), J.$add$ns(J.get$y$x(this.game.get$camera()), J.$index$asx(this._worldTransform, 5)));
      if (this.visible === true) {
        t1 = this._cache;
        t2 = this.game.get$stage();
        t3 = t2.get$currentRenderOrderID();
        t2.set$currentRenderOrderID(J.$add$ns(t3, 1));
        J.$indexSet$ax(t1, 3, t3);
      }
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 54, "update"],
    postUpdate$0: [function() {
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.Phaser$Graphics$position, J.$div$n(J.$add$ns(J.get$x$x(J.get$view$x(this.game.get$camera())), J.get$x$x(this.cameraOffset)), J.get$x$x(J.get$scale$x(this.game.get$camera()))));
        J.set$y$x(this.Phaser$Graphics$position, J.$div$n(J.$add$ns(J.get$y$x(J.get$view$x(this.game.get$camera())), J.get$y$x(this.cameraOffset)), J.get$y$x(J.get$scale$x(this.game.get$camera()))));
      }
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    destroy$1: [function(destroyChildren) {
      var i, t1, i0;
      if (this.game == null || J.$eq(J.$index$asx(this._cache, 8), 1))
        return;
      if (destroyChildren == null)
        destroyChildren = true;
      J.$indexSet$ax(this._cache, 8, 1);
      this.clear$0(0);
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        if (!!J.getInterceptor(M.DisplayObject.prototype.get$parent.call(this, this)).$isGroup)
          H.interceptedTypeCast(M.DisplayObject.prototype.get$parent.call(this, this), "$isGroup").remove$1(0, this);
        else
          M.DisplayObject.prototype.get$parent.call(this, this).removeChild$1(this);
      i = J.get$length$asx(this.Phaser$Graphics$children);
      if (destroyChildren === true)
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          J.$index$asx(this.Phaser$Graphics$children, i0).destroy$1(destroyChildren);
      else
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0) {
          t1 = J.$index$asx(this.Phaser$Graphics$children, i0);
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Graphics$children, t1));
        }
      this.exists = false;
      this.visible = false;
      this.game = null;
      J.$indexSet$ax(this._cache, 8, 0);
    }, function() {
      return this.destroy$1(true);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 956, 78, 1069, [], "destroy"],
    drawPolygon$1: [function(poly) {
      var t1, i, t2, t3;
      t1 = J.getInterceptor$x(poly);
      this.moveTo$2(0, J.get$x$x(J.$index$asx(t1.get$points(poly), 0)), J.get$y$x(J.$index$asx(t1.get$points(poly), 0)));
      i = 1;
      while (true) {
        t2 = J.get$length$asx(t1.get$points(poly));
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        t2 = J.get$x$x(J.$index$asx(t1.get$points(poly), i));
        t3 = J.get$y$x(J.$index$asx(t1.get$points(poly), i));
        J.addAll$1$ax(J.get$points$x(this._currentPath), [t2, t3]);
        this._dirty = true;
        ++i;
      }
      this.lineTo$2(0, J.get$x$x(J.$index$asx(t1.get$points(poly), 0)), J.get$y$x(J.$index$asx(t1.get$points(poly), 0)));
    }, "call$1", "get$drawPolygon", 2, 0, 1208, 1209, [], "drawPolygon"],
    drawTriangle$2: [function(points, cull) {
      var triangle, t1, t2, t3, cameraToFace, t4, t5, ab, t6, cb, faceNormal;
      if (cull == null)
        cull = false;
      triangle = new R.Polygon0(points, null);
      triangle.type = 12;
      if (cull === true) {
        t1 = J.getInterceptor$asx(points);
        t2 = J.$sub$n(J.get$x$x(this.game.get$camera()), J.get$x$x(t1.$index(points, 0)));
        t3 = J.$sub$n(J.get$y$x(this.game.get$camera()), J.get$y$x(t1.$index(points, 0)));
        cameraToFace = new R.Point(null, null);
        cameraToFace.x = t2;
        cameraToFace.y = t3;
        t4 = J.$sub$n(J.get$x$x(t1.$index(points, 1)), J.get$x$x(t1.$index(points, 0)));
        t5 = J.$sub$n(J.get$y$x(t1.$index(points, 1)), J.get$y$x(t1.$index(points, 0)));
        ab = new R.Point(null, null);
        ab.x = t4;
        ab.y = t5;
        t6 = J.$sub$n(J.get$x$x(t1.$index(points, 1)), J.get$x$x(t1.$index(points, 2)));
        t1 = J.$sub$n(J.get$y$x(t1.$index(points, 1)), J.get$y$x(t1.$index(points, 2)));
        cb = new R.Point(null, null);
        cb.x = t6;
        cb.y = t1;
        faceNormal = J.$sub$n(J.$mul$ns(t6, t5), J.$mul$ns(t1, t4));
        t1 = new R.Point(null, null);
        t1.x = faceNormal;
        t1.y = 0;
        if (J.$gt$n(J.$add$ns(J.$mul$ns(t2, faceNormal), J.$mul$ns(t3, 0)), 0))
          this.drawPolygon$1(triangle);
      } else
        this.drawPolygon$1(triangle);
    }, function(points) {
      return this.drawTriangle$2(points, false);
    }, "drawTriangle$1", "call$2", "call$1", "get$drawTriangle", 2, 2, 1210, 19, 57, [], 1211, [], "drawTriangle"],
    drawTriangles$3: [function(vertices, indices, cull) {
      var point1, point2, point3, points, t1, i, t2, t3;
      if (cull == null)
        cull = false;
      point1 = new R.Point(null, null);
      point1.x = 0;
      point1.y = 0;
      point2 = new R.Point(null, null);
      point2.x = 0;
      point2.y = 0;
      point3 = new R.Point(null, null);
      point3.x = 0;
      point3.y = 0;
      points = [];
      if (indices == null) {
        t1 = J.getInterceptor$asx(vertices);
        if (!!J.getInterceptor(t1.$index(vertices, 0)).$isPoint) {
          i = 0;
          while (true) {
            t2 = J.$div$n(t1.get$length(vertices), 3);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            t2 = i * 3;
            this.drawTriangle$2([t1.$index(vertices, t2), t1.$index(vertices, t2 + 1), t1.$index(vertices, t2 + 2)], cull);
            ++i;
          }
        } else {
          i = 0;
          while (true) {
            t2 = J.$div$n(t1.get$length(vertices), 6);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            t2 = i * 6;
            point1.x = t1.$index(vertices, t2);
            point1.y = t1.$index(vertices, t2 + 1);
            point2.x = t1.$index(vertices, t2 + 2);
            point2.y = t1.$index(vertices, t2 + 3);
            point3.x = t1.$index(vertices, t2 + 4);
            point3.y = t1.$index(vertices, t2 + 5);
            this.drawTriangle$2([point1, point2, point3], cull);
            ++i;
          }
        }
      } else {
        t1 = J.getInterceptor$asx(vertices);
        if (!!J.getInterceptor(t1.$index(vertices, 0)).$isPoint) {
          t2 = J.getInterceptor$asx(indices);
          i = 0;
          while (true) {
            t3 = J.$div$n(t2.get$length(indices), 3);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(i < t3))
              break;
            t3 = i * 3;
            points.push(t1.$index(vertices, t2.$index(indices, t3)));
            points.push(t1.$index(vertices, t2.$index(indices, t3 + 1)));
            points.push(t1.$index(vertices, t2.$index(indices, t3 + 2)));
            if (points.length === 3) {
              this.drawTriangle$2(points, cull);
              points = [];
            }
            ++i;
          }
        } else {
          t2 = J.getInterceptor$asx(indices);
          i = 0;
          while (true) {
            t3 = t2.get$length(indices);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(i < t3))
              break;
            point1.x = t1.$index(vertices, J.$mul$ns(t2.$index(indices, i), 2));
            point1.y = t1.$index(vertices, J.$add$ns(J.$mul$ns(t2.$index(indices, i), 2), 1));
            t3 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
            t3.set$x(0, point1.x);
            t3.set$y(0, point1.y);
            points.push(t3);
            if (points.length === 3) {
              this.drawTriangle$2(points, cull);
              points = [];
            }
            ++i;
          }
        }
      }
    }, function(vertices) {
      return this.drawTriangles$3(vertices, null, false);
    }, "drawTriangles$1", function(vertices, indices) {
      return this.drawTriangles$3(vertices, indices, false);
    }, "drawTriangles$2", "call$3", "call$1", "call$2", "get$drawTriangles", 2, 4, 1212, 12, 19, 782, [], 1213, [], 1211, [], "drawTriangles"],
    getBounds$1: [function(matrix) {
      return new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Graphics0.prototype.getBounds$1.call(this, matrix));
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 1071, 12, 580, [], "getBounds"],
    Graphics$3: function(game, x, y) {
      var t1;
      J.set$x$x(this.Phaser$Graphics$position, x);
      J.set$y$x(this.Phaser$Graphics$position, y);
      this.exists = true;
      this.name = "";
      this.type = 3;
      this.z = 0;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.world = t1;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.cameraOffset = t1;
      this.Phaser$Graphics$position.set$2(x, y);
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
    },
    $isGameObject: true,
    static: {Graphics$: [function(game, x, y) {
        var t1, t2, t3, t4, t5, t6, t7;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = $.Graphics_POLY;
        t4 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = new M.Point0(null, null);
        t6.x = 1;
        t6.y = 1;
        t7 = new M.Point0(null, null);
        t7.x = 0;
        t7.y = 0;
        t7 = new R.Graphics(game, t1, null, null, null, [], null, null, false, false, null, null, null, null, t2, null, 1, 1, 0, 0, false, 1, [], 16777215, null, new M.GraphicsData([], 1, 0, null, 1, 1, 0, t3), t4, false, null, 0, false, [], false, 0, 0, t5, t6, t7, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t7.Graphics$0();
        t7.Graphics$3(game, x, y);
        return t7;
      }, null, null, 2, 4, 325, 49, 49, 252, [], 9, [], 10, [], "new Graphics"]}
  },
  "+Graphics": [660, 2],
  Image: {
    "^": "Sprite0;game@-613,exists@-617,name*-644,type*-614,z*-614,events@-648,key*-12,world@-615,autoCull@-617,input@-1141,body*-4,cameraOffset@-615,anchor:Phaser$Image$anchor@-615,cropRect@-649,_frame@-649,_cache@-645,_crop@-649,_Phaser$_bounds@-649,_Phaser$_dirty@-617,_frameName@-644,alive@-617,debug@-617,children:Phaser$Image$children*-1091,animations@-1147,__tilePattern@-822,_Phaser$_currentBounds@-649,anchor-652,texture-698,updateFrame-617,PIXI$Sprite0$_PIXI$_width-616,PIXI$Sprite0$_PIXI$_height-616,_uvs-699,tintedTexture-700,buffer-701,tint-614,cachedTint-614,blendMode-702,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.body.call$3(arg0, arg1, arg2);
    },
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.position), J.$div$n(J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.get$texture().get$frame())), 2));
      t2 = J.$add$ns(J.get$y$x(this.position), J.$div$n(J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.get$texture().get$frame())), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1010, "center"],
    debug$0: function() {
      return this.debug.call$0();
    },
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 324, "parent"],
    preUpdate$0: [function() {
      var t1, t2, t3, len, i;
      J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
      J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
      J.$indexSet$ax(this._cache, 2, this.rotation);
      if (this.exists !== true || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        J.$indexSet$ax(this._cache, 3, -1);
        return false;
      }
      if (this.autoCull === true)
        this.renderable = J.intersects$1$x(this.get$game().get$world().get$camera().get$screenView(), this.getBounds$0());
      this.world.setTo$2(J.$add$ns(J.get$x$x(this.get$game().get$camera()), J.$index$asx(this._worldTransform, 2)), J.$add$ns(J.get$y$x(this.get$game().get$camera()), J.$index$asx(this._worldTransform, 5)));
      if (this.visible === true) {
        t1 = this._cache;
        t2 = this.get$game().get$stage();
        t3 = t2.get$currentRenderOrderID();
        t2.set$currentRenderOrderID(J.$add$ns(t3, 1));
        J.$indexSet$ax(t1, 3, t3);
      }
      len = J.get$length$asx(this.Phaser$Image$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Image$children, i).preUpdate$0();
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 54, "update"],
    postUpdate$0: [function() {
      var t1, len, i;
      t1 = this.key;
      if (!!J.getInterceptor(t1).$isBitmapData)
        H.interceptedTypeCast(t1, "$isBitmapData").render$0();
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.position, J.$div$n(J.$add$ns(J.get$x$x(J.get$view$x(this.get$game().get$camera())), J.get$x$x(this.get$cameraOffset())), J.get$x$x(J.get$scale$x(this.get$game().get$camera()))));
        J.set$y$x(this.position, J.$div$n(J.$add$ns(J.get$y$x(J.get$view$x(this.get$game().get$camera())), J.get$y$x(this.get$cameraOffset())), J.get$y$x(J.get$scale$x(this.get$game().get$camera()))));
      }
      len = J.get$length$asx(this.Phaser$Image$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Image$children, i).postUpdate$0();
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    loadTexture$2: [function(key, frame) {
      var smoothed, t1, setFrame, t2;
      smoothed = J.$eq(this.get$texture().get$baseTexture().get$scaleMode(), 0);
      t1 = J.getInterceptor(key);
      if (!!t1.$isRenderTexture) {
        this.key = key.key;
        this.set$texture(key);
        this.cachedTint = 16777215;
        setFrame = true;
      } else if (!!t1.$isBitmapData) {
        this.set$texture(key.texture);
        this.cachedTint = 16777215;
        setFrame = this.get$game().get$cache().getFrameData$2(key.key, 9) == null || !this.animations.loadFrameData$2(this.get$game().get$cache().getFrameData$2(key.key, 9), frame);
      } else if (!!t1.$isTexture) {
        this.set$texture(key);
        this.cachedTint = 16777215;
        setFrame = true;
      } else if (key == null) {
        this.key = "__default";
        this.set$texture(J.$index$asx($.get$TextureCache(), "__default"));
        this.cachedTint = 16777215;
        setFrame = true;
      } else if (typeof key === "string" && !this.get$game().get$cache().checkImageKey$1(key)) {
        window;
        t1 = C.JSString_methods.$add("Texture with key '", key) + "' not found.";
        if (typeof console != "undefined")
          console.warn(t1);
        this.key = "__missing";
        this.set$texture(J.$index$asx($.get$TextureCache(), "__missing"));
        this.cachedTint = 16777215;
        setFrame = true;
      } else {
        this.set$texture(M.Texture$(J.$index$asx($.get$BaseTextureCache(), key), null));
        this.cachedTint = 16777215;
        setFrame = !this.animations.loadFrameData$2(this.get$game().get$cache().getFrameData$1(key), frame);
      }
      if (setFrame) {
        t1 = this.get$texture().get$frame();
        t2 = J.getInterceptor$x(t1);
        this._frame = new R.Rectangle1(t2.get$x(t1), t2.get$y(t1), t2.get$width(t1), t2.get$height(t1), 0, 0, 0, 0);
      }
      if (!smoothed)
        this.set$smoothed(false);
    }, function(key) {
      return this.loadTexture$2(key, 0);
    }, "loadTexture$1", "call$2", "call$1", "get$loadTexture", 2, 2, 888, 49, 269, [], 216, [], "loadTexture"],
    setFrame$1: [function(frame) {
      var t1;
      this._frame = frame;
      t1 = J.getInterceptor$x(frame);
      J.set$x$x(this.get$texture().get$frame(), t1.get$x(frame));
      J.set$y$x(this.get$texture().get$frame(), t1.get$y(frame));
      J.set$width$x(this.get$texture().get$frame(), t1.get$width(frame));
      J.set$height$x(this.get$texture().get$frame(), t1.get$height(frame));
      J.set$x$x(this.get$texture().get$crop(), t1.get$x(frame));
      J.set$y$x(this.get$texture().get$crop(), t1.get$y(frame));
      J.set$width$x(this.get$texture().get$crop(), t1.get$width(frame));
      J.set$height$x(this.get$texture().get$crop(), t1.get$height(frame));
      if (frame.get$trimmed() === true) {
        if (J.get$trim$s(this.get$texture()) != null) {
          J.set$x$x(J.get$trim$s(this.get$texture()), frame.get$spriteSourceSizeX());
          J.set$y$x(J.get$trim$s(this.get$texture()), frame.get$spriteSourceSizeY());
          J.set$width$x(J.get$trim$s(this.get$texture()), frame.get$sourceSizeW());
          J.set$height$x(J.get$trim$s(this.get$texture()), frame.get$sourceSizeH());
        } else
          J.set$trim$s(this.get$texture(), new R.Rectangle1(frame.get$spriteSourceSizeX(), frame.get$spriteSourceSizeY(), frame.get$sourceSizeW(), frame.get$sourceSizeH(), 0, 0, 0, 0));
        J.set$width$x(this.get$texture(), frame.get$sourceSizeW());
        J.set$height$x(this.get$texture(), frame.get$sourceSizeH());
        J.set$width$x(this.get$texture().get$frame(), frame.get$sourceSizeW());
        J.set$height$x(this.get$texture().get$frame(), frame.get$sourceSizeH());
      } else if (frame.get$trimmed() !== true && J.get$trim$s(this.get$texture()) != null)
        J.set$trim$s(this.get$texture(), null);
      if (this.cropRect != null)
        this.updateCrop$0();
      else if (J.$eq(this.get$game().get$renderType(), 2))
        this.get$texture()._updateWebGLuvs$0();
    }, "call$1", "get$setFrame", 2, 0, 1214, 216, [], "setFrame"],
    resetFrame$0: [function() {
      var t1 = this._frame;
      if (t1 != null)
        this.setFrame$1(t1);
    }, "call$0", "get$resetFrame", 0, 0, 54, "resetFrame"],
    crop$2: [function(rect, copy) {
      var t1;
      if (copy == null)
        copy = false;
      if (rect != null) {
        t1 = copy === true;
        if (t1 && this.cropRect != null) {
          t1 = J.getInterceptor$x(rect);
          this.cropRect.setTo$4(t1.get$x(rect), t1.get$y(rect), t1.get$width(rect), t1.get$height(rect));
        } else if (t1 && this.cropRect == null) {
          t1 = J.getInterceptor$x(rect);
          this.cropRect = new R.Rectangle1(t1.get$x(rect), t1.get$y(rect), t1.get$width(rect), t1.get$height(rect), 0, 0, 0, 0);
        } else
          this.cropRect = rect;
        this.updateCrop$0();
      } else {
        this._crop = null;
        this.cropRect = null;
        t1 = this._frame;
        if (t1 != null)
          this.setFrame$1(t1);
      }
    }, function(rect) {
      return this.crop$2(rect, false);
    }, "crop$1", "call$2", "call$1", "get$crop", 2, 2, 1215, 19, 1125, [], 1216, [], "crop"],
    updateCrop$0: [function() {
      var t1, t2, cx, cy, cw, ch;
      t1 = this.cropRect;
      if (t1 == null)
        return;
      t1 = J.clone$0$x(t1);
      this._crop = t1;
      t2 = J.getInterceptor$x(t1);
      t2.set$x(t1, J.$add$ns(t2.get$x(t1), J.get$x$x(this._frame)));
      t1 = this._crop;
      t2 = J.getInterceptor$x(t1);
      t2.set$y(t1, J.$add$ns(t2.get$y(t1), J.get$y$x(this._frame)));
      cx = P.max(J.get$x$x(this._frame), J.get$x$x(this._crop));
      cy = P.max(J.get$y$x(this._frame), J.get$y$x(this._crop));
      cw = P.min(J.get$right$x(this._frame), J.get$right$x(this._crop)) - cx;
      ch = P.min(J.get$bottom$x(this._frame), J.get$bottom$x(this._crop)) - cy;
      J.set$x$x(this.get$texture().get$crop(), cx);
      J.set$y$x(this.get$texture().get$crop(), cy);
      J.set$width$x(this.get$texture().get$crop(), cw);
      J.set$height$x(this.get$texture().get$crop(), ch);
      J.set$width$x(this.get$texture().get$frame(), P.min(cw, J.get$width$x(this.cropRect)));
      J.set$height$x(this.get$texture().get$frame(), P.min(ch, J.get$height$x(this.cropRect)));
      J.set$width$x(this.get$texture(), J.get$width$x(this.get$texture().get$frame()));
      J.set$height$x(this.get$texture(), J.get$height$x(this.get$texture().get$frame()));
      if (J.$eq(this.get$game().get$renderType(), 2))
        this.get$texture()._updateWebGLuvs$0();
    }, "call$0", "get$updateCrop", 0, 0, 54, "updateCrop"],
    revive$0: [function() {
      this.alive = true;
      this.exists = true;
      this.visible = true;
      var t1 = this.events;
      if (t1 != null)
        t1.get$onRevived().dispatch$1(this);
      return this;
    }, "call$0", "get$revive", 0, 0, 54, "revive"],
    kill$0: [function() {
      this.alive = false;
      this.exists = false;
      this.visible = false;
      var t1 = this.events;
      if (t1 != null)
        t1.get$onKilled().dispatch$1(this);
      return this;
    }, "call$0", "get$kill", 0, 0, 54, "kill"],
    destroy$1: [function(destroyChildren) {
      var t1, i, i0;
      if (this.get$game() == null || J.$eq(J.$index$asx(this._cache, 8), 1))
        return;
      J.$indexSet$ax(this._cache, 8, 1);
      t1 = this.events;
      if (t1 != null)
        t1.get$onDestroy().dispatch$1(this);
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        if (!!J.getInterceptor(M.DisplayObject.prototype.get$parent.call(this, this)).$isGroup)
          H.interceptedTypeCast(M.DisplayObject.prototype.get$parent.call(this, this), "$isGroup").remove$1(0, this);
        else
          M.DisplayObject.prototype.get$parent.call(this, this).removeChild$1(this);
      t1 = this.events;
      if (t1 != null)
        t1.destroy$0();
      t1 = this.input;
      if (t1 != null)
        t1.destroy$0();
      t1 = this.animations;
      if (t1 != null)
        t1.destroy$0();
      i = J.get$length$asx(this.Phaser$Image$children);
      if (destroyChildren === true)
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          J.$index$asx(this.Phaser$Image$children, i0).destroy$1(destroyChildren);
      else
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0) {
          t1 = J.$index$asx(this.Phaser$Image$children, i0);
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Image$children, t1));
        }
      this.alive = false;
      this.exists = false;
      this.visible = false;
      this.set$filters(null);
      this.set$mask(0, null);
      this.set$game(null);
      J.$indexSet$ax(this._cache, 8, 0);
    }, function() {
      return this.destroy$1(true);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 956, 78, 1069, [], "destroy"],
    reset$2: [function(_, x, y) {
      this.world.setTo$2(x, y);
      J.set$x$x(this.position, x);
      J.set$y$x(this.position, y);
      this.alive = true;
      this.exists = true;
      this.visible = true;
      this.renderable = true;
      return this;
    }, "call$2", "get$reset", 4, 0, 149, 9, [], 10, [], "reset"],
    bringToTop$1: [function(obj) {
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
      return this;
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1217, 12, 630, [], "bringToTop"],
    get$angle: [function(_) {
      return R.Math_wrapAngle(J.$mul$ns(this.rotation, 57.29577951308232), false);
    }, null, null, 1, 0, 619, "angle"],
    angle$0: function($receiver) {
      return this.get$angle(this).call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.get$angle(this).call$2(arg0, arg1);
    },
    set$angle: [function(_, value) {
      this.rotation = R.Math_wrapAngle(value, false) * 0.017453292519943295;
    }, null, null, 3, 0, 620, 138, [], "angle"],
    get$deltaX: [function(_) {
      return J.$sub$n(J.get$x$x(this.world), J.$index$asx(this._cache, 0));
    }, null, null, 1, 0, 619, "deltaX"],
    get$deltaY: [function(_) {
      return J.$sub$n(J.get$y$x(this.world), J.$index$asx(this._cache, 1));
    }, null, null, 1, 0, 619, "deltaY"],
    get$deltaZ: [function(_) {
      return J.$sub$n(this.rotation, J.$index$asx(this._cache, 2));
    }, null, null, 1, 0, 619, "deltaZ"],
    get$inWorld: [function() {
      return J.intersects$1$x(this.get$game().get$world().get$bounds(), this.getBounds$0());
    }, null, null, 1, 0, 54, "inWorld"],
    get$inCamera: [function() {
      return J.intersects$1$x(this.get$game().get$world().get$camera().get$screenView(), this.getBounds$0());
    }, null, null, 1, 0, 54, "inCamera"],
    get$frame: [function() {
      return this.animations.get$frame();
    }, null, null, 1, 0, 412, "frame"],
    set$frame: [function(value) {
      this.animations.set$frame(value);
    }, null, null, 3, 0, 99, 138, [], "frame"],
    get$frameName: [function() {
      return this._frameName;
    }, null, null, 1, 0, 810, "frameName"],
    set$frameName: [function(value) {
      var frameData;
      if (!J.$eq(value, this._frameName)) {
        frameData = this.get$game().get$cache().getFrameData$1(this.key);
        if (frameData === true && frameData.getFrameByName$1(value) === true) {
          this.set$texture(J.$index$asx($.get$TextureCache(), frameData.getFrameByName$1(value).get$uuid()));
          this.cachedTint = 16777215;
          this._frameName = value;
        }
      }
    }, null, null, 3, 0, 91, 138, [], "frameName"],
    get$renderOrderID: [function() {
      return J.$index$asx(this._cache, 3);
    }, null, null, 1, 0, 619, "renderOrderID"],
    get$inputEnabled: [function() {
      var t1 = this.input;
      return t1 != null && t1.get$enabled() === true;
    }, null, null, 1, 0, 247, "inputEnabled"],
    set$inputEnabled: [function(value) {
      var t1;
      if (value === true) {
        t1 = this.input;
        if (t1 == null) {
          t1 = R.InputHandler$(this);
          this.input = t1;
          t1.start$0(0);
        } else if (t1.get$enabled() !== true)
          J.start$0$x(this.input);
      } else {
        t1 = this.input;
        if (t1 != null && t1.get$enabled() === true)
          J.stop$0$x(this.input);
      }
    }, null, null, 3, 0, 639, 138, [], "inputEnabled"],
    get$fixedToCamera: [function() {
      return J.$eq(J.$index$asx(this._cache, 7), 1);
    }, null, null, 1, 0, 247, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.get$cameraOffset().set$2(J.get$x$x(this.position), J.get$y$x(this.position));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 639, 138, [], "fixedToCamera"],
    get$smoothed: [function() {
      return J.$eq(this.get$texture().get$baseTexture().get$scaleMode(), 0);
    }, null, null, 1, 0, 247, "smoothed"],
    set$smoothed: [function(value) {
      if (value === true) {
        if (this.get$texture() != null)
          this.get$texture().get$baseTexture().set$scaleMode(C.scaleModes_0);
      } else if (this.get$texture() != null)
        this.get$texture().get$baseTexture().set$scaleMode(C.scaleModes_1);
    }, null, null, 3, 0, 639, 138, [], "smoothed"],
    get$destroyPhase: [function() {
      return J.$eq(J.$index$asx(this._cache, 8), 1);
    }, null, null, 1, 0, 54, "destroyPhase"],
    Image$5: function(game, x, y, key, frame) {
      var t1;
      this.set$game(this.get$game());
      this.exists = true;
      this.set$name(0, "");
      this.set$type(0, 2);
      this.z = 0;
      this.events = R.Events$(this);
      this.key = key;
      this.position.set$2(x, y);
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.world = t1;
      this.autoCull = false;
      this.input = null;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.set$cameraOffset(t1);
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.Phaser$Image$anchor = t1;
      this.cropRect = null;
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
      this._crop = null;
      t1 = new R.AnimationManager(this, null, null, null, true, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), [], 0, null, null);
      t1.game = this.get$game();
      this.animations = t1;
      this._Phaser$_bounds = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      this.loadTexture$2(key, frame);
    },
    $isImage: true,
    $isSpriteInterface: true,
    $isGameObject: true,
    static: {Image$: [function(game, x, y, key, frame) {
        var t1, t2, t3, t4, t5;
        t1 = J.$index$asx($.get$TextureCache(), "__default");
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = new R.Image(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, true, false, [], null, null, null, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t5.texture = t1;
        t5._setupTexture$0();
        t5.Image$5(game, x, y, key, frame);
        return t5;
      }, null, null, 2, 8, 326, 49, 49, 12, 12, 252, [], 9, [], 10, [], 269, [], 216, [], "new Image"]}
  },
  "+Image": [661, 977, 1169, 2],
  Particle: {
    "^": "Sprite;autoScale@-617,scaleData@-1218,_s@-614,autoAlpha@-617,alphaData@-1218,_a@-614,game-613,key-12,name-644,type-616,z-616,events-648,animations-1147,_frameName-644,world-615,autoCull-617,input-1141,body-1219,alive-617,health-616,checkWorldBounds-617,outOfBoundsKill-617,debug-617,cameraOffset-615,cropRect-649,_cache-709,_crop-649,_frame-649,_Phaser$_bounds-649,lifespan-616,_Phaser$_dirty-617,__tilePattern-822,tilingTexture-698,camerOffset-615,Phaser$Sprite$children-1091,_Phaser$_currentBounds-649,Phaser$Sprite$anchor-615,Phaser$Sprite$position-615,_outOfBoundsFired-617,anchor-652,texture-698,updateFrame-617,PIXI$Sprite0$_PIXI$_width-616,PIXI$Sprite0$_PIXI$_height-616,_uvs-699,tintedTexture-700,buffer-701,tint-614,cachedTint-614,blendMode-702,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    update$0: [function() {
      if (this.autoScale === true) {
        var t1 = J.$sub$n(this._s, 1);
        this._s = t1;
        if (J.$ge$n(t1, 0))
          this.scale.set$2(J.$index$asx(J.$index$asx(this.scaleData, this._s), "x"), J.$index$asx(J.$index$asx(this.scaleData, this._s), "y"));
        else
          this.autoScale = false;
      }
      if (this.autoAlpha === true) {
        t1 = J.$sub$n(this._a, 1);
        this._a = t1;
        if (J.$ge$n(t1, 0))
          this.alpha = J.$index$asx(J.$index$asx(this.alphaData, this._a), "v");
        else
          this.autoAlpha = false;
      }
    }, "call$0", "get$update", 0, 0, 54, "update"],
    onEmit$0: [function() {
    }, "call$0", "get$onEmit", 0, 0, 54, "onEmit"],
    setAlphaData$1: [function(data) {
      var t1;
      this.alphaData = data;
      t1 = J.$sub$n(J.get$length$asx(data), 1);
      this._a = t1;
      this.alpha = J.$index$asx(J.$index$asx(this.alphaData, t1), "v");
      this.autoAlpha = true;
    }, "call$1", "get$setAlphaData", 2, 0, 1220, 87, [], "setAlphaData"],
    setScaleData$1: [function(data) {
      var t1;
      this.scaleData = data;
      t1 = J.$sub$n(J.get$length$asx(data), 1);
      this._s = t1;
      this.scale.set$2(J.$index$asx(J.$index$asx(this.scaleData, t1), "x"), J.$index$asx(J.$index$asx(this.scaleData, this._s), "y"));
      this.autoScale = true;
    }, "call$1", "get$setScaleData", 2, 0, 1220, 87, [], "setScaleData"],
    reset$3: [function(_, x, y, health) {
      var t1;
      if (health == null)
        health = 1;
      this.world.setTo$2(x, y);
      J.set$x$x(this.Phaser$Sprite$position, x);
      J.set$y$x(this.Phaser$Sprite$position, y);
      this.alive = true;
      this.set$exists(true);
      this.visible = true;
      this.renderable = true;
      this._outOfBoundsFired = false;
      this.health = health;
      t1 = this.body;
      if (t1 != null)
        J.reset$4$x(t1, x, y, false, false);
      J.$indexSet$ax(this._cache, 4, 1);
      this.alpha = 1;
      this.scale.set$1(1);
      this.autoScale = false;
      this.autoAlpha = false;
      return this;
    }, function($receiver, x, y) {
      return this.reset$3($receiver, x, y, 1);
    }, "reset$2", "call$3", "call$2", "get$reset", 4, 2, 1221, 433, 9, [], 10, [], 1222, [], "reset"],
    Particle$5: function(game, x, y, key, frame) {
      this.autoScale = false;
      this.scaleData = null;
      this._s = 0;
      this.autoAlpha = false;
      this.alphaData = null;
      this._a = 0;
    },
    $asSprite: function() {
      return [null];
    },
    "<>": [],
    static: {Particle$: [function(game, x, y, key, frame) {
        var t1, t2, t3, t4, t5, t6, t7;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = J.$index$asx($.get$TextureCache(), "__default");
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = new M.Point0(null, null);
        t6.x = 1;
        t6.y = 1;
        t7 = new M.Point0(null, null);
        t7.x = 0;
        t7.y = 0;
        t7 = new R.Particle(null, null, null, null, null, null, game, null, null, null, null, null, null, null, null, null, null, null, null, null, false, false, false, null, null, null, null, null, null, null, false, null, null, null, [], null, t1, t2, false, t4, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t5, t6, t7, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t7.texture = t3;
        t7._setupTexture$0();
        t7.Sprite$5(game, x, y, key, frame, null);
        t7.Particle$5(game, x, y, key, frame);
        return t7;
      }, null, null, 10, 0, 327, 252, [], 9, [], 10, [], 269, [], 216, [], "new Particle"]}
  },
  "+Particle": [961],
  RenderTexture: {
    "^": "RenderTexture0;key*-644,type*-614,_temp@-615,game@-613,renderer-837,PIXI$RenderTexture0$width-614,PIXI$RenderTexture0$height-614,PIXI$RenderTexture0$frame-659,PIXI$RenderTexture0$scaleMode-891,PIXI$RenderTexture0$baseTexture-853,textureBuffer-12,projection-652,render-950,PIXI$RenderTexture0$valid-617,noFrame-617,updateFrame-617,frame-659,trim-659,scope-853,_uvs-699,valid-617,baseTexture-853,PIXI$Texture$width-616,PIXI$Texture$height-616,sourceWidth-616,sourceHeight-616,tintCache-783,needsUpdate-617,isTiling-617,canvasBuffer-701,crop-659,id-614,width-616,height-616,scaleMode-891,_hasLoaded-617,source-12,_glTextures-947,imageUrl-644,_powerOf2-617,onLoaded-948,premultipliedAlpha-617,_dirty-783,listeners-848",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    renderXY$4: [function(displayObject, x, y, clear) {
      this._temp.set$2(x, y);
      this.render$3(displayObject, this._temp, clear);
    }, "call$4", "get$renderXY", 8, 0, 1223, 833, [], 9, [], 10, [], 954, [], "renderXY"],
    RenderTexture$5: function(game, width, height, key, scaleMode) {
      var t1;
      this.game = game;
      if (key == null)
        key = "";
      if (scaleMode == null)
        ;
      this.game = game;
      this.key = key;
      this.type = 8;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this._temp = t1;
    },
    $isRenderTexture: true,
    static: {RenderTexture$: [function(game, width, height, key, scaleMode) {
        var t1, t2, t3;
        t1 = game.get$renderer();
        t2 = M.BaseTexture$(null, C.scaleModes_0);
        t3 = $.BaseTextureCacheIdGenerator;
        $.BaseTextureCacheIdGenerator = J.$add$ns(t3, 1);
        t3 = new R.RenderTexture(null, null, null, null, t1, width, height, null, scaleMode, t2, null, null, null, null, false, false, null, null, null, null, false, null, 0, 0, 0, 0, null, true, null, null, null, t3, 100, 100, C.scaleModes_0, false, null, P.LinkedHashMap_LinkedHashMap(null, null, null, P.RenderingContext, null), null, false, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t3.BaseTexture$2(null, C.scaleModes_0);
        t3.scope = t3;
        t3.RenderTexture$4(width, height, t1, scaleMode);
        t3.RenderTexture$5(game, width, height, key, scaleMode);
        return t3;
      }, null, null, 6, 4, 328, 12, 12, 252, [], 31, [], 52, [], 269, [], 74, [], "new RenderTexture"]}
  },
  "+RenderTexture": [707],
  RetroFont: {
    "^": "RenderTexture;characterWidth@-616,characterHeight@-616,characterSpacingX@-616,characterSpacingY@-616,characterPerRow@-616,offsetX@-616,offsetY@-616,align@-644,multiLine@-617,autoUpperCase@-617,customSpacingX@-616,customSpacingY@-616,fixedWidth@-616,fontSet@-1224,stamp@-1165,_text@-644,grabData@-645,key-644,type-614,_temp-615,game-613,renderer-837,PIXI$RenderTexture0$width-614,PIXI$RenderTexture0$height-614,PIXI$RenderTexture0$frame-659,PIXI$RenderTexture0$scaleMode-891,PIXI$RenderTexture0$baseTexture-853,textureBuffer-12,projection-652,render-950,PIXI$RenderTexture0$valid-617,noFrame-617,updateFrame-617,frame-659,trim-659,scope-853,_uvs-699,valid-617,baseTexture-853,PIXI$Texture$width-616,PIXI$Texture$height-616,sourceWidth-616,sourceHeight-616,tintCache-783,needsUpdate-617,isTiling-617,canvasBuffer-701,crop-659,id-614,width-616,height-616,scaleMode-891,_hasLoaded-617,source-12,_glTextures-947,imageUrl-644,_powerOf2-617,onLoaded-948,premultipliedAlpha-617,_dirty-783,listeners-848",
    get$text: [function(_) {
      return this._text;
    }, null, null, 1, 0, 810, "text"],
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$text(this).call$4(arg0, arg1, arg2, arg3);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return this.get$text(this).call$3(arg0, arg1, arg2);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.get$text(this).call$5(arg0, arg1, arg2, arg3, arg4);
    },
    set$text: [function(_, value) {
      var newText = this.autoUpperCase === true ? J.toUpperCase$0$s(value) : value;
      if (!J.$eq(newText, this._text)) {
        this._text = newText;
        this.removeUnsupportedCharacters$1(this.multiLine);
        this.buildRetroFontText$0();
      }
    }, null, null, 3, 0, 91, 138, [], "text"],
    get$smoothed: [function() {
      return this.stamp.get$smoothed();
    }, null, null, 1, 0, 247, "smoothed"],
    set$smoothed: [function(value) {
      this.stamp.set$smoothed(value);
      this.buildRetroFontText$0();
    }, null, null, 3, 0, 639, 138, [], "smoothed"],
    setFixedWidth$2: [function(width, lineAlignment) {
      if (lineAlignment == null)
        lineAlignment = "left";
      this.fixedWidth = width;
      this.align = lineAlignment;
    }, function(width) {
      return this.setFixedWidth$2(width, "left");
    }, "setFixedWidth$1", "call$2", "call$1", "get$setFixedWidth", 2, 2, 1225, 198, 31, [], 1226, [], "setFixedWidth"],
    setText$6: [function($content, multiLine, characterSpacing, lineSpacing, lineAlignment, allowLowerCase) {
      var t1, newText;
      if (allowLowerCase === true)
        this.autoUpperCase = false;
      else
        this.autoUpperCase = true;
      t1 = J.getInterceptor$asx($content);
      if (J.$gt$n(t1.get$length($content), 0)) {
        newText = this.autoUpperCase === true ? t1.toUpperCase$0($content) : $content;
        if (!J.$eq(newText, this._text)) {
          this._text = newText;
          this.removeUnsupportedCharacters$1(this.multiLine);
          this.buildRetroFontText$0();
        }
      }
    }, function(content) {
      return this.setText$6(content, false, 0, 0, "left", false);
    }, "setText$1", function(content, multiLine) {
      return this.setText$6(content, multiLine, 0, 0, "left", false);
    }, "setText$2", function(content, multiLine, characterSpacing) {
      return this.setText$6(content, multiLine, characterSpacing, 0, "left", false);
    }, "setText$3", function(content, multiLine, characterSpacing, lineSpacing) {
      return this.setText$6(content, multiLine, characterSpacing, lineSpacing, "left", false);
    }, "setText$4", function(content, multiLine, characterSpacing, lineSpacing, lineAlignment) {
      return this.setText$6(content, multiLine, characterSpacing, lineSpacing, lineAlignment, false);
    }, "setText$5", "call$6", "call$1", "call$2", "call$3", "call$4", "call$5", "get$setText", 2, 10, 1227, 19, 49, 49, 198, 19, 226, [], 1228, [], 1229, [], 1230, [], 1226, [], 1231, [], "setText"],
    buildRetroFontText$0: [function() {
      var lines, t1, t2, t3, t4, cx, cy, i;
      this.clear$0(0);
      if (this.multiLine === true) {
        lines = J.split$1$s(this._text, "\n");
        if (J.$gt$n(this.fixedWidth, 0)) {
          t1 = this.fixedWidth;
          t2 = lines.length;
          t3 = J.$add$ns(this.characterHeight, this.customSpacingY);
          if (typeof t3 !== "number")
            return H.iae(t3);
          t4 = this.customSpacingY;
          if (typeof t4 !== "number")
            return H.iae(t4);
          this.resize$3(0, t1, t2 * t3 - t4, true);
        } else {
          t1 = J.$mul$ns(this.getLongestLine$0(), J.$add$ns(this.characterWidth, this.customSpacingX));
          t2 = lines.length;
          t3 = J.$add$ns(this.characterHeight, this.customSpacingY);
          if (typeof t3 !== "number")
            return H.iae(t3);
          t4 = this.customSpacingY;
          if (typeof t4 !== "number")
            return H.iae(t4);
          this.resize$3(0, t1, t2 * t3 - t4, true);
        }
        for (cx = 0, cy = 0, i = 0; i < lines.length; ++i) {
          switch (this.align) {
            case "left":
              cx = 0;
              break;
            case "right":
              cx = J.$sub$n(this.PIXI$RenderTexture0$width, J.$mul$ns(J.get$length$asx(lines[i]), J.$add$ns(this.characterWidth, this.customSpacingX)));
              break;
            case "center":
              t1 = J.$div$n(this.PIXI$RenderTexture0$width, 2);
              if (i >= lines.length)
                return H.ioore(lines, i);
              cx = J.$add$ns(J.$sub$n(t1, J.$div$n(J.$mul$ns(J.get$length$asx(lines[i]), J.$add$ns(this.characterWidth, this.customSpacingX)), 2)), J.$div$n(this.customSpacingX, 2));
              break;
          }
          if (J.$lt$n(cx, 0))
            cx = 0;
          if (i >= lines.length)
            return H.ioore(lines, i);
          this.pasteLine$4(lines[i], cx, cy, this.customSpacingX);
          t1 = J.$add$ns(this.characterHeight, this.customSpacingY);
          if (typeof t1 !== "number")
            return H.iae(t1);
          cy += t1;
        }
      } else {
        if (J.$gt$n(this.fixedWidth, 0))
          this.resize$3(0, this.fixedWidth, this.characterHeight, true);
        else
          this.resize$3(0, J.$mul$ns(J.get$length$asx(this._text), J.$add$ns(this.characterWidth, this.customSpacingX)), this.characterHeight, true);
        switch (this.align) {
          case "left":
            cx = 0;
            break;
          case "right":
            cx = J.$sub$n(this.PIXI$RenderTexture0$width, J.$mul$ns(J.get$length$asx(this._text), J.$add$ns(this.characterWidth, this.customSpacingX)));
            break;
          case "center":
            cx = J.$add$ns(J.$sub$n(J.$div$n(this.PIXI$RenderTexture0$width, 2), J.$div$n(J.$mul$ns(J.get$length$asx(this._text), J.$add$ns(this.characterWidth, this.customSpacingX)), 2)), J.$div$n(this.customSpacingX, 2));
            break;
          default:
            cx = 0;
        }
        J.clear$0$ax(this.textureBuffer);
        this.pasteLine$4(this._text, cx, 0, this.customSpacingX);
      }
    }, "call$0", "get$buildRetroFontText", 0, 0, 54, "buildRetroFontText"],
    pasteLine$4: [function(line, x, y, customSpacingX) {
      var p, t1, t2, c, t3;
      p = new R.Point(null, null);
      p.x = 0;
      p.y = 0;
      t1 = J.getInterceptor$asx(line);
      t2 = y == null;
      c = 0;
      while (true) {
        t3 = t1.get$length(line);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(c < t3))
          break;
        if (J.$eq(t1.$index(line, c), " "))
          x = J.$add$ns(x, J.$add$ns(this.characterWidth, customSpacingX));
        else if (J.$ge$n(J.$index$asx(this.grabData, t1.codeUnitAt$1(line, c)), 0)) {
          this.stamp.set$frame(J.$index$asx(this.grabData, t1.codeUnitAt$1(line, c)));
          p.x = x;
          p.y = t2 ? x : y;
          this.render$3(this.stamp, p, false);
          x = J.$add$ns(x, J.$add$ns(this.characterWidth, customSpacingX));
          if (J.$gt$n(x, this.PIXI$RenderTexture0$width))
            break;
        }
        ++c;
      }
    }, "call$4", "get$pasteLine", 8, 0, 1232, 1233, [], 9, [], 10, [], 1234, [], "pasteLine"],
    getLongestLine$0: [function() {
      var lines, longestLine, i;
      if (J.$gt$n(J.get$length$asx(this._text), 0)) {
        lines = J.split$1$s(this._text, "\n");
        for (longestLine = 0, i = 0; i < lines.length; ++i)
          if (J.$gt$n(J.get$length$asx(lines[i]), longestLine)) {
            if (i >= lines.length)
              return H.ioore(lines, i);
            longestLine = J.get$length$asx(lines[i]);
          }
      } else
        longestLine = 0;
      return longestLine;
    }, "call$0", "get$getLongestLine", 0, 0, 619, "getLongestLine"],
    removeUnsupportedCharacters$1: [function(stripCR) {
      var t1, newString, c, t2, aChar, code;
      t1 = stripCR !== true;
      newString = "";
      c = 0;
      while (true) {
        t2 = J.get$length$asx(this._text);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(c < t2))
          break;
        aChar = J.$index$asx(this._text, c);
        t2 = J.getInterceptor$s(aChar);
        code = t2.codeUnitAt$1(aChar, 0);
        if (!J.$ge$n(J.$index$asx(this.grabData, code), 0))
          t2 = t1 && t2.$eq(aChar, "\n");
        else
          t2 = true;
        if (t2)
          newString = C.JSString_methods.$add(newString, aChar);
        ++c;
      }
      return newString;
    }, "call$1", "get$removeUnsupportedCharacters", 2, 0, 1235, 1236, [], "removeUnsupportedCharacters"],
    updateOffset$2: [function(x, y) {
      var diffX, diffY, $frames, t1, i, i0, t2, t3;
      if (J.$eq(this.offsetX, x) && J.$eq(this.offsetY, y))
        return;
      diffX = J.$sub$n(x, this.offsetX);
      diffY = J.$sub$n(y, this.offsetY);
      $frames = this.game.get$cache().getFrameData$1(J.get$key$x(this.stamp)).getFrames$0();
      t1 = J.getInterceptor$asx($frames);
      i = t1.get$length($frames);
      for (; i0 = J.$sub$n(i, 1), i === true; i = i0) {
        t2 = t1.$index($frames, i0);
        t3 = J.getInterceptor$x(t2);
        t3.set$x(t2, J.$add$ns(t3.get$x(t2), diffX));
        t2 = t1.$index($frames, i0);
        t3 = J.getInterceptor$x(t2);
        t3.set$y(t2, J.$add$ns(t3.get$y(t2), diffY));
        J.set$x$x(J.$index$asx($.get$TextureCache(), t1.$index($frames, i0).get$uuid()).get$frame(), J.get$x$x(t1.$index($frames, i0)));
        J.set$y$x(J.$index$asx($.get$TextureCache(), t1.$index($frames, i0).get$uuid()).get$frame(), J.get$y$x(t1.$index($frames, i0)));
      }
      this.buildRetroFontText$0();
    }, function() {
      return this.updateOffset$2(0, 0);
    }, "updateOffset$0", function(x) {
      return this.updateOffset$2(x, 0);
    }, "updateOffset$1", "call$2", "call$0", "call$1", "get$updateOffset", 0, 4, 56, 49, 49, 9, [], 10, [], "updateOffset"],
    RetroFont$10: function(game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
      var currentX, currentY, data, t1, r, c, t2, uuid, t3, t4, dx, dy, frame;
      if (!game.get$cache().checkImageKey$1(key))
        throw H.wrapException(P.Exception_Exception("error!"));
      if (charsPerRow == null || false)
        charsPerRow = J.$div$n(J.get$width$x(game.get$cache().getImage$1(key)), characterWidth);
      this.characterWidth = characterWidth;
      this.characterHeight = characterHeight;
      this.characterSpacingX = xSpacing;
      this.characterSpacingY = ySpacing;
      this.characterPerRow = charsPerRow;
      this.offsetX = xOffset;
      this.offsetY = yOffset;
      this.align = "left";
      this.multiLine = false;
      this.autoUpperCase = true;
      this.customSpacingX = 0;
      this.customSpacingY = 0;
      this.fixedWidth = 0;
      this.fontSet = game.get$cache().getImage$1(key);
      this._text = "";
      this.grabData = [];
      currentX = this.offsetX;
      currentY = this.offsetY;
      data = new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      t1 = J.getInterceptor$asx(chars);
      r = 0;
      c = 0;
      while (true) {
        t2 = t1.get$length(chars);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(c < t2))
          break;
        uuid = game.get$rnd().uuid$0();
        t2 = this.characterWidth;
        t3 = this.characterHeight;
        t4 = new R.Frame(c, currentX, currentY, t2, t3, "", uuid, null, null, null, false, "cw", false, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        t4.centerX = J.floor$0$n(J.$div$n(t2, 2));
        t4.centerY = J.floor$0$n(J.$div$n(t3, 2));
        t4.sourceSizeW = t2;
        t4.sourceSizeH = t3;
        if (typeof t2 !== "number")
          return H.iae(t2);
        dx = 0 - t2;
        if (typeof t3 !== "number")
          return H.iae(t3);
        dy = 0 - t3;
        t4.distance = Math.sqrt(dx * dx + dy * dy);
        frame = data.addFrame$1(t4);
        J.$indexSet$ax(this.grabData, t1.codeUnitAt$1(chars, c), J.get$index$x(frame));
        t2 = $.get$TextureCache();
        t3 = J.$index$asx($.get$BaseTextureCache(), key);
        t4 = new M.Rectangle0(0, 0, 0, 0);
        t4.x = currentX;
        t4.y = currentY;
        t4.width = this.characterWidth;
        t4.height = this.characterHeight;
        J.$indexSet$ax(t2, uuid, M.Texture$(t3, t4));
        ++r;
        if (r === this.characterPerRow) {
          currentX = this.offsetX;
          currentY = J.$add$ns(currentY, J.$add$ns(this.characterHeight, this.characterSpacingY));
          r = 0;
        } else
          currentX = J.$add$ns(currentX, J.$add$ns(this.characterWidth, this.characterSpacingX));
        ++c;
      }
      game.get$cache().updateFrameData$2(key, data);
      this.stamp = R.Image$(game, 0, 0, key, 0);
      this.type = 17;
    },
    static: {"^": "RetroFont_ALIGN_LEFT<-644,RetroFont_ALIGN_RIGHT<-644,RetroFont_ALIGN_CENTER<-644,RetroFont_TEXT_SET1<-644,RetroFont_TEXT_SET2<-644,RetroFont_TEXT_SET3<-644,RetroFont_TEXT_SET4<-644,RetroFont_TEXT_SET5<-644,RetroFont_TEXT_SET6<-644,RetroFont_TEXT_SET7<-644,RetroFont_TEXT_SET8<-644,RetroFont_TEXT_SET9<-644,RetroFont_TEXT_SET10<-644,RetroFont_TEXT_SET11<-644", RetroFont$: [function(game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
        var t1, t2, t3;
        t1 = game.get$renderer();
        t2 = M.BaseTexture$(null, C.scaleModes_0);
        t3 = $.BaseTextureCacheIdGenerator;
        $.BaseTextureCacheIdGenerator = J.$add$ns(t3, 1);
        t3 = new R.RetroFont(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t1, 100, 100, null, C.scaleModes_2, t2, null, null, null, null, false, false, null, null, null, null, false, null, 0, 0, 0, 0, null, true, null, null, null, t3, 100, 100, C.scaleModes_0, false, null, P.LinkedHashMap_LinkedHashMap(null, null, null, P.RenderingContext, null), null, false, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t3.BaseTexture$2(null, C.scaleModes_0);
        t3.scope = t3;
        t3.RenderTexture$4(100, 100, t1, C.scaleModes_2);
        t3.RenderTexture$5(game, 100, 100, "", C.scaleModes_2);
        t3.RetroFont$10(game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
        return t3;
      }, null, null, 10, 10, 329, 12, 12, 12, 12, 12, 252, [], 269, [], 330, [], 331, [], 332, [], 333, [], 334, [], 335, [], 336, [], 337, [], "new RetroFont"]}
  },
  "+RetroFont": [1237],
  Rope0: {
    "^": "Rope;points:Phaser$Rope0$points*-645,_hasUpdateAnimation@-617,_updateAnimationCallback@-0,game@-613,name*-644,type*-614,z*-616,events@-648,animations@-1147,_frame@-616,_frameName@-644,_scroll@-615,input@-1141,world@-615,checkWorldBounds@-617,key*-12,tilePosition@-615,_outOfBoundsFired@-617,_updateAnimation@-0,children:Phaser$Rope0$children*-1091,_Phaser$_bounds@-649,__tilePattern@-822,_Phaser$_dirty@-617,_Phaser$_currentBounds@-649,_cache@-645,anchor@-615,cameraOffset@-615,autoCull@-617,alive@-617,center@-615,body*-4,points-675,PIXI$Rope$count-616,texture-698,blendMode-702,uvs-672,verticies-672,colors-672,indices-714,updateFrame-617,_vertexBuffer-715,_indexBuffer-715,_uvBuffer-715,_colorBuffer-715,count-614,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 324, "parent"],
    get$renderOrderID: [function() {
      return J.$index$asx(this._cache, 3);
    }, null, null, 1, 0, 619, "renderOrderID"],
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.body.call$3(arg0, arg1, arg2);
    },
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Rope0$children, child), J.get$length$asx(this.Phaser$Rope0$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Rope0$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$Rope0$children));
        }
        return this;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1092, 12, 687, [], "bringToTop"],
    preUpdate$0: [function() {
      var t1, t2, t3, len, i;
      if (J.$eq(J.$index$asx(this._cache, 4), 1) && J.$eq(J.$index$asx(this._cache, 6), 1)) {
        this.world.setTo$2(J.$add$ns(J.get$x$x(J.get$position$x(M.DisplayObject.prototype.get$parent.call(this, this))), J.get$x$x(this.position)), J.$add$ns(J.get$y$x(J.get$position$x(M.DisplayObject.prototype.get$parent.call(this, this))), J.get$y$x(this.position)));
        this._worldTransform.set$tx(J.toDouble$0$n(J.get$x$x(this.world)));
        this._worldTransform.set$ty(J.toDouble$0$n(J.get$y$x(this.world)));
        J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
        J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
        J.$indexSet$ax(this._cache, 2, this.rotation);
        t1 = this.body;
        if (t1 != null)
          t1.preUpdate$0();
        J.$indexSet$ax(this._cache, 4, 0);
        return false;
      }
      J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
      J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
      J.$indexSet$ax(this._cache, 2, this.rotation);
      if (!J.$eq(J.$index$asx(this._cache, 6), 1) || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        J.$indexSet$ax(this._cache, 3, -1);
        return false;
      }
      if (this.autoCull === true || this.checkWorldBounds === true)
        this._Phaser$_bounds = J.clone$0$x(this.getBounds$0());
      if (this.autoCull === true)
        this.renderable = J.intersects$1$x(this.game.get$world().get$camera().get$screenView(), this._Phaser$_bounds);
      if (this.checkWorldBounds === true)
        if (J.$eq(J.$index$asx(this._cache, 5), 1) && J.intersects$1$x(this.game.get$world().get$bounds(), this._Phaser$_bounds) === true) {
          J.$indexSet$ax(this._cache, 5, 0);
          this.events.get$onEnterBounds().dispatch$1(this);
        } else if (J.$eq(J.$index$asx(this._cache, 5), 0) && J.intersects$1$x(this.game.get$world().get$bounds(), this._Phaser$_bounds) !== true) {
          J.$indexSet$ax(this._cache, 5, 1);
          this.events.get$onOutOfBounds().dispatch$1(this);
        }
      this.world.setTo$2(J.$add$ns(J.get$x$x(this.game.get$camera()), this._worldTransform.get$tx()), J.$add$ns(J.get$y$x(this.game.get$camera()), this._worldTransform.get$ty()));
      if (this.visible === true) {
        t1 = this._cache;
        t2 = this.game.get$stage();
        t3 = t2.get$currentRenderOrderID();
        t2.set$currentRenderOrderID(J.$add$ns(t3, 1));
        J.$indexSet$ax(t1, 3, t3);
      }
      this.animations.update$0();
      if (!J.$eq(J.get$x$x(this._scroll), 0)) {
        t1 = this.tilePosition;
        t2 = J.getInterceptor$x(t1);
        t2.set$x(t1, J.$add$ns(t2.get$x(t1), J.$mul$ns(J.get$x$x(this._scroll), this.game.get$time().get$physicsElapsed())));
      }
      if (!J.$eq(J.get$y$x(this._scroll), 0)) {
        t1 = this.tilePosition;
        t2 = J.getInterceptor$x(t1);
        t2.set$y(t1, J.$add$ns(t2.get$y(t1), J.$mul$ns(J.get$y$x(this._scroll), this.game.get$time().get$physicsElapsed())));
      }
      t1 = this.body;
      if (t1 != null)
        t1.preUpdate$0();
      len = J.get$length$asx(this.Phaser$Rope0$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Rope0$children, i).preUpdate$0();
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    update$0: [function() {
      if (this._hasUpdateAnimation === true)
        this.updateAnimation$0();
    }, "call$0", "get$update", 0, 0, 54, "update"],
    postUpdate$0: [function() {
      var len, i;
      if (J.$eq(J.$index$asx(this._cache, 6), 1) && this.body != null)
        this.body.postUpdate$0();
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.position, J.$add$ns(J.get$x$x(J.get$view$x(this.game.get$camera())), J.get$x$x(this.cameraOffset)));
        J.set$y$x(this.position, J.$add$ns(J.get$y$x(J.get$view$x(this.game.get$camera())), J.get$y$x(this.cameraOffset)));
      }
      len = J.get$length$asx(this.Phaser$Rope0$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Rope0$children, i).postUpdate$0();
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    loadTexture$2: [function(key, frame) {
      var t1;
      this.key = key;
      t1 = J.getInterceptor(key);
      if (!!t1.$isRenderTexture) {
        this.key = key.key;
        this.texture = key;
      } else if (!!t1.$isBitmapData)
        this.texture = key.texture;
      else if (!!t1.$isTexture)
        this.texture = key;
      else if (key == null) {
        this.key = "__default";
        this.texture = J.$index$asx($.get$TextureCache(), "__default");
      } else if (typeof key === "string" && !this.game.get$cache().checkImageKey$1(key)) {
        window;
        t1 = C.JSString_methods.$add("Texture with key '", key) + "' not found.";
        if (typeof console != "undefined")
          console.warn(t1);
        this.key = "__missing";
        this.texture = J.$index$asx($.get$TextureCache(), "__missing");
      } else {
        this.texture = M.Texture$(J.$index$asx($.get$BaseTextureCache(), key), null);
        this.animations.loadFrameData$2(this.game.get$cache().getFrameData$1(key), frame);
      }
    }, function(key) {
      return this.loadTexture$2(key, 0);
    }, "loadTexture$1", "call$2", "call$1", "get$loadTexture", 2, 2, 888, 49, 269, [], 216, [], "loadTexture"],
    setFrame$1: [function(frame) {
      var t1, t2;
      t1 = J.getInterceptor$x(frame);
      J.set$x$x(this.texture.get$frame(), t1.get$x(frame));
      J.set$y$x(this.texture.get$frame(), t1.get$y(frame));
      J.set$width$x(this.texture.get$frame(), t1.get$width(frame));
      J.set$height$x(this.texture.get$frame(), t1.get$height(frame));
      J.set$x$x(this.texture.get$crop(), t1.get$x(frame));
      J.set$y$x(this.texture.get$crop(), t1.get$y(frame));
      J.set$width$x(this.texture.get$crop(), t1.get$width(frame));
      J.set$height$x(this.texture.get$crop(), t1.get$height(frame));
      if (frame.get$trimmed() === true) {
        t1 = J.get$trim$s(this.texture);
        t2 = this.texture;
        if (t1 != null) {
          J.set$x$x(J.get$trim$s(t2), frame.get$spriteSourceSizeX());
          J.set$y$x(J.get$trim$s(this.texture), frame.get$spriteSourceSizeY());
          J.set$width$x(J.get$trim$s(this.texture), frame.get$sourceSizeW());
          J.set$height$x(J.get$trim$s(this.texture), frame.get$sourceSizeH());
        } else
          J.set$trim$s(t2, new R.Rectangle1(frame.get$spriteSourceSizeX(), frame.get$spriteSourceSizeY(), frame.get$sourceSizeW(), frame.get$sourceSizeH(), 0, 0, 0, 0));
        J.set$width$x(this.texture, frame.get$sourceSizeW());
        J.set$height$x(this.texture, frame.get$sourceSizeH());
        J.set$width$x(this.texture.get$frame(), frame.get$sourceSizeW());
        J.set$height$x(this.texture.get$frame(), frame.get$sourceSizeH());
      } else if (frame.get$trimmed() !== true && J.get$trim$s(this.texture) != null)
        J.set$trim$s(this.texture, null);
      if (J.$eq(this.game.get$renderType(), 2))
        this.texture._updateWebGLuvs$0();
    }, "call$1", "get$setFrame", 2, 0, 102, 216, [], "setFrame"],
    destroy$1: [function(destroyChildren) {
      var t1, i, i0;
      if (this.game == null || J.$eq(J.$index$asx(this._cache, 8), 1))
        return;
      J.$indexSet$ax(this._cache, 8, 1);
      t1 = this.events;
      if (t1 != null)
        t1.get$onDestroy().dispatch$1(this);
      if (this._filters != null)
        this.set$filters(null);
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        if (!!J.getInterceptor(M.DisplayObject.prototype.get$parent.call(this, this)).$isGroup)
          H.interceptedTypeCast(M.DisplayObject.prototype.get$parent.call(this, this), "$isGroup").remove$1(0, this);
        else {
          t1 = H.interceptedTypeCast(M.DisplayObject.prototype.get$parent.call(this, this), "$isGroup");
          t1.removeChildAt$1(J.indexOf$1$asx(t1.Phaser$Group$children, this));
        }
      this.animations.destroy$0();
      this.events.destroy$0();
      i = J.get$length$asx(this.Phaser$Rope0$children);
      if (destroyChildren === true)
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          J.$index$asx(this.Phaser$Rope0$children, i0).destroy$1(destroyChildren);
      else
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0) {
          t1 = J.$index$asx(this.Phaser$Rope0$children, i0);
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Rope0$children, t1));
        }
      this.set$exists(false);
      this.visible = false;
      this.set$filters(null);
      this.set$mask(0, null);
      this.game = null;
      J.$indexSet$ax(this._cache, 8, 0);
    }, function() {
      return this.destroy$1(true);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 956, 78, 1069, [], "destroy"],
    play$4: [function(_, $name, frameRate, loop, killOnComplete) {
      return J.play$4$x(this.animations, $name, frameRate, loop, killOnComplete);
    }, "call$4", "get$play", 8, 0, 1148, 83, [], 256, [], 257, [], 967, [], "play"],
    reset$2: [function(_, x, y) {
      var t1;
      this.world.setTo$2(x, y);
      J.set$x$x(this.position, x);
      J.set$y$x(this.position, y);
      this.alive = true;
      this.set$exists(true);
      this.visible = true;
      this.renderable = true;
      this._outOfBoundsFired = false;
      J.set$x$x(this.tilePosition, 0);
      J.set$y$x(this.tilePosition, 0);
      t1 = this.body;
      if (t1 != null)
        J.reset$4$x(t1, x, y, false, false);
      J.$indexSet$ax(this._cache, 4, 1);
      return this;
    }, "call$2", "get$reset", 4, 0, 959, 9, [], 10, [], "reset"],
    get$angle: [function(_) {
      return R.Math_wrapAngle(J.$mul$ns(this.rotation, 57.29577951308232), false);
    }, null, null, 1, 0, 54, "angle"],
    angle$0: function($receiver) {
      return this.get$angle(this).call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.get$angle(this).call$2(arg0, arg1);
    },
    set$angle: [function(_, value) {
      this.rotation = R.Math_wrapAngle(value, false) * 0.017453292519943295;
    }, null, null, 3, 0, 102, 138, [], "angle"],
    get$frame: [function() {
      return this.animations.get$frame();
    }, null, null, 1, 0, 54, "frame"],
    set$frame: [function(value) {
      if (!J.$eq(value, this.animations.get$frame()))
        this.animations.set$frame(value);
    }, null, null, 3, 0, 102, 138, [], "frame"],
    get$frameName: [function() {
      return this.animations.get$frameName();
    }, null, null, 1, 0, 54, "frameName"],
    set$frameName: [function(value) {
      if (!J.$eq(value, this.animations.get$frameName()))
        this.animations.set$frameName(value);
    }, null, null, 3, 0, 102, 138, [], "frameName"],
    get$fixedToCamera: [function() {
      return J.$eq(J.$index$asx(this._cache, 7), 1);
    }, null, null, 1, 0, 54, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.cameraOffset.set$2(J.get$x$x(this.position), J.get$y$x(this.position));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 102, 138, [], "fixedToCamera"],
    get$exists: [function() {
      return J.$eq(J.$index$asx(this._cache, 6), 1);
    }, null, null, 1, 0, 54, "exists"],
    set$exists: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 6, 1);
        t1 = this.body;
        if (t1 != null && J.$eq(J.get$type$x(t1), 1))
          this.body.addToWorld$0();
        this.visible = true;
      } else {
        J.$indexSet$ax(t1, 6, 0);
        t1 = this.body;
        if (t1 != null && J.$eq(J.get$type$x(t1), 1))
          this.body.set$safeRemove(true);
        this.visible = false;
      }
    }, null, null, 3, 0, 102, 138, [], "exists"],
    get$inputEnabled: [function() {
      var t1 = this.input;
      return t1 != null && t1.get$enabled() === true;
    }, null, null, 1, 0, 54, "inputEnabled"],
    set$inputEnabled: [function(value) {
      var t1;
      if (value === true) {
        t1 = this.input;
        if (t1 == null) {
          t1 = R.InputHandler$(this);
          this.input = t1;
          t1.start$0(0);
        } else if (t1.get$enabled() !== true)
          J.start$0$x(this.input);
      } else {
        t1 = this.input;
        if (t1 != null && t1.get$enabled() === true)
          J.stop$0$x(this.input);
      }
    }, null, null, 3, 0, 102, 138, [], "inputEnabled"],
    get$x: [function(_) {
      return J.get$x$x(this.position);
    }, null, null, 1, 0, 54, "x"],
    set$x: [function(_, value) {
      var t1;
      J.set$x$x(this.position, value);
      t1 = this.body;
      if (t1 != null && J.$eq(J.get$type$x(t1), 0) && J.$eq(this.body.get$phase(), 2))
        this.body.set$_reset(true);
    }, null, null, 3, 0, 102, 138, [], "x"],
    get$y: [function(_) {
      return J.get$y$x(this.position);
    }, null, null, 1, 0, 54, "y"],
    set$y: [function(_, value) {
      var t1;
      J.set$y$x(this.position, value);
      t1 = this.body;
      if (t1 != null && J.$eq(J.get$type$x(t1), 0) && J.$eq(this.body.get$phase(), 2))
        this.body.set$_reset(true);
    }, null, null, 3, 0, 102, 138, [], "y"],
    get$updateAnimation: [function() {
      return this._updateAnimation;
    }, null, null, 1, 0, 1238, "updateAnimation"],
    updateAnimation$0: function() {
      return this.get$updateAnimation().call$0();
    },
    set$updateAnimation: [function(value) {
      if (value != null && !!J.getInterceptor(value).$isFunction) {
        this._hasUpdateAnimation = true;
        this._updateAnimation = value;
      } else {
        this._hasUpdateAnimation = false;
        this._updateAnimation = null;
      }
    }, null, null, 3, 0, 1060, 138, [], "updateAnimation"],
    get$segments: [function() {
      var segments, i, t1, index, t2, x1, y1, x2, y2, width, height;
      segments = [];
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.Phaser$Rope0$points);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        index = i * 4;
        t1 = index + 4;
        t2 = J.get$length$asx(this.verticies);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (t1 >= t2)
          break;
        x1 = J.$index$asx(this.verticies, index);
        y1 = J.$index$asx(this.verticies, index + 1);
        x2 = J.$index$asx(this.verticies, t1);
        y2 = J.$index$asx(this.verticies, index + 3);
        t1 = J.getInterceptor$n(x1);
        width = J.abs$0$n(t1.$sub(x1, x2));
        t2 = J.getInterceptor$n(y1);
        height = J.abs$0$n(t2.$sub(y1, y2));
        segments.push(new R.Rectangle1(t1.$add(x1, J.get$x$x(this.world)), t2.$add(y1, J.get$y$x(this.world)), width, height, 0, 0, 0, 0));
        ++i;
      }
      return segments;
    }, null, null, 1, 0, 1239, "segments"],
    get$destroyPhase: [function() {
      return J.$eq(J.$index$asx(this._cache, 8), 1);
    }, null, null, 1, 0, 54, "destroyPhase"],
    Rope$6: function(game, x, y, key, frame, points) {
      var t1;
      this.Phaser$Rope0$points = points;
      this._hasUpdateAnimation = false;
      this._updateAnimationCallback = null;
      this.game = game;
      this.name = "";
      this.type = 20;
      this.z = 0;
      this.events = R.Events$(this);
      t1 = new R.AnimationManager(this, null, null, null, true, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), [], 0, null, null);
      t1.game = this.game;
      this.animations = t1;
      this.key = key;
      this._frame = 0;
      this._frameName = "";
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this._scroll = t1;
      this.position.set$2(x, y);
      this.input = null;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.world = t1;
      this.autoCull = false;
      this.checkWorldBounds = false;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.cameraOffset = t1;
      this.body = null;
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
      this.loadTexture$2(key, frame);
    },
    $isSpriteInterface: true,
    $isGameObject: true,
    static: {Rope$: [function(game, x, y, key, frame, points) {
        var t1, t2, t3, t4;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t4 = new R.Rope0(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false, null, [], null, null, null, null, null, t1, null, null, null, null, null, null, 0, null, C.BlendModes_0, null, null, null, null, false, null, null, null, null, 0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t4.Strip$1(null);
        t4.Rope$2(null, points);
        t4.Rope$6(game, x, y, key, frame, points);
        return t4;
      }, null, null, 2, 10, 338, 49, 49, 12, 12, 12, 252, [], 9, [], 10, [], 269, [], 216, [], 57, [], "new Rope"]}
  },
  "+Rope": [1240, 977, 2],
  Sprite: {
    "^": "Sprite0;game@-613,key*-12,name*-644,type*-616,z*-616,events@-648,animations@-1147,_frameName@-644,world@-615,autoCull@-617,input@-1141,body*-1219,alive@-617,health@-616,checkWorldBounds@-617,outOfBoundsKill@-617,debug@-617,cameraOffset@-615,cropRect@-649,_cache@-709,_crop@-649,_frame@-649,_Phaser$_bounds@-649,lifespan@-616,_Phaser$_dirty@-617,__tilePattern@-822,tilingTexture@-698,camerOffset@-615,children:Phaser$Sprite$children*-1091,_Phaser$_currentBounds@-649,anchor:Phaser$Sprite$anchor@-615,position:Phaser$Sprite$position*-615,_outOfBoundsFired@-617,anchor-652,texture-698,updateFrame-617,PIXI$Sprite0$_PIXI$_width-616,PIXI$Sprite0$_PIXI$_height-616,_uvs-699,tintedTexture-700,buffer-701,tint-614,cachedTint-614,blendMode-702,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.body.call$3(arg0, arg1, arg2);
    },
    debug$0: function() {
      return this.debug.call$0();
    },
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 324, "parent"],
    get$angle: [function(_) {
      return R.Math_wrapAngle(J.$mul$ns(this.rotation, 57.29577951308232), false);
    }, null, null, 1, 0, 619, "angle"],
    angle$0: function($receiver) {
      return this.get$angle(this).call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.get$angle(this).call$2(arg0, arg1);
    },
    set$angle: [function(_, value) {
      this.rotation = R.Math_wrapAngle(value, false) * 0.017453292519943295;
    }, null, null, 3, 0, 620, 138, [], "angle"],
    get$deltaX: [function(_) {
      return J.$sub$n(J.get$x$x(this.world), J.$index$asx(this._cache, 0));
    }, null, null, 1, 0, 619, "deltaX"],
    get$deltaY: [function(_) {
      return J.$sub$n(J.get$y$x(this.world), J.$index$asx(this._cache, 1));
    }, null, null, 1, 0, 619, "deltaY"],
    get$deltaZ: [function(_) {
      return J.$sub$n(this.rotation, J.$index$asx(this._cache, 2));
    }, null, null, 1, 0, 619, "deltaZ"],
    get$inWorld: [function() {
      var t1, t2;
      t1 = this.game.get$world().get$bounds();
      t2 = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      t2.copyFrom$1(new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Sprite0.prototype.getBounds$1.call(this, null)));
      return J.intersects$1$x(t1, t2);
    }, null, null, 1, 0, 247, "inWorld"],
    get$inCamera: [function() {
      var t1, t2;
      t1 = this.game.get$world().get$camera().get$screenView();
      t2 = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      t2.copyFrom$1(new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Sprite0.prototype.getBounds$1.call(this, null)));
      return J.intersects$1$x(t1, t2);
    }, null, null, 1, 0, 247, "inCamera"],
    get$frame: [function() {
      return this.animations.get$frame();
    }, null, null, 1, 0, 412, "frame"],
    set$frame: [function(value) {
      this.animations.set$frame(value);
    }, null, null, 3, 0, 99, 138, [], "frame"],
    get$frameName: [function() {
      return this.animations.get$frameName();
    }, null, null, 1, 0, 810, "frameName"],
    set$frameName: [function(value) {
      this.animations.set$frameName(value);
    }, null, null, 3, 0, 91, 138, [], "frameName"],
    get$renderOrderID: [function() {
      return J.$index$asx(this._cache, 3);
    }, null, null, 1, 0, 619, "renderOrderID"],
    get$inputEnabled: [function() {
      var t1 = this.input;
      return t1 != null && t1.get$enabled() === true;
    }, null, null, 1, 0, 247, "inputEnabled"],
    set$inputEnabled: [function(value) {
      var t1;
      if (value === true) {
        t1 = this.input;
        if (t1 == null) {
          t1 = R.InputHandler$(this);
          this.input = t1;
          t1.start$0(0);
        } else if (t1.get$enabled() !== true)
          J.start$0$x(this.input);
      } else {
        t1 = this.input;
        if (t1 != null && t1.get$enabled() === true)
          J.stop$0$x(this.input);
      }
    }, null, null, 3, 0, 639, 138, [], "inputEnabled"],
    get$exists: [function() {
      return J.$eq(J.$index$asx(this._cache, 6), 1);
    }, null, null, 1, 0, 247, "exists"],
    set$exists: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 6, 1);
        t1 = this.body;
        if (t1 != null && J.$eq(J.get$type$x(t1), 1))
          this.body.addToWorld$0();
        this.visible = true;
      } else {
        J.$indexSet$ax(t1, 6, 0);
        t1 = this.body;
        if (t1 != null && J.$eq(J.get$type$x(t1), 1))
          this.body.removeFromWorld$0();
        this.visible = false;
      }
    }, null, null, 3, 0, 639, 138, [], "exists"],
    get$fixedToCamera: [function() {
      return J.$eq(J.$index$asx(this._cache, 7), 1);
    }, null, null, 1, 0, 247, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.cameraOffset.set$2(J.get$x$x(this.Phaser$Sprite$position), J.get$y$x(this.Phaser$Sprite$position));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 639, 138, [], "fixedToCamera"],
    get$smoothed: [function() {
      return J.$eq(this.texture.get$baseTexture().get$scaleMode(), C.scaleModes_0);
    }, null, null, 1, 0, 247, "smoothed"],
    set$smoothed: [function(value) {
      var t1;
      if (value === true) {
        t1 = this.texture;
        if (t1 != null)
          t1.get$baseTexture().set$scaleMode(C.scaleModes_0);
      } else {
        t1 = this.texture;
        if (t1 != null)
          t1.get$baseTexture().set$scaleMode(C.scaleModes_1);
      }
    }, null, null, 3, 0, 639, 138, [], "smoothed"],
    get$x: [function(_) {
      return J.get$x$x(this.Phaser$Sprite$position);
    }, null, null, 1, 0, 619, "x"],
    set$x: [function(_, value) {
      var t1;
      J.set$x$x(this.Phaser$Sprite$position, value);
      t1 = this.body;
      if (t1 != null && J.$eq(J.get$type$x(t1), 0) && J.$eq(this.body.get$phase(), 2))
        this.body.set$_reset(true);
    }, null, null, 3, 0, 620, 138, [], "x"],
    get$y: [function(_) {
      return J.get$y$x(this.Phaser$Sprite$position);
    }, null, null, 1, 0, 619, "y"],
    set$y: [function(_, value) {
      var t1;
      J.set$y$x(this.Phaser$Sprite$position, value);
      t1 = this.body;
      if (t1 != null && J.$eq(J.get$type$x(t1), 0) && J.$eq(this.body.get$phase(), 2))
        this.body.set$_reset(true);
    }, null, null, 3, 0, 620, 138, [], "y"],
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.Phaser$Sprite$position), J.$div$n(J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.texture.get$frame())), 2));
      t2 = J.$add$ns(J.get$y$x(this.Phaser$Sprite$position), J.$div$n(J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.texture.get$frame())), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1010, "center"],
    get$destroyPhase: [function() {
      return J.$eq(J.$index$asx(this._cache, 8), 1);
    }, null, null, 1, 0, 247, "destroyPhase"],
    get$fresh: [function() {
      return J.$eq(J.$index$asx(this._cache, 4), 1);
    }, null, null, 1, 0, 247, "fresh"],
    preUpdate$0: [function() {
      var t1, t2, t3, len, i;
      if (J.$eq(J.$index$asx(this._cache, 4), 1) && J.$eq(J.$index$asx(this._cache, 6), 1)) {
        this.world.setTo$2(J.$add$ns(J.get$x$x(J.get$position$x(M.DisplayObject.prototype.get$parent.call(this, this))), J.get$x$x(this.Phaser$Sprite$position)), J.$add$ns(J.get$y$x(J.get$position$x(M.DisplayObject.prototype.get$parent.call(this, this))), J.get$y$x(this.Phaser$Sprite$position)));
        this._worldTransform.set$tx(J.toDouble$0$n(J.get$x$x(this.world)));
        this._worldTransform.set$ty(J.toDouble$0$n(J.get$y$x(this.world)));
        J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
        J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
        J.$indexSet$ax(this._cache, 2, this.rotation);
        t1 = this.body;
        if (t1 != null)
          t1.preUpdate$0();
        J.$indexSet$ax(this._cache, 4, 0);
        return false;
      }
      J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
      J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
      J.$indexSet$ax(this._cache, 2, this.rotation);
      if (!J.$eq(J.$index$asx(this._cache, 6), 1) || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        J.$indexSet$ax(this._cache, 3, -1);
        return false;
      }
      if (J.$gt$n(this.lifespan, 0)) {
        t1 = J.$sub$n(this.lifespan, this.game.get$time().get$elapsed());
        this.lifespan = t1;
        if (J.$le$n(t1, 0)) {
          this.kill$0();
          return false;
        }
      }
      if (this.autoCull === true || this.checkWorldBounds === true)
        this._Phaser$_bounds.copyFrom$1(new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Sprite0.prototype.getBounds$1.call(this, null)));
      if (this.autoCull === true)
        this.renderable = J.intersects$1$x(this.game.get$world().get$camera().get$screenView(), this._Phaser$_bounds);
      if (this.checkWorldBounds === true)
        if (J.$eq(J.$index$asx(this._cache, 5), 1) && J.intersects$1$x(this.game.get$world().get$bounds(), this._Phaser$_bounds) === true) {
          J.$indexSet$ax(this._cache, 5, 0);
          this.events.get$onEnterBounds().dispatch$1(this);
        } else if (J.$eq(J.$index$asx(this._cache, 5), 0) && J.intersects$1$x(this.game.get$world().get$bounds(), this._Phaser$_bounds) !== true) {
          J.$indexSet$ax(this._cache, 5, 1);
          this.events.get$onOutOfBounds().dispatch$1(this);
          if (this.outOfBoundsKill === true) {
            this.kill$0();
            return false;
          }
        }
      this.world.setTo$2(J.$add$ns(J.get$x$x(this.game.get$camera()), this._worldTransform.get$tx()), J.$add$ns(J.get$y$x(this.game.get$camera()), this._worldTransform.get$ty()));
      if (this.visible === true) {
        t1 = this._cache;
        t2 = this.game.get$stage();
        t3 = t2.get$currentRenderOrderID();
        t2.set$currentRenderOrderID(J.$add$ns(t3, 1));
        J.$indexSet$ax(t1, 3, t3);
      }
      this.animations.update$0();
      t1 = this.body;
      if (t1 != null)
        t1.preUpdate$0();
      len = J.get$length$asx(this.Phaser$Sprite$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Sprite$children, i).preUpdate$0();
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 54, "update"],
    postUpdate$0: [function() {
      var t1, len, i;
      t1 = this.key;
      if (!!J.getInterceptor(t1).$isBitmapData)
        H.interceptedTypeCast(t1, "$isBitmapData").render$0();
      if (J.$eq(J.$index$asx(this._cache, 6), 1) && this.body != null)
        this.body.postUpdate$0();
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.Phaser$Sprite$position, J.$div$n(J.$add$ns(J.get$x$x(J.get$view$x(this.game.get$camera())), J.get$x$x(this.cameraOffset)), J.get$x$x(J.get$scale$x(this.game.get$camera()))));
        J.set$y$x(this.Phaser$Sprite$position, J.$div$n(J.$add$ns(J.get$y$x(J.get$view$x(this.game.get$camera())), J.get$y$x(this.cameraOffset)), J.get$y$x(J.get$scale$x(this.game.get$camera()))));
      }
      len = J.get$length$asx(this.Phaser$Sprite$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Sprite$children, i).postUpdate$0();
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    loadTexture$3: [function(key, frame, stopAnimation) {
      var smoothed, t1, setFrame;
      if (J.$eq(stopAnimation, true))
        J.stop$0$x(this.animations);
      this.key = key;
      smoothed = J.$eq(this.texture.get$baseTexture().get$scaleMode(), C.scaleModes_0);
      t1 = J.getInterceptor(key);
      if (!!t1.$isRenderTexture) {
        this.key = key.key;
        this.texture = key;
        this.cachedTint = 16777215;
        setFrame = true;
      } else if (!!t1.$isBitmapData) {
        this.texture = key.texture;
        this.cachedTint = 16777215;
        setFrame = this.game.get$cache().getFrameData$2(key.key, 9) == null || !this.animations.loadFrameData$2(this.game.get$cache().getFrameData$2(key.key, 9), frame);
      } else if (!!t1.$isTexture) {
        this.texture = key;
        this.cachedTint = 16777215;
        setFrame = true;
      } else if (key == null) {
        this.key = "__default";
        this.texture = J.$index$asx($.get$TextureCache(), "__default");
        this.cachedTint = 16777215;
        setFrame = true;
      } else if (typeof key === "string" && !this.game.get$cache().checkImageKey$1(key)) {
        window;
        t1 = C.JSString_methods.$add("Texture with key '", key) + "' not found.";
        if (typeof console != "undefined")
          console.warn(t1);
        this.key = "__missing";
        this.texture = J.$index$asx($.get$TextureCache(), "__missing");
        this.cachedTint = 16777215;
        setFrame = true;
      } else {
        this.texture = M.Texture$(J.$index$asx($.get$BaseTextureCache(), key), null);
        this.cachedTint = 16777215;
        setFrame = !this.animations.loadFrameData$2(this.game.get$cache().getFrameData$1(key), frame);
      }
      if (setFrame)
        this._frame = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(this.texture.get$frame());
      if (!smoothed)
        this.set$smoothed(false);
    }, function(key, frame) {
      return this.loadTexture$3(key, frame, true);
    }, "loadTexture$2", function(key) {
      return this.loadTexture$3(key, 0, true);
    }, "loadTexture$1", "call$3", "call$2", "call$1", "get$loadTexture", 2, 4, 1241, 49, 78, 269, [], 216, [], 1242, [], "loadTexture"],
    setFrame$1: [function(frame) {
      var t1, t2;
      this._frame = frame;
      t1 = J.getInterceptor$x(frame);
      J.set$x$x(this.texture.get$frame(), t1.get$x(frame));
      J.set$y$x(this.texture.get$frame(), t1.get$y(frame));
      J.set$width$x(this.texture.get$frame(), t1.get$width(frame));
      J.set$height$x(this.texture.get$frame(), t1.get$height(frame));
      J.set$x$x(this.texture.get$crop(), t1.get$x(frame));
      J.set$y$x(this.texture.get$crop(), t1.get$y(frame));
      J.set$width$x(this.texture.get$crop(), t1.get$width(frame));
      J.set$height$x(this.texture.get$crop(), t1.get$height(frame));
      if (frame.get$trimmed() === true) {
        t1 = J.get$trim$s(this.texture);
        t2 = this.texture;
        if (t1 != null) {
          J.set$x$x(J.get$trim$s(t2), frame.get$spriteSourceSizeX());
          J.set$y$x(J.get$trim$s(this.texture), frame.get$spriteSourceSizeY());
          J.set$width$x(J.get$trim$s(this.texture), frame.get$sourceSizeW());
          J.set$height$x(J.get$trim$s(this.texture), frame.get$sourceSizeH());
        } else
          J.set$trim$s(t2, new R.Rectangle1(frame.get$spriteSourceSizeX(), frame.get$spriteSourceSizeY(), frame.get$sourceSizeW(), frame.get$sourceSizeH(), 0, 0, 0, 0));
        J.set$width$x(this.texture, frame.get$sourceSizeW());
        J.set$height$x(this.texture, frame.get$sourceSizeH());
        J.set$width$x(this.texture.get$frame(), frame.get$sourceSizeW());
        J.set$height$x(this.texture.get$frame(), frame.get$sourceSizeH());
      } else if (frame.get$trimmed() !== true && J.get$trim$s(this.texture) != null)
        J.set$trim$s(this.texture, null);
      else if (frame.get$trimmed() !== true && J.get$trim$s(this.texture) != null)
        J.set$trim$s(this.texture, null);
      if (this.cropRect != null)
        this.updateCrop$0();
      else if (J.$eq(this.game.get$renderType(), 2))
        this.texture._updateWebGLuvs$0();
    }, "call$1", "get$setFrame", 2, 0, 1214, 216, [], "setFrame"],
    resetFrame$0: [function() {
      var t1 = this._frame;
      if (t1 != null)
        this.setFrame$1(t1);
    }, "call$0", "get$resetFrame", 0, 0, 54, "resetFrame"],
    crop$2: [function(rect, copy) {
      var t1;
      if (rect != null) {
        t1 = copy === true;
        if (t1 && this.cropRect != null) {
          t1 = J.getInterceptor$x(rect);
          this.cropRect.setTo$4(t1.get$x(rect), t1.get$y(rect), t1.get$width(rect), t1.get$height(rect));
        } else if (t1 && this.cropRect == null) {
          t1 = J.getInterceptor$x(rect);
          this.cropRect = new R.Rectangle1(t1.get$x(rect), t1.get$y(rect), t1.get$width(rect), t1.get$height(rect), 0, 0, 0, 0);
        } else
          this.cropRect = rect;
        this.updateCrop$0();
      } else {
        this._crop = null;
        this.cropRect = null;
        t1 = this._frame;
        if (t1 != null)
          this.setFrame$1(t1);
      }
    }, function(rect) {
      return this.crop$2(rect, false);
    }, "crop$1", function() {
      return this.crop$2(null, false);
    }, "crop$0", "call$2", "call$1", "call$0", "get$crop", 0, 4, 1243, 12, 19, 1125, [], 1216, [], "crop"],
    updateCrop$0: [function() {
      var t1, t2, cx, cy, cw, ch;
      t1 = this.cropRect;
      if (t1 == null)
        return;
      t1 = J.clone$0$x(t1);
      this._crop = t1;
      t2 = J.getInterceptor$x(t1);
      t2.set$x(t1, J.$add$ns(t2.get$x(t1), J.get$x$x(this._frame)));
      t1 = this._crop;
      t2 = J.getInterceptor$x(t1);
      t2.set$y(t1, J.$add$ns(t2.get$y(t1), J.get$y$x(this._frame)));
      cx = P.max(J.get$x$x(this._frame), J.get$x$x(this._crop));
      cy = P.max(J.get$y$x(this._frame), J.get$y$x(this._crop));
      cw = P.min(J.get$right$x(this._frame), J.get$right$x(this._crop)) - cx;
      ch = P.min(J.get$bottom$x(this._frame), J.get$bottom$x(this._crop)) - cy;
      J.set$x$x(this.texture.get$crop(), cx);
      J.set$y$x(this.texture.get$crop(), cy);
      J.set$width$x(this.texture.get$crop(), cw);
      J.set$height$x(this.texture.get$crop(), ch);
      J.set$width$x(this.texture.get$frame(), P.min(cw, J.get$width$x(this.cropRect)));
      J.set$height$x(this.texture.get$frame(), P.min(ch, J.get$height$x(this.cropRect)));
      t1 = this.texture;
      J.set$width$x(t1, J.get$width$x(t1.get$frame()));
      t1 = this.texture;
      J.set$height$x(t1, J.get$height$x(t1.get$frame()));
      if (J.$eq(this.game.get$renderType(), 2))
        this.texture._updateWebGLuvs$0();
    }, "call$0", "get$updateCrop", 0, 0, 54, "updateCrop"],
    revive$1: [function(health) {
      var t1;
      if (health == null)
        health = 1;
      this.alive = true;
      this.set$exists(true);
      this.visible = true;
      this.health = health;
      t1 = this.events;
      if (t1 != null)
        t1.get$onRevived().dispatch$1(this);
      return this;
    }, function() {
      return this.revive$1(null);
    }, "revive$0", "call$1", "call$0", "get$revive", 0, 2, 944, 12, 1222, [], "revive"],
    kill$0: [function() {
      this.alive = false;
      this.set$exists(false);
      this.visible = false;
      var t1 = this.events;
      if (t1 != null)
        t1.get$onKilled().dispatch$1(this);
      return this;
    }, "call$0", "get$kill", 0, 0, 54, "kill"],
    destroy$1: [function(destroyChildren) {
      var t1, i, i0;
      if (this.game == null || J.$eq(J.$index$asx(this._cache, 8), 1))
        return;
      if (destroyChildren == null)
        destroyChildren = true;
      J.$indexSet$ax(this._cache, 8, 1);
      t1 = this.events;
      if (t1 != null)
        t1.get$onDestroy().dispatch$1(this);
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        if (!!J.getInterceptor(M.DisplayObject.prototype.get$parent.call(this, this)).$isGroup)
          H.interceptedTypeCast(M.DisplayObject.prototype.get$parent.call(this, this), "$isGroup").remove$1(0, this);
        else
          M.DisplayObject.prototype.get$parent.call(this, this).removeChild$1(this);
      t1 = this.input;
      if (t1 != null)
        t1.destroy$0();
      t1 = this.animations;
      if (t1 != null)
        t1.destroy$0();
      t1 = this.body;
      if (t1 != null)
        t1.destroy$0();
      t1 = this.events;
      if (t1 != null)
        t1.destroy$0();
      i = J.get$length$asx(this.Phaser$Sprite$children);
      if (destroyChildren === true)
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          J.$index$asx(this.Phaser$Sprite$children, i0).destroy$1(destroyChildren);
      else
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0) {
          t1 = J.$index$asx(this.Phaser$Sprite$children, i0);
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Sprite$children, t1));
        }
      this.alive = false;
      this.set$exists(false);
      this.visible = false;
      this.set$filters(null);
      this.set$mask(0, null);
      this.game = null;
      J.$indexSet$ax(this._cache, 8, 0);
    }, function() {
      return this.destroy$1(true);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 956, 78, 1069, [], "destroy"],
    damage$1: [function(amount) {
      var t1;
      if (this.alive === true) {
        t1 = J.$sub$n(this.health, amount);
        this.health = t1;
        if (J.$le$n(t1, 0))
          this.kill$0();
      }
      return this;
    }, "call$1", "get$damage", 2, 0, 102, 411, [], "damage"],
    reset$3: [function(_, x, y, health) {
      var t1;
      this.world.setTo$2(x, y);
      J.set$x$x(this.Phaser$Sprite$position, x);
      J.set$y$x(this.Phaser$Sprite$position, y);
      this.alive = true;
      this.set$exists(true);
      this.visible = true;
      this.renderable = true;
      this._outOfBoundsFired = false;
      this.health = health;
      t1 = this.body;
      if (t1 != null)
        J.reset$4$x(t1, x, y, false, false);
      J.$indexSet$ax(this._cache, 4, 1);
      return this;
    }, function($receiver, x, y) {
      return this.reset$3($receiver, x, y, 1);
    }, "reset$2", "call$3", "call$2", "get$reset", 4, 2, 1244, 433, 9, [], 10, [], 1222, [], "reset"],
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Sprite$children, child), J.get$length$asx(this.Phaser$Sprite$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Sprite$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$Sprite$children));
        }
        return this;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1092, 12, 687, [], "bringToTop"],
    play$4: [function(_, $name, frameRate, loop, killOnComplete) {
      var t1 = this.animations;
      if (t1 != null)
        return J.play$4$x(t1, $name, frameRate, loop, killOnComplete);
    }, function($receiver, name) {
      return this.play$4($receiver, name, 60, true, false);
    }, "play$1", function($receiver, name, frameRate, loop) {
      return this.play$4($receiver, name, frameRate, loop, false);
    }, "play$3", function($receiver, name, frameRate) {
      return this.play$4($receiver, name, frameRate, true, false);
    }, "play$2", "call$4", "call$1", "call$3", "call$2", "get$play", 2, 6, 1245, 251, 78, 19, 83, [], 256, [], 257, [], 967, [], "play"],
    overlap$1: [function(displayObject) {
      return new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Sprite0.prototype.getBounds$1.call(this, null)).intersects$1(0, displayObject.getBounds$0());
    }, "call$1", "get$overlap", 2, 0, 1246, 833, [], "overlap"],
    getBounds$1: [function(matrix) {
      return new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Sprite0.prototype.getBounds$1.call(this, null));
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 1071, 12, 580, [], "getBounds"],
    Sprite$5: function(game, x, y, key, frame, $T) {
      var t1;
      this.set$x(0, x);
      this.set$y(0, y);
      this.key = key;
      this.name = "";
      this.type = 0;
      this.z = 0;
      this.events = R.Events$(this);
      t1 = new R.AnimationManager(this, null, null, null, true, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), [], 0, null, null);
      t1.game = this.game;
      this.animations = t1;
      this._frameName = "";
      this.loadTexture$2(key, frame);
      this.Phaser$Sprite$position.set$2(x, y);
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.world = t1;
      this.autoCull = false;
      this.input = null;
      this.body = null;
      this.health = 1;
      this.lifespan = 0;
      this.checkWorldBounds = false;
      this.outOfBoundsKill = false;
      this.debug = false;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.cameraOffset = t1;
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
      this._Phaser$_bounds = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      this.loadTexture$2(key, frame);
    },
    $isSprite: true,
    $isSpriteInterface: true,
    $isGameObject: true,
    "<>": [5],
    static: {Sprite$: [function(game, x, y, key, frame, $T) {
        var t1, t2, t3, t4, t5, t6, t7;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = J.$index$asx($.get$TextureCache(), "__default");
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = new M.Point0(null, null);
        t6.x = 1;
        t6.y = 1;
        t7 = new M.Point0(null, null);
        t7.x = 0;
        t7.y = 0;
        t7 = H.setRuntimeTypeInfo(new R.Sprite(game, null, null, null, null, null, null, null, null, null, null, null, null, null, false, false, false, null, null, null, null, null, null, null, false, null, null, null, [], null, t1, t2, false, t4, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t5, t6, t7, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0), [$T]);
        t7.texture = t3;
        t7._setupTexture$0();
        t7.Sprite$5(game, x, y, key, frame, $T);
        return t7;
      }, null, null, 2, 8, 326, 49, 49, 12, 49, 252, [], 9, [], 10, [], 269, [], 216, [], "new Sprite"]}
  },
  "+Sprite": [661, 977, 1169, 2],
  SpriteBatch: {
    "^": "Group;game-613,name-644,addToStage-617,enableBody-617,physicsBodyType-616,z-614,type-614,alive-617,exists-617,ignoreDestroy-617,_Phaser$_dirty-617,cursor-12,cameraOffset-615,_sortProperty-644,enableBodyDebug-617,_cache-645,creator-646,renderOrderID-614,Phaser$Group$children-647,autoCull-617,events-648,_anchor-615,_Phaser$_currentBounds-649,Phaser$Group$position-615,onDestroy-650,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    SpriteBatch$4: function(game, $parent, $name, addToStage) {
      if ($parent == null)
        game.get$world();
      this.type = 17;
    },
    $asGroup: function() {
      return [null];
    },
    $asGroup: function() {
      return [null];
    },
    "<>": [],
    static: {SpriteBatch$: [function(game, $parent, $name, addToStage) {
        var t1, t2, t3, t4, t5;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = new R.SpriteBatch(null, "group", false, false, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, t1, null, t2, null, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t5.Group$6(game, null, "group", false, false, 0, null);
        t5.SpriteBatch$4(game, $parent, $name, addToStage);
        return t5;
      }, null, null, 8, 0, 339, 252, [], 84, [], 83, [], 298, [], "new SpriteBatch"]}
  },
  "+SpriteBatch": [1029],
  TextStyle: {
    "^": "TextStyle0;shadowOffsetX*-616,shadowOffsetY*-616,shadowColor*-644,shadowBlur*-616,fill-644,font-644,align-644,stroke-644,strokeThickness-616,wordWrap-617,wordWrapWidth-616,dropShadow-617,dropShadowAngle-616,dropShadowDistance-616,dropShadowColor-644,tint-616",
    TextStyle$6$align$fill$font$stroke$strokeThickness$tint: function(align, fill, font, stroke, strokeThickness, tint) {
      this.fill = fill;
      this.font = font;
      this.align = align;
      this.stroke = stroke;
      this.strokeThickness = strokeThickness;
      this.tint = tint;
    },
    static: {TextStyle$: [function(align, fill, font, stroke, strokeThickness, tint) {
        var t1 = new R.TextStyle(0, 0, "rgba(0,0,0,0)", 0, "black", "bold 20pt Arial", "left", "black", 0, false, 100, false, 0.5235987755982988, 4, "black", 16777215);
        t1.TextStyle$6$align$fill$font$stroke$strokeThickness$tint("left", "black", "bold 20pt Arial", "black", 0, 16777215);
        t1.TextStyle$6$align$fill$font$stroke$strokeThickness$tint(align, fill, font, stroke, strokeThickness, tint);
        return t1;
      }, null, null, 0, 13, 195, 196, 197, 198, 196, 49, 199, 200, [], 201, [], 202, [], 203, [], 204, [], 205, [], "new TextStyle"]}
  },
  "+TextStyle": [935],
  Text: {
    "^": "Text0;game@-613,name*-644,style*-1247,exists@-617,type*-614,z*-614,world@-615,_text@-644,_font@-644,_fontSize@-614,_fontWeight@-644,_lineSpacing@-614,input@-1141,cameraOffset@-615,renderOrderID@-614,autoCull@-617,_cache@-645,children:Phaser$Text$children*-1091,events@-648,alive@-617,_Phaser$_dirty@-617,_charCount@-614,colors@-847,__tilePattern@-822,anchor:Phaser$Text$anchor@-615,_Phaser$_currentBounds@-649,_PIXI$_text-644,_style-935,_canvas-836,_context-876,PIXI$Text0$_dirty-617,_requiresUpdate-617,anchor-652,texture-698,updateFrame-617,PIXI$Sprite0$_PIXI$_width-616,PIXI$Sprite0$_PIXI$_height-616,_uvs-699,tintedTexture-700,buffer-701,tint-614,cachedTint-614,blendMode-702,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 324, "parent"],
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.position), J.$div$n(this.get$width(this), 2));
      t2 = J.$add$ns(J.get$y$x(this.position), J.$div$n(this.get$height(this), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1010, "center"],
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Text$children, child), J.get$length$asx(this.Phaser$Text$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Text$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$Text$children));
        }
        return this;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1092, 12, 687, [], "bringToTop"],
    preUpdate$0: [function() {
      var t1, t2, t3, len, i;
      J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
      J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
      J.$indexSet$ax(this._cache, 2, this.rotation);
      if (this.exists !== true || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        this.renderOrderID = -1;
        return false;
      }
      if (this.autoCull === true)
        this.renderable = J.intersects$1$x(this.game.get$world().get$camera().get$screenView(), this.getBounds$0());
      this.world.setTo$2(J.$add$ns(J.get$x$x(this.game.get$camera()), this._worldTransform.get$tx()), J.$add$ns(J.get$y$x(this.game.get$camera()), this._worldTransform.get$ty()));
      if (this.visible === true) {
        t1 = this._cache;
        t2 = this.game.get$stage();
        t3 = t2.get$currentRenderOrderID();
        t2.set$currentRenderOrderID(J.$add$ns(t3, 1));
        J.$indexSet$ax(t1, 3, t3);
      }
      len = J.get$length$asx(this.Phaser$Text$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Text$children, i).preUpdate$0();
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 54, "update"],
    postUpdate$0: [function() {
      var len, i;
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.position, J.$div$n(J.$add$ns(J.get$x$x(J.get$view$x(this.game.get$camera())), J.get$x$x(this.cameraOffset)), J.get$x$x(J.get$scale$x(this.game.get$camera()))));
        J.set$y$x(this.position, J.$div$n(J.$add$ns(J.get$y$x(J.get$view$x(this.game.get$camera())), J.get$y$x(this.cameraOffset)), J.get$y$x(J.get$scale$x(this.game.get$camera()))));
      }
      len = J.get$length$asx(this.Phaser$Text$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Text$children, i).postUpdate$0();
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    destroy$1: [function(destroyChildren) {
      var t1, i, i0;
      if (this.game == null || J.$eq(J.$index$asx(this._cache, 8), 1))
        return;
      if (destroyChildren == null)
        destroyChildren = true;
      J.$indexSet$ax(this._cache, 8, 1);
      t1 = this.events;
      if (t1 != null)
        t1.get$onDestroy().dispatch$1(this);
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        if (!!J.getInterceptor(M.DisplayObject.prototype.get$parent.call(this, this)).$isGroup)
          H.interceptedTypeCast(M.DisplayObject.prototype.get$parent.call(this, this), "$isGroup").remove$1(0, this);
        else
          M.DisplayObject.prototype.get$parent.call(this, this).removeChild$1(this);
      this.texture.destroy$1(true);
      if (J.get$parentNode$x(this._canvas) != null)
        J.remove$0$ax(this._canvas);
      else
        M.Text0.prototype.destroy$1.call(this, null);
      i = J.get$length$asx(this.Phaser$Text$children);
      if (destroyChildren === true)
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          J.$index$asx(this.Phaser$Text$children, i0).destroy$1(destroyChildren);
      else
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0) {
          t1 = J.$index$asx(this.Phaser$Text$children, i0);
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Text$children, t1));
        }
      this.exists = false;
      this.visible = false;
      this.set$filters(null);
      this.set$mask(0, null);
      this.game = null;
      J.$indexSet$ax(this._cache, 8, 0);
    }, function() {
      return this.destroy$1(null);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 956, 12, 1069, [], "destroy"],
    setShadow$4: [function(x, y, color, $blur) {
      J.set$shadowOffsetX$x(this.style, x);
      J.set$shadowOffsetY$x(this.style, y);
      J.set$shadowColor$x(this.style, color);
      J.set$shadowBlur$x(this.style, $blur);
      this._Phaser$_dirty = true;
    }, function(x) {
      return this.setShadow$4(x, 0, "rgba(0,0,0,0)", 0);
    }, "setShadow$1", function(x, y) {
      return this.setShadow$4(x, y, "rgba(0,0,0,0)", 0);
    }, "setShadow$2", function() {
      return this.setShadow$4(0, 0, "rgba(0,0,0,0)", 0);
    }, "setShadow$0", function(x, y, color) {
      return this.setShadow$4(x, y, color, 0);
    }, "setShadow$3", "call$4", "call$1", "call$2", "call$0", "call$3", "get$setShadow", 0, 8, 1248, 49, 49, 1249, 49, 9, [], 10, [], 152, [], 1250, [], "setShadow"],
    setStyle$1: [function(style) {
      this.style = style;
      this._Phaser$_dirty = true;
    }, "call$1", "get$setStyle", 2, 0, 1251, 194, [], "setStyle"],
    updateText$0: [function() {
      var outputText, lines, t1, lineWidths, maxLineWidth, i, lineWidth, t2, t3, lineHeight, linePosition, t4;
      J.set$font$x(this._context, J.get$font$x(this.style));
      outputText = this._text;
      if (J.get$wordWrap$x(this.style) === true)
        outputText = this.runWordWrap$1(this._text);
      lines = J.split$1$s(outputText, $.get$Text_linesReg());
      t1 = lines.length;
      lineWidths = Array(t1);
      for (maxLineWidth = 0, i = 0; i < lines.length; ++i) {
        lineWidth = J.measureText$1$x(this._context, lines[i]).width;
        if (i >= t1)
          return H.ioore(lineWidths, i);
        lineWidths[i] = lineWidth;
        maxLineWidth = C.JSNumber_methods.floor$0(P.max(maxLineWidth, lineWidth));
      }
      t2 = this._canvas;
      t3 = this.style.get$strokeThickness();
      if (typeof t3 !== "number")
        return H.iae(t3);
      J.set$width$x(t2, maxLineWidth + t3);
      lineHeight = J.$add$ns(J.$add$ns(J.$add$ns(this.determineFontHeight$1(C.JSString_methods.$add("font: ", J.get$font$x(this.style)) + ";"), this.style.get$strokeThickness()), this._lineSpacing), J.get$shadowOffsetY$x(this.style));
      J.set$height$x(this._canvas, J.$mul$ns(lineHeight, lines.length));
      if (this.game.get$device().get$cocoonJS() === true)
        J.clearRect$4$x(this._context, 0, 0, J.get$width$x(this._canvas), J.get$height$x(this._canvas));
      J.set$fillStyle$x(this._context, J.get$fill$x(this.style));
      J.set$font$x(this._context, J.get$font$x(this.style));
      J.set$strokeStyle$x(this._context, J.get$stroke$x(this.style));
      J.set$lineWidth$x(this._context, this.style.get$strokeThickness());
      J.set$shadowOffsetX$x(this._context, J.get$shadowOffsetX$x(this.style));
      J.set$shadowOffsetY$x(this._context, J.get$shadowOffsetY$x(this.style));
      J.set$shadowColor$x(this._context, J.get$shadowColor$x(this.style));
      J.set$shadowBlur$x(this._context, J.get$shadowBlur$x(this.style));
      J.set$textBaseline$x(this._context, "top");
      J.set$lineCap$x(this._context, "round");
      J.set$lineJoin$x(this._context, "round");
      this._charCount = 0;
      for (i = 0; i < lines.length; ++i) {
        t2 = J.$div$n(this.style.get$strokeThickness(), 2);
        t3 = J.$div$n(this.style.get$strokeThickness(), 2);
        if (typeof lineHeight !== "number")
          return H.iae(lineHeight);
        t3 = J.$add$ns(t3, i * lineHeight);
        linePosition = new R.Point(null, null);
        linePosition.x = t2;
        linePosition.y = t3;
        if (J.$eq(this.style.get$align(), "right")) {
          if (i >= t1)
            return H.ioore(lineWidths, i);
          t4 = lineWidths[i];
          if (typeof t4 !== "number")
            return H.iae(t4);
          t4 = J.$add$ns(t2, maxLineWidth - t4);
          linePosition.x = t4;
          t2 = t4;
        } else if (J.$eq(this.style.get$align(), "center")) {
          if (i >= t1)
            return H.ioore(lineWidths, i);
          t4 = lineWidths[i];
          if (typeof t4 !== "number")
            return H.iae(t4);
          t4 = J.$add$ns(t2, (maxLineWidth - t4) / 2);
          linePosition.x = t4;
          t2 = t4;
        }
        t3 = J.$add$ns(t3, this._lineSpacing);
        linePosition.y = t3;
        if (J.$gt$n(J.get$length$asx(this.colors), 0)) {
          if (i >= lines.length)
            return H.ioore(lines, i);
          this.updateLine$3(lines[i], t2, t3);
        } else {
          if (J.get$stroke$x(this.style) != null && !J.$eq(this.style.get$strokeThickness(), 0)) {
            t4 = this._context;
            if (i >= lines.length)
              return H.ioore(lines, i);
            J.strokeText$3$x(t4, lines[i], t2, t3);
          }
          if (J.get$fill$x(this.style) != null) {
            t4 = this._context;
            if (i >= lines.length)
              return H.ioore(lines, i);
            J.fillText$3$x(t4, lines[i], t2, t3);
          }
        }
      }
      this.updateTexture$0();
    }, "call$0", "get$updateText", 0, 0, 54, "updateText"],
    updateLine$3: [function(line, x, y) {
      var t1, i, t2, letter;
      t1 = J.getInterceptor$asx(line);
      i = 0;
      while (true) {
        t2 = t1.get$length(line);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        letter = t1.$index(line, i);
        if (J.$index$asx(this.colors, this._charCount) != null) {
          J.set$fillStyle$x(this._context, J.$index$asx(this.colors, this._charCount));
          J.set$strokeStyle$x(this._context, J.$index$asx(this.colors, this._charCount));
        }
        if (J.get$stroke$x(this.style) != null && !J.$eq(this.style.get$strokeThickness(), 0))
          J.strokeText$3$x(this._context, letter, x, y);
        if (J.get$fill$x(this.style) != null)
          J.fillText$3$x(this._context, letter, x, y);
        x = J.$add$ns(x, J.measureText$1$x(this._context, letter).width);
        this._charCount = J.$add$ns(this._charCount, 1);
        ++i;
      }
    }, "call$3", "get$updateLine", 6, 0, 1252, 1233, [], 9, [], 10, [], "updateLine"],
    updateTransform$0: [function() {
      if (this._Phaser$_dirty === true) {
        this.updateText$0();
        this._Phaser$_dirty = false;
      }
      M.Text0.prototype.updateTransform$0.call(this);
    }, "call$0", "get$updateTransform", 0, 0, 54, "updateTransform"],
    clearColors$0: [function() {
      J.clear$0$ax(this.colors);
      this._Phaser$_dirty = true;
    }, "call$0", "get$clearColors", 0, 0, 54, "clearColors"],
    addColor$2: [function(color, position) {
      J.$indexSet$ax(this.colors, position, color);
      this._Phaser$_dirty = true;
    }, "call$2", "get$addColor", 4, 0, 116, 152, [], 290, [], "addColor"],
    runWordWrap$1: [function(text) {
      var lines, result, i, spaceLeft, words, j, wordWidth, t1, wordWidthWithSpace;
      lines = J.split$1$s(text, "\n");
      for (result = "", i = 0; i < lines.length; ++i) {
        spaceLeft = this.style.get$wordWrapWidth();
        if (i >= lines.length)
          return H.ioore(lines, i);
        words = J.split$1$s(lines[i], " ");
        for (j = 0; j < words.length; ++j) {
          wordWidth = J.measureText$1$x(this._context, words[j]).width;
          t1 = J.measureText$1$x(this._context, " ").width;
          if (typeof wordWidth !== "number")
            return wordWidth.$add();
          if (typeof t1 !== "number")
            return H.iae(t1);
          wordWidthWithSpace = wordWidth + t1;
          if (typeof spaceLeft !== "number")
            return H.iae(spaceLeft);
          if (wordWidthWithSpace > spaceLeft) {
            if (j > 0)
              result += "\n";
            if (j >= words.length)
              return H.ioore(words, j);
            result = C.JSString_methods.$add(result, J.$add$ns(words[j], " "));
            spaceLeft = J.$sub$n(this.style.get$wordWrapWidth(), wordWidth);
          } else {
            spaceLeft -= wordWidthWithSpace;
            if (j >= words.length)
              return H.ioore(words, j);
            result = C.JSString_methods.$add(result, J.$add$ns(words[j], " "));
          }
        }
        if (i < lines.length - 1)
          result += "\n";
      }
      return result;
    }, "call$1", "get$runWordWrap", 2, 0, 91, 124, [], "runWordWrap"],
    get$angle: [function(_) {
      return J.$mul$ns(this.rotation, 57.29577951308232);
    }, null, null, 1, 0, 619, "angle"],
    angle$0: function($receiver) {
      return this.get$angle(this).call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.get$angle(this).call$2(arg0, arg1);
    },
    set$angle: [function(_, value) {
      this.rotation = J.$mul$ns(value, 0.017453292519943295);
    }, null, null, 3, 0, 620, 138, [], "angle"],
    get$text: [function(_) {
      return this._text;
    }, null, null, 1, 0, 810, "text"],
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$text(this).call$4(arg0, arg1, arg2, arg3);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return this.get$text(this).call$3(arg0, arg1, arg2);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.get$text(this).call$5(arg0, arg1, arg2, arg3, arg4);
    },
    set$text: [function(_, value) {
      if (!J.$eq(value, this._text)) {
        this._text = value;
        this._Phaser$_dirty = true;
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          this.updateTransform$0();
      }
    }, null, null, 3, 0, 91, 138, [], "text"],
    setText$1: [function(text) {
      this._text = J.toString$0(text);
      this._Phaser$_dirty = true;
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        this.updateTransform$0();
    }, "call$1", "get$setText", 2, 0, 940, 124, [], "setText"],
    get$font: [function(_) {
      return this._font;
    }, null, null, 1, 0, 810, "font"],
    set$font: [function(_, value) {
      var t1 = J.getInterceptor(value);
      if (!t1.$eq(value, this._font)) {
        this._font = t1.trim$0(value);
        J.set$font$x(this.style, J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(this._fontWeight, " "), J.toString$0(this._fontSize)), "px '"), this._font), "'"));
        this._Phaser$_dirty = true;
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          this.updateTransform$0();
      }
    }, null, null, 3, 0, 91, 138, [], "font"],
    get$fontSize: [function(_) {
      return this._fontSize;
    }, null, null, 1, 0, 619, "fontSize"],
    set$fontSize: [function(_, value) {
      if (!J.$eq(value, this._fontSize)) {
        this._fontSize = value;
        J.set$font$x(this.style, J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(this._fontWeight, " "), J.toString$0(this._fontSize)), "px '"), this._font), "'"));
        this._Phaser$_dirty = true;
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          this.updateTransform$0();
      }
    }, null, null, 3, 0, 620, 138, [], "fontSize"],
    get$fontWeight: [function(_) {
      return this._fontWeight;
    }, null, null, 1, 0, 810, "fontWeight"],
    set$fontWeight: [function(_, value) {
      if (!J.$eq(value, this._fontWeight)) {
        this._fontWeight = value;
        J.set$font$x(this.style, J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(value, " "), J.toString$0(this._fontSize)), "px '"), this._font), "'"));
        this._Phaser$_dirty = true;
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          this.updateTransform$0();
      }
    }, null, null, 3, 0, 91, 138, [], "fontWeight"],
    get$fill: [function(_) {
      return J.get$fill$x(this.style);
    }, null, null, 1, 0, 810, "fill"],
    fill$0: function($receiver) {
      return this.get$fill(this).call$0();
    },
    fill$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$fill(this).call$4(arg0, arg1, arg2, arg3);
    },
    fill$6: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5) {
      return this.get$fill(this).call$6(arg0, arg1, arg2, arg3, arg4, arg5);
    },
    set$fill: [function(_, value) {
      if (!J.$eq(value, J.get$fill$x(this.style))) {
        J.set$fill$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 91, 138, [], "fill"],
    get$align: [function() {
      return this.style.get$align();
    }, null, null, 1, 0, 810, "align"],
    set$align: [function(value) {
      if (!J.$eq(value, this.style.get$align())) {
        this.style.set$align(value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 91, 138, [], "align"],
    get$stroke: [function(_) {
      return J.get$stroke$x(this.style);
    }, null, null, 1, 0, 810, "stroke"],
    stroke$0: function($receiver) {
      return this.get$stroke(this).call$0();
    },
    set$stroke: [function(_, value) {
      if (!J.$eq(value, J.get$stroke$x(this.style))) {
        J.set$stroke$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 91, 138, [], "stroke"],
    get$strokeThickness: [function() {
      return this.style.get$strokeThickness();
    }, null, null, 1, 0, 619, "strokeThickness"],
    set$strokeThickness: [function(value) {
      if (!J.$eq(value, this.style.get$strokeThickness())) {
        this.style.set$strokeThickness(value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 620, 138, [], "strokeThickness"],
    get$isWordWrap: [function() {
      return J.get$wordWrap$x(this.style);
    }, null, null, 1, 0, 247, "isWordWrap"],
    set$isWordWrap: [function(value) {
      if (!J.$eq(value, J.get$wordWrap$x(this.style))) {
        J.set$wordWrap$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 639, 138, [], "isWordWrap"],
    get$wordWrapWidth: [function() {
      return this.style.get$wordWrapWidth();
    }, null, null, 1, 0, 619, "wordWrapWidth"],
    set$wordWrapWidth: [function(value) {
      if (!J.$eq(value, this.style.get$wordWrapWidth())) {
        this.style.set$wordWrapWidth(value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 620, 138, [], "wordWrapWidth"],
    get$lineSpacing: [function() {
      return this._lineSpacing;
    }, null, null, 1, 0, 619, "lineSpacing"],
    set$lineSpacing: [function(value) {
      if (!J.$eq(value, this._lineSpacing)) {
        this._lineSpacing = value;
        this._Phaser$_dirty = true;
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          this.updateTransform$0();
      }
    }, null, null, 3, 0, 620, 138, [], "lineSpacing"],
    get$shadowOffsetX: [function(_) {
      return J.get$shadowOffsetX$x(this.style);
    }, null, null, 1, 0, 619, "shadowOffsetX"],
    set$shadowOffsetX: [function(_, value) {
      if (!J.$eq(value, J.get$shadowOffsetX$x(this.style))) {
        J.set$shadowOffsetX$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 620, 138, [], "shadowOffsetX"],
    get$shadowOffsetY: [function(_) {
      return J.get$shadowOffsetY$x(this.style);
    }, null, null, 1, 0, 54, "shadowOffsetY"],
    set$shadowOffsetY: [function(_, value) {
      if (!J.$eq(value, J.get$shadowOffsetY$x(this.style))) {
        J.set$shadowOffsetY$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 620, 138, [], "shadowOffsetY"],
    get$shadowColor: [function(_) {
      return J.get$shadowColor$x(this.style);
    }, null, null, 1, 0, 810, "shadowColor"],
    set$shadowColor: [function(_, value) {
      if (!J.$eq(value, J.get$shadowColor$x(this.style))) {
        J.set$shadowColor$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 91, 138, [], "shadowColor"],
    get$shadowBlur: [function(_) {
      return J.get$shadowBlur$x(this.style);
    }, null, null, 1, 0, 619, "shadowBlur"],
    set$shadowBlur: [function(_, value) {
      if (!J.$eq(value, J.get$shadowBlur$x(this.style))) {
        J.set$shadowBlur$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 620, 138, [], "shadowBlur"],
    get$inputEnabled: [function() {
      var t1 = this.input;
      return t1 != null && t1.get$enabled() === true;
    }, null, null, 1, 0, 247, "inputEnabled"],
    set$inputEnabled: [function(value) {
      var t1;
      if (value === true) {
        t1 = this.input;
        if (t1 == null) {
          t1 = R.InputHandler$(this);
          this.input = t1;
          t1.start$0(0);
        } else if (t1.get$enabled() !== true)
          J.start$0$x(this.input);
      } else {
        t1 = this.input;
        if (t1 != null && t1.get$enabled() === true)
          J.stop$0$x(this.input);
      }
    }, null, null, 3, 0, 639, 138, [], "inputEnabled"],
    get$fixedToCamera: [function() {
      return J.$eq(J.$index$asx(this._cache, 7), 1);
    }, null, null, 1, 0, 247, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.cameraOffset.set$2(J.get$x$x(this.position), J.get$y$x(this.position));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 639, 138, [], "fixedToCamera"],
    get$destroyPhase: [function() {
      return J.$eq(J.$index$asx(this._cache, 8), 1);
    }, null, null, 1, 0, 247, "destroyPhase"],
    Text$5: function(game, x, y, text, style) {
      var t1;
      J.set$x$x(this.position, x);
      J.set$y$x(this.position, y);
      this.style = style;
      if (style == null)
        this.style = M.TextStyle$0("left", "black", "bold 20pt Arial", "black", 0, 16777215);
      this._text = text;
      this.exists = true;
      this.name = "";
      this.type = 4;
      this.z = 0;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.world = t1;
      this._font = "";
      this._fontSize = 32;
      this._fontWeight = "normal";
      this._lineSpacing = 0;
      this.events = R.Events$(this);
      this.input = null;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.cameraOffset = t1;
      this.style = style;
      this._Phaser$_dirty = true;
      this.position.set$2(x, y);
      this._charCount = 0;
      this.colors = [];
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
      if (!J.$eq(text, ""))
        this.updateText$0();
    },
    $isText: true,
    $isGameObject: true,
    static: {"^": "Text_linesReg@-813", Text$: [function(game, x, y, text, style) {
        var t1, t2, t3, t4, t5;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = new R.Text(game, null, null, null, null, null, null, "", null, null, null, null, null, null, null, false, null, [], null, null, false, null, null, null, t1, null, null, null, null, null, false, null, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t5.renderable = true;
        t5.Text$2(text, style);
        t5.Text$5(game, x, y, text, style);
        return t5;
      }, null, null, 2, 8, 340, 12, 12, 259, 12, 252, [], 9, [], 10, [], 124, [], 194, [], "new Text"]}
  },
  "+Text": [1253, 2],
  TileSprite: {
    "^": "TilingSprite;game@-613,name*-644,type*-616,events@-648,alive@-617,body*-4,input@-1141,animations@-1147,key*-12,z*-616,_cache@-709,_Phaser$_currentBounds@-649,_frame@-12,_frameName@-644,world@-615,_scroll@-615,_Phaser$_dirty@-617,children:Phaser$TileSprite$children*-1091,_Phaser$_bounds@-649,checkWorldBounds@-617,_outOfBoundsFired@-617,autoCull@-617,cameraOffset@-615,__tilePattern@-822,PIXI$TilingSprite$_PIXI$_width-616,PIXI$TilingSprite$_PIXI$_height-616,tileScale-652,tilePosition-652,_PIXI$__tilePattern-822,tilingTexture-698,refreshTexture-617,tileScaleOffset-652,anchor-652,texture-698,updateFrame-617,PIXI$Sprite0$_PIXI$_width-616,PIXI$Sprite0$_PIXI$_height-616,_uvs-699,tintedTexture-700,buffer-701,tint-614,cachedTint-614,blendMode-702,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 324, "parent"],
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.body.call$3(arg0, arg1, arg2);
    },
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.position), J.$div$n(this.PIXI$TilingSprite$_PIXI$_width, 2));
      t2 = J.$add$ns(J.get$y$x(this.position), J.$div$n(this.PIXI$TilingSprite$_PIXI$_height, 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1010, "center"],
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$TileSprite$children, child), J.get$length$asx(this.Phaser$TileSprite$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$TileSprite$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$TileSprite$children));
        }
        return this;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1092, 12, 687, [], "bringToTop"],
    get$renderOrderID: [function() {
      return J.$index$asx(this._cache, 3);
    }, null, null, 1, 0, 619, "renderOrderID"],
    get$angle: [function(_) {
      return R.Math_wrapAngle(J.$mul$ns(this.rotation, 57.29577951308232), false);
    }, null, null, 1, 0, 54, "angle"],
    angle$0: function($receiver) {
      return this.get$angle(this).call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.get$angle(this).call$2(arg0, arg1);
    },
    set$angle: [function(_, value) {
      this.rotation = R.Math_wrapAngle(value, false) * 0.017453292519943295;
    }, null, null, 3, 0, 102, 138, [], "angle"],
    get$frame: [function() {
      return this.animations.get$frame();
    }, null, null, 1, 0, 54, "frame"],
    set$frame: [function(value) {
      if (!J.$eq(value, this.animations.get$frame()))
        this.animations.set$frame(value);
    }, null, null, 3, 0, 102, 138, [], "frame"],
    get$frameName: [function() {
      return this.animations.get$frameName();
    }, null, null, 1, 0, 810, "frameName"],
    set$frameName: [function(value) {
      if (!J.$eq(value, this.animations.get$frameName()))
        this.animations.set$frameName(value);
    }, null, null, 3, 0, 91, 138, [], "frameName"],
    get$fixedToCamera: [function() {
      return J.$eq(J.$index$asx(this._cache, 7), 1);
    }, null, null, 1, 0, 247, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.cameraOffset.set$2(J.get$x$x(this.position), J.get$y$x(this.position));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 639, 138, [], "fixedToCamera"],
    get$exists: [function() {
      return J.$eq(J.$index$asx(this._cache, 6), 1);
    }, null, null, 1, 0, 247, "exists"],
    set$exists: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 6, 1);
        t1 = this.body;
        if (t1 != null && J.$eq(J.get$type$x(t1), 1))
          H.interceptedTypeCast(this.body, "$isBody1").addToWorld$0();
        this.visible = true;
      } else {
        J.$indexSet$ax(t1, 6, 0);
        t1 = this.body;
        if (t1 != null && J.$eq(J.get$type$x(t1), 1))
          this.body.set$safeRemove(true);
        this.visible = false;
      }
    }, null, null, 3, 0, 639, 138, [], "exists"],
    get$inputEnabled: [function() {
      var t1 = this.input;
      return t1 != null && t1.get$enabled() === true;
    }, null, null, 1, 0, 247, "inputEnabled"],
    set$inputEnabled: [function(value) {
      var t1;
      if (value === true) {
        t1 = this.input;
        if (t1 == null) {
          t1 = R.InputHandler$(this);
          this.input = t1;
          t1.start$0(0);
        } else if (t1.get$enabled() !== true)
          J.start$0$x(this.input);
      } else {
        t1 = this.input;
        if (t1 != null && t1.get$enabled() === true)
          J.stop$0$x(this.input);
      }
    }, null, null, 3, 0, 639, 138, [], "inputEnabled"],
    get$x: [function(_) {
      return J.get$x$x(this.position);
    }, null, null, 1, 0, 54, "x"],
    set$x: [function(_, value) {
      var t1;
      J.set$x$x(this.position, value);
      t1 = this.body;
      if (t1 != null && J.$eq(J.get$type$x(t1), 0) && J.$eq(this.body.get$phase(), 2))
        this.body.set$_reset(true);
    }, null, null, 3, 0, 102, 138, [], "x"],
    get$y: [function(_) {
      return J.get$y$x(this.position);
    }, null, null, 1, 0, 54, "y"],
    set$y: [function(_, value) {
      var t1;
      J.set$y$x(this.position, value);
      t1 = this.body;
      if (t1 != null && J.$eq(J.get$type$x(t1), 0) && J.$eq(this.body.get$phase(), 2))
        this.body.set$_reset(true);
    }, null, null, 3, 0, 102, 138, [], "y"],
    get$destroyPhase: [function() {
      return J.$eq(J.$index$asx(this._cache, 8), 1);
    }, null, null, 1, 0, 247, "destroyPhase"],
    preUpdate$0: [function() {
      var t1, t2, t3, len, i;
      if (J.$eq(J.$index$asx(this._cache, 4), 1) && J.$eq(J.$index$asx(this._cache, 6), 1)) {
        this.world.setTo$2(J.$add$ns(J.get$x$x(J.get$position$x(M.DisplayObject.prototype.get$parent.call(this, this))), J.get$x$x(this.position)), J.$add$ns(J.get$y$x(J.get$position$x(M.DisplayObject.prototype.get$parent.call(this, this))), J.get$y$x(this.position)));
        this._worldTransform.set$tx(J.toDouble$0$n(J.get$x$x(this.world)));
        this._worldTransform.set$ty(J.toDouble$0$n(J.get$y$x(this.world)));
        J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
        J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
        J.$indexSet$ax(this._cache, 2, this.rotation);
        t1 = this.body;
        if (t1 != null)
          t1.preUpdate$0();
        J.$indexSet$ax(this._cache, 4, 0);
        return false;
      }
      J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
      J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
      J.$indexSet$ax(this._cache, 2, this.rotation);
      if (!J.$eq(J.$index$asx(this._cache, 6), 1) || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        J.$indexSet$ax(this._cache, 3, -1);
        return false;
      }
      if (this.autoCull === true || this.checkWorldBounds === true)
        this._Phaser$_bounds.copyFrom$1(this.getBounds$0());
      if (this.autoCull === true)
        this.renderable = J.intersects$1$x(this.game.get$world().get$camera().get$screenView(), this._Phaser$_bounds);
      if (this.checkWorldBounds === true)
        if (J.$eq(J.$index$asx(this._cache, 5), 1) && J.intersects$1$x(this.game.get$world().get$bounds(), this._Phaser$_bounds) === true) {
          J.$indexSet$ax(this._cache, 5, 0);
          this.events.get$onEnterBounds().dispatch$1(this);
        } else if (J.$eq(J.$index$asx(this._cache, 5), 0) && J.intersects$1$x(this.game.get$world().get$bounds(), this._Phaser$_bounds) !== true) {
          J.$indexSet$ax(this._cache, 5, 1);
          this.events.get$onOutOfBounds().dispatch$1(this);
        }
      this.world.setTo$2(J.$add$ns(J.get$x$x(this.game.get$camera()), this._worldTransform.get$tx()), J.$add$ns(J.get$y$x(this.game.get$camera()), this._worldTransform.get$ty()));
      if (this.visible === true) {
        t1 = this._cache;
        t2 = this.game.get$stage();
        t3 = t2.get$currentRenderOrderID();
        t2.set$currentRenderOrderID(J.$add$ns(t3, 1));
        J.$indexSet$ax(t1, 3, t3);
      }
      this.animations.update$0();
      if (!J.$eq(J.get$x$x(this._scroll), 0)) {
        t1 = this.tilePosition;
        t2 = J.getInterceptor$x(t1);
        t2.set$x(t1, J.$add$ns(t2.get$x(t1), J.$mul$ns(J.get$x$x(this._scroll), this.game.get$time().get$physicsElapsed())));
      }
      if (!J.$eq(J.get$y$x(this._scroll), 0)) {
        t1 = this.tilePosition;
        t2 = J.getInterceptor$x(t1);
        t2.set$y(t1, J.$add$ns(t2.get$y(t1), J.$mul$ns(J.get$y$x(this._scroll), this.game.get$time().get$physicsElapsed())));
      }
      t1 = this.body;
      if (t1 != null)
        t1.preUpdate$0();
      len = J.get$length$asx(this.Phaser$TileSprite$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$TileSprite$children, i).preUpdate$0();
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 54, "update"],
    postUpdate$0: [function() {
      var len, i;
      if (J.$eq(J.$index$asx(this._cache, 6), 1) && this.body != null)
        this.body.postUpdate$0();
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.position, J.$add$ns(J.get$x$x(J.get$view$x(this.game.get$camera())), J.get$x$x(this.cameraOffset)));
        J.set$y$x(this.position, J.$add$ns(J.get$y$x(J.get$view$x(this.game.get$camera())), J.get$y$x(this.cameraOffset)));
      }
      len = J.get$length$asx(this.Phaser$TileSprite$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$TileSprite$children, i).postUpdate$0();
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    autoScroll$2: [function(x, y) {
      this._scroll.set$2(x, y);
    }, "call$2", "get$autoScroll", 4, 0, 149, 9, [], 10, [], "autoScroll"],
    stopScroll$0: [function() {
      this._scroll.set$2(0, 0);
    }, "call$0", "get$stopScroll", 0, 0, 54, "stopScroll"],
    loadTexture$2: [function(key, frame) {
      var t1, setFrame;
      this.key = key;
      t1 = J.getInterceptor(key);
      if (!!t1.$isRenderTexture) {
        this.key = key.key;
        this.setTexture$1(key);
        setFrame = true;
      } else if (!!t1.$isBitmapData) {
        this.setTexture$1(key.texture);
        setFrame = true;
      } else if (!!t1.$isTexture) {
        this.setTexture$1(key);
        setFrame = true;
      } else if (key == null) {
        this.key = "__default";
        this.setTexture$1(J.$index$asx($.get$TextureCache(), "__default"));
        setFrame = true;
      } else if (typeof key === "string" && !this.game.get$cache().checkImageKey$1(key)) {
        window;
        t1 = C.JSString_methods.$add("Texture with key '", key) + "' not found.";
        if (typeof console != "undefined")
          console.warn(t1);
        this.key = "__missing";
        this.setTexture$1(J.$index$asx($.get$TextureCache(), "__missing"));
        setFrame = true;
      } else {
        this.setTexture$1(M.Texture$(J.$index$asx($.get$BaseTextureCache(), key), null));
        setFrame = !this.animations.loadFrameData$2(this.game.get$cache().getFrameData$1(key), frame);
      }
      if (setFrame)
        this._frame = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(this.texture.get$frame());
    }, "call$2", "get$loadTexture", 4, 0, 959, 269, [], 216, [], "loadTexture"],
    setFrame$1: [function(frame) {
      var t1, t2;
      t1 = J.getInterceptor$x(frame);
      J.set$x$x(this.texture.get$frame(), t1.get$x(frame));
      J.set$y$x(this.texture.get$frame(), t1.get$y(frame));
      J.set$width$x(this.texture.get$frame(), t1.get$width(frame));
      J.set$height$x(this.texture.get$frame(), t1.get$height(frame));
      J.set$x$x(this.texture.get$crop(), t1.get$x(frame));
      J.set$y$x(this.texture.get$crop(), t1.get$y(frame));
      J.set$width$x(this.texture.get$crop(), t1.get$width(frame));
      J.set$height$x(this.texture.get$crop(), t1.get$height(frame));
      if (frame.get$trimmed() === true) {
        t1 = J.get$trim$s(this.texture);
        t2 = this.texture;
        if (t1 != null) {
          J.set$x$x(J.get$trim$s(t2), frame.get$spriteSourceSizeX());
          J.set$y$x(J.get$trim$s(this.texture), frame.get$spriteSourceSizeY());
          J.set$width$x(J.get$trim$s(this.texture), frame.get$sourceSizeW());
          J.set$height$x(J.get$trim$s(this.texture), frame.get$sourceSizeH());
        } else {
          t1 = new M.Rectangle0(0, 0, 0, 0);
          t1.x = frame.get$spriteSourceSizeX();
          t1.y = frame.get$spriteSourceSizeY();
          t1.width = frame.get$sourceSizeW();
          t1.height = frame.get$sourceSizeH();
          J.set$trim$s(t2, t1);
        }
        J.set$width$x(this.texture, frame.get$sourceSizeW());
        J.set$height$x(this.texture, frame.get$sourceSizeH());
        J.set$width$x(this.texture.get$frame(), frame.get$sourceSizeW());
        J.set$height$x(this.texture.get$frame(), frame.get$sourceSizeH());
      } else if (frame.get$trimmed() !== true && J.get$trim$s(this.texture) != null)
        J.set$trim$s(this.texture, null);
      if (J.$eq(this.game.get$renderType(), 2))
        this.texture._updateWebGLuvs$0();
    }, "call$1", "get$setFrame", 2, 0, 1214, 216, [], "setFrame"],
    destroy$1: [function(destroyChildren) {
      var t1, i, i0;
      if (this.game == null || J.$eq(J.$index$asx(this._cache, 8), 1))
        return;
      if (destroyChildren == null)
        destroyChildren = true;
      J.$indexSet$ax(this._cache, 8, 1);
      t1 = this.events;
      if (t1 != null)
        t1.get$onDestroy().dispatch$1(this);
      if (this._filters != null)
        this.set$filters(null);
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        if (!!J.getInterceptor(M.DisplayObject.prototype.get$parent.call(this, this)).$isGroup)
          H.interceptedTypeCast(M.DisplayObject.prototype.get$parent.call(this, this), "$isGroup").remove$1(0, this);
        else
          M.DisplayObject.prototype.get$parent.call(this, this).removeChild$1(this);
      this.animations.destroy$0();
      this.events.destroy$0();
      i = J.get$length$asx(this.Phaser$TileSprite$children);
      if (destroyChildren === true)
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          J.$index$asx(this.Phaser$TileSprite$children, i0).destroy$1(destroyChildren);
      else
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0) {
          t1 = J.$index$asx(this.Phaser$TileSprite$children, i0);
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$TileSprite$children, t1));
        }
      this.set$exists(false);
      this.visible = false;
      this.alive = false;
      this.set$filters(null);
      this.set$mask(0, null);
      this.game = null;
      J.$indexSet$ax(this._cache, 8, 0);
    }, function() {
      return this.destroy$1(true);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 956, 78, 1069, [], "destroy"],
    play$4: [function(_, $name, frameRate, loop, killOnComplete) {
      return J.play$4$x(this.animations, $name, frameRate, loop, killOnComplete);
    }, function($receiver, name, frameRate, loop) {
      return this.play$4($receiver, name, frameRate, loop, null);
    }, "play$3", function($receiver, name, frameRate) {
      return this.play$4($receiver, name, frameRate, null, null);
    }, "play$2", "call$4", "call$3", "call$2", "get$play", 4, 4, 1254, 12, 12, 83, [], 256, [], 257, [], 967, [], "play"],
    reset$2: [function(_, x, y) {
      var t1;
      this.world.setTo$2(x, y);
      J.set$x$x(this.position, x);
      J.set$y$x(this.position, y);
      this.alive = true;
      this.set$exists(true);
      this.visible = true;
      this.renderable = true;
      this._outOfBoundsFired = false;
      J.set$x$x(this.tilePosition, 0);
      J.set$y$x(this.tilePosition, 0);
      t1 = this.body;
      if (t1 != null)
        J.reset$4$x(t1, x, y, false, false);
      J.$indexSet$ax(this._cache, 4, 1);
      return this;
    }, "call$2", "get$reset", 4, 0, 149, 9, [], 10, [], "reset"],
    TileSprite$7: function(game, x, y, width, height, key, frame) {
      var t1, setFrame;
      this.set$x(0, J.toInt$0$n(x));
      this.set$y(0, J.toInt$0$n(y));
      this.PIXI$TilingSprite$_PIXI$_width = J.toInt$0$n(width);
      this.PIXI$TilingSprite$_PIXI$_height = J.toInt$0$n(height);
      this.game = this.game;
      this.name = "";
      this.type = 5;
      this.z = 0;
      this.events = R.Events$(this);
      t1 = new R.AnimationManager(this, null, null, null, true, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), [], 0, null, null);
      t1.game = this.game;
      this.animations = t1;
      this.key = key;
      this._frame = 0;
      this._frameName = "";
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this._scroll = t1;
      this.position.set$2(x, y);
      this.input = null;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.world = t1;
      this.autoCull = false;
      this.checkWorldBounds = false;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.cameraOffset = t1;
      this.body = null;
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
      this.key = key;
      t1 = J.getInterceptor(key);
      if (!!t1.$isRenderTexture) {
        this.key = key.key;
        this.setTexture$1(key);
        setFrame = true;
      } else if (!!t1.$isBitmapData) {
        this.setTexture$1(key.texture);
        setFrame = true;
      } else if (!!t1.$isTexture) {
        this.setTexture$1(key);
        setFrame = true;
      } else if (key == null) {
        this.key = "__default";
        this.setTexture$1(J.$index$asx($.get$TextureCache(), "__default"));
        setFrame = true;
      } else if (typeof key === "string" && !this.game.get$cache().checkImageKey$1(key)) {
        window;
        t1 = C.JSString_methods.$add("Texture with key '", key) + "' not found.";
        if (typeof console != "undefined")
          console.warn(t1);
        this.key = "__missing";
        this.setTexture$1(J.$index$asx($.get$TextureCache(), "__missing"));
        setFrame = true;
      } else {
        this.setTexture$1(M.Texture$(J.$index$asx($.get$BaseTextureCache(), key), null));
        setFrame = !this.animations.loadFrameData$2(this.game.get$cache().getFrameData$1(key), frame);
      }
      if (setFrame)
        this._frame = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(this.texture.get$frame());
    },
    $isTileSprite: true,
    $isSpriteInterface: true,
    $isGameObject: true,
    static: {TileSprite$: [function(game, x, y, width, height, key, frame) {
        var t1, t2, t3, t4, t5, t6;
        t1 = J.$index$asx($.get$TextureCache(), "__default");
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = new M.Point0(null, null);
        t5.x = 1;
        t5.y = 1;
        t6 = new M.Point0(null, null);
        t6.x = 0;
        t6.y = 0;
        t6 = new R.TileSprite(game, null, null, null, true, null, null, null, null, null, null, null, null, null, null, null, false, [], null, null, null, null, null, null, null, null, null, null, null, null, false, t2, t3, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t4, t5, t6, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t6.texture = t1;
        t6._setupTexture$0();
        t6.TilingSprite$3(t1, width, height);
        t6.TileSprite$7(game, x, y, width, height, key, frame);
        return t6;
      }, null, null, 2, 12, 341, 49, 49, 342, 342, 12, 12, 252, [], 9, [], 10, [], 31, [], 52, [], 269, [], 216, [], "new TileSprite"]}
  },
  "+TileSprite": [1255, 977, 2],
  Circle0: {
    "^": "Circle;x:Phaser$Circle0$x*-616,y:Phaser$Circle0$y*-616,_diameter@-616,_radius@-616,x-616,y-616,radius-616",
    get$diameter: [function() {
      return this._diameter;
    }, null, null, 1, 0, 619, "diameter"],
    set$diameter: [function(value) {
      var t1 = J.getInterceptor$n(value);
      if (t1.$gt(value, 0)) {
        this._diameter = value;
        this._radius = t1.$mul(value, 0.5);
      }
    }, null, null, 3, 0, 620, 138, [], "diameter"],
    get$radius: [function() {
      return this._radius;
    }, null, null, 1, 0, 619, "radius"],
    set$radius: [function(value) {
      var t1 = J.getInterceptor$n(value);
      if (t1.$gt(value, 0)) {
        this._radius = value;
        this._diameter = t1.$mul(value, 2);
      }
    }, null, null, 3, 0, 620, 138, [], "radius"],
    get$left: [function(_) {
      return J.$sub$n(this.Phaser$Circle0$x, this._radius);
    }, null, null, 1, 0, 619, "left"],
    set$left: [function(_, value) {
      if (J.$gt$n(value, this.Phaser$Circle0$x)) {
        this._radius = 0;
        this._diameter = 0;
      } else
        this.set$radius(J.$sub$n(this.Phaser$Circle0$x, value));
    }, null, null, 3, 0, 620, 138, [], "left"],
    get$right: [function(_) {
      return J.$sub$n(this.Phaser$Circle0$x, this._radius);
    }, null, null, 1, 0, 619, "right"],
    set$right: [function(_, value) {
      var t1 = J.getInterceptor$n(value);
      if (t1.$lt(value, this.Phaser$Circle0$x)) {
        this._radius = 0;
        this._diameter = 0;
      } else
        this.set$radius(t1.$sub(value, this.Phaser$Circle0$x));
    }, null, null, 3, 0, 620, 138, [], "right"],
    get$top: [function(_) {
      return J.$sub$n(this.Phaser$Circle0$y, this._radius);
    }, null, null, 1, 0, 619, "top"],
    set$top: [function(_, value) {
      if (J.$gt$n(value, this.Phaser$Circle0$y)) {
        this._radius = 0;
        this._diameter = 0;
      } else
        this.set$radius(J.$sub$n(this.Phaser$Circle0$y, value));
    }, null, null, 3, 0, 620, 138, [], "top"],
    get$bottom: [function(_) {
      return J.$sub$n(this.Phaser$Circle0$y, this._radius);
    }, null, null, 1, 0, 619, "bottom"],
    set$bottom: [function(_, value) {
      var t1 = J.getInterceptor$n(value);
      if (t1.$lt(value, this.Phaser$Circle0$y)) {
        this._radius = 0;
        this._diameter = 0;
      } else
        this.set$radius(t1.$sub(value, this.Phaser$Circle0$y));
    }, null, null, 3, 0, 620, 138, [], "bottom"],
    get$area: [function() {
      if (J.$gt$n(this._radius, 0)) {
        var t1 = this._radius;
        if (typeof t1 !== "number")
          return H.iae(t1);
        return 3.141592653589793 * t1 * t1;
      } else
        return 0;
    }, null, null, 1, 0, 619, "area"],
    get$empty: [function() {
      return J.$eq(this._diameter, 0);
    }, null, null, 1, 0, 247, "empty"],
    set$1: [function(value) {
      if (J.$eq(value, true))
        this.setTo$3(0, 0, 0);
    }, "call$1", "get$set", 2, 0, 639, 138, [], "set"],
    circumference$0: [function() {
      var t1 = this._radius;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 2 * (3.141592653589793 * t1);
    }, "call$0", "get$circumference", 0, 0, 619, "circumference"],
    setTo$3: [function(x, y, diameter) {
      this.Phaser$Circle0$x = x;
      this.Phaser$Circle0$y = y;
      this._diameter = diameter;
      this._radius = J.$mul$ns(diameter, 0.5);
      return this;
    }, "call$3", "get$setTo", 6, 0, 1256, 9, [], 10, [], 1257, [], "setTo"],
    copyFromfunction$1: [function(source) {
      var t1 = J.getInterceptor$x(source);
      return this.setTo$3(t1.get$x(source), t1.get$y(source), source.get$_diameter());
    }, "call$1", "get$copyFromfunction", 2, 0, 1258, 208, [], "copyFromfunction"],
    copyTo$1: [function(dest) {
      var t1 = J.getInterceptor$x(dest);
      t1.set$x(dest, this.Phaser$Circle0$x);
      t1.set$y(dest, this.Phaser$Circle0$y);
      dest.set$diameter(this._diameter);
      return dest;
    }, "call$1", "get$copyTo", 2, 0, 1258, 1259, [], "copyTo"],
    distance$2: [function(dest, round) {
      var t1, t2, t3;
      t1 = J.getInterceptor$x(dest);
      t2 = this.Phaser$Circle0$x;
      t3 = this.Phaser$Circle0$y;
      if (round === true)
        return C.JSNumber_methods.toInt$0(C.JSDouble_methods.roundToDouble$0(R.Math_distance(t2, t3, t1.get$x(dest), t1.get$y(dest))));
      else
        return R.Math_distance(t2, t3, t1.get$x(dest), t1.get$y(dest));
    }, function(dest) {
      return this.distance$2(dest, false);
    }, "distance$1", "call$2", "call$1", "get$distance", 2, 2, 968, 19, 1259, [], 1260, [], "distance"],
    clone$1: [function(_, output) {
      var t1, t2, t3;
      t1 = this.Phaser$Circle0$x;
      t2 = this.Phaser$Circle0$y;
      t3 = this._diameter;
      if (output == null)
        output = R.Circle$(t1, t2, t3);
      else
        output.setTo$3(t1, t2, t3);
      return output;
    }, function($receiver) {
      return this.clone$1($receiver, null);
    }, "clone$0", "call$1", "call$0", "get$clone", 0, 2, 1261, 12, 999, [], "clone"],
    contains$2: [function(_, x, y) {
      var t1, t2;
      if (J.$gt$n(this._radius, 0)) {
        t1 = J.getInterceptor$n(x);
        if (t1.$ge(x, J.$sub$n(this.Phaser$Circle0$x, this._radius)))
          if (t1.$le(x, J.$sub$n(this.Phaser$Circle0$x, this._radius))) {
            t1 = J.getInterceptor$n(y);
            t1 = t1.$ge(y, J.$sub$n(this.Phaser$Circle0$y, this._radius)) && t1.$le(y, J.$sub$n(this.Phaser$Circle0$y, this._radius));
          } else
            t1 = false;
        else
          t1 = false;
      } else
        t1 = false;
      if (t1) {
        t1 = J.getInterceptor$n(x);
        t2 = J.getInterceptor$n(y);
        t2 = J.$add$ns(J.$mul$ns(t1.$sub(x, x), t1.$sub(x, x)), J.$mul$ns(t2.$sub(y, y), t2.$sub(y, y)));
        t1 = this._radius;
        return J.$le$n(t2, J.$mul$ns(t1, t1));
      } else
        return false;
    }, "call$2", "get$contains", 4, 0, 668, 9, [], 10, [], "contains"],
    circumferencePoint$3: [function(angle, asDegrees, out) {
      var t1;
      if (out == null) {
        out = new R.Point(null, null);
        out.x = 0;
        out.y = 0;
      }
      if (J.$eq(asDegrees, true))
        angle = J.$mul$ns(angle, 0.017453292519943295);
      t1 = J.getInterceptor$x(out);
      t1.set$x(out, J.$add$ns(this.Phaser$Circle0$x, J.$mul$ns(this._radius, Math.cos(H.checkNum(angle)))));
      t1.set$y(out, J.$add$ns(this.Phaser$Circle0$y, J.$mul$ns(this._radius, Math.sin(H.checkNum(angle)))));
      return out;
    }, function(angle) {
      return this.circumferencePoint$3(angle, false, null);
    }, "circumferencePoint$1", function(angle, asDegrees) {
      return this.circumferencePoint$3(angle, asDegrees, null);
    }, "circumferencePoint$2", "call$3", "call$1", "call$2", "get$circumferencePoint", 2, 4, 1262, 19, 12, 7, [], 1263, [], 361, [], "circumferencePoint"],
    intersects$2: [function(_, a, b) {
      var t1, t2;
      t1 = J.getInterceptor$x(a);
      t2 = J.getInterceptor$x(b);
      t2 = R.Math_distance(t1.get$x(a), t1.get$y(a), t2.get$x(b), t2.get$y(b));
      t1 = J.$add$ns(a.get$radius(), b.get$radius());
      if (typeof t1 !== "number")
        return H.iae(t1);
      return t2 <= t1;
    }, "call$2", "get$intersects", 4, 0, 347, 348, [], 349, [], "intersects"],
    offset$2: [function(_, dx, dy) {
      this.Phaser$Circle0$x = J.$add$ns(this.Phaser$Circle0$x, dx);
      this.Phaser$Circle0$y = J.$add$ns(this.Phaser$Circle0$y, dy);
      return this;
    }, "call$2", "get$offset", 4, 0, 1264, 1265, [], 1266, [], "offset"],
    offsetPoint$1: [function(point) {
      var t1, t2;
      t1 = J.getInterceptor$x(point);
      t2 = t1.get$x(point);
      t1 = t1.get$y(point);
      this.Phaser$Circle0$x = J.$add$ns(this.Phaser$Circle0$x, t2);
      this.Phaser$Circle0$y = J.$add$ns(this.Phaser$Circle0$y, t1);
      return this;
    }, "call$1", "get$offsetPoint", 2, 0, 1267, 475, [], "offsetPoint"],
    toString$0: [function(_) {
      return "[{Phaser.Circle (x=" + H.S(this.Phaser$Circle0$x) + " + " + H.S(this.Phaser$Circle0$y) + "=" + H.S(this.Phaser$Circle0$y) + " " + H.S(this._diameter) + "=" + H.S(this._diameter) + " + " + H.S(this._radius) + "=" + H.S(this._radius) + ")}]";
    }, "call$0", "get$toString", 0, 0, 810, "toString"],
    Circle$3: function(x, y, _diameter) {
      if (J.$gt$n(this._diameter, 0))
        this._radius = J.$mul$ns(this._diameter, 0.5);
      else
        this._radius = 0;
    },
    $isCircle0: true,
    static: {Circle$: [function(x, y, _diameter) {
        var t1 = new R.Circle0(x, y, _diameter, null, 0, 0, 0);
        t1.Circle$3(x, y, _diameter);
        return t1;
      }, null, null, 0, 6, 48, 49, 49, 49, 9, [], 10, [], 343, [], "new Circle"], Circle_intersectsRectangle: [function(c, r) {
        var t1, t2, cx, t3, cy, xCornerDist, yCornerDist, xCornerDistSq, yCornerDistSq, maxCornerDistSq;
        t1 = J.getInterceptor$x(c);
        t2 = J.getInterceptor$x(r);
        cx = J.abs$0$n(J.$sub$n(J.$sub$n(t1.get$x(c), t2.get$x(r)), r.get$halfWidth()));
        t3 = J.getInterceptor$n(cx);
        if (t3.$gt(cx, J.$add$ns(r.get$halfWidth(), c.get$radius())))
          return false;
        cy = J.abs$0$n(J.$sub$n(J.$sub$n(t1.get$y(c), t2.get$y(r)), r.get$halfHeight()));
        t1 = J.getInterceptor$n(cy);
        if (t1.$gt(cy, J.$add$ns(r.get$halfHeight(), c.get$radius())))
          return false;
        if (t3.$le(cx, r.get$halfWidth()) || t1.$le(cy, r.get$halfHeight()))
          return true;
        xCornerDist = t3.$sub(cx, r.get$halfWidth());
        yCornerDist = t1.$sub(cy, r.get$halfHeight());
        xCornerDistSq = J.$mul$ns(xCornerDist, xCornerDist);
        yCornerDistSq = J.$mul$ns(yCornerDist, yCornerDist);
        maxCornerDistSq = J.$mul$ns(c.get$radius(), c.get$radius());
        return J.$le$n(J.$add$ns(xCornerDistSq, yCornerDistSq), maxCornerDistSq);
      }, "call$2", "Circle_intersectsRectangle$closure", 4, 0, 344, 345, [], 346, [], "intersectsRectangle"], Circle_equals: [function(a, b) {
        var t1, t2;
        t1 = J.getInterceptor$x(a);
        t2 = J.getInterceptor$x(b);
        return J.$eq(t1.get$x(a), t2.get$x(b)) && J.$eq(t1.get$y(a), t2.get$y(b)) && J.$eq(a.get$diameter(), b.get$diameter());
      }, "call$2", "Circle_equals$closure", 4, 0, 347, 348, [], 349, [], "equals"]}
  },
  "+Circle": [1268],
  Ellipse0: {
    "^": "Ellipse;type*-614,x:Phaser$Ellipse0$x*-616,y:Phaser$Ellipse0$y*-616,width:Phaser$Ellipse0$width*-616,height:Phaser$Ellipse0$height*-616,x-616,y-616,width-616,height-616",
    get$left: [function(_) {
      return this.Phaser$Ellipse0$x;
    }, null, null, 1, 0, 619, "left"],
    set$left: [function(_, value) {
      this.Phaser$Ellipse0$x = value;
    }, null, null, 3, 0, 620, 138, [], "left"],
    get$right: [function(_) {
      return J.$add$ns(this.Phaser$Ellipse0$x, this.Phaser$Ellipse0$width);
    }, null, null, 1, 0, 619, "right"],
    set$right: [function(_, value) {
      if (J.$lt$n(value, this.Phaser$Ellipse0$x))
        this.Phaser$Ellipse0$width = 0;
      else
        this.Phaser$Ellipse0$width = J.$add$ns(this.Phaser$Ellipse0$x, value);
    }, null, null, 3, 0, 620, 138, [], "right"],
    get$top: [function(_) {
      return this.Phaser$Ellipse0$y;
    }, null, null, 1, 0, 619, "top"],
    set$top: [function(_, value) {
      this.Phaser$Ellipse0$y = value;
    }, null, null, 3, 0, 620, 138, [], "top"],
    get$bottom: [function(_) {
      return J.$add$ns(this.Phaser$Ellipse0$y, this.Phaser$Ellipse0$height);
    }, null, null, 1, 0, 619, "bottom"],
    set$bottom: [function(_, value) {
      if (J.$lt$n(value, this.Phaser$Ellipse0$y))
        this.Phaser$Ellipse0$height = 0;
      else
        this.Phaser$Ellipse0$height = J.$add$ns(this.Phaser$Ellipse0$y, value);
    }, null, null, 3, 0, 620, 138, [], "bottom"],
    get$empty: [function() {
      return J.$eq(this.Phaser$Ellipse0$width, 0) || J.$eq(this.Phaser$Ellipse0$height, 0);
    }, null, null, 1, 0, 247, "empty"],
    set$1: [function(value) {
      if (J.$eq(value, true))
        this.setTo$4(0, 0, 0, 0);
    }, "call$1", "get$set", 2, 0, 639, 138, [], "set"],
    setTo$4: [function(x, y, width, height) {
      this.Phaser$Ellipse0$x = x;
      this.Phaser$Ellipse0$y = y;
      this.Phaser$Ellipse0$width = width;
      this.Phaser$Ellipse0$height = height;
      return this;
    }, "call$4", "get$setTo", 8, 0, 1269, 9, [], 10, [], 31, [], 52, [], "setTo"],
    copyFrom$1: [function(source) {
      var t1 = J.getInterceptor$x(source);
      return this.setTo$4(t1.get$x(source), t1.get$y(source), t1.get$width(source), t1.get$height(source));
    }, "call$1", "get$copyFrom", 2, 0, 1270, 208, [], "copyFrom"],
    copyTo$1: [function(dest) {
      var t1 = J.getInterceptor$x(dest);
      t1.set$x(dest, this.Phaser$Ellipse0$x);
      t1.set$y(dest, this.Phaser$Ellipse0$y);
      t1.set$width(dest, this.Phaser$Ellipse0$width);
      t1.set$height(dest, this.Phaser$Ellipse0$height);
      return dest;
    }, "call$1", "get$copyTo", 2, 0, 102, 1259, [], "copyTo"],
    clone$1: [function(_, output) {
      var t1, t2, t3, t4;
      t1 = this.Phaser$Ellipse0$x;
      t2 = this.Phaser$Ellipse0$y;
      t3 = this.Phaser$Ellipse0$width;
      t4 = this.Phaser$Ellipse0$height;
      if (output == null) {
        output = new R.Ellipse0(null, null, null, null, null, 0, 0, 0, 0);
        output.Ellipse$4(t1, t2, t3, t4);
      } else
        output.setTo$4(t1, t2, t3, t4);
      return output;
    }, function($receiver) {
      return this.clone$1($receiver, null);
    }, "clone$0", "call$1", "call$0", "get$clone", 0, 2, 1271, 12, 999, [], "clone"],
    contains$2: [function(_, x, y) {
      var normx, normy;
      if (J.$le$n(this.Phaser$Ellipse0$width, 0) || J.$le$n(this.Phaser$Ellipse0$height, 0))
        return false;
      normx = J.$sub$n(J.$div$n(J.$sub$n(x, this.Phaser$Ellipse0$x), this.Phaser$Ellipse0$width), 0.5);
      normy = J.$sub$n(J.$div$n(J.$sub$n(y, this.Phaser$Ellipse0$y), this.Phaser$Ellipse0$height), 0.5);
      return J.$lt$n(J.$add$ns(J.$mul$ns(normx, normx), J.$mul$ns(normy, normy)), 0.25);
    }, "call$2", "get$contains", 4, 0, 668, 9, [], 10, [], "contains"],
    toString$0: [function(_) {
      return "[{Phaser.Ellipse (x=" + H.S(this.Phaser$Ellipse0$x) + " y=" + H.S(this.Phaser$Ellipse0$y) + " width=" + H.S(this.Phaser$Ellipse0$width) + " height=" + H.S(this.Phaser$Ellipse0$height) + ")}]";
    }, "call$0", "get$toString", 0, 0, 810, "toString"],
    getBounds$0: [function() {
      return new R.Rectangle1(this.Phaser$Ellipse0$x, this.Phaser$Ellipse0$y, this.Phaser$Ellipse0$width, this.Phaser$Ellipse0$height, 0, 0, 0, 0);
    }, "call$0", "get$getBounds", 0, 0, 1272, "getBounds"],
    Ellipse$4: function(x, y, width, height) {
      this.type = 16;
      this.Phaser$Ellipse0$x = x;
      this.Phaser$Ellipse0$y = y;
      this.Phaser$Ellipse0$width = width;
      this.Phaser$Ellipse0$height = height;
    },
    static: {Ellipse$0: [function(x, y, width, height) {
        var t1 = new R.Ellipse0(null, null, null, null, null, 0, 0, 0, 0);
        t1.Ellipse$4(x, y, width, height);
        return t1;
      }, null, null, 8, 0, 350, 9, [], 10, [], 31, [], 52, [], "new Ellipse"]}
  },
  "+Ellipse": [1273],
  Line: {
    "^": "Object;x1*-616,x2*-616,y1*-616,y2*-616,start*-615,end@-615",
    start$1: function($receiver, arg0) {
      return this.start.call$1(arg0);
    },
    start$0: function($receiver) {
      return this.start.call$0();
    },
    start$2: function($receiver, arg0, arg1) {
      return this.start.call$2(arg0, arg1);
    },
    start$3: function($receiver, arg0, arg1, arg2) {
      return this.start.call$3(arg0, arg1, arg2);
    },
    start$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.start.call$4(arg0, arg1, arg2, arg3);
    },
    start$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.start.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    end$0: function() {
      return this.end.call$0();
    },
    setTo$4: [function(x1, y1, x2, y2) {
      this.start.setTo$2(x1, y1);
      this.end.setTo$2(x2, y2);
      return this;
    }, function(x1, y1) {
      return this.setTo$4(x1, y1, 0, 0);
    }, "setTo$2", function(x1, y1, x2) {
      return this.setTo$4(x1, y1, x2, 0);
    }, "setTo$3", function(x1) {
      return this.setTo$4(x1, 0, 0, 0);
    }, "setTo$1", function() {
      return this.setTo$4(0, 0, 0, 0);
    }, "setTo$0", "call$4", "call$2", "call$3", "call$1", "call$0", "get$setTo", 0, 8, 1109, 49, 49, 49, 49, 351, [], 352, [], 353, [], 354, [], "setTo"],
    fromSprite$3: [function(startSprite, endSprite, useCenter) {
      var t1, t2, t3, t4;
      if (useCenter === true) {
        t1 = J.get$x$x(startSprite.get$center());
        t2 = J.get$y$x(startSprite.get$center());
        t3 = J.get$x$x(endSprite.get$center());
        t4 = J.get$y$x(endSprite.get$center());
        this.start.setTo$2(t1, t2);
        this.end.setTo$2(t3, t4);
        return this;
      }
      t1 = J.getInterceptor$x(startSprite);
      t2 = t1.get$x(startSprite);
      t1 = t1.get$y(startSprite);
      t3 = J.getInterceptor$x(endSprite);
      t4 = t3.get$x(endSprite);
      t3 = t3.get$y(endSprite);
      this.start.setTo$2(t2, t1);
      this.end.setTo$2(t4, t3);
      return this;
    }, function(startSprite, endSprite) {
      return this.fromSprite$3(startSprite, endSprite, false);
    }, "fromSprite$2", "call$3", "call$2", "get$fromSprite", 4, 2, 1274, 19, 1275, [], 1276, [], 1277, [], "fromSprite"],
    clone$1: [function(_, output) {
      var t1, t2, t3, t4, t5;
      t1 = this.start;
      if (output == null) {
        t1 = J.get$x$x(t1);
        t2 = J.get$y$x(this.start);
        t3 = J.get$x$x(this.end);
        t4 = J.get$y$x(this.end);
        output = new R.Line(t1, t3, t2, t4, null, null);
        t5 = new R.Point(null, null);
        t5.x = t1;
        t5.y = t2;
        output.start = t5;
        t5 = new R.Point(null, null);
        t5.x = t3;
        t5.y = t4;
        output.end = t5;
      } else
        output.setTo$4(J.get$x$x(t1), J.get$y$x(this.start), J.get$x$x(this.end), J.get$y$x(this.end));
      return output;
    }, "call$1", "get$clone", 2, 0, 1278, 999, [], "clone"],
    intersects$3: [function(_, line, asSegment, result) {
      return R.Line_intersectsPoints(this.start, this.end, J.get$start$x(line), line.get$end(), asSegment, result);
    }, function($receiver, line) {
      return this.intersects$3($receiver, line, null, null);
    }, "intersects$1", function($receiver, line, asSegment) {
      return this.intersects$3($receiver, line, asSegment, null);
    }, "intersects$2", "call$3", "call$1", "call$2", "get$intersects", 2, 4, 1279, 12, 12, 1233, [], 358, [], 359, [], "intersects"],
    pointOnLine$2: [function(x, y) {
      return J.$eq(J.$mul$ns(J.$sub$n(x, J.get$x$x(this.start)), J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start))), J.$mul$ns(J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start)), J.$sub$n(y, J.get$y$x(this.start))));
    }, "call$2", "get$pointOnLine", 4, 0, 1280, 9, [], 10, [], "pointOnLine"],
    pointOnSegment$2: [function(x, y) {
      var xMin, xMax, yMin, yMax, t1, t2;
      xMin = P.min(J.get$x$x(this.start), J.get$x$x(this.end));
      xMax = P.max(J.get$x$x(this.start), J.get$x$x(this.end));
      yMin = P.min(J.get$y$x(this.start), J.get$y$x(this.end));
      yMax = P.max(J.get$y$x(this.start), J.get$y$x(this.end));
      t1 = J.getInterceptor$n(x);
      t2 = J.getInterceptor$n(y);
      if (J.$eq(J.$mul$ns(t1.$sub(x, J.get$x$x(this.start)), J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start))), J.$mul$ns(J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start)), t2.$sub(y, J.get$y$x(this.start)))))
        t1 = t1.$ge(x, xMin) && t1.$le(x, xMax) && t2.$ge(y, yMin) && t2.$le(y, yMax);
      else
        t1 = false;
      return t1;
    }, "call$2", "get$pointOnSegment", 4, 0, 1280, 9, [], 10, [], "pointOnSegment"],
    coordinatesOnLine$2: [function(stepRate, results) {
      var x1, y1, x2, y2, dx, dy, sx, sy, err, t1, t2, i, e2;
      if (results == null)
        results = [];
      x1 = J.round$0$n(J.get$x$x(this.start));
      y1 = J.round$0$n(J.get$y$x(this.start));
      x2 = J.round$0$n(J.get$x$x(this.end));
      y2 = J.round$0$n(J.get$y$x(this.end));
      dx = C.JSInt_methods.abs$0(x2 - x1);
      dy = C.JSInt_methods.abs$0(y2 - y1);
      sx = x1 < x2 ? 1 : -1;
      sy = y1 < y2 ? 1 : -1;
      err = dx - dy;
      t1 = J.getInterceptor$ax(results);
      t1.add$1(results, [x1, y1]);
      t2 = -dy;
      i = 1;
      while (true) {
        if (!!(x1 === x2 && y1 === y2))
          break;
        e2 = err << 1 >>> 0;
        if (e2 > t2) {
          err -= dy;
          x1 += sx;
        }
        if (e2 < dx) {
          err += dx;
          y1 += sy;
        }
        if (typeof stepRate !== "number")
          return H.iae(stepRate);
        if (C.JSInt_methods.$mod(i, stepRate) === 0)
          t1.add$1(results, [x1, y1]);
        ++i;
      }
      return results;
    }, function(stepRate) {
      return this.coordinatesOnLine$2(stepRate, null);
    }, "coordinatesOnLine$1", function() {
      return this.coordinatesOnLine$2(1, null);
    }, "coordinatesOnLine$0", "call$2", "call$1", "call$0", "get$coordinatesOnLine", 0, 4, 1281, 433, 12, 1282, [], 1283, [], "coordinatesOnLine"],
    get$length: [function(_) {
      return Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start)), J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start))), J.$mul$ns(J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start)), J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start))))));
    }, null, null, 1, 0, 412, "length"],
    get$angle: [function(_) {
      var t1, t2;
      t1 = J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start));
      t2 = J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start));
      return Math.atan2(H.checkNum(t1), H.checkNum(t2));
    }, null, null, 1, 0, 619, "angle"],
    angle$0: function($receiver) {
      return this.get$angle(this).call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.get$angle(this).call$2(arg0, arg1);
    },
    get$slope: [function() {
      return J.$div$n(J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start)), J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start)));
    }, null, null, 1, 0, 619, "slope"],
    get$perpSlope: [function() {
      return J.$negate$n(J.$div$n(J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start)), J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start))));
    }, null, null, 1, 0, 619, "perpSlope"],
    get$x: [function(_) {
      return P.min(J.get$x$x(this.start), J.get$x$x(this.end));
    }, null, null, 1, 0, 619, "x"],
    get$y: [function(_) {
      return P.min(J.get$y$x(this.start), J.get$y$x(this.end));
    }, null, null, 1, 0, 619, "y"],
    get$left: [function(_) {
      return P.min(J.get$x$x(this.start), J.get$x$x(this.end));
    }, null, null, 1, 0, 619, "left"],
    get$right: [function(_) {
      return P.max(J.get$x$x(this.start), J.get$x$x(this.end));
    }, null, null, 1, 0, 619, "right"],
    get$bottom: [function(_) {
      return P.max(J.get$y$x(this.start), J.get$y$x(this.end));
    }, null, null, 1, 0, 619, "bottom"],
    get$width: [function(_) {
      return J.abs$0$n(J.$sub$n(J.get$x$x(this.start), J.get$x$x(this.end)));
    }, null, null, 1, 0, 619, "width"],
    get$height: [function(_) {
      return J.abs$0$n(J.$sub$n(J.get$y$x(this.start), J.get$y$x(this.end)));
    }, null, null, 1, 0, 619, "height"],
    $isLine: true,
    static: {Line$: [function(x1, y1, x2, y2) {
        var t1, t2;
        t1 = new R.Line(x1, x2, y1, y2, null, null);
        t2 = new R.Point(null, null);
        t2.x = x1;
        t2.y = y1;
        t1.start = t2;
        t2 = new R.Point(null, null);
        t2.x = x2;
        t2.y = y2;
        t1.end = t2;
        return t1;
      }, null, null, 0, 8, 51, 49, 49, 49, 49, 351, [], 352, [], 353, [], 354, [], "new Line"], Line_intersectsPoints: [function(a, b, e, f, asSegment, result) {
        var t1, t2, a1, t3, t4, a2, b1, b2, c1, c2, t5, t6, denom, t7, uc, ua, ub;
        if (result == null) {
          result = new R.Point(null, null);
          result.x = 0;
          result.y = 0;
        }
        t1 = J.getInterceptor$x(b);
        t2 = J.getInterceptor$x(a);
        a1 = J.$sub$n(t1.get$y(b), t2.get$y(a));
        t3 = J.getInterceptor$x(f);
        t4 = J.getInterceptor$x(e);
        a2 = J.$sub$n(t3.get$y(f), t4.get$y(e));
        b1 = J.$sub$n(t2.get$x(a), t1.get$x(b));
        b2 = J.$sub$n(t4.get$x(e), t3.get$x(f));
        c1 = J.$sub$n(J.$mul$ns(t1.get$x(b), t2.get$y(a)), J.$mul$ns(t2.get$x(a), t1.get$y(b)));
        c2 = J.$sub$n(J.$mul$ns(t3.get$x(f), t4.get$y(e)), J.$mul$ns(t4.get$x(e), t3.get$y(f)));
        t5 = J.getInterceptor$ns(a1);
        t6 = J.getInterceptor$ns(a2);
        denom = J.$sub$n(t5.$mul(a1, b2), t6.$mul(a2, b1));
        if (J.$eq(denom, 0))
          return;
        t7 = J.getInterceptor$x(result);
        t7.set$x(result, J.$div$n(J.$sub$n(J.$mul$ns(b1, c2), J.$mul$ns(b2, c1)), denom));
        t7.set$y(result, J.$div$n(J.$sub$n(t6.$mul(a2, c1), t5.$mul(a1, c2)), denom));
        if (asSegment === true) {
          uc = J.$sub$n(J.$mul$ns(J.$sub$n(t3.get$y(f), t4.get$y(e)), J.$sub$n(t1.get$x(b), t2.get$x(a))), J.$mul$ns(J.$sub$n(t3.get$x(f), t4.get$x(e)), J.$sub$n(t1.get$y(b), t2.get$y(a))));
          ua = J.$div$n(J.$sub$n(J.$mul$ns(J.$sub$n(t3.get$x(f), t4.get$x(e)), J.$sub$n(t2.get$y(a), t4.get$y(e))), J.$mul$ns(J.$sub$n(t3.get$y(f), t4.get$y(e)), J.$sub$n(t2.get$x(a), t4.get$x(e)))), uc);
          ub = J.$div$n(J.$sub$n(J.$mul$ns(J.$sub$n(t1.get$x(b), t2.get$x(a)), J.$sub$n(t2.get$y(a), t4.get$y(e))), J.$mul$ns(J.$sub$n(t1.get$y(b), t2.get$y(a)), J.$sub$n(t2.get$x(a), t4.get$x(e)))), uc);
          t1 = J.getInterceptor$n(ua);
          if (t1.$ge(ua, 0))
            if (t1.$le(ua, 1)) {
              t1 = J.getInterceptor$n(ub);
              t1 = t1.$ge(ub, 0) && t1.$le(ub, 1);
            } else
              t1 = false;
          else
            t1 = false;
          if (t1)
            return result;
          else
            return;
        }
        return result;
      }, function(a, b, e, f) {
        return R.Line_intersectsPoints(a, b, e, f, true, null);
      }, null, function(a, b, e, f, asSegment) {
        return R.Line_intersectsPoints(a, b, e, f, asSegment, null);
      }, null, "call$6", "call$4", "call$5", "Line_intersectsPoints$closure", 8, 4, 355, 78, 12, 348, [], 349, [], 356, [], 357, [], 358, [], 359, [], "intersectsPoints"]}
  },
  "+Line": [674],
  Point: {
    "^": "Point0;x-616,y-616",
    copyFrom$1: [function(source) {
      var t1 = J.getInterceptor$x(source);
      return this.setTo$2(t1.get$x(source), t1.get$y(source));
    }, "call$1", "get$copyFrom", 2, 0, 1284, 208, [], "copyFrom"],
    invert$0: [function() {
      return this.setTo$2(this.get$y(this), this.get$x(this));
    }, "call$0", "get$invert", 0, 0, 1010, "invert"],
    setTo$2: [function(x, y) {
      this.set$x(0, x);
      this.set$y(0, y == null ? this.get$x(this) : y);
      return this;
    }, function(x) {
      return this.setTo$2(x, null);
    }, "setTo$1", function() {
      return this.setTo$2(0, null);
    }, "setTo$0", "call$2", "call$1", "call$0", "get$setTo", 0, 4, 1285, 49, 12, 9, [], 10, [], "setTo"],
    set$2: [function(x, y) {
      this.set$x(0, x);
      this.set$y(0, y == null ? this.get$x(this) : y);
      return this;
    }, function(x) {
      return this.set$2(x, null);
    }, "set$1", function() {
      return this.set$2(0, null);
    }, "set$0", "call$2", "call$1", "call$0", "get$set", 0, 4, 1285, 49, 12, 9, [], 10, [], "set"],
    add$2: [function(_, x, y) {
      this.set$x(0, J.$add$ns(this.get$x(this), x));
      this.set$y(0, J.$add$ns(this.get$y(this), y));
      return this;
    }, "call$2", "get$add", 4, 0, 1286, 9, [], 10, [], "add"],
    subtract$2: [function(x, y) {
      this.set$x(0, J.$sub$n(this.get$x(this), x));
      this.set$y(0, J.$sub$n(this.get$y(this), y));
      return this;
    }, "call$2", "get$subtract", 4, 0, 1286, 9, [], 10, [], "subtract"],
    multiply$2: [function(x, y) {
      this.set$x(0, J.$mul$ns(this.get$x(this), x));
      this.set$y(0, J.$mul$ns(this.get$y(this), y));
      return this;
    }, "call$2", "get$multiply", 4, 0, 1286, 9, [], 10, [], "multiply"],
    divide$2: [function(x, y) {
      this.set$x(0, J.$div$n(this.get$x(this), x));
      this.set$y(0, J.$div$n(this.get$y(this), y));
      return this;
    }, "call$2", "get$divide", 4, 0, 1286, 9, [], 10, [], "divide"],
    clampX$2: [function(min, max) {
      var t1, t2;
      t1 = this.get$x(this);
      t2 = J.getInterceptor$n(t1);
      if (t2.$lt(t1, min))
        t1 = min;
      else if (t2.$gt(t1, max))
        t1 = max;
      this.set$x(0, t1);
      return this;
    }, "call$2", "get$clampX", 4, 0, 1286, 409, [], 410, [], "clampX"],
    clampY$2: [function(min, max) {
      var t1, t2;
      t1 = this.get$y(this);
      t2 = J.getInterceptor$n(t1);
      if (t2.$lt(t1, min))
        t1 = min;
      else if (t2.$gt(t1, max))
        t1 = max;
      this.set$y(0, t1);
      return this;
    }, "call$2", "get$clampY", 4, 0, 1286, 409, [], 410, [], "clampY"],
    clamp$2: [function(_, min, max) {
      var t1, t2;
      t1 = this.get$x(this);
      t2 = J.getInterceptor$n(t1);
      if (t2.$lt(t1, min))
        t1 = min;
      else if (t2.$gt(t1, max))
        t1 = max;
      this.set$x(0, t1);
      t1 = this.get$y(this);
      t2 = J.getInterceptor$n(t1);
      if (t2.$lt(t1, min))
        t1 = min;
      else if (t2.$gt(t1, max))
        t1 = max;
      this.set$y(0, t1);
      return this;
    }, "call$2", "get$clamp", 4, 0, 1286, 409, [], 410, [], "clamp"],
    clone$1: [function(_, output) {
      var t1, t2;
      if (output == null) {
        t1 = this.get$x(this);
        t2 = this.get$y(this);
        output = new R.Point(null, null);
        output.x = t1;
        output.y = t2;
      } else
        output.setTo$2(this.get$x(this), this.get$y(this));
      return output;
    }, function($receiver) {
      return this.clone$1($receiver, null);
    }, "clone$0", "call$1", "call$0", "get$clone", 0, 2, 1287, 12, 999, [], "clone"],
    copyTo$1: [function(dest) {
      var t1 = J.getInterceptor$x(dest);
      t1.set$x(dest, this.get$x(this));
      t1.set$y(dest, this.get$y(this));
      return dest;
    }, "call$1", "get$copyTo", 2, 0, 102, 1259, [], "copyTo"],
    distance$2: [function(b, round) {
      var t1 = J.getInterceptor$x(b);
      if (round === true)
        return C.JSNumber_methods.toInt$0(C.JSDouble_methods.roundToDouble$0(R.Math_distance(this.get$x(this), this.get$y(this), t1.get$x(b), t1.get$y(b))));
      else
        return R.Math_distance(this.get$x(this), this.get$y(this), t1.get$x(b), t1.get$y(b));
    }, function(b) {
      return this.distance$2(b, false);
    }, "distance$1", "call$2", "call$1", "get$distance", 2, 2, 1288, 19, 349, [], 1260, [], "distance"],
    equals$1: [function(a) {
      var t1 = J.getInterceptor$x(a);
      return J.$eq(t1.get$x(a), this.get$x(this)) && J.$eq(t1.get$y(a), this.get$y(this));
    }, "call$1", "get$equals", 2, 0, 1289, 348, [], "equals"],
    angle$2: [function(_, a, asDegrees) {
      var t1, t2;
      t1 = J.getInterceptor$x(a);
      if (asDegrees === true) {
        t2 = J.$sub$n(t1.get$y(a), this.get$y(this));
        t1 = J.$sub$n(t1.get$x(a), this.get$x(this));
        return Math.atan2(H.checkNum(t2), H.checkNum(t1)) * 57.29577951308232;
      } else {
        t2 = J.$sub$n(t1.get$y(a), this.get$y(this));
        t1 = J.$sub$n(t1.get$x(a), this.get$x(this));
        return Math.atan2(H.checkNum(t2), H.checkNum(t1));
      }
    }, function($receiver, a) {
      return this.angle$2($receiver, a, false);
    }, "angle$1", "call$2", "call$1", "get$angle", 2, 2, 1290, 19, 348, [], 1263, [], "angle"],
    angleSq$1: [function(a) {
      return this.$sub(0, a).angle$1(0, J.$sub$n(a, this));
    }, "call$1", "get$angleSq", 2, 0, 1291, 348, [], "angleSq"],
    rotate$5: [function(_, x, y, angle, asDegrees, distance) {
      var t1, t2, requiredAngle;
      if (asDegrees === true)
        angle = J.$mul$ns(angle, 0.017453292519943295);
      if (distance == null)
        distance = R.Math_distance(x, y, this.get$x(this), this.get$y(this));
      t1 = J.$sub$n(this.get$y(this), y);
      t2 = J.$sub$n(this.get$x(this), x);
      requiredAngle = J.$add$ns(angle, Math.atan2(H.checkNum(t1), H.checkNum(t2)));
      t2 = J.getInterceptor$ns(distance);
      return this.setTo$2(J.$add$ns(x, t2.$mul(distance, Math.cos(H.checkNum(requiredAngle)))), J.$add$ns(y, t2.$mul(distance, Math.sin(H.checkNum(requiredAngle)))));
    }, function($receiver, x, y, angle) {
      return this.rotate$5($receiver, x, y, angle, false, null);
    }, "rotate$3", function($receiver, x, y, angle, asDegrees) {
      return this.rotate$5($receiver, x, y, angle, asDegrees, null);
    }, "rotate$4", "call$5", "call$3", "call$4", "get$rotate", 6, 4, 1292, 19, 12, 9, [], 10, [], 7, [], 1263, [], 1293, [], "rotate"],
    getMagnitude$0: [function() {
      return Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(this.get$x(this), this.get$x(this)), J.$mul$ns(this.get$y(this), this.get$y(this)))));
    }, "call$0", "get$getMagnitude", 0, 0, 619, "getMagnitude"],
    getMagnitudeSq$0: [function() {
      return J.$add$ns(J.$mul$ns(this.get$x(this), this.get$x(this)), J.$mul$ns(this.get$y(this), this.get$y(this)));
    }, "call$0", "get$getMagnitudeSq", 0, 0, 619, "getMagnitudeSq"],
    setMagnitude$1: [function(magnitude) {
      var m;
      if (!(J.$eq(this.get$x(this), 0) && J.$eq(this.get$y(this), 0))) {
        m = Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(this.get$x(this), this.get$x(this)), J.$mul$ns(this.get$y(this), this.get$y(this)))));
        this.set$x(0, J.$div$n(this.get$x(this), m));
        this.set$y(0, J.$div$n(this.get$y(this), m));
      }
      this.set$x(0, J.$mul$ns(this.get$x(this), magnitude));
      this.set$y(0, J.$mul$ns(this.get$y(this), magnitude));
      return this;
    }, "call$1", "get$setMagnitude", 2, 0, 1294, 1295, [], "setMagnitude"],
    normalize$0: [function() {
      if (!(J.$eq(this.get$x(this), 0) && J.$eq(this.get$y(this), 0))) {
        var m = Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(this.get$x(this), this.get$x(this)), J.$mul$ns(this.get$y(this), this.get$y(this)))));
        this.set$x(0, J.$div$n(this.get$x(this), m));
        this.set$y(0, J.$div$n(this.get$y(this), m));
      }
      return this;
    }, "call$0", "get$normalize", 0, 0, 1010, "normalize"],
    isZero$0: [function() {
      return J.$eq(this.get$x(this), 0) && J.$eq(this.get$y(this), 0);
    }, "call$0", "get$isZero", 0, 0, 247, "isZero"],
    dot$1: [function(a) {
      var t1 = J.getInterceptor$x(a);
      return J.$add$ns(J.$mul$ns(this.get$x(this), t1.get$x(a)), J.$mul$ns(this.get$y(this), t1.get$y(a)));
    }, "call$1", "get$dot", 2, 0, 1291, 348, [], "dot"],
    cross$1: [function(a) {
      var t1 = J.getInterceptor$x(a);
      return J.$sub$n(J.$mul$ns(this.get$x(this), t1.get$y(a)), J.$mul$ns(this.get$y(this), t1.get$x(a)));
    }, "call$1", "get$cross", 2, 0, 1291, 348, [], "cross"],
    perp$0: [function() {
      return this.setTo$2(J.$negate$n(this.get$y(this)), this.get$x(this));
    }, "call$0", "get$perp", 0, 0, 1010, "perp"],
    rperp$0: [function() {
      return this.setTo$2(this.get$y(this), J.$negate$n(this.get$x(this)));
    }, "call$0", "get$rperp", 0, 0, 1010, "rperp"],
    normalRightHand$0: [function() {
      return this.setTo$2(J.$mul$ns(this.get$y(this), -1), this.get$x(this));
    }, "call$0", "get$normalRightHand", 0, 0, 1010, "normalRightHand"],
    toString$0: [function(_) {
      return "[{Point (x=" + H.S(this.get$x(this)) + " y=" + H.S(this.get$y(this)) + ")}]";
    }, "call$0", "get$toString", 0, 0, 810, "toString"],
    $add: [function(_, b) {
      var out, t1;
      out = new R.Point(null, null);
      out.x = 0;
      out.y = 0;
      t1 = J.getInterceptor(b);
      if (!!t1.$isPoint) {
        out.x = J.$add$ns(this.get$x(this), t1.get$x(b));
        out.y = J.$add$ns(this.get$y(this), t1.get$y(b));
      } else {
        out.x = J.$add$ns(this.get$x(this), b);
        out.y = J.$add$ns(this.get$y(this), b);
      }
      return out;
    }, "call$1", "get$+", 2, 0, 1284, 349, [], "+"],
    $sub: [function(_, b) {
      var out, t1;
      out = new R.Point(null, null);
      out.x = 0;
      out.y = 0;
      t1 = J.getInterceptor(b);
      if (!!t1.$isPoint) {
        out.x = J.$sub$n(this.get$x(this), t1.get$x(b));
        out.y = J.$sub$n(this.get$y(this), t1.get$y(b));
      } else {
        out.x = J.$sub$n(this.get$x(this), b);
        out.y = J.$sub$n(this.get$y(this), b);
      }
      return out;
    }, "call$1", "get$-", 2, 0, 1284, 349, [], "-"],
    $mul: [function(_, b) {
      var out, t1;
      out = new R.Point(null, null);
      out.x = 0;
      out.y = 0;
      t1 = J.getInterceptor(b);
      if (!!t1.$isPoint) {
        out.x = J.$mul$ns(this.get$x(this), t1.get$x(b));
        out.y = J.$mul$ns(this.get$y(this), t1.get$y(b));
      } else {
        out.x = J.$mul$ns(this.get$x(this), b);
        out.y = J.$mul$ns(this.get$y(this), b);
      }
      return out;
    }, "call$1", "get$*", 2, 0, 1284, 349, [], "*"],
    $div: [function(_, b) {
      var out, t1;
      out = new R.Point(null, null);
      out.x = 0;
      out.y = 0;
      t1 = J.getInterceptor(b);
      if (!!t1.$isPoint) {
        out.x = J.$div$n(this.get$x(this), t1.get$x(b));
        out.y = J.$div$n(this.get$y(this), t1.get$y(b));
      } else {
        out.x = J.$div$n(this.get$x(this), b);
        out.y = J.$div$n(this.get$y(this), b);
      }
      return out;
    }, "call$1", "get$/", 2, 0, 1284, 349, [], "/"],
    $eq: [function(_, b) {
      var t1;
      if (b == null)
        return false;
      t1 = J.getInterceptor$x(b);
      return J.$eq(this.get$x(this), t1.get$x(b)) && J.$eq(this.get$y(this), t1.get$y(b));
    }, "call$1", "get$==", 2, 0, 1289, 349, [], "=="],
    get$hashCode: [function(_) {
      var t1, t2;
      t1 = J.get$hashCode$(this.get$x(this));
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = J.get$hashCode$(this.get$y(this));
      if (typeof t2 !== "number")
        return H.iae(t2);
      return 37 * (629 + t1) + t2;
    }, null, null, 1, 0, 412, "hashCode"],
    multiplyAdd$4: [function(a, b, s, out) {
      var t1, t2;
      if (out == null) {
        out = new R.Point(null, null);
        out.x = 0;
        out.y = 0;
      }
      t1 = J.getInterceptor$x(a);
      t2 = J.getInterceptor$x(b);
      return out.setTo$2(J.$add$ns(t1.get$x(a), J.$mul$ns(t2.get$x(b), s)), J.$add$ns(t1.get$y(a), J.$mul$ns(t2.get$y(b), s)));
    }, function(a, b, s) {
      return this.multiplyAdd$4(a, b, s, null);
    }, "multiplyAdd$3", "call$4", "call$3", "get$multiplyAdd", 6, 2, 360, 12, 348, [], 349, [], 545, [], 361, [], "multiplyAdd"],
    parse$3: [function(obj, xProp, yProp) {
      var point, t1;
      point = new R.Point(null, null);
      point.x = 0;
      point.y = 0;
      t1 = J.getInterceptor$asx(obj);
      if (t1.$index(obj, xProp) === true)
        point.x = H.Primitives_parseInt(t1.$index(obj, xProp), null, null);
      if (t1.$index(obj, yProp) === true)
        point.y = H.Primitives_parseInt(t1.$index(obj, yProp), null, null);
      return point;
    }, function(obj) {
      return this.parse$3(obj, "x", "y");
    }, "parse$1", function(obj, xProp) {
      return this.parse$3(obj, xProp, "y");
    }, "parse$2", "call$3", "call$1", "call$2", "get$parse", 2, 4, 1296, 9, 10, 630, [], 1297, [], 1298, [], "parse"],
    $isPoint: true,
    static: {Point$0: [function(x, y) {
        var t1 = new R.Point(null, null);
        t1.x = x;
        t1.y = y;
        return t1;
      }, null, null, 0, 4, 56, 49, 49, 9, [], 10, [], "new Point"], Point_interpolate: [function(a, b, f, out) {
        var t1, t2;
        if (out == null) {
          out = new R.Point(null, null);
          out.x = 0;
          out.y = 0;
        }
        t1 = J.getInterceptor$x(a);
        t2 = J.getInterceptor$x(b);
        return out.setTo$2(J.$add$ns(t1.get$x(a), J.$mul$ns(J.$sub$n(t2.get$x(b), t1.get$x(a)), f)), J.$add$ns(t1.get$y(a), J.$mul$ns(J.$sub$n(t2.get$y(b), t1.get$y(a)), f)));
      }, function(a, b, f) {
        return R.Point_interpolate(a, b, f, null);
      }, null, "call$4", "call$3", "Point_interpolate$closure", 6, 2, 360, 12, 348, [], 349, [], 357, [], 361, [], "interpolate"], Point_project: [function(a, b, out) {
        var amt, t1, t2;
        if (out == null) {
          out = new R.Point(null, null);
          out.x = 0;
          out.y = 0;
        }
        amt = J.$div$n(a.dot$1(b), b.getMagnitudeSq$0());
        t1 = J.getInterceptor(amt);
        if (!t1.$eq(amt, 0)) {
          t2 = J.getInterceptor$x(b);
          out.setTo$2(t1.$mul(amt, t2.get$x(b)), t1.$mul(amt, t2.get$y(b)));
        }
        return out;
      }, function(a, b) {
        return R.Point_project(a, b, null);
      }, null, "call$3", "call$2", "Point_project$closure", 4, 2, 362, 12, 348, [], 349, [], 361, [], "project"], Point_projectUnit: [function(a, b, out) {
        var amt, t1, t2;
        if (out == null) {
          out = new R.Point(null, null);
          out.x = 0;
          out.y = 0;
        }
        amt = a.dot$1(b);
        t1 = J.getInterceptor(amt);
        if (!t1.$eq(amt, 0)) {
          t2 = J.getInterceptor$x(b);
          out.setTo$2(t1.$mul(amt, t2.get$x(b)), t1.$mul(amt, t2.get$y(b)));
        }
        return out;
      }, function(a, b) {
        return R.Point_projectUnit(a, b, null);
      }, null, "call$3", "call$2", "Point_projectUnit$closure", 4, 2, 362, 12, 348, [], 349, [], 361, [], "projectUnit"], Point_centroid: [function(points, out) {
        var t1, pointslength, t2, i;
        if (out == null) {
          out = new R.Point(null, null);
          out.x = 0;
          out.y = 0;
        }
        t1 = H.checkSubtype(points, "$isList", [R.Point], "$asList");
        if (!t1)
          throw H.wrapException(P.Exception_Exception("Phaser.Point. Parameter 'points' must be an array"));
        t1 = J.getInterceptor$asx(points);
        pointslength = t1.get$length(points);
        t2 = J.getInterceptor$n(pointslength);
        if (t2.$lt(pointslength, 1))
          throw H.wrapException(P.Exception_Exception("Phaser.Point. Parameter 'points' array must not be empty"));
        if (t2.$eq(pointslength, 1)) {
          out.copyFrom$1(t1.$index(points, 0));
          return out;
        }
        if (typeof pointslength !== "number")
          return H.iae(pointslength);
        t2 = J.getInterceptor$ax(out);
        i = 0;
        for (; i < pointslength; ++i)
          t2.add$2(out, J.get$x$x(t1.$index(points, i)), J.get$y$x(t1.$index(points, i)));
        out.divide$2(pointslength, pointslength);
        return out;
      }, function(points) {
        return R.Point_centroid(points, null);
      }, null, "call$2", "call$1", "Point_centroid$closure", 2, 2, 363, 12, 57, [], 361, [], "centroid"]}
  },
  "+Point": [652],
  Polygon0: {
    "^": "Object;_points@-1299,type*-614",
    get$points: [function(_) {
      return this._points;
    }, null, null, 1, 0, 1300, "points"],
    set$points: [function(_, points) {
      this._points = points;
    }, null, null, 3, 0, 364, 57, [], "points"],
    get$area: [function() {
      var i, y0, t1, area, p1, t2, p2;
      i = 0;
      y0 = 1 / 0;
      while (true) {
        t1 = J.get$length$asx(this._points);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$lt$n(J.get$y$x(J.$index$asx(this._points, i)), y0))
          y0 = J.get$y$x(J.$index$asx(this._points, i));
        ++i;
      }
      i = 0;
      area = 0;
      while (true) {
        t1 = J.get$length$asx(this._points);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        p1 = J.$index$asx(this._points, i);
        t1 = J.$sub$n(J.get$length$asx(this._points), 1);
        t2 = this._points;
        p2 = i === t1 ? J.$index$asx(t2, 0) : J.$index$asx(t2, i + 1);
        t1 = J.getInterceptor$x(p1);
        t2 = J.getInterceptor$x(p2);
        t2 = J.$mul$ns(J.$div$n(J.$add$ns(J.$sub$n(t1.get$y(p1), y0), J.$sub$n(t2.get$y(p2), y0)), 2), J.$sub$n(t1.get$x(p1), t2.get$x(p2)));
        if (typeof t2 !== "number")
          return H.iae(t2);
        area += t2;
        ++i;
      }
      return area;
    }, null, null, 1, 0, 619, "area"],
    clone$1: [function(_, output) {
      var points, i, t1;
      points = [];
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._points);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        points.push(J.clone$0$x(J.$index$asx(this._points, i)));
        ++i;
      }
      if (output == null) {
        output = new R.Polygon0(points, null);
        output.type = 12;
      } else
        output.setTo$1(points);
      return output;
    }, "call$1", "get$clone", 2, 0, 1301, 999, [], "clone"],
    setTo$1: [function(points) {
      this._points = points;
      return this;
    }, "call$1", "get$setTo", 2, 0, 364, 57, [], "setTo"],
    contains$2: [function(_, x, y) {
      var j, t1, t2, inside, i, t3, xi, yi, xj, yj, i0;
      j = J.$sub$n(J.get$length$asx(this._points), 1);
      t1 = J.getInterceptor$n(y);
      t2 = J.getInterceptor$n(x);
      inside = false;
      i = 0;
      while (true) {
        t3 = J.get$length$asx(this._points);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        xi = J.get$x$x(J.$index$asx(this._points, i));
        yi = J.get$y$x(J.$index$asx(this._points, i));
        xj = J.get$x$x(J.$index$asx(this._points, j));
        yj = J.get$y$x(J.$index$asx(this._points, j));
        t3 = J.getInterceptor$n(yj);
        if (J.$gt$n(yi, y) !== t3.$gt(yj, y) && t2.$lt(x, J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(xj, xi), t1.$sub(y, yi)), t3.$sub(yj, yi)), xi)))
          inside = !inside;
        i0 = i + 1;
        j = i;
        i = i0;
      }
      return inside;
    }, "call$2", "get$contains", 4, 0, 149, 9, [], 10, [], "contains"],
    static: {Polygon$0: [function(_points) {
        var t1 = new R.Polygon0(_points, null);
        t1.type = 12;
        return t1;
      }, null, null, 2, 0, 364, 365, [], "new Polygon"]}
  },
  "+Polygon": [674],
  Rectangle1: {
    "^": "Rectangle0;x:Phaser$Rectangle1$x*-616,y:Phaser$Rectangle1$y*-616,width:Phaser$Rectangle1$width*-616,height:Phaser$Rectangle1$height*-616,x-616,y-616,width-616,height-616",
    get$halfWidth: [function() {
      return J.round$0$n(J.$div$n(this.get$width(this), 2));
    }, null, null, 1, 0, 619, "halfWidth"],
    get$halfHeight: [function() {
      return J.round$0$n(J.$div$n(this.get$height(this), 2));
    }, null, null, 1, 0, 619, "halfHeight"],
    get$bottom: [function(_) {
      return J.$add$ns(this.get$y(this), this.get$height(this));
    }, null, null, 1, 0, 619, "bottom"],
    set$bottom: [function(_, value) {
      var t1 = J.getInterceptor$n(value);
      if (t1.$le(value, this.get$y(this)))
        this.set$height(0, 0);
      else
        this.set$height(0, t1.$sub(value, this.get$y(this)));
    }, null, null, 3, 0, 620, 138, [], "bottom"],
    get$bottomRight: [function(_) {
      var t1, t2, t3;
      t1 = this.get$right(this);
      t2 = this.get$bottom(this);
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1010, "bottomRight"],
    set$bottomRight: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      this.set$right(0, t1.get$x(value));
      this.set$bottom(0, t1.get$y(value));
    }, null, null, 3, 0, 1011, 138, [], "bottomRight"],
    get$left: [function(_) {
      return this.get$x(this);
    }, null, null, 1, 0, 619, "left"],
    set$left: [function(_, value) {
      if (J.$ge$n(value, this.get$right(this)))
        this.set$width(0, 0);
      else
        this.set$width(0, J.$sub$n(this.get$right(this), value));
      this.set$x(0, value);
    }, null, null, 3, 0, 620, 138, [], "left"],
    get$right: [function(_) {
      return J.$add$ns(this.get$x(this), this.get$width(this));
    }, null, null, 1, 0, 619, "right"],
    set$right: [function(_, value) {
      if (J.$le$n(value, this.get$x(this)))
        this.set$width(0, 0);
      else
        this.set$width(0, J.$add$ns(this.get$x(this), value));
    }, null, null, 3, 0, 620, 138, [], "right"],
    get$volume: [function(_) {
      return J.$mul$ns(this.get$width(this), this.get$height(this));
    }, null, null, 1, 0, 619, "volume"],
    get$perimeter: [function() {
      return J.$add$ns(J.$mul$ns(this.get$width(this), 2), J.$mul$ns(this.get$height(this), 2));
    }, null, null, 1, 0, 619, "perimeter"],
    get$centerX: [function() {
      return J.$add$ns(this.get$x(this), this.get$halfWidth());
    }, null, null, 1, 0, 619, "centerX"],
    set$centerX: [function(value) {
      this.set$x(0, J.$sub$n(value, this.get$halfWidth()));
    }, null, null, 3, 0, 620, 138, [], "centerX"],
    get$centerY: [function() {
      return J.$add$ns(this.get$y(this), this.get$halfHeight());
    }, null, null, 1, 0, 619, "centerY"],
    set$centerY: [function(value) {
      this.set$y(0, J.$sub$n(value, this.get$halfHeight()));
    }, null, null, 3, 0, 620, 138, [], "centerY"],
    get$top: [function(_) {
      return this.get$y(this);
    }, null, null, 1, 0, 619, "top"],
    set$top: [function(_, value) {
      if (J.$ge$n(value, this.get$bottom(this))) {
        this.set$height(0, 0);
        this.set$y(0, value);
      } else
        this.set$height(0, J.$sub$n(this.get$bottom(this), value));
    }, null, null, 3, 0, 620, 138, [], "top"],
    get$topLeft: [function(_) {
      var t1, t2, t3;
      t1 = this.get$x(this);
      t2 = this.get$y(this);
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1010, "topLeft"],
    set$topLeft: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      this.set$x(0, t1.get$x(value));
      this.set$y(0, t1.get$y(value));
    }, null, null, 3, 0, 1011, 138, [], "topLeft"],
    get$empty: [function() {
      return J.$eq(this.get$width(this), 0) || J.$eq(this.get$height(this), 0);
    }, null, null, 1, 0, 247, "empty"],
    set$empty: [function(value) {
      if (J.$eq(value, true))
        this.setTo$4(0, 0, 0, 0);
    }, null, null, 3, 0, 639, 138, [], "empty"],
    get$topRight: [function(_) {
      var t1, t2, t3;
      t1 = J.$add$ns(this.get$x(this), this.get$width(this));
      t2 = this.get$y(this);
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1010, "topRight"],
    set$topRight: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      this.set$right(0, t1.get$x(value));
      this.set$y(0, t1.get$y(value));
    }, null, null, 3, 0, 102, 138, [], "topRight"],
    get$bottomLeft: [function(_) {
      var t1, t2, t3;
      t1 = this.get$x(this);
      t2 = J.$add$ns(this.get$y(this), this.get$height(this));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1010, "bottomLeft"],
    set$bottomLeft: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      this.set$x(0, t1.get$x(value));
      this.set$bottom(0, t1.get$y(value));
    }, null, null, 3, 0, 1011, 138, [], "bottomLeft"],
    offsetRect$2: [function(dx, dy) {
      this.set$x(0, J.$add$ns(this.get$x(this), dx));
      this.set$y(0, J.$add$ns(this.get$y(this), dy));
      return this;
    }, "call$2", "get$offsetRect", 4, 0, 1302, 1265, [], 1266, [], "offsetRect"],
    offsetPoint$1: [function(point) {
      var t1, t2;
      t1 = J.getInterceptor$x(point);
      t2 = t1.get$x(point);
      t1 = t1.get$y(point);
      this.set$x(0, J.$add$ns(this.get$x(this), t2));
      this.set$y(0, J.$add$ns(this.get$y(this), t1));
      return this;
    }, "call$1", "get$offsetPoint", 2, 0, 1303, 475, [], "offsetPoint"],
    setTo$4: [function(x, y, width, height) {
      this.set$x(0, x);
      this.set$y(0, y);
      this.set$width(0, width);
      this.set$height(0, height);
      return this;
    }, "call$4", "get$setTo", 8, 0, 1304, 9, [], 10, [], 31, [], 52, [], "setTo"],
    floor$0: [function(_) {
      this.set$x(0, J.floor$0$n(this.get$x(this)));
      this.set$y(0, J.floor$0$n(this.get$y(this)));
    }, "call$0", "get$floor", 0, 0, 54, "floor"],
    floorAll$0: [function() {
      this.set$x(0, J.floor$0$n(this.get$x(this)));
      this.set$y(0, J.floor$0$n(this.get$y(this)));
      this.set$width(0, J.floor$0$n(this.get$width(this)));
      this.set$height(0, J.floor$0$n(this.get$height(this)));
    }, "call$0", "get$floorAll", 0, 0, 54, "floorAll"],
    copyFrom$1: [function(source) {
      var t1 = J.getInterceptor$x(source);
      return this.setTo$4(t1.get$x(source), t1.get$y(source), t1.get$width(source), t1.get$height(source));
    }, "call$1", "get$copyFrom", 2, 0, 366, 208, [], "copyFrom"],
    copyTo$1: [function(dest) {
      var t1 = J.getInterceptor$x(dest);
      t1.set$x(dest, this.get$x(this));
      t1.set$y(dest, this.get$y(this));
      t1.set$width(dest, this.get$width(this));
      t1.set$height(dest, this.get$height(this));
      return dest;
    }, "call$1", "get$copyTo", 2, 0, 1305, 1259, [], "copyTo"],
    inflate$2: [function(dx, dy) {
      var t1;
      this.set$x(0, J.$sub$n(this.get$x(this), dx));
      t1 = this.get$width(this);
      if (typeof dx !== "number")
        return H.iae(dx);
      this.set$width(0, J.$add$ns(t1, 2 * dx));
      this.set$y(0, J.$sub$n(this.get$y(this), dy));
      t1 = this.get$height(this);
      if (typeof dy !== "number")
        return H.iae(dy);
      this.set$height(0, J.$add$ns(t1, 2 * dy));
      return this;
    }, "call$2", "get$inflate", 4, 0, 1302, 1265, [], 1266, [], "inflate"],
    size$1: [function(_, output) {
      var t1, t2;
      if (output == null) {
        t1 = this.get$width(this);
        t2 = this.get$height(this);
        output = new R.Point(null, null);
        output.x = t1;
        output.y = t2;
      } else
        output.setTo$2(this.get$width(this), this.get$height(this));
      return output;
    }, function($receiver) {
      return this.size$1($receiver, null);
    }, "size$0", "call$1", "call$0", "get$size", 0, 2, 1287, 12, 999, [], "size"],
    clone$1: [function(_, output) {
      if (output == null)
        output = new R.Rectangle1(this.get$x(this), this.get$y(this), this.get$width(this), this.get$height(this), 0, 0, 0, 0);
      else
        output.setTo$4(this.get$x(this), this.get$y(this), this.get$width(this), this.get$height(this));
      return output;
    }, function($receiver) {
      return this.clone$1($receiver, null);
    }, "clone$0", "call$1", "call$0", "get$clone", 0, 2, 997, 12, 999, [], "clone"],
    contains$2: [function(_, x, y) {
      var t1;
      if (J.$le$n(this.get$width(this), 0) || J.$le$n(this.get$height(this), 0))
        return false;
      t1 = J.getInterceptor$n(x);
      if (t1.$ge(x, this.get$x(this)))
        if (t1.$le(x, this.get$right(this))) {
          t1 = J.getInterceptor$n(y);
          t1 = t1.$ge(y, this.get$y(this)) && t1.$le(y, this.get$bottom(this));
        } else
          t1 = false;
      else
        t1 = false;
      return t1;
    }, "call$2", "get$contains", 4, 0, 600, 9, [], 10, [], "contains"],
    centerOn$2: [function(x, y) {
      this.set$centerX(x);
      this.set$centerY(y);
      return this;
    }, "call$2", "get$centerOn", 4, 0, 149, 9, [], 10, [], "centerOn"],
    containsRect$1: [function(b) {
      var t1 = J.getInterceptor$x(b);
      if (J.$gt$n(J.$mul$ns(this.get$width(this), this.get$height(this)), t1.get$volume(b)))
        return false;
      return J.$ge$n(this.get$x(this), t1.get$x(b)) && J.$ge$n(this.get$y(this), t1.get$y(b)) && J.$le$n(this.get$right(this), t1.get$right(b)) && J.$le$n(this.get$bottom(this), t1.get$bottom(b));
    }, "call$1", "get$containsRect", 2, 0, 1306, 349, [], "containsRect"],
    equals$1: [function(b) {
      var t1 = J.getInterceptor$x(b);
      return J.$eq(this.get$x(this), t1.get$x(b)) && J.$eq(this.get$y(this), t1.get$y(b)) && J.$eq(this.get$width(this), t1.get$width(b)) && J.$eq(this.get$height(this), t1.get$height(b));
    }, "call$1", "get$equals", 2, 0, 1306, 349, [], "equals"],
    intersection$2: [function(_, b, output) {
      var t1, t2, t3, t4;
      if (output == null)
        output = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      if (this.intersects$1(0, b)) {
        t1 = J.getInterceptor$x(b);
        t2 = J.getInterceptor$x(output);
        t2.set$x(output, P.max(this.get$x(this), t1.get$x(b)));
        t2.set$y(output, P.max(this.get$y(this), t1.get$y(b)));
        t3 = P.min(this.get$right(this), t1.get$right(b));
        t4 = t2.get$x(output);
        if (typeof t4 !== "number")
          return H.iae(t4);
        t2.set$width(output, t3 - t4);
        t1 = P.min(this.get$bottom(this), t1.get$bottom(b));
        t4 = t2.get$y(output);
        if (typeof t4 !== "number")
          return H.iae(t4);
        t2.set$height(output, t1 - t4);
      }
      return output;
    }, function($receiver, b) {
      return this.intersection$2($receiver, b, null);
    }, "intersection$1", "call$2", "call$1", "get$intersection", 2, 2, 1307, 12, 349, [], 999, [], "intersection"],
    intersects$2: [function(_, b, tolerance) {
      var t1;
      if (!J.$le$n(this.get$width(this), 0))
        if (!J.$le$n(this.get$height(this), 0)) {
          t1 = J.getInterceptor$x(b);
          t1 = J.$le$n(t1.get$width(b), 0) || J.$le$n(t1.get$height(b), 0);
        } else
          t1 = true;
      else
        t1 = true;
      if (t1)
        return false;
      t1 = J.getInterceptor$x(b);
      return !(J.$lt$n(this.get$right(this), t1.get$x(b)) || J.$lt$n(this.get$bottom(this), t1.get$y(b)) || J.$gt$n(this.get$x(this), t1.get$right(b)) || J.$gt$n(this.get$y(this), t1.get$bottom(b)));
    }, function($receiver, b) {
      return this.intersects$2($receiver, b, 0);
    }, "intersects$1", "call$2", "call$1", "get$intersects", 2, 2, 1308, 49, 349, [], 444, [], "intersects"],
    intersectsRaw$5: [function(left, right, $top, bottom, tolerance) {
      var t1, t2;
      t1 = J.getInterceptor$ns(right);
      t2 = J.getInterceptor$n(left);
      if (!t2.$gt(left, t1.$add(right, tolerance)))
        if (!t1.$lt(right, t2.$sub(left, tolerance))) {
          t1 = J.getInterceptor$ns(bottom);
          t2 = J.getInterceptor$n($top);
          t1 = t2.$gt($top, t1.$add(bottom, tolerance)) || t1.$lt(bottom, t2.$sub($top, tolerance));
        } else
          t1 = true;
      else
        t1 = true;
      return !t1;
    }, function(left, right, top, bottom) {
      return this.intersectsRaw$5(left, right, top, bottom, 0);
    }, "intersectsRaw$4", "call$5", "call$4", "get$intersectsRaw", 8, 2, 1309, 49, 198, [], 462, [], 1310, [], 1311, [], 444, [], "intersectsRaw"],
    union$2: [function(b, output) {
      var t1;
      if (output == null)
        output = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      t1 = J.getInterceptor$x(b);
      return output.setTo$4(P.min(this.get$x(this), t1.get$x(b)), P.min(this.get$y(this), t1.get$y(b)), P.max(this.get$right(this), t1.get$right(b)) - P.min(this.get$x(this), t1.get$left(b)), P.max(this.get$bottom(this), t1.get$bottom(b)) - P.min(this.get$y(this), t1.get$top(b)));
    }, "call$2", "get$union", 4, 0, 1312, 349, [], 999, [], "union"],
    AABB$2: [function(points, out) {
      var t1, t2;
      t1 = {};
      if (out == null)
        out = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      t1.xMax_0 = 5e-324;
      t1.xMin_1 = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
      t1.yMax_2 = 5e-324;
      t1.yMin_3 = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
      J.forEach$1$ax(points, new R.Rectangle_AABB_closure(t1));
      t2 = t1.xMin_1;
      out.setTo$4(t2, t1.yMin_3, J.$sub$n(t1.xMax_0, t2), J.$sub$n(t1.yMax_2, t1.yMin_3));
      return out;
    }, "call$2", "get$AABB", 4, 0, 1313, 57, [], 361, [], "AABB"],
    $isRectangle1: true,
    static: {Rectangle$2: [function(x, y, width, height) {
        return new R.Rectangle1(x, y, width, height, 0, 0, 0, 0);
      }, null, null, 0, 8, 51, 49, 49, 49, 49, 9, [], 10, [], 31, [], 52, [], "new Rectangle"], Rectangle_Rectangle$fromRect: [function(source) {
        var t1 = J.getInterceptor$x(source);
        return new R.Rectangle1(t1.get$x(source), t1.get$y(source), t1.get$width(source), t1.get$height(source), 0, 0, 0, 0);
      }, "call$1", null, 2, 0, 366, 208, [], "new Rectangle$fromRect"]}
  },
  "+Rectangle": [659],
  Rectangle_AABB_closure: {
    "^": "Closure:1011;box_0",
    call$1: [function(point) {
      var t1, t2;
      t1 = J.getInterceptor$x(point);
      t2 = this.box_0;
      if (J.$gt$n(t1.get$x(point), t2.xMax_0))
        t2.xMax_0 = t1.get$x(point);
      if (J.$lt$n(t1.get$x(point), t2.xMin_1))
        t2.xMin_1 = t1.get$x(point);
      if (J.$gt$n(t1.get$y(point), t2.yMax_2))
        t2.yMax_2 = t1.get$y(point);
      if (J.$lt$n(t1.get$y(point), t2.yMin_3))
        t2.yMin_3 = t1.get$y(point);
    }, "call$1", null, 2, 0, 1011, 475, [], "call"]
  },
  Gamepad: {
    "^": "Object;",
    static: {Gamepad$: [function() {
        return new R.Gamepad();
      }, null, null, 0, 0, 54, "new Gamepad"]}
  },
  "+Gamepad": [674],
  GamepadButton: {
    "^": "Object;",
    static: {GamepadButton$: [function() {
        return new R.GamepadButton();
      }, null, null, 0, 0, 54, "new GamepadButton"]}
  },
  "+GamepadButton": [674],
  Input: {
    "^": "Object;game@-613,hitCanvas@-836,hitContext@-876,moveCallbacks@-645,moveCallback@-0,pollRate@-671,disabled*-617,multiInputOverride@-614,position*-615,speed@-615,circle@-1314,scale*-615,maxPointers@-614,currentPointers@-614,tapRate@-614,doubleTapRate@-614,holdRate@-614,justPressedRate@-614,justReleasedRate@-614,recordPointerHistory@-617,recordRate@-614,recordLimit@-614,pointers@-1315,activePointer@-1316,mousePointer@-1316,mouse@-1317,keyboard@-1318,touch@-1319,resetLocked@-617,onDown@-1320,onUp@-1320,onTap@-1320,onHold@-1320,minPriorityID@-614,interactiveItems@-1321,_localPoint@-615,_pollCounter@-614,_oldPosition@-615,_x@-616,_y@-616",
    circle$4: function(arg0, arg1, arg2, arg3) {
      return this.circle.call$4(arg0, arg1, arg2, arg3);
    },
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    get$x: [function(_) {
      return this._x;
    }, null, null, 1, 0, 619, "x"],
    set$x: [function(_, value) {
      this._x = J.floor$0$n(value);
    }, null, null, 3, 0, 620, 138, [], "x"],
    get$y: [function(_) {
      return this._y;
    }, null, null, 1, 0, 619, "y"],
    set$y: [function(_, value) {
      this._y = J.floor$0$n(value);
    }, null, null, 3, 0, 620, 138, [], "y"],
    get$pollLocked: [function() {
      return J.$gt$n(this.pollRate, 0) && J.$lt$n(this._pollCounter, this.pollRate);
    }, null, null, 1, 0, 247, "pollLocked"],
    get$totalInactivePointers: [function() {
      var t1 = this.currentPointers;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 10 - t1;
    }, null, null, 1, 0, 412, "totalInactivePointers"],
    get$totalActivePointers: [function() {
      this.currentPointers = 0;
      for (var i = 1; i <= 10; ++i)
        if (J.$index$asx(this.pointers, i) != null && J.$index$asx(this.pointers, i).get$active() === true)
          this.currentPointers = J.$add$ns(this.currentPointers, 1);
      return this.currentPointers;
    }, null, null, 1, 0, 412, "totalActivePointers"],
    get$worldX: [function() {
      return J.$add$ns(J.get$x$x(J.get$view$x(this.game.get$camera())), this._x);
    }, null, null, 1, 0, 619, "worldX"],
    get$worldY: [function() {
      return J.$add$ns(J.get$y$x(J.get$view$x(this.game.get$camera())), this._y);
    }, null, null, 1, 0, 619, "worldY"],
    boot$0: [function() {
      var t1, t2;
      this.mousePointer = R.Pointer$(this.game, 0);
      J.$indexSet$ax(this.pointers, 1, R.Pointer$(this.game, 1));
      J.$indexSet$ax(this.pointers, 2, R.Pointer$(this.game, 2));
      t1 = this.game;
      t2 = new R.Mouse(t1, null, null, null, null, null, null, false, -1, 0, false, false, false, null, null, null, null, null, null, null, null, null, null);
      t2.Mouse$1(t1);
      this.mouse = t2;
      t2 = this.game;
      t1 = new R.Keyboard(t2, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t1.Keyboard$1(t2);
      this.keyboard = t1;
      t1 = this.game;
      t2 = new R.Touch(t1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2.Touch$1(t1);
      this.touch = t2;
      this.onDown = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onUp = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onTap = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onHold = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      t2 = new R.Point(null, null);
      t2.x = 1;
      t2.y = 1;
      this.scale = t2;
      t2 = new R.Point(null, null);
      t2.x = 0;
      t2.y = 0;
      this.speed = t2;
      t2 = new R.Point(null, null);
      t2.x = 0;
      t2.y = 0;
      this.position = t2;
      t2 = new R.Point(null, null);
      t2.x = 0;
      t2.y = 0;
      this._oldPosition = t2;
      this.circle = R.Circle$(0, 0, 44);
      this.activePointer = this.mousePointer;
      this.currentPointers = 0;
      t2 = document.createElement("canvas", null);
      this.hitCanvas = t2;
      J.set$width$x(t2, 1);
      J.set$height$x(this.hitCanvas, 1);
      this.hitContext = J.getContext$1$x(this.hitCanvas, "2d");
      J.start$0$x(this.mouse);
      J.start$0$x(this.keyboard);
      J.start$0$x(this.touch);
      this.mousePointer.set$active(true);
    }, "call$0", "get$boot", 0, 0, 54, "boot"],
    destroy$0: [function() {
      J.stop$0$x(this.mouse);
      J.stop$0$x(this.keyboard);
      J.stop$0$x(this.touch);
      this.moveCallbacks = [];
      this.moveCallback = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    addMoveCallback$1: [function(callback) {
      J.add$1$ax(this.moveCallbacks, P.LinkedHashMap_LinkedHashMap$_literal(["callback", callback], null, null));
      return J.$sub$n(J.get$length$asx(this.moveCallbacks), 1);
    }, "call$1", "get$addMoveCallback", 2, 0, 1322, 26, [], "addMoveCallback"],
    deleteMoveCallback$1: [function(index) {
      if (J.$index$asx(this.moveCallbacks, index) === true)
        J.removeAt$1$ax(this.moveCallbacks, index);
    }, "call$1", "get$deleteMoveCallback", 2, 0, 99, 281, [], "deleteMoveCallback"],
    addPointer$0: [function() {
      var next, i;
      for (next = 0, i = 10; i > 0; --i)
        if (J.$index$asx(this.pointers, i) == null)
          next = i;
      if (next === 0) {
        window;
        if (typeof console != "undefined")
          console.warn("You can only have 10 Pointer objects");
        return;
      } else {
        J.$indexSet$ax(this.pointers, next, R.Pointer$(this.game, next));
        return J.$index$asx(this.pointers, next);
      }
    }, "call$0", "get$addPointer", 0, 0, 1323, "addPointer"],
    update$0: [function() {
      this.keyboard.update$0();
      if (J.$gt$n(this.pollRate, 0) && J.$lt$n(this._pollCounter, this.pollRate)) {
        this._pollCounter = J.$add$ns(this._pollCounter, 1);
        return;
      }
      J.set$x$x(this.speed, J.$sub$n(J.get$x$x(this.position), J.get$x$x(this._oldPosition)));
      J.set$y$x(this.speed, J.$sub$n(J.get$y$x(this.position), J.get$y$x(this._oldPosition)));
      this._oldPosition.copyFrom$1(this.position);
      this.mousePointer.update$0();
      J.$index$asx(this.pointers, 1).update$0();
      J.$index$asx(this.pointers, 2).update$0();
      if (J.$index$asx(this.pointers, 3) != null)
        J.$index$asx(this.pointers, 3).update$0();
      if (J.$index$asx(this.pointers, 4) != null)
        J.$index$asx(this.pointers, 4).update$0();
      if (J.$index$asx(this.pointers, 5) != null)
        J.$index$asx(this.pointers, 5).update$0();
      if (J.$index$asx(this.pointers, 6) != null)
        J.$index$asx(this.pointers, 6).update$0();
      if (J.$index$asx(this.pointers, 7) != null)
        J.$index$asx(this.pointers, 7).update$0();
      if (J.$index$asx(this.pointers, 8) != null)
        J.$index$asx(this.pointers, 8).update$0();
      if (J.$index$asx(this.pointers, 9) != null)
        J.$index$asx(this.pointers, 9).update$0();
      if (J.$index$asx(this.pointers, 10) != null)
        J.$index$asx(this.pointers, 10).update$0();
      this._pollCounter = 0;
    }, "call$0", "get$update", 0, 0, 54, "update"],
    reset$1: [function(_, hard) {
      var i;
      if (this.game.get$isBooted() !== true || this.resetLocked === true)
        return;
      J.reset$1$x(this.keyboard, hard);
      J.reset$0$x(this.mousePointer);
      for (i = 1; i <= 10; ++i)
        if (J.$index$asx(this.pointers, i) != null)
          J.reset$0$x(J.$index$asx(this.pointers, i));
      this.currentPointers = 0;
      if (!J.$eq(J.get$cursor$x(J.get$style$x(J.get$canvas$x(this.game))), "none"))
        J.set$cursor$x(J.get$style$x(J.get$canvas$x(this.game)), "inherit");
      if (hard === true) {
        this.onDown.dispose$0();
        this.onUp.dispose$0();
        this.onTap.dispose$0();
        this.onHold.dispose$0();
        this.onDown = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
        this.onUp = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
        this.onTap = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
        this.onHold = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
        this.moveCallbacks = [];
      }
      this._pollCounter = 0;
    }, function($receiver) {
      return this.reset$1($receiver, false);
    }, "reset$0", "call$1", "call$0", "get$reset", 0, 2, 956, 19, 1324, [], "reset"],
    resetSpeed$2: [function(x, y) {
      this._oldPosition.setTo$2(x, y);
      this.speed.setTo$2(0, 0);
    }, "call$2", "get$resetSpeed", 4, 0, 149, 9, [], 10, [], "resetSpeed"],
    startPointer$1: [function($event) {
      var i;
      if (J.$lt$n(this.maxPointers, 10) && J.$eq(this.get$totalActivePointers(), this.maxPointers))
        return;
      if (J.$eq(J.$index$asx(this.pointers, 1).get$active(), false))
        return J.start$1$x(J.$index$asx(this.pointers, 1), $event);
      else if (J.$eq(J.$index$asx(this.pointers, 2).get$active(), false))
        return J.start$1$x(J.$index$asx(this.pointers, 2), $event);
      else
        for (i = 3; i <= 10; ++i)
          if (J.$index$asx(this.pointers, i) != null && J.$eq(J.$index$asx(this.pointers, i).get$active(), false))
            return J.start$1$x(J.$index$asx(this.pointers, i), $event);
      return;
    }, "call$1", "get$startPointer", 2, 0, 1325, 666, [], "startPointer"],
    updatePointer$1: [function($event) {
      var t1, identifier, i;
      t1 = J.getInterceptor($event);
      identifier = !!t1.$isJsObject ? t1.$index($event, "identifier") : t1.get$identifier($event);
      if (J.$index$asx(this.pointers, 1).get$active() === true && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, 1)), identifier))
        return J.$index$asx(this.pointers, 1).move$1($event);
      else if (J.$index$asx(this.pointers, 2).get$active() === true && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, 2)), identifier))
        return J.$index$asx(this.pointers, 2).move$1($event);
      else
        for (i = 3; i <= 10; ++i)
          if (J.$index$asx(this.pointers, i) != null && J.$index$asx(this.pointers, i).get$active() === true && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, i)), identifier))
            return J.$index$asx(this.pointers, i).move$1($event);
      return;
    }, "call$1", "get$updatePointer", 2, 0, 1325, 666, [], "updatePointer"],
    stopPointer$1: [function($event) {
      var t1, identifier, i;
      t1 = J.getInterceptor($event);
      identifier = !!t1.$isJsObject ? t1.$index($event, "identifier") : t1.get$identifier($event);
      if (J.$index$asx(this.pointers, 1).get$active() === true && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, 1)), identifier))
        return J.stop$1$x(J.$index$asx(this.pointers, 1), $event);
      else if (J.$index$asx(this.pointers, 2).get$active() === true && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, 2)), identifier))
        return J.stop$1$x(J.$index$asx(this.pointers, 2), $event);
      else
        for (i = 3; i <= 10; ++i)
          if (J.$index$asx(this.pointers, i) != null && J.$index$asx(this.pointers, i).get$active() === true && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, i)), identifier))
            return J.stop$1$x(J.$index$asx(this.pointers, i), $event);
      return;
    }, "call$1", "get$stopPointer", 2, 0, 1325, 666, [], "stopPointer"],
    getPointer$1: [function(state) {
      var i;
      if (J.$eq(J.$index$asx(this.pointers, 1).get$active(), state))
        return J.$index$asx(this.pointers, 1);
      else if (J.$eq(J.$index$asx(this.pointers, 2).get$active(), state))
        return J.$index$asx(this.pointers, 2);
      else
        for (i = 3; i <= 10; ++i)
          if (J.$index$asx(this.pointers, i) != null && J.$eq(J.$index$asx(this.pointers, i).get$active(), state))
            return J.$index$asx(this.pointers, i);
      return;
    }, function() {
      return this.getPointer$1(false);
    }, "getPointer$0", "call$1", "call$0", "get$getPointer", 0, 2, 1326, 19, 294, [], "getPointer"],
    getPointerFromIdentifier$1: [function(identifier) {
      var i;
      if (J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, 1)), identifier))
        return J.$index$asx(this.pointers, 1);
      else if (J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, 2)), identifier))
        return J.$index$asx(this.pointers, 2);
      else
        for (i = 3; i <= 10; ++i)
          if (J.$index$asx(this.pointers, i) != null && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, i)), identifier))
            return J.$index$asx(this.pointers, i);
      return;
    }, "call$1", "get$getPointerFromIdentifier", 2, 0, 1327, 1328, [], "getPointerFromIdentifier"],
    getPointerFromId$1: [function(pointerId) {
      var i;
      if (J.$eq(J.$index$asx(this.pointers, 1).get$pointerId(), pointerId))
        return J.$index$asx(this.pointers, 1);
      else if (J.$eq(J.$index$asx(this.pointers, 2).get$pointerId(), pointerId))
        return J.$index$asx(this.pointers, 2);
      else
        for (i = 3; i <= 10; ++i)
          if (J.$index$asx(this.pointers, i) != null && J.$eq(J.$index$asx(this.pointers, i).get$pointerId(), pointerId))
            return J.$index$asx(this.pointers, i);
      return;
    }, "call$1", "get$getPointerFromId", 2, 0, 1327, 1329, [], "getPointerFromId"],
    getLocalPosition$3: [function(displayObject, pointer, output) {
      var wt, t1, t2, id;
      if (output == null) {
        output = new R.Point(null, null);
        output.x = 0;
        output.y = 0;
      }
      wt = displayObject.get$worldTransform();
      t1 = J.getInterceptor$x(wt);
      t2 = J.$add$ns(J.$mul$ns(t1.get$a(wt), wt.get$d()), J.$mul$ns(wt.get$b(), J.$negate$n(wt.get$c())));
      if (typeof t2 !== "number")
        return H.iae(t2);
      id = 1 / t2;
      t2 = J.getInterceptor$x(pointer);
      return output.setTo$2(J.$add$ns(J.$add$ns(J.$mul$ns(J.$mul$ns(wt.get$d(), id), t2.get$x(pointer)), J.$mul$ns(J.$mul$ns(J.$negate$n(wt.get$b()), id), t2.get$y(pointer))), J.$mul$ns(J.$sub$n(J.$mul$ns(wt.get$ty(), wt.get$b()), J.$mul$ns(wt.get$tx(), wt.get$d())), id)), J.$add$ns(J.$add$ns(J.$mul$ns(J.$mul$ns(t1.get$a(wt), id), t2.get$y(pointer)), J.$mul$ns(J.$mul$ns(J.$negate$n(wt.get$c()), id), t2.get$x(pointer))), J.$mul$ns(J.$add$ns(J.$mul$ns(J.$negate$n(wt.get$ty()), t1.get$a(wt)), J.$mul$ns(wt.get$tx(), wt.get$c())), id)));
    }, "call$3", "get$getLocalPosition", 6, 0, 1330, 833, [], 1021, [], 999, [], "getLocalPosition"],
    hitTest$3: [function(displayObject, pointer, localPoint) {
      var t1, width, height, x1, y1, len, i;
      if (!displayObject.get$worldVisible())
        return false;
      this.getLocalPosition$3(displayObject, pointer, this._localPoint);
      localPoint.copyFrom$1(this._localPoint);
      if (displayObject.get$hitArea() != null) {
        if (J.contains$2$asx(displayObject.get$hitArea(), J.get$x$x(this._localPoint), J.get$y$x(this._localPoint)))
          return true;
        return false;
      } else {
        t1 = J.getInterceptor(displayObject);
        if (!!t1.$isTileSprite) {
          width = displayObject.PIXI$TilingSprite$_PIXI$_width;
          height = displayObject.PIXI$TilingSprite$_PIXI$_height;
          x1 = J.$mul$ns(J.$negate$n(width), J.get$x$x(displayObject.anchor));
          if (J.$gt$n(J.get$x$x(this._localPoint), x1) && J.$lt$n(J.get$x$x(this._localPoint), J.$add$ns(x1, width))) {
            y1 = J.$mul$ns(J.$negate$n(height), J.get$y$x(displayObject.anchor));
            if (J.$gt$n(J.get$y$x(this._localPoint), y1) && J.$lt$n(J.get$y$x(this._localPoint), J.$add$ns(y1, height)))
              return true;
          }
        } else if (!!t1.$isSpriteInterface) {
          width = J.get$width$x(displayObject.get$texture().get$frame());
          height = J.get$height$x(displayObject.get$texture().get$frame());
          x1 = J.$mul$ns(J.$negate$n(width), J.get$x$x(displayObject.get$anchor()));
          if (J.$gt$n(J.get$x$x(this._localPoint), x1) && J.$lt$n(J.get$x$x(this._localPoint), J.$add$ns(x1, width))) {
            y1 = J.$mul$ns(J.$negate$n(height), J.get$y$x(displayObject.get$anchor()));
            if (J.$gt$n(J.get$y$x(this._localPoint), y1) && J.$lt$n(J.get$y$x(this._localPoint), J.$add$ns(y1, height)))
              return true;
          }
        }
      }
      len = J.get$length$asx(t1.get$children(displayObject));
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        if (this.hitTest$3(J.$index$asx(t1.get$children(displayObject), i), pointer, localPoint))
          return true;
      return false;
    }, "call$3", "get$hitTest", 6, 0, 1331, 833, [], 1021, [], 1332, [], "hitTest"],
    Input$1: function(game) {
      var t1;
      this.hitCanvas = null;
      this.hitContext = null;
      this.moveCallbacks = [];
      this.moveCallback = null;
      this.pollRate = 0;
      this.disabled = false;
      this.multiInputOverride = 2;
      this.position = null;
      this.speed = null;
      this.circle = null;
      this.scale = null;
      this.maxPointers = 10;
      this.currentPointers = 0;
      this.tapRate = 200;
      this.doubleTapRate = 300;
      this.holdRate = 2000;
      this.justPressedRate = 200;
      this.justReleasedRate = 200;
      this.recordPointerHistory = false;
      this.recordRate = 100;
      this.recordLimit = 100;
      this.activePointer = null;
      this.mousePointer = null;
      this.mouse = null;
      this.keyboard = null;
      this.touch = null;
      this.resetLocked = false;
      this.onDown = null;
      this.onUp = null;
      this.onTap = null;
      this.onHold = null;
      this.minPriorityID = 0;
      this.interactiveItems = [];
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this._localPoint = t1;
      this._pollCounter = 0;
      this._oldPosition = null;
      this._x = 0;
      this._y = 0;
    },
    static: {"^": "Input_MOUSE_OVERRIDES_TOUCH<-614,Input_TOUCH_OVERRIDES_MOUSE<-614,Input_MOUSE_TOUCH_COMBINE<-614", Input$: [function(game) {
        var t1 = Array(11);
        t1.fixed$length = init;
        t1 = new R.Input(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo(t1, [R.Pointer]), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0);
        t1.Input$1(game);
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new Input"]}
  },
  "+Input": [674],
  InputHandler: {
    "^": "Object;sprite@-2,game@-613,enabled@-617,priorityID@-614,useHandCursor@-617,_setHandCursor@-617,isDragged@-617,allowHorizontalDrag@-617,allowVerticalDrag@-617,bringToTop@-617,snapOffset@-615,snapOnDrag@-617,snapOnRelease@-617,snapX@-616,snapY@-616,_dx@-616,_dy@-616,snapOffsetX@-616,snapOffsetY@-616,pixelPerfectOver@-617,pixelPerfectClick@-617,pixelPerfectAlpha@-614,draggable*-617,boundsRect@-649,boundsSprite@-961,consumePointerEvent@-617,scaleLayer@-617,_dragPhase@-617,_wasEnabled@-617,_tempPoint@-615,_pointerData@-1315,_draggedPointerID@-614,_dragPoint@-615,dragOffset@-615,dragFromCenter@-617,checked*-617",
    sprite$3: function(arg0, arg1, arg2) {
      return this.sprite.call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.sprite.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.sprite.call$4(arg0, arg1, arg2, arg3);
    },
    bringToTop$0: function() {
      return this.bringToTop.call$0();
    },
    bringToTop$1: function(arg0) {
      return this.bringToTop.call$1(arg0);
    },
    start$2: [function(_, priority, useHandCursor) {
      var i, t1, t2;
      if (J.$eq(this.enabled, false)) {
        J.add$1$ax(this.game.get$input().get$interactiveItems(), this);
        this.useHandCursor = useHandCursor;
        this.priorityID = priority;
        for (i = 0; i < 10; ++i) {
          t1 = this._pointerData;
          t2 = R.Pointer$(this.sprite.get$game(), i);
          t2.x = 0;
          t2.y = 0;
          t2.isDown = false;
          t2.isUp = false;
          t2.isOver = false;
          t2.isOut = false;
          t2.timeOver = 0;
          t2.timeOut = 0;
          t2.timeDown = 0;
          t2.timeUp = 0;
          t2.downDuration = 0;
          t2.isDragged = false;
          J.$indexSet$ax(t1, i, t2);
        }
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        this.snapOffset = t1;
        this.enabled = true;
        this._wasEnabled = true;
        if (this.sprite.get$events() != null && this.sprite.get$events().get$onInputOver() == null) {
          this.sprite.get$events().set$onInputOver(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
          this.sprite.get$events().set$onInputOut(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
          this.sprite.get$events().set$onInputDown(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
          this.sprite.get$events().set$onInputUp(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
          J.set$onDragStart$x(this.sprite.get$events(), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
          this.sprite.get$events().set$onDragStop(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
        }
      }
      J.add$1$ax(this.sprite.get$events().get$onAddedToGroup(), this.get$addedToGroup());
      J.add$1$ax(this.sprite.get$events().get$onRemovedFromGroup(), this.get$removedFromGroup());
      return this.sprite;
    }, function($receiver, priority) {
      return this.start$2($receiver, priority, false);
    }, "start$1", function($receiver) {
      return this.start$2($receiver, 0, false);
    }, "start$0", "call$2", "call$1", "call$0", "get$start", 0, 4, 1333, 49, 19, 1016, [], 1334, [], "start"],
    addedToGroup$2: [function(s, w) {
      if (this._dragPhase === true)
        return;
      if (this._wasEnabled === true && this.enabled !== true)
        this.start$0(0);
    }, "call$2", "get$addedToGroup", 4, 0, 1335, 545, [], 43, [], "addedToGroup"],
    removedFromGroup$2: [function(s, w) {
      if (this._dragPhase === true)
        return;
      if (this.enabled === true) {
        this._wasEnabled = true;
        this.stop$0(0);
      } else
        this._wasEnabled = false;
    }, "call$2", "get$removedFromGroup", 4, 0, 1335, 545, [], 43, [], "removedFromGroup"],
    reset$0: [function(_) {
      var i, t1, t2;
      this.enabled = false;
      for (i = 0; i < 10; ++i) {
        t1 = this._pointerData;
        t2 = R.Pointer$(this.sprite.get$game(), i);
        t2.x = 0;
        t2.y = 0;
        t2.isDown = false;
        t2.isUp = false;
        t2.isOver = false;
        t2.isOut = false;
        t2.timeOver = 0;
        t2.timeOut = 0;
        t2.timeDown = 0;
        t2.timeUp = 0;
        t2.downDuration = 0;
        t2.isDragged = false;
        J.$indexSet$ax(t1, i, t2);
      }
    }, "call$0", "get$reset", 0, 0, 54, "reset"],
    stop$0: [function(_) {
      if (J.$eq(this.enabled, false))
        return;
      else {
        this.enabled = false;
        J.remove$1$ax(this.game.get$input().get$interactiveItems(), this);
      }
    }, "call$0", "get$stop", 0, 0, 54, "stop"],
    destroy$0: [function() {
      if (this.sprite != null) {
        if (this._setHandCursor === true) {
          J.set$cursor$x(J.get$style$x(J.get$canvas$x(this.game)), "default");
          this._setHandCursor = false;
        }
        this.enabled = false;
        J.remove$1$ax(this.game.get$input().get$interactiveItems(), this);
        this._pointerData = null;
        this.boundsRect = null;
        this.boundsSprite = null;
        this.sprite = null;
      }
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    validForInput$3: [function(highestID, highestRenderID, includePixelPerfect) {
      var t1;
      if (J.$eq(J.get$x$x(J.get$scale$x(this.sprite)), 0) || J.$eq(J.get$y$x(J.get$scale$x(this.sprite)), 0) || J.$lt$n(this.priorityID, this.game.get$input().get$minPriorityID()))
        return false;
      if (includePixelPerfect !== true)
        t1 = this.pixelPerfectClick === true || this.pixelPerfectOver === true;
      else
        t1 = false;
      if (t1)
        return true;
      if (!J.$gt$n(this.priorityID, highestID))
        t1 = J.$eq(this.priorityID, highestID) && J.$lt$n(J.$index$asx(this.sprite.get$_cache(), 3), highestRenderID);
      else
        t1 = true;
      if (t1)
        return true;
      return false;
    }, function(highestID, highestRenderID) {
      return this.validForInput$3(highestID, highestRenderID, true);
    }, "validForInput$2", "call$3", "call$2", "get$validForInput", 4, 2, 1336, 78, 1337, [], 1338, [], 1339, [], "validForInput"],
    pointerX$1: [function(pointer) {
      return J.get$x$x(J.$index$asx(this._pointerData, pointer));
    }, function() {
      return this.pointerX$1(0);
    }, "pointerX$0", "call$1", "call$0", "get$pointerX", 0, 2, 1340, 49, 1021, [], "pointerX"],
    pointerY$1: [function(pointer) {
      return J.get$y$x(J.$index$asx(this._pointerData, pointer));
    }, function() {
      return this.pointerY$1(0);
    }, "pointerY$0", "call$1", "call$0", "get$pointerY", 0, 2, 1340, 49, 1021, [], "pointerY"],
    pointerDown$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$isDown();
    }, function() {
      return this.pointerDown$1(0);
    }, "pointerDown$0", "call$1", "call$0", "get$pointerDown", 0, 2, 1341, 49, 1021, [], "pointerDown"],
    pointerUp$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$isUp();
    }, function() {
      return this.pointerUp$1(0);
    }, "pointerUp$0", "call$1", "call$0", "get$pointerUp", 0, 2, 1341, 49, 1021, [], "pointerUp"],
    pointerTimeDown$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$timeDown();
    }, function() {
      return this.pointerTimeDown$1(0);
    }, "pointerTimeDown$0", "call$1", "call$0", "get$pointerTimeDown", 0, 2, 1342, 49, 1021, [], "pointerTimeDown"],
    pointerTimeUp$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$timeUp();
    }, function() {
      return this.pointerTimeUp$1(0);
    }, "pointerTimeUp$0", "call$1", "call$0", "get$pointerTimeUp", 0, 2, 1342, 49, 1021, [], "pointerTimeUp"],
    pointerOver$1: [function(index) {
      var i;
      if (this.enabled === true)
        if (index == null) {
          for (i = 0; i < 10; ++i)
            if (J.$index$asx(this._pointerData, i).get$isOver() === true)
              return true;
        } else
          return J.$index$asx(this._pointerData, index).get$isOver();
      return false;
    }, function() {
      return this.pointerOver$1(null);
    }, "pointerOver$0", "call$1", "call$0", "get$pointerOver", 0, 2, 1341, 12, 281, [], "pointerOver"],
    pointerOut$1: [function(index) {
      var i;
      if (this.enabled === true)
        if (index == null) {
          for (i = 0; i < 10; ++i)
            if (J.$index$asx(this._pointerData, i).get$isOut() === true)
              return true;
        } else
          return J.$index$asx(this._pointerData, index).get$isOut();
      return false;
    }, function() {
      return this.pointerOut$1(null);
    }, "pointerOut$0", "call$1", "call$0", "get$pointerOut", 0, 2, 1341, 12, 281, [], "pointerOut"],
    pointerTimeOver$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$timeOver();
    }, function() {
      return this.pointerTimeOver$1(0);
    }, "pointerTimeOver$0", "call$1", "call$0", "get$pointerTimeOver", 0, 2, 1342, 49, 1021, [], "pointerTimeOver"],
    pointerTimeOut$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$timeOut();
    }, function() {
      return this.pointerTimeOut$1(0);
    }, "pointerTimeOut$0", "call$1", "call$0", "get$pointerTimeOut", 0, 2, 1342, 49, 1021, [], "pointerTimeOut"],
    pointerDragged$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$isDragged();
    }, function() {
      return this.pointerDragged$1(0);
    }, "pointerDragged$0", "call$1", "call$0", "get$pointerDragged", 0, 2, 1341, 49, 1021, [], "pointerDragged"],
    checkPointerDown$2: [function(pointer, fastTest) {
      var t1;
      if (pointer.get$isDown() === true)
        if (this.enabled === true) {
          t1 = this.sprite;
          t1 = t1 == null || J.get$parent$x(t1) == null || this.sprite.get$visible() !== true || J.get$parent$x(this.sprite).get$visible() !== true;
        } else
          t1 = true;
      else
        t1 = true;
      if (t1)
        return false;
      if (this.game.get$input().hitTest$3(this.sprite, pointer, this._tempPoint) === true)
        if (fastTest !== true && this.pixelPerfectClick === true)
          return this.checkPixel$2(J.get$x$x(this._tempPoint), J.get$y$x(this._tempPoint));
        else
          return true;
      return false;
    }, function(pointer) {
      return this.checkPointerDown$2(pointer, false);
    }, "checkPointerDown$1", "call$2", "call$1", "get$checkPointerDown", 2, 2, 1343, 19, 1021, [], 1344, [], "checkPointerDown"],
    checkPointerOver$2: [function(pointer, fastTest) {
      var t1;
      if (this.enabled === true) {
        t1 = this.sprite;
        t1 = t1 == null || J.get$parent$x(t1) == null || this.sprite.get$visible() !== true || J.get$parent$x(this.sprite).get$visible() !== true;
      } else
        t1 = true;
      if (t1)
        return false;
      if (this.game.get$input().hitTest$3(this.sprite, pointer, this._tempPoint) === true)
        if (fastTest !== true && this.pixelPerfectOver === true)
          return this.checkPixel$2(J.get$x$x(this._tempPoint), J.get$y$x(this._tempPoint));
        else
          return true;
      return false;
    }, function(pointer) {
      return this.checkPointerOver$2(pointer, false);
    }, "checkPointerOver$1", "call$2", "call$1", "get$checkPointerOver", 2, 2, 1343, 19, 1021, [], 1344, [], "checkPointerOver"],
    checkPixel$3: [function(x, y, pointer) {
      var sprite, t1, t2;
      sprite = H.interceptedTypeCast(this.sprite, "$isSprite");
      if (J.get$source$x(sprite.texture.get$baseTexture()) != null) {
        J.clearRect$4$x(this.game.get$input().get$hitContext(), 0, 0, 1, 1);
        if (x == null && y == null) {
          this.game.get$input().getLocalPosition$3(this.sprite, pointer, this._tempPoint);
          x = J.get$x$x(this._tempPoint);
          y = J.get$y$x(this._tempPoint);
        }
        if (!J.$eq(J.get$x$x(this.sprite.get$anchor()), 0))
          x = J.$sub$n(x, J.$mul$ns(J.$negate$n(J.get$width$x(sprite.texture.get$frame())), J.get$x$x(this.sprite.get$anchor())));
        if (!J.$eq(J.get$y$x(this.sprite.get$anchor()), 0))
          y = J.$sub$n(y, J.$mul$ns(J.$negate$n(J.get$height$x(sprite.texture.get$frame())), J.get$y$x(this.sprite.get$anchor())));
        x = J.$add$ns(x, J.get$x$x(sprite.texture.get$frame()));
        y = J.$add$ns(y, J.get$y$x(sprite.texture.get$frame()));
        if (J.get$trim$s(sprite.texture) != null) {
          x = J.$sub$n(x, J.get$x$x(J.get$trim$s(sprite.texture)));
          y = J.$sub$n(y, J.get$y$x(J.get$trim$s(sprite.texture)));
          t1 = J.getInterceptor$n(x);
          if (!t1.$lt(x, J.get$x$x(sprite.texture.get$crop())))
            if (!t1.$gt(x, J.$add$ns(J.get$x$x(sprite.texture.get$crop()), J.get$width$x(sprite.texture.get$crop())))) {
              t1 = J.getInterceptor$n(y);
              t1 = t1.$lt(y, J.get$y$x(sprite.texture.get$crop())) || t1.$gt(y, J.$add$ns(J.get$y$x(sprite.texture.get$crop()), J.get$height$x(sprite.texture.get$crop())));
            } else
              t1 = true;
          else
            t1 = true;
          if (t1) {
            this._dx = x;
            this._dy = y;
            return false;
          }
        }
        this._dx = x;
        this._dy = y;
        J.clearRect$4$x(this.game.get$input().get$hitContext(), 0, 0, 1, 1);
        J.drawImageScaledFromSource$9$x(this.game.get$input().get$hitContext(), J.get$source$x(sprite.texture.get$baseTexture()), x, y, 1, 1, 0, 0, 1, 1);
        t1 = J.get$data$x(J.getImageData$4$x(this.game.get$input().get$hitContext(), 0, 0, 1, 1));
        if (3 >= t1.length)
          return H.ioore(t1, 3);
        t1 = t1[3];
        t2 = this.pixelPerfectAlpha;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (t1 >= t2)
          return true;
      }
      return false;
    }, function(x, y) {
      return this.checkPixel$3(x, y, null);
    }, "checkPixel$2", "call$3", "call$2", "get$checkPixel", 4, 2, 1345, 12, 9, [], 10, [], 1021, [], "checkPixel"],
    update$1: [function(pointer) {
      var t1 = this.sprite;
      if (t1 == null || J.get$parent$x(t1) == null)
        return false;
      if (this.enabled !== true || this.sprite.get$visible() !== true || J.get$parent$x(this.sprite).get$visible() !== true) {
        this._pointerOutHandler$1(pointer);
        return false;
      }
      if (this.draggable === true && J.$eq(this._draggedPointerID, J.get$id$x(pointer)))
        return this.updateDrag$1(pointer);
      else {
        t1 = J.getInterceptor$x(pointer);
        if (J.$eq(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isOver(), true))
          if (this.checkPointerOver$1(pointer)) {
            J.set$x$x(J.$index$asx(this._pointerData, t1.get$id(pointer)), J.$sub$n(t1.get$x(pointer), J.get$x$x(this.sprite)));
            J.set$y$x(J.$index$asx(this._pointerData, t1.get$id(pointer)), J.$sub$n(t1.get$y(pointer), J.get$y$x(this.sprite)));
            return true;
          } else {
            this._pointerOutHandler$1(pointer);
            return false;
          }
      }
      return true;
    }, "call$1", "get$update", 2, 0, 1346, 1021, [], "update"],
    _pointerOverHandler$1: [function(pointer) {
      var t1;
      if (this.sprite == null)
        return;
      t1 = J.getInterceptor$x(pointer);
      if (J.$eq(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isOver(), false) || pointer.get$dirty() === true) {
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isOver(true);
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isOut(false);
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$timeOver(J.get$now$x(this.game.get$time()));
        J.set$x$x(J.$index$asx(this._pointerData, t1.get$id(pointer)), J.$sub$n(t1.get$x(pointer), J.get$x$x(this.sprite)));
        J.set$y$x(J.$index$asx(this._pointerData, t1.get$id(pointer)), J.$sub$n(t1.get$y(pointer), J.get$y$x(this.sprite)));
        if (this.useHandCursor === true && J.$eq(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isDragged(), false)) {
          J.set$cursor$x(J.get$style$x(J.get$canvas$x(this.game)), "pointer");
          this._setHandCursor = true;
        }
        t1 = this.sprite;
        if (t1 != null && t1.get$events() != null)
          this.sprite.get$events().get$onInputOver().dispatch$1([this.sprite, pointer]);
      }
    }, "call$1", "get$_pointerOverHandler", 2, 0, 1347, 1021, [], "_pointerOverHandler"],
    _pointerOutHandler$1: [function(pointer) {
      var t1;
      if (this.sprite == null)
        return;
      t1 = J.getInterceptor$x(pointer);
      J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isOver(false);
      J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isOut(true);
      J.$index$asx(this._pointerData, t1.get$id(pointer)).set$timeOut(J.get$now$x(this.game.get$time()));
      if (this.useHandCursor === true && J.$eq(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isDragged(), false)) {
        J.set$cursor$x(J.get$style$x(J.get$canvas$x(this.game)), "default");
        this._setHandCursor = false;
      }
      t1 = this.sprite;
      if (t1 != null && t1.get$events() != null)
        this.sprite.get$events().get$onInputOut().dispatch$1([this.sprite, pointer]);
    }, "call$1", "get$_pointerOutHandler", 2, 0, 1347, 1021, [], "_pointerOutHandler"],
    _touchedHandler$1: [function(pointer) {
      var t1, t2, t3, t4, bounds;
      if (this.sprite == null)
        return false;
      t1 = J.getInterceptor$x(pointer);
      if (J.$eq(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isDown(), false) && J.$eq(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isOver(), true)) {
        if (this.pixelPerfectClick === true && !this.checkPixel$3(null, null, pointer))
          return false;
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isDown(true);
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isUp(false);
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$timeDown(J.get$now$x(this.game.get$time()));
        t2 = this.sprite;
        if (t2 != null && t2.get$events() != null)
          this.sprite.get$events().get$onInputDown().dispatch$1([this.sprite, pointer]);
        pointer.set$dirty(true);
        if (this.draggable === true && J.$eq(this.isDragged, false)) {
          this.isDragged = true;
          this._draggedPointerID = t1.get$id(pointer);
          J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isDragged(true);
          if (this.sprite.get$fixedToCamera() === true) {
            t2 = this.dragFromCenter;
            t3 = this._dragPoint;
            t4 = this.sprite;
            if (t2 === true)
              t3.setTo$2(J.$sub$n(J.get$x$x(t4.get$cameraOffset()), t1.get$x(pointer)), J.$sub$n(J.get$y$x(this.sprite.get$cameraOffset()), t1.get$y(pointer)));
            else
              t3.setTo$2(J.$sub$n(J.get$x$x(t4.get$cameraOffset()), t1.get$x(pointer)), J.$sub$n(J.get$y$x(this.sprite.get$cameraOffset()), t1.get$y(pointer)));
          } else {
            if (this.dragFromCenter === true) {
              bounds = this.sprite.getBounds$0();
              J.set$x$x(this.sprite, J.$add$ns(this.globalToLocalX$1(t1.get$x(pointer)), J.$sub$n(J.get$x$x(this.sprite), bounds.get$centerX())));
              J.set$y$x(this.sprite, J.$add$ns(this.globalToLocalY$1(t1.get$y(pointer)), J.$sub$n(J.get$y$x(this.sprite), bounds.get$centerY())));
            }
            this._dragPoint.setTo$2(J.$sub$n(J.get$x$x(this.sprite), this.globalToLocalX$1(t1.get$x(pointer))), J.$sub$n(J.get$y$x(this.sprite), this.globalToLocalY$1(t1.get$y(pointer))));
          }
          this.updateDrag$1(pointer);
          if (this.bringToTop === true) {
            this._dragPhase = true;
            this.sprite.bringToTop$0();
          }
          J.get$onDragStart$x(this.sprite.get$events()).dispatch$1([this.sprite, pointer]);
        }
        if (this.bringToTop === true)
          this.sprite.bringToTop$0();
      }
      return this.consumePointerEvent;
    }, "call$1", "get$_touchedHandler", 2, 0, 1346, 1021, [], "_touchedHandler"],
    _releasedHandler$1: [function(pointer) {
      var t1, t2;
      if (this.sprite == null)
        return;
      t1 = J.getInterceptor$x(pointer);
      if (J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isDown() === true && pointer.get$isUp() === true) {
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isDown(false);
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isUp(true);
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$timeUp(J.get$now$x(this.game.get$time()));
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$downDuration(J.$sub$n(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$timeUp(), J.$index$asx(this._pointerData, t1.get$id(pointer)).get$timeDown()));
        if (this.checkPointerOver$1(pointer)) {
          t2 = this.sprite;
          if (t2 != null && t2.get$events() != null)
            this.sprite.get$events().get$onInputUp().dispatch$1([this.sprite, pointer, true]);
        } else {
          t2 = this.sprite;
          if (t2 != null && t2.get$events() != null)
            this.sprite.get$events().get$onInputUp().dispatch$1([this.sprite, pointer, false]);
          if (this.useHandCursor === true) {
            J.set$cursor$x(J.get$style$x(J.get$canvas$x(this.game)), "default");
            this._setHandCursor = false;
          }
        }
        pointer.set$dirty(true);
        if (this.draggable === true && this.isDragged === true && J.$eq(this._draggedPointerID, t1.get$id(pointer)))
          this.stopDrag$1(pointer);
      }
    }, "call$1", "get$_releasedHandler", 2, 0, 1347, 1021, [], "_releasedHandler"],
    updateDrag$1: [function(pointer) {
      var t1, px, py, t2, t3, t4;
      if (pointer.get$isUp() === true) {
        this.stopDrag$1(pointer);
        return false;
      }
      t1 = J.getInterceptor$x(pointer);
      px = J.$add$ns(J.$add$ns(this.globalToLocalX$1(t1.get$x(pointer)), J.get$x$x(this._dragPoint)), J.get$x$x(this.dragOffset));
      py = J.$add$ns(J.$add$ns(this.globalToLocalY$1(t1.get$y(pointer)), J.get$y$x(this._dragPoint)), J.get$y$x(this.dragOffset));
      if (this.sprite.get$fixedToCamera() === true) {
        if (this.allowHorizontalDrag === true)
          J.set$x$x(this.sprite.get$cameraOffset(), px);
        if (this.allowVerticalDrag === true)
          J.set$y$x(this.sprite.get$cameraOffset(), py);
        if (this.boundsRect != null)
          this.checkBoundsRect$0();
        if (this.boundsSprite != null)
          this.checkBoundsSprite$0();
        if (this.snapOnDrag === true) {
          t1 = this.sprite.get$cameraOffset();
          t2 = J.round$0$n(J.$div$n(J.$sub$n(J.get$x$x(this.sprite.get$cameraOffset()), J.$mod$n(this.snapOffsetX, this.snapX)), this.snapX));
          t3 = this.snapX;
          if (typeof t3 !== "number")
            return H.iae(t3);
          J.set$x$x(t1, t2 * t3 + J.$mod$n(this.snapOffsetX, t3));
          t3 = this.sprite.get$cameraOffset();
          t2 = J.round$0$n(J.$div$n(J.$sub$n(J.get$y$x(this.sprite.get$cameraOffset()), J.$mod$n(this.snapOffsetY, this.snapY)), this.snapY));
          t1 = this.snapY;
          if (typeof t1 !== "number")
            return H.iae(t1);
          J.set$y$x(t3, t2 * t1 + J.$mod$n(this.snapOffsetY, t1));
        }
      } else {
        if (this.allowHorizontalDrag === true)
          J.set$x$x(this.sprite, px);
        if (this.allowVerticalDrag === true)
          J.set$y$x(this.sprite, py);
        if (this.boundsRect != null)
          this.checkBoundsRect$0();
        if (this.boundsSprite != null)
          this.checkBoundsSprite$0();
        if (this.snapOnDrag === true) {
          t1 = this.sprite;
          t2 = J.getInterceptor$x(t1);
          t3 = J.round$0$n(J.$div$n(J.$sub$n(t2.get$x(t1), J.$mod$n(this.snapOffsetX, this.snapX)), this.snapX));
          t4 = this.snapX;
          if (typeof t4 !== "number")
            return H.iae(t4);
          t2.set$x(t1, t3 * t4 + J.$mod$n(this.snapOffsetX, t4));
          t4 = this.sprite;
          t3 = J.getInterceptor$x(t4);
          t1 = J.round$0$n(J.$div$n(J.$sub$n(t3.get$y(t4), J.$mod$n(this.snapOffsetY, this.snapY)), this.snapY));
          t2 = this.snapY;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t3.set$y(t4, t1 * t2 + J.$mod$n(this.snapOffsetY, t2));
        }
      }
      return true;
    }, "call$1", "get$updateDrag", 2, 0, 1346, 1021, [], "updateDrag"],
    justOver$2: [function(pointer, delay) {
      return J.$index$asx(this._pointerData, pointer).get$isOver() === true && J.$lt$n(this.overDuration$1(pointer), delay);
    }, function() {
      return this.justOver$2(0, 500);
    }, "justOver$0", function(pointer) {
      return this.justOver$2(pointer, 500);
    }, "justOver$1", "call$2", "call$0", "call$1", "get$justOver", 0, 4, 1348, 49, 1349, 1021, [], 516, [], "justOver"],
    justOut$2: [function(pointer, delay) {
      return J.$index$asx(this._pointerData, pointer).get$isOut() === true && J.$lt$n(J.$sub$n(J.get$now$x(this.game.get$time()), J.$index$asx(this._pointerData, pointer).get$timeOut()), delay);
    }, function() {
      return this.justOut$2(0, 500);
    }, "justOut$0", function(pointer) {
      return this.justOut$2(pointer, 500);
    }, "justOut$1", "call$2", "call$0", "call$1", "get$justOut", 0, 4, 1348, 49, 1349, 1021, [], 516, [], "justOut"],
    justPressed$2: [function(pointer, delay) {
      return J.$index$asx(this._pointerData, pointer).get$isDown() === true && J.$lt$n(this.downDuration$1(pointer), delay);
    }, function(pointer) {
      return this.justPressed$2(pointer, 500);
    }, "justPressed$1", function() {
      return this.justPressed$2(0, 500);
    }, "justPressed$0", "call$2", "call$1", "call$0", "get$justPressed", 0, 4, 1348, 49, 1349, 1021, [], 516, [], "justPressed"],
    justReleased$2: [function(pointer, delay) {
      return J.$index$asx(this._pointerData, pointer).get$isUp() === true && J.$lt$n(J.$sub$n(J.get$now$x(this.game.get$time()), J.$index$asx(this._pointerData, pointer).get$timeUp()), delay);
    }, function(pointer) {
      return this.justReleased$2(pointer, 500);
    }, "justReleased$1", function() {
      return this.justReleased$2(0, 500);
    }, "justReleased$0", "call$2", "call$1", "call$0", "get$justReleased", 0, 4, 1348, 49, 1349, 1021, [], 516, [], "justReleased"],
    overDuration$1: [function(pointer) {
      if (J.$index$asx(this._pointerData, pointer).get$isOver() === true)
        return J.$sub$n(J.get$now$x(this.game.get$time()), J.$index$asx(this._pointerData, pointer).get$timeOver());
      return -1;
    }, function() {
      return this.overDuration$1(0);
    }, "overDuration$0", "call$1", "call$0", "get$overDuration", 0, 2, 1340, 49, 1021, [], "overDuration"],
    downDuration$1: [function(pointer) {
      if (J.$index$asx(this._pointerData, pointer).get$isDown() === true)
        return J.$sub$n(J.get$now$x(this.game.get$time()), J.$index$asx(this._pointerData, pointer).get$timeDown());
      return -1;
    }, function() {
      return this.downDuration$1(0);
    }, "downDuration$0", "call$1", "call$0", "get$downDuration", 0, 2, 1340, 49, 1021, [], "downDuration"],
    enableDrag$6: [function(lockCenter, bringToTop, pixelPerfect, alphaThreshold, boundsRect, boundsSprite) {
      var t1;
      if (lockCenter == null)
        lockCenter = false;
      if (bringToTop == null)
        bringToTop = false;
      if (pixelPerfect == null)
        pixelPerfect = false;
      if (alphaThreshold == null)
        alphaThreshold = 255;
      if (boundsRect == null)
        boundsRect = null;
      if (boundsSprite == null)
        boundsSprite = null;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this._dragPoint = t1;
      this.draggable = true;
      this.bringToTop = bringToTop;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.dragOffset = t1;
      this.dragFromCenter = lockCenter;
      this.pixelPerfectClick = pixelPerfect;
      this.pixelPerfectAlpha = alphaThreshold;
      if (boundsRect != null)
        this.boundsRect = boundsRect;
      if (boundsSprite != null)
        this.boundsSprite = boundsSprite;
    }, function(lockCenter) {
      return this.enableDrag$6(lockCenter, false, false, 255, null, null);
    }, "enableDrag$1", function(lockCenter, bringToTop) {
      return this.enableDrag$6(lockCenter, bringToTop, false, 255, null, null);
    }, "enableDrag$2", function() {
      return this.enableDrag$6(false, false, false, 255, null, null);
    }, "enableDrag$0", function(lockCenter, bringToTop, pixelPerfect) {
      return this.enableDrag$6(lockCenter, bringToTop, pixelPerfect, 255, null, null);
    }, "enableDrag$3", function(lockCenter, bringToTop, pixelPerfect, alphaThreshold) {
      return this.enableDrag$6(lockCenter, bringToTop, pixelPerfect, alphaThreshold, null, null);
    }, "enableDrag$4", function(lockCenter, bringToTop, pixelPerfect, alphaThreshold, boundsRect) {
      return this.enableDrag$6(lockCenter, bringToTop, pixelPerfect, alphaThreshold, boundsRect, null);
    }, "enableDrag$5", "call$6", "call$1", "call$2", "call$0", "call$3", "call$4", "call$5", "get$enableDrag", 0, 12, 1350, 19, 19, 19, 551, 12, 12, 1351, [], 1352, [], 1353, [], 1354, [], 1355, [], 1356, [], "enableDrag"],
    disableDrag$0: [function() {
      if (this._pointerData != null)
        for (var i = 0; i < 10; ++i)
          J.$index$asx(this._pointerData, i).set$isDragged(false);
      this.draggable = false;
      this.isDragged = false;
      this._draggedPointerID = -1;
    }, "call$0", "get$disableDrag", 0, 0, 54, "disableDrag"],
    startDrag$1: [function(pointer) {
      var t1, t2, t3, t4, bounds;
      this.isDragged = true;
      t1 = J.getInterceptor$x(pointer);
      this._draggedPointerID = t1.get$id(pointer);
      J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isDragged(true);
      if (this.sprite.get$fixedToCamera() === true) {
        t2 = this.dragFromCenter;
        t3 = this._dragPoint;
        t4 = this.sprite;
        if (t2 === true)
          t3.setTo$2(J.$sub$n(J.get$x$x(t4.get$cameraOffset()), t1.get$x(pointer)), J.$sub$n(J.get$y$x(this.sprite.get$cameraOffset()), t1.get$y(pointer)));
        else
          t3.setTo$2(J.$sub$n(J.get$x$x(t4.get$cameraOffset()), t1.get$x(pointer)), J.$sub$n(J.get$y$x(this.sprite.get$cameraOffset()), t1.get$y(pointer)));
      } else {
        if (this.dragFromCenter === true) {
          bounds = this.sprite.getBounds$0();
          J.set$x$x(this.sprite, J.$add$ns(this.globalToLocalX$1(t1.get$x(pointer)), J.$sub$n(J.get$x$x(this.sprite), bounds.get$centerX())));
          J.set$y$x(this.sprite, J.$add$ns(this.globalToLocalY$1(t1.get$y(pointer)), J.$sub$n(J.get$y$x(this.sprite), bounds.get$centerY())));
        }
        this._dragPoint.setTo$2(J.$sub$n(J.get$x$x(this.sprite), this.globalToLocalX$1(t1.get$x(pointer))), J.$sub$n(J.get$y$x(this.sprite), this.globalToLocalY$1(t1.get$y(pointer))));
      }
      this.updateDrag$1(pointer);
      if (this.bringToTop === true) {
        this._dragPhase = true;
        this.sprite.bringToTop$0();
      }
      J.get$onDragStart$x(this.sprite.get$events()).dispatch$1([this.sprite, pointer]);
    }, "call$1", "get$startDrag", 2, 0, 1347, 1021, [], "startDrag"],
    globalToLocalX$1: [function(x) {
      return this.scaleLayer === true ? J.$mul$ns(J.$sub$n(x, J.get$x$x(J.get$grid$x(J.get$scale$x(this.game)).get$boundsFluid())), J.get$x$x(J.get$grid$x(J.get$scale$x(this.game)).get$scaleFluidInversed())) : x;
    }, "call$1", "get$globalToLocalX", 2, 0, 620, 9, [], "globalToLocalX"],
    globalToLocalY$1: [function(y) {
      return this.scaleLayer === true ? J.$mul$ns(J.$sub$n(y, J.get$y$x(J.get$grid$x(J.get$scale$x(this.game)).get$boundsFluid())), J.get$y$x(J.get$grid$x(J.get$scale$x(this.game)).get$scaleFluidInversed())) : y;
    }, "call$1", "get$globalToLocalY", 2, 0, 620, 10, [], "globalToLocalY"],
    stopDrag$1: [function(pointer) {
      var t1, t2, t3, t4;
      this.isDragged = false;
      this._draggedPointerID = -1;
      J.$index$asx(this._pointerData, J.get$id$x(pointer)).set$isDragged(false);
      this._dragPhase = false;
      if (this.snapOnRelease === true) {
        t1 = this.sprite.get$fixedToCamera();
        t2 = this.sprite;
        if (t1 === true) {
          t1 = t2.get$cameraOffset();
          t2 = J.round$0$n(J.$div$n(J.$sub$n(J.get$x$x(this.sprite.get$cameraOffset()), J.$mod$n(this.snapOffsetX, this.snapX)), this.snapX));
          t3 = this.snapX;
          if (typeof t3 !== "number")
            return H.iae(t3);
          J.set$x$x(t1, t2 * t3 + J.$mod$n(this.snapOffsetX, t3));
          t3 = this.sprite.get$cameraOffset();
          t2 = J.round$0$n(J.$div$n(J.$sub$n(J.get$y$x(this.sprite.get$cameraOffset()), J.$mod$n(this.snapOffsetY, this.snapY)), this.snapY));
          t1 = this.snapY;
          if (typeof t1 !== "number")
            return H.iae(t1);
          J.set$y$x(t3, t2 * t1 + J.$mod$n(this.snapOffsetY, t1));
        } else {
          t1 = J.getInterceptor$x(t2);
          t3 = J.round$0$n(J.$div$n(J.$sub$n(t1.get$x(t2), J.$mod$n(this.snapOffsetX, this.snapX)), this.snapX));
          t4 = this.snapX;
          if (typeof t4 !== "number")
            return H.iae(t4);
          t1.set$x(t2, t3 * t4 + J.$mod$n(this.snapOffsetX, t4));
          t4 = this.sprite;
          t3 = J.getInterceptor$x(t4);
          t2 = J.round$0$n(J.$div$n(J.$sub$n(t3.get$y(t4), J.$mod$n(this.snapOffsetY, this.snapY)), this.snapY));
          t1 = this.snapY;
          if (typeof t1 !== "number")
            return H.iae(t1);
          t3.set$y(t4, t2 * t1 + J.$mod$n(this.snapOffsetY, t1));
        }
      }
      this.sprite.get$events().get$onDragStop().dispatch$1([this.sprite, pointer]);
      if (!this.checkPointerOver$1(pointer))
        this._pointerOutHandler$1(pointer);
    }, "call$1", "get$stopDrag", 2, 0, 1347, 1021, [], "stopDrag"],
    setDragLock$2: [function(allowHorizontal, allowVertical) {
      this.allowHorizontalDrag = allowHorizontal;
      this.allowVerticalDrag = allowVertical;
    }, function(allowHorizontal) {
      return this.setDragLock$2(allowHorizontal, true);
    }, "setDragLock$1", function() {
      return this.setDragLock$2(true, true);
    }, "setDragLock$0", "call$2", "call$1", "call$0", "get$setDragLock", 0, 4, 970, 78, 78, 1357, [], 1358, [], "setDragLock"],
    enableSnap$6: [function(snapX, snapY, onDrag, onRelease, snapOffsetX, snapOffsetY) {
      this.snapX = snapX;
      this.snapY = snapY;
      this.snapOffsetX = snapOffsetX;
      this.snapOffsetY = snapOffsetY;
      this.snapOnDrag = onDrag;
      this.snapOnRelease = onRelease;
    }, function(snapX, snapY) {
      return this.enableSnap$6(snapX, snapY, true, true, 0, 0);
    }, "enableSnap$2", function(snapX, snapY, onDrag) {
      return this.enableSnap$6(snapX, snapY, onDrag, true, 0, 0);
    }, "enableSnap$3", function(snapX, snapY, onDrag, onRelease) {
      return this.enableSnap$6(snapX, snapY, onDrag, onRelease, 0, 0);
    }, "enableSnap$4", function(snapX, snapY, onDrag, onRelease, snapOffsetX) {
      return this.enableSnap$6(snapX, snapY, onDrag, onRelease, snapOffsetX, 0);
    }, "enableSnap$5", "call$6", "call$2", "call$3", "call$4", "call$5", "get$enableSnap", 4, 8, 1359, 78, 78, 49, 49, 1360, [], 1361, [], 1362, [], 1363, [], 1364, [], 1365, [], "enableSnap"],
    disableSnap$0: [function() {
      this.snapOnDrag = false;
      this.snapOnRelease = false;
    }, "call$0", "get$disableSnap", 0, 0, 54, "disableSnap"],
    checkBoundsRect$0: [function() {
      if (this.sprite.get$fixedToCamera() === true) {
        if (J.$lt$n(J.get$x$x(this.sprite.get$cameraOffset()), J.get$left$x(this.boundsRect)))
          J.set$x$x(this.sprite.get$cameraOffset(), J.get$left$x(this.boundsRect));
        else if (J.$gt$n(J.$add$ns(J.get$x$x(this.sprite.get$cameraOffset()), J.get$width$x(this.sprite)), J.get$right$x(this.boundsRect)))
          J.set$x$x(this.sprite.get$cameraOffset(), J.$sub$n(J.get$right$x(this.boundsRect), J.get$width$x(this.sprite)));
        if (J.$lt$n(J.get$y$x(this.sprite.get$cameraOffset()), J.get$top$x(this.boundsRect)))
          J.set$y$x(this.sprite.get$cameraOffset(), J.get$top$x(this.boundsRect));
        else if (J.$gt$n(J.$add$ns(J.get$y$x(this.sprite.get$cameraOffset()), J.get$height$x(this.sprite)), J.get$bottom$x(this.boundsRect)))
          J.set$y$x(this.sprite.get$cameraOffset(), J.$sub$n(J.get$bottom$x(this.boundsRect), J.get$height$x(this.sprite)));
      } else {
        if (J.$lt$n(J.get$x$x(this.sprite), J.get$left$x(this.boundsRect)))
          J.set$x$x(this.sprite, J.get$x$x(this.boundsRect));
        else if (J.$gt$n(J.$add$ns(J.get$x$x(this.sprite), J.get$width$x(this.sprite)), J.get$right$x(this.boundsRect)))
          J.set$x$x(this.sprite, J.$sub$n(J.get$right$x(this.boundsRect), J.get$width$x(this.sprite)));
        if (J.$lt$n(J.get$y$x(this.sprite), J.get$top$x(this.boundsRect)))
          J.set$y$x(this.sprite, J.get$top$x(this.boundsRect));
        else if (J.$gt$n(J.$add$ns(J.get$y$x(this.sprite), J.get$height$x(this.sprite)), J.get$bottom$x(this.boundsRect)))
          J.set$y$x(this.sprite, J.$sub$n(J.get$bottom$x(this.boundsRect), J.get$height$x(this.sprite)));
      }
    }, "call$0", "get$checkBoundsRect", 0, 0, 54, "checkBoundsRect"],
    checkBoundsSprite$0: [function() {
      if (this.sprite.get$fixedToCamera() === true && this.boundsSprite.get$fixedToCamera() === true) {
        if (J.$lt$n(J.get$x$x(this.sprite.get$cameraOffset()), J.get$x$x(this.boundsSprite.get$camerOffset())))
          J.set$x$x(this.sprite.get$cameraOffset(), J.get$x$x(this.boundsSprite.get$camerOffset()));
        else if (J.$gt$n(J.$add$ns(J.get$x$x(this.sprite.get$cameraOffset()), J.get$width$x(this.sprite)), J.$add$ns(J.get$x$x(this.boundsSprite.get$camerOffset()), J.get$width$x(this.boundsSprite))))
          J.set$x$x(this.sprite.get$cameraOffset(), J.$sub$n(J.$add$ns(J.get$x$x(this.boundsSprite.get$camerOffset()), J.get$width$x(this.boundsSprite)), J.get$width$x(this.sprite)));
        if (J.$lt$n(J.get$y$x(this.sprite.get$cameraOffset()), J.get$y$x(this.boundsSprite.get$camerOffset())))
          J.set$y$x(this.sprite.get$cameraOffset(), J.get$y$x(this.boundsSprite.get$camerOffset()));
        else if (J.$gt$n(J.$add$ns(J.get$y$x(this.sprite.get$cameraOffset()), J.get$height$x(this.sprite)), J.$add$ns(J.get$y$x(this.boundsSprite.get$camerOffset()), J.get$height$x(this.boundsSprite))))
          J.set$y$x(this.sprite.get$cameraOffset(), J.$sub$n(J.$add$ns(J.get$y$x(this.boundsSprite.get$camerOffset()), J.get$height$x(this.boundsSprite)), J.get$height$x(this.sprite)));
      } else {
        if (J.$lt$n(J.get$x$x(this.sprite), J.get$x$x(this.boundsSprite)))
          J.set$x$x(this.sprite, J.get$x$x(this.boundsSprite));
        else if (J.$gt$n(J.$add$ns(J.get$x$x(this.sprite), J.get$width$x(this.sprite)), J.$add$ns(J.get$x$x(this.boundsSprite), J.get$width$x(this.boundsSprite))))
          J.set$x$x(this.sprite, J.$sub$n(J.$add$ns(J.get$x$x(this.boundsSprite), J.get$width$x(this.boundsSprite)), J.get$width$x(this.sprite)));
        if (J.$lt$n(J.get$y$x(this.sprite), J.get$y$x(this.boundsSprite)))
          J.set$y$x(this.sprite, J.get$y$x(this.boundsSprite));
        else if (J.$gt$n(J.$add$ns(J.get$y$x(this.sprite), J.get$height$x(this.sprite)), J.$add$ns(J.get$y$x(this.boundsSprite), J.get$height$x(this.boundsSprite))))
          J.set$y$x(this.sprite, J.$sub$n(J.$add$ns(J.get$y$x(this.boundsSprite), J.get$height$x(this.boundsSprite)), J.get$height$x(this.sprite)));
      }
    }, "call$0", "get$checkBoundsSprite", 0, 0, 54, "checkBoundsSprite"],
    InputHandler$1: function(sprite) {
      var t1, t2;
      this.game = this.sprite.get$game();
      this.enabled = false;
      this.priorityID = 0;
      this.useHandCursor = false;
      this._setHandCursor = false;
      this.isDragged = false;
      this.allowHorizontalDrag = true;
      this.allowVerticalDrag = true;
      this.bringToTop = false;
      this.snapOffset = null;
      this.snapOnDrag = false;
      this.snapOnRelease = false;
      this.snapX = 0;
      this.snapY = 0;
      this.snapOffsetX = 0;
      this.snapOffsetY = 0;
      this.pixelPerfectOver = false;
      this.pixelPerfectClick = false;
      this.pixelPerfectAlpha = 255;
      this.draggable = false;
      this.boundsRect = null;
      this.boundsSprite = null;
      this.consumePointerEvent = false;
      this.scaleLayer = false;
      this._dragPhase = false;
      this._wasEnabled = false;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this._tempPoint = t1;
      t1 = Array(11);
      t1.fixed$length = init;
      t1 = H.setRuntimeTypeInfo(t1, [R.Pointer]);
      this._pointerData = t1;
      t2 = R.Pointer$(this.sprite.get$game(), 0);
      t2.x = 0;
      t2.y = 0;
      t2.isDown = false;
      t2.isUp = false;
      t2.isOver = false;
      t2.isOut = false;
      t2.timeOver = 0;
      t2.timeOut = 0;
      t2.timeDown = 0;
      t2.timeUp = 0;
      t2.downDuration = 0;
      t2.isDragged = false;
      if (0 < 0 || 0 >= 11)
        return H.ioore(t1, 0);
      t1[0] = t2;
    },
    static: {InputHandler$: [function(sprite) {
        var t1 = new R.InputHandler(sprite, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);
        t1.InputHandler$1(sprite);
        return t1;
      }, null, null, 2, 0, 320, 151, [], "new InputHandler"]}
  },
  "+InputHandler": [674],
  Key: {
    "^": "Object;game@-613,enabled@-617,event@-12,isDown@-617,isUp@-617,altKey*-617,ctrlKey*-617,shiftKey*-617,timeDown@-616,duration*-616,timeUp@-616,repeats@-614,keyCode*-614,onDown@-1366,onHoldCallback@-0,onUp@-1366",
    isDown$1: function(arg0) {
      return this.isDown.call$1(arg0);
    },
    onHoldCallback$1: function(arg0) {
      return this.onHoldCallback.call$1(arg0);
    },
    update$0: [function() {
      if (this.enabled !== true)
        return;
      if (this.isDown === true) {
        this.duration = J.$sub$n(J.get$now$x(this.game.get$time()), this.timeDown);
        this.repeats = J.$add$ns(this.repeats, 1);
        if (this.onHoldCallback != null)
          this.onHoldCallback$1(this);
      }
    }, "call$0", "get$update", 0, 0, 54, "update"],
    processKeyDown$1: [function($event) {
      var t1;
      if (this.enabled !== true)
        return;
      this.event = $event;
      if (this.isDown === true)
        return;
      t1 = J.getInterceptor$x($event);
      this.altKey = t1.get$altKey($event);
      this.ctrlKey = t1.get$ctrlKey($event);
      this.shiftKey = t1.get$shiftKey($event);
      this.isDown = true;
      this.isUp = false;
      this.timeDown = J.get$now$x(this.game.get$time());
      this.duration = 0;
      this.repeats = 0;
      this.onDown.dispatch$1(this);
    }, "call$1", "get$processKeyDown", 2, 0, 1367, 666, [], "processKeyDown"],
    processKeyUp$1: [function($event) {
      if (this.enabled !== true)
        return;
      this.event = $event;
      if (this.isUp === true)
        return;
      this.isDown = false;
      this.isUp = true;
      this.timeUp = J.get$now$x(this.game.get$time());
      this.duration = J.$sub$n(J.get$now$x(this.game.get$time()), this.timeDown);
      this.onUp.dispatch$1(this);
    }, "call$1", "get$processKeyUp", 2, 0, 1367, 666, [], "processKeyUp"],
    reset$1: [function(_, hard) {
      this.isDown = false;
      this.isUp = true;
      this.timeUp = J.get$now$x(this.game.get$time());
      this.duration = 0;
      this.enabled = true;
      if (hard === true) {
        this.onDown.removeAll$0();
        this.onUp.removeAll$0();
        this.onHoldCallback = null;
      }
    }, function($receiver) {
      return this.reset$1($receiver, true);
    }, "reset$0", "call$1", "call$0", "get$reset", 0, 2, 956, 78, 1324, [], "reset"],
    justPressed$1: [function(duration) {
      return this.isDown === true && J.$lt$n(this.duration, duration);
    }, function() {
      return this.justPressed$1(50);
    }, "justPressed$0", "call$1", "call$0", "get$justPressed", 0, 2, 1341, 406, 94, [], "justPressed"],
    justReleased$1: [function(duration) {
      return this.isDown !== true && J.$lt$n(J.$sub$n(J.get$now$x(this.game.get$time()), this.timeUp), duration);
    }, function() {
      return this.justReleased$1(50);
    }, "justReleased$0", "call$1", "call$0", "get$justReleased", 0, 2, 1341, 406, 94, [], "justReleased"],
    Key$2: function(game, keycode) {
      this.enabled = true;
      this.event = null;
      this.isDown = false;
      this.isUp = true;
      this.altKey = false;
      this.ctrlKey = false;
      this.shiftKey = false;
      this.timeDown = 0;
      this.duration = 0;
      this.timeUp = -2500;
      this.repeats = 0;
      this.keyCode = keycode;
      this.onDown = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onHoldCallback = null;
      this.onUp = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
    },
    static: {Key$: [function(game, keycode) {
        var t1 = new R.Key(game, null, null, null, null, null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), null, null);
        t1.Key$2(game, keycode);
        return t1;
      }, null, null, 4, 0, 367, 252, [], 368, [], "new Key"]}
  },
  "+Key": [674],
  CursorKeys: {
    "^": "Object;up@-1368,down@-1368,left*-1368,right*-1368",
    static: {CursorKeys$: [function() {
        return new R.CursorKeys(null, null, null, null);
      }, null, null, 0, 0, 369, "new CursorKeys"]}
  },
  "+CursorKeys": [674],
  Keyboard: {
    "^": "Object;game@-613,disabled*-617,event@-12,pressEvent@-12,callbackContext@-12,onDownCallback@-0,onPressCallback@-0,onUpCallback@-0,_Phaser$_keys@-1369,_capture@-919,_onKeyDown@-0,_onKeyPress@-0,_onKeyUp@-0,_i@-614,_k@-614",
    get$lastChar: [function() {
      if (J.$eq(J.get$charCode$x(this.event), 32))
        return "";
      else
        return H.Primitives_stringFromCharCode(J.get$charCode$x(this.pressEvent));
    }, null, null, 1, 0, 810, "lastChar"],
    get$lastKey: [function() {
      return J.$index$asx(this._Phaser$_keys, this._k);
    }, null, null, 1, 0, 1370, "lastKey"],
    addCallbacks$4: [function(context, onDown, onUp, onPress) {
      this.callbackContext = context;
      if (onDown != null)
        this.onDownCallback = onDown;
      if (onUp != null)
        this.onUpCallback = onUp;
      if (onPress != null)
        this.onPressCallback = onPress;
    }, function(context) {
      return this.addCallbacks$4(context, null, null, null);
    }, "addCallbacks$1", function(context, onDown) {
      return this.addCallbacks$4(context, onDown, null, null);
    }, "addCallbacks$2", function(context, onDown, onUp) {
      return this.addCallbacks$4(context, onDown, onUp, null);
    }, "addCallbacks$3", "call$4", "call$1", "call$2", "call$3", "get$addCallbacks", 2, 6, 1371, 12, 12, 12, 142, [], 1372, [], 1373, [], 1374, [], "addCallbacks"],
    addKey$1: [function(_, keycode) {
      if (J.$index$asx(this._Phaser$_keys, keycode) == null) {
        J.$indexSet$ax(this._Phaser$_keys, keycode, R.Key$(this.game, keycode));
        this.addKeyCapture$1(keycode);
      }
      return J.$index$asx(this._Phaser$_keys, keycode);
    }, "call$1", "get$addKey", 2, 0, 1375, 368, [], "addKey"],
    removeKey$1: [function(keycode) {
      if (J.$index$asx(this._Phaser$_keys, keycode) != null) {
        J.$indexSet$ax(this._Phaser$_keys, keycode, null);
        J.remove$1$ax(this._capture, keycode);
      }
    }, "call$1", "get$removeKey", 2, 0, 102, 368, [], "removeKey"],
    createCursorKeys$0: [function() {
      var t1 = new R.CursorKeys(null, null, null, null);
      t1.up = this.addKey$1(0, 38);
      t1.down = this.addKey$1(0, 40);
      t1.left = this.addKey$1(0, 37);
      t1.right = this.addKey$1(0, 39);
      return t1;
    }, "call$0", "get$createCursorKeys", 0, 0, 369, "createCursorKeys"],
    start$0: [function(_) {
      var t1, t2;
      if (this.game.get$device().get$cocoonJS() === true)
        return;
      if (this._onKeyDown != null)
        return;
      t1 = new R.Keyboard_start_closure(this);
      this._onKeyDown = t1;
      this._onKeyUp = new R.Keyboard_start_closure0(this);
      this._onKeyPress = new R.Keyboard_start_closure1(this);
      t2 = window;
      C.Window_methods._addEventListener$3(t2, "keydown", t1, false);
      t1 = window;
      t2 = this._onKeyUp;
      if (t2 != null)
        C.Window_methods._addEventListener$3(t1, "keyup", t2, false);
      t1 = window;
      t2 = this._onKeyPress;
      if (t2 != null)
        C.Window_methods._addEventListener$3(t1, "keypress", t2, false);
    }, "call$0", "get$start", 0, 0, 54, "start"],
    stop$0: [function(_) {
      var t1, t2;
      t1 = window;
      t2 = this._onKeyDown;
      if (t2 != null)
        C.Window_methods._removeEventListener$3(t1, "keydown", t2, null);
      t1 = window;
      t2 = this._onKeyUp;
      if (t2 != null)
        C.Window_methods._removeEventListener$3(t1, "keyup", t2, null);
      t1 = window;
      t2 = this._onKeyPress;
      if (t2 != null)
        C.Window_methods._removeEventListener$3(t1, "keypress", t2, null);
      this._onKeyDown = null;
      this._onKeyUp = null;
      this._onKeyPress = null;
    }, "call$0", "get$stop", 0, 0, 54, "stop"],
    destroy$0: [function() {
      this.stop$0(0);
      this._capture = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      J.clear$0$ax(this._Phaser$_keys);
      this._i = 0;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    addKeyCapture$1: [function(keycode) {
      var t1, t2, key;
      t1 = J.getInterceptor(keycode);
      if (!!t1.$isMap)
        for (t2 = J.get$iterator$ax(t1.get$keys(keycode)); t2.moveNext$0();) {
          key = t2.get$current();
          J.$indexSet$ax(this._capture, t1.$index(keycode, key), true);
        }
      else
        J.$indexSet$ax(this._capture, keycode, true);
    }, "call$1", "get$addKeyCapture", 2, 0, 102, 368, [], "addKeyCapture"],
    removeKeyCapture$1: [function(keycode) {
      J.remove$1$ax(this._capture, keycode);
    }, "call$1", "get$removeKeyCapture", 2, 0, 102, 368, [], "removeKeyCapture"],
    clearCaptures$0: [function() {
      this._capture = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
    }, "call$0", "get$clearCaptures", 0, 0, 54, "clearCaptures"],
    update$0: [function() {
      var t1, t2;
      this._i = J.get$length$asx(this._Phaser$_keys);
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this._Phaser$_keys, this._i) != null)
          J.$index$asx(this._Phaser$_keys, this._i).update$0();
    }, "call$0", "get$update", 0, 0, 54, "update"],
    processKeyDown$1: [function($event) {
      var t1;
      this.event = $event;
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      t1 = J.getInterceptor$x($event);
      if (J.$index$asx(this._capture, t1.get$keyCode($event)) != null)
        t1.preventDefault$0($event);
      if (J.$index$asx(this._Phaser$_keys, t1.get$keyCode($event)) == null)
        J.$indexSet$ax(this._Phaser$_keys, t1.get$keyCode($event), R.Key$(this.game, t1.get$keyCode($event)));
      J.$index$asx(this._Phaser$_keys, t1.get$keyCode($event)).processKeyDown$1($event);
      this._k = t1.get$keyCode($event);
      t1 = this.onDownCallback;
      if (t1 != null)
        t1.call$2(this.callbackContext, $event);
    }, "call$1", "get$processKeyDown", 2, 0, 102, 666, [], "processKeyDown"],
    processKeyPress$1: [function($event) {
      var t1;
      this.pressEvent = $event;
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      t1 = this.onPressCallback;
      if (t1 != null)
        t1.call$3(this.callbackContext, H.Primitives_stringFromCharCode(J.get$charCode$x($event)), $event);
    }, "call$1", "get$processKeyPress", 2, 0, 102, 666, [], "processKeyPress"],
    processKeyUp$1: [function($event) {
      var t1;
      this.event = $event;
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      t1 = J.getInterceptor$x($event);
      if (J.$index$asx(this._capture, t1.get$keyCode($event)) != null)
        t1.preventDefault$0($event);
      if (J.$index$asx(this._Phaser$_keys, t1.get$keyCode($event)) == null)
        J.$indexSet$ax(this._Phaser$_keys, t1.get$keyCode($event), R.Key$(this.game, t1.get$keyCode($event)));
      J.$index$asx(this._Phaser$_keys, t1.get$keyCode($event)).processKeyUp$1($event);
      t1 = this.onUpCallback;
      if (t1 != null)
        t1.call$2(this.callbackContext, $event);
    }, "call$1", "get$processKeyUp", 2, 0, 102, 666, [], "processKeyUp"],
    reset$1: [function(_, hard) {
      var i, t1, i0;
      this.event = null;
      i = J.get$length$asx(this._Phaser$_keys);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        if (J.$index$asx(this._Phaser$_keys, i0) != null)
          J.reset$1$x(J.$index$asx(this._Phaser$_keys, i0), hard);
    }, function($receiver) {
      return this.reset$1($receiver, true);
    }, "reset$0", "call$1", "call$0", "get$reset", 0, 2, 956, 78, 1324, [], "reset"],
    justPressed$2: [function(keycode, duration) {
      if (J.$index$asx(this._Phaser$_keys, keycode) != null)
        return J.$index$asx(this._Phaser$_keys, keycode).justPressed$1(duration);
      else
        return false;
    }, function(keycode) {
      return this.justPressed$2(keycode, 50);
    }, "justPressed$1", "call$2", "call$1", "get$justPressed", 2, 2, 1376, 406, 368, [], 94, [], "justPressed"],
    justReleased$2: [function(keycode, duration) {
      if (J.$index$asx(this._Phaser$_keys, keycode) != null)
        return J.$index$asx(this._Phaser$_keys, keycode).justReleased$1(duration);
      else
        return false;
    }, function(keycode) {
      return this.justReleased$2(keycode, 50);
    }, "justReleased$1", "call$2", "call$1", "get$justReleased", 2, 2, 1377, 406, 368, [], 94, [], "justReleased"],
    isDown$1: [function(keycode) {
      if (J.$index$asx(this._Phaser$_keys, keycode) != null)
        return J.$index$asx(this._Phaser$_keys, keycode).get$isDown();
      return false;
    }, "call$1", "get$isDown", 2, 0, 99, 368, [], "isDown"],
    Keyboard$1: function(game) {
      this.disabled = false;
      this.event = null;
      this.pressEvent = null;
      this.callbackContext = this;
      this.onDownCallback = null;
      this.onPressCallback = null;
      this.onUpCallback = null;
      this._Phaser$_keys = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._capture = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._onKeyDown = null;
      this._onKeyPress = null;
      this._onKeyUp = null;
      this._i = 0;
      this._k = 0;
    },
    static: {"^": "Keyboard_A<-614,Keyboard_B<-614,Keyboard_C<-614,Keyboard_D<-614,Keyboard_E<-614,Keyboard_F<-614,Keyboard_G<-614,Keyboard_H<-614,Keyboard_I<-614,Keyboard_J<-614,Keyboard_K<-614,Keyboard_L<-614,Keyboard_M<-614,Keyboard_N<-614,Keyboard_O<-614,Keyboard_P<-614,Keyboard_Q<-614,Keyboard_R<-614,Keyboard_S<-614,Keyboard_T<-614,Keyboard_U<-614,Keyboard_V<-614,Keyboard_W<-614,Keyboard_X<-614,Keyboard_Y<-614,Keyboard_Z<-614,Keyboard_ZERO<-614,Keyboard_ONE<-614,Keyboard_TWO<-614,Keyboard_THREE<-614,Keyboard_FOUR<-614,Keyboard_FIVE<-614,Keyboard_SIX<-614,Keyboard_SEVEN<-614,Keyboard_EIGHT<-614,Keyboard_NINE<-614,Keyboard_NUMPAD_0<-614,Keyboard_NUMPAD_1<-614,Keyboard_NUMPAD_2<-614,Keyboard_NUMPAD_3<-614,Keyboard_NUMPAD_4<-614,Keyboard_NUMPAD_5<-614,Keyboard_NUMPAD_6<-614,Keyboard_NUMPAD_7<-614,Keyboard_NUMPAD_8<-614,Keyboard_NUMPAD_9<-614,Keyboard_NUMPAD_MULTIPLY<-614,Keyboard_NUMPAD_ADD<-614,Keyboard_NUMPAD_ENTER<-614,Keyboard_NUMPAD_SUBTRACT<-614,Keyboard_NUMPAD_DECIMAL<-614,Keyboard_NUMPAD_DIVIDE<-614,Keyboard_F1<-614,Keyboard_F2<-614,Keyboard_F3<-614,Keyboard_F4<-614,Keyboard_F5<-614,Keyboard_F6<-614,Keyboard_F7<-614,Keyboard_F8<-614,Keyboard_F9<-614,Keyboard_F10<-614,Keyboard_F11<-614,Keyboard_F12<-614,Keyboard_F13<-614,Keyboard_F14<-614,Keyboard_F15<-614,Keyboard_COLON<-614,Keyboard_EQUALS<-614,Keyboard_UNDERSCORE<-614,Keyboard_QUESTION_MARK<-614,Keyboard_TILDE<-614,Keyboard_OPEN_BRACKET<-614,Keyboard_BACKWARD_SLASH<-614,Keyboard_CLOSED_BRACKET<-614,Keyboard_QUOTES<-614,Keyboard_BACKSPACE<-614,Keyboard_TAB<-614,Keyboard_CLEAR<-614,Keyboard_ENTER<-614,Keyboard_SHIFT<-614,Keyboard_CONTROL<-614,Keyboard_ALT<-614,Keyboard_CAPS_LOCK<-614,Keyboard_ESC<-614,Keyboard_SPACEBAR<-614,Keyboard_PAGE_UP<-614,Keyboard_PAGE_DOWN<-614,Keyboard_END<-614,Keyboard_HOME<-614,Keyboard_LEFT<-614,Keyboard_UP<-614,Keyboard_RIGHT<-614,Keyboard_DOWN<-614,Keyboard_INSERT<-614,Keyboard_DELETE<-614,Keyboard_HELP<-614,Keyboard_NUM_LOCK<-614,Keyboard_PLUS<-614,Keyboard_MINUS<-614", Keyboard$: [function(game) {
        var t1 = new R.Keyboard(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Keyboard$1(game);
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new Keyboard"]}
  },
  "+Keyboard": [674],
  Keyboard_start_closure: {
    "^": "Closure:102;_this_0",
    call$1: [function($event) {
      return this._this_0.processKeyDown$1($event);
    }, "call$1", null, 2, 0, 102, 666, [], "call"]
  },
  Keyboard_start_closure0: {
    "^": "Closure:102;_this_1",
    call$1: [function($event) {
      return this._this_1.processKeyUp$1($event);
    }, "call$1", null, 2, 0, 102, 666, [], "call"]
  },
  Keyboard_start_closure1: {
    "^": "Closure:102;_this_2",
    call$1: [function($event) {
      return this._this_2.processKeyPress$1($event);
    }, "call$1", null, 2, 0, 102, 666, [], "call"]
  },
  Mouse: {
    "^": "Object;game@-613,mouseDownCallback@-0,mouseMoveCallback@-0,mouseUpCallback@-0,mouseOutCallback@-0,mouseOverCallback@-0,mouseWheelCallback@-0,capture*-617,button*-614,wheelDelta@-616,disabled*-617,locked@-617,stopOnGameOut@-617,pointerLock@-1145,event@-1378,_onMouseDown@-0,_onMouseMove@-0,_onMouseUp@-0,_onMouseUpGlobal@-0,_onMouseOut@-0,_onMouseOver@-0,_onMouseWheel@-0,_pointerLockChange@-0",
    mouseDownCallback$1: function(arg0) {
      return this.mouseDownCallback.call$1(arg0);
    },
    mouseMoveCallback$1: function(arg0) {
      return this.mouseMoveCallback.call$1(arg0);
    },
    mouseUpCallback$1: function(arg0) {
      return this.mouseUpCallback.call$1(arg0);
    },
    mouseOutCallback$1: function(arg0) {
      return this.mouseOutCallback.call$1(arg0);
    },
    mouseOverCallback$1: function(arg0) {
      return this.mouseOverCallback.call$1(arg0);
    },
    mouseWheelCallback$1: function(arg0) {
      return this.mouseWheelCallback.call$1(arg0);
    },
    button$9: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
      return this.button.call$9(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    },
    button$8: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      return this.button.call$8(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
    },
    start$0: [function(_) {
      var t1, t2;
      if (this.game.get$device().get$android() === true && J.$eq(this.game.get$device().get$chrome(), false))
        return;
      if (this._onMouseDown != null)
        return;
      this._onMouseDown = new R.Mouse_start_closure(this);
      this._onMouseMove = new R.Mouse_start_closure0(this);
      this._onMouseUp = new R.Mouse_start_closure1(this);
      this._onMouseUpGlobal = new R.Mouse_start_closure2(this);
      this._onMouseOut = new R.Mouse_start_closure3(this);
      this._onMouseOver = new R.Mouse_start_closure4(this);
      this._onMouseWheel = new R.Mouse_start_closure5(this);
      J.addEventListener$3$x(J.get$canvas$x(this.game), "mousedown", this._onMouseDown, true);
      J.addEventListener$3$x(J.get$canvas$x(this.game), "mousemove", this._onMouseMove, true);
      J.addEventListener$3$x(J.get$canvas$x(this.game), "mouseup", this._onMouseUp, true);
      J.addEventListener$3$x(J.get$canvas$x(this.game), "mousewheel", this._onMouseWheel, true);
      J.addEventListener$3$x(J.get$canvas$x(this.game), "DOMMouseScroll", this._onMouseWheel, true);
      if (this.game.get$device().get$cocoonJS() !== true) {
        t1 = window;
        t2 = this._onMouseUpGlobal;
        if (t2 != null)
          C.Window_methods._addEventListener$3(t1, "mouseup", t2, true);
        J.addEventListener$3$x(J.get$canvas$x(this.game), "mouseover", this._onMouseOver, true);
        J.addEventListener$3$x(J.get$canvas$x(this.game), "mouseout", this._onMouseOut, true);
        J.addEventListener$3$x(J.get$canvas$x(this.game), "mousewheel", this._onMouseWheel, true);
        J.addEventListener$3$x(J.get$canvas$x(this.game), "DOMMouseScroll", this._onMouseWheel, true);
      }
    }, "call$0", "get$start", 0, 0, 54, "start"],
    onMouseDown$1: [function(_, $event) {
      this.event = $event;
      if (this.capture === true)
        J.preventDefault$0$x($event);
      this.button = J.get$button$x($event);
      if (this.mouseDownCallback != null)
        this.mouseDownCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      J.start$1$x(this.game.get$input().get$mousePointer(), $event);
    }, "call$1", "get$onMouseDown", 2, 0, 842, 666, [], "onMouseDown"],
    onMouseMove$1: [function(_, $event) {
      this.event = $event;
      if (this.capture === true)
        J.preventDefault$0$x($event);
      if (this.mouseMoveCallback != null)
        this.mouseMoveCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      this.game.get$input().get$mousePointer().move$1($event);
    }, "call$1", "get$onMouseMove", 2, 0, 842, 666, [], "onMouseMove"],
    onMouseUp$1: [function(_, $event) {
      this.event = $event;
      if (this.capture === true)
        J.preventDefault$0$x($event);
      this.button = -1;
      if (this.mouseUpCallback != null)
        this.mouseUpCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      J.stop$1$x(this.game.get$input().get$mousePointer(), $event);
    }, "call$1", "get$onMouseUp", 2, 0, 842, 666, [], "onMouseUp"],
    onMouseUpGlobal$1: [function($event) {
      if (this.game.get$input().get$mousePointer().get$withinGame() !== true) {
        this.button = -1;
        if (this.mouseUpCallback != null)
          this.mouseUpCallback$1($event);
        J.stop$1$x(this.game.get$input().get$mousePointer(), $event);
      }
    }, "call$1", "get$onMouseUpGlobal", 2, 0, 842, 666, [], "onMouseUpGlobal"],
    onMouseOut$1: [function(_, $event) {
      this.event = $event;
      if (this.capture === true)
        J.preventDefault$0$x($event);
      this.game.get$input().get$mousePointer().set$withinGame(false);
      if (this.mouseOutCallback != null)
        this.mouseOutCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      if (this.stopOnGameOut != null)
        J.stop$1$x(this.game.get$input().get$mousePointer(), $event);
    }, "call$1", "get$onMouseOut", 2, 0, 842, 666, [], "onMouseOut"],
    onMouseWheel$1: [function(_, $event) {
      var val;
      this.event = $event;
      if (this.capture === true)
        J.preventDefault$0$x($event);
      val = $event.get$wheelDeltaY();
      this.wheelDelta = P.max(-1, P.min(1, val));
      if (this.mouseWheelCallback != null)
        this.mouseWheelCallback$1($event);
    }, "call$1", "get$onMouseWheel", 2, 0, 1379, 666, [], "onMouseWheel"],
    onMouseOver$1: [function(_, $event) {
      this.event = $event;
      if (this.capture === true)
        J.preventDefault$0$x($event);
      this.game.get$input().get$mousePointer().set$withinGame(true);
      if (this.mouseOverCallback != null)
        this.mouseOverCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
    }, "call$1", "get$onMouseOver", 2, 0, 842, 666, [], "onMouseOver"],
    requestPointerLock$0: [function(_) {
      var element, t1, t2;
      if (this.game.get$device().get$pointerLock() === true) {
        element = J.get$canvas$x(this.game);
        t1 = J.getInterceptor$x(element);
        t1.set$requestPointerLock(element, t1.get$requestPointerLock(element));
        t1.requestPointerLock$0(element);
        t1 = new R.Mouse_requestPointerLock_closure(this);
        this._pointerLockChange = t1;
        t2 = document;
        C.HtmlDocument_methods._addEventListener$3(t2, "pointerlockchange", t1, true);
        t1 = document;
        t2 = this._pointerLockChange;
        if (t2 != null)
          C.HtmlDocument_methods._addEventListener$3(t1, "mozpointerlockchange", t2, true);
        t1 = document;
        t2 = this._pointerLockChange;
        if (t2 != null)
          C.HtmlDocument_methods._addEventListener$3(t1, "webkitpointerlockchange", t2, true);
      }
    }, "call$0", "get$requestPointerLock", 0, 0, 54, "requestPointerLock"],
    pointerLockChange$1: [function($event) {
      var element, t1;
      element = J.get$canvas$x(this.game);
      t1 = document.pointerLockElement;
      if (t1 == null ? element == null : t1 === element) {
        this.locked = true;
        this.pointerLock.dispatch$1([true, $event]);
      } else {
        this.locked = false;
        this.pointerLock.dispatch$1([false, $event]);
      }
    }, "call$1", "get$pointerLockChange", 2, 0, 102, 666, [], "pointerLockChange"],
    releasePointerLock$0: [function() {
      var t1, t2;
      document.exitPointerLock();
      t1 = document;
      t2 = this._pointerLockChange;
      if (t2 != null)
        C.HtmlDocument_methods._removeEventListener$3(t1, "pointerlockchange", t2, true);
      t1 = document;
      t2 = this._pointerLockChange;
      if (t2 != null)
        C.HtmlDocument_methods._removeEventListener$3(t1, "mozpointerlockchange", t2, true);
      t1 = document;
      t2 = this._pointerLockChange;
      if (t2 != null)
        C.HtmlDocument_methods._removeEventListener$3(t1, "webkitpointerlockchange", t2, true);
    }, "call$0", "get$releasePointerLock", 0, 0, 54, "releasePointerLock"],
    stop$0: [function(_) {
      var t1, t2;
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "mousedown", this._onMouseDown, true);
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "mousemove", this._onMouseMove, true);
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "mouseup", this._onMouseUp, true);
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "mouseover", this._onMouseOver, true);
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "mouseout", this._onMouseOut, true);
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "mousewheel", this._onMouseWheel, true);
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "DOMMouseScroll", this._onMouseWheel, true);
      t1 = window;
      t2 = this._onMouseUpGlobal;
      if (t2 != null)
        C.Window_methods._removeEventListener$3(t1, "mouseup", t2, true);
      t1 = document;
      t2 = this._pointerLockChange;
      if (t2 != null)
        C.HtmlDocument_methods._removeEventListener$3(t1, "pointerlockchange", t2, true);
      t1 = document;
      t2 = this._pointerLockChange;
      if (t2 != null)
        C.HtmlDocument_methods._removeEventListener$3(t1, "mozpointerlockchange", t2, true);
      t1 = document;
      t2 = this._pointerLockChange;
      if (t2 != null)
        C.HtmlDocument_methods._removeEventListener$3(t1, "webkitpointerlockchange", t2, true);
    }, "call$0", "get$stop", 0, 0, 54, "stop"],
    Mouse$1: function(game) {
      this.mouseDownCallback = null;
      this.mouseMoveCallback = null;
      this.mouseUpCallback = null;
      this.mouseOutCallback = null;
      this.mouseOverCallback = null;
      this.mouseWheelCallback = null;
      this.capture = false;
      this.button = -1;
      this.wheelDelta = 0;
      this.disabled = false;
      this.locked = false;
      this.stopOnGameOut = false;
      this.pointerLock = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.event = null;
      this._onMouseDown = null;
      this._onMouseMove = null;
      this._onMouseUp = null;
      this._onMouseOut = null;
      this._onMouseOver = null;
      this._onMouseWheel = null;
    },
    static: {"^": "Mouse_NO_BUTTON<-614,Mouse_LEFT_BUTTON<-614,Mouse_MIDDLE_BUTTON<-614,Mouse_RIGHT_BUTTON<-614,Mouse_WHEEL_UP<-614,Mouse_WHEEL_DOWN<-614", Mouse$: [function(game) {
        var t1 = new R.Mouse(game, null, null, null, null, null, null, false, -1, 0, false, false, false, null, null, null, null, null, null, null, null, null, null);
        t1.Mouse$1(game);
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new Mouse"]}
  },
  "+Mouse": [674],
  Mouse_start_closure: {
    "^": "Closure:842;_this_0",
    call$1: [function($event) {
      return this._this_0.onMouseDown$1(0, $event);
    }, "call$1", null, 2, 0, 842, 666, [], "call"]
  },
  Mouse_start_closure0: {
    "^": "Closure:842;_this_1",
    call$1: [function($event) {
      return this._this_1.onMouseMove$1(0, $event);
    }, "call$1", null, 2, 0, 842, 666, [], "call"]
  },
  Mouse_start_closure1: {
    "^": "Closure:842;_this_2",
    call$1: [function($event) {
      return this._this_2.onMouseUp$1(0, $event);
    }, "call$1", null, 2, 0, 842, 666, [], "call"]
  },
  Mouse_start_closure2: {
    "^": "Closure:842;_this_3",
    call$1: [function($event) {
      var t1 = this._this_3;
      if (t1.game.get$input().get$mousePointer().get$withinGame() !== true) {
        t1.button = -1;
        if (t1.mouseUpCallback != null)
          t1.mouseUpCallback$1($event);
        J.stop$1$x(t1.game.get$input().get$mousePointer(), $event);
      }
      return;
    }, "call$1", null, 2, 0, 842, 666, [], "call"]
  },
  Mouse_start_closure3: {
    "^": "Closure:842;_this_4",
    call$1: [function($event) {
      return this._this_4.onMouseOut$1(0, $event);
    }, "call$1", null, 2, 0, 842, 666, [], "call"]
  },
  Mouse_start_closure4: {
    "^": "Closure:842;_this_5",
    call$1: [function($event) {
      var t1 = this._this_5;
      t1.event = $event;
      if (t1.capture === true)
        J.preventDefault$0$x($event);
      t1.game.get$input().get$mousePointer().set$withinGame(true);
      if (t1.mouseOverCallback != null)
        t1.mouseOverCallback$1($event);
      if (J.get$disabled$x(t1.game.get$input()) === true || t1.disabled === true)
        ;
      return;
    }, "call$1", null, 2, 0, 842, 666, [], "call"]
  },
  Mouse_start_closure5: {
    "^": "Closure:842;_this_6",
    call$1: [function($event) {
      var t1, val;
      t1 = this._this_6;
      t1.event = $event;
      if (t1.capture === true)
        J.preventDefault$0$x($event);
      val = $event.get$wheelDeltaY();
      t1.wheelDelta = P.max(-1, P.min(1, val));
      if (t1.mouseWheelCallback != null)
        t1.mouseWheelCallback$1($event);
      return;
    }, "call$1", null, 2, 0, 842, 666, [], "call"]
  },
  Mouse_requestPointerLock_closure: {
    "^": "Closure:102;_this_0",
    call$1: [function($event) {
      var t1, element, t2;
      t1 = this._this_0;
      element = J.get$canvas$x(t1.game);
      t2 = document.pointerLockElement;
      if (t2 == null ? element == null : t2 === element) {
        t1.locked = true;
        t1.pointerLock.dispatch$1([true, $event]);
      } else {
        t1.locked = false;
        t1.pointerLock.dispatch$1([false, $event]);
      }
      return;
    }, "call$1", null, 2, 0, 102, 666, [], "call"]
  },
  MSPointer: {
    "^": "Object;",
    static: {MSPointer$: [function() {
        return new R.MSPointer();
      }, null, null, 0, 0, 54, "new MSPointer"]}
  },
  "+MSPointer": [674],
  Pointer: {
    "^": "Object;game@-613,id*-614,type*-614,exists@-617,identifier*-614,pointerId@-614,target*-12,button*-12,_holdSent@-617,_history@-645,_nextDrop@-671,_stateReset@-617,withinGame@-617,clientX@-614,clientY@-614,pageX@-614,pageY@-614,screenX*-614,screenY*-614,rawMovementX@-614,rawMovementY@-614,movementX@-614,movementY@-614,x*-616,y*-616,isMouse@-617,isDown@-617,isUp@-617,isOver@-617,isOut@-617,timeOver@-616,timeOut@-616,timeDown@-616,timeUp@-616,downDuration@-616,isDragged@-617,previousTapTime@-616,totalTouches@-614,msSinceLastClick@-616,targetObject@-1141,_highestRenderOrderID@-614,_highestRenderObject@-1141,_highestInputPriorityID@-614,active@-617,position*-615,positionDown@-615,positionUp@-615,circle@-1314,dirty@-617",
    button$9: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
      return this.button.call$9(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    },
    button$8: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      return this.button.call$8(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
    },
    isDown$1: function(arg0) {
      return this.isDown.call$1(arg0);
    },
    downDuration$1: function(arg0) {
      return this.downDuration.call$1(arg0);
    },
    downDuration$0: function() {
      return this.downDuration.call$0();
    },
    circle$4: function(arg0, arg1, arg2, arg3) {
      return this.circle.call$4(arg0, arg1, arg2, arg3);
    },
    get$duration: [function(_) {
      if (this.isUp === true)
        return -1;
      return J.$sub$n(J.get$now$x(this.game.get$time()), this.timeDown);
    }, null, null, 1, 0, 619, "duration"],
    get$worldX: [function() {
      return J.$add$ns(J.get$x$x(this.game.get$world().get$camera()), this.x);
    }, null, null, 1, 0, 619, "worldX"],
    get$worldY: [function() {
      return J.$add$ns(J.get$y$x(this.game.get$world().get$camera()), this.y);
    }, null, null, 1, 0, 619, "worldY"],
    start$1: [function(_, $event) {
      var t1 = J.getInterceptor($event);
      if (!!t1.$isJsObject) {
        this.pointerId = t1.$index($event, "pointerId");
        this.identifier = t1.$index($event, "identifier");
        this.target = t1.$index($event, "target");
      } else if (!!t1.$isMouseEvent)
        this.target = W._convertNativeToDart_EventTarget($event.target);
      else {
        this.identifier = t1.get$identifier($event);
        this.target = t1.get$target($event);
      }
      if (!!t1.$isMouseEvent && $event.button != null)
        this.button = t1.get$button($event);
      this._history = [];
      this.active = true;
      this.withinGame = true;
      this.isDown = true;
      this.isUp = false;
      this.dirty = false;
      this.msSinceLastClick = J.$sub$n(J.get$now$x(this.game.get$time()), this.timeDown);
      this.timeDown = J.get$now$x(this.game.get$time());
      this._holdSent = false;
      this.move$2($event, true);
      this.positionDown.setTo$2(this.x, this.y);
      if (!J.$eq(this.game.get$input().get$multiInputOverride(), 0))
        if (!J.$eq(this.game.get$input().get$multiInputOverride(), 2))
          t1 = J.$eq(this.game.get$input().get$multiInputOverride(), 1) && J.$eq(this.game.get$input().get$currentPointers(), 0);
        else
          t1 = true;
      else
        t1 = true;
      if (t1) {
        J.set$x$x(this.game.get$input(), this.x);
        J.set$y$x(this.game.get$input(), this.y);
        J.get$position$x(this.game.get$input()).setTo$2(this.x, this.y);
        this.game.get$input().get$onDown().dispatch$1([this, $event]);
        this.game.get$input().resetSpeed$2(this.x, this.y);
      }
      this._stateReset = false;
      this.totalTouches = J.$add$ns(this.totalTouches, 1);
      if (this.isMouse !== true) {
        t1 = this.game.get$input();
        t1.set$currentPointers(J.$add$ns(t1.get$currentPointers(), 1));
      }
      t1 = this.targetObject;
      if (t1 != null)
        t1._touchedHandler$1(this);
      return this;
    }, "call$1", "get$start", 2, 0, 102, 666, [], "start"],
    update$0: [function() {
      var t1, t2, t3, t4;
      if (this.active === true) {
        if (this.dirty === true) {
          if (J.$gt$n(J.get$length$asx(this.game.get$input().get$interactiveItems()), 0))
            this.processInteractiveObjects$1(true);
          this.dirty = false;
        }
        if (J.$eq(this._holdSent, false) && J.$ge$n(this.get$duration(this), this.game.get$input().get$holdRate())) {
          if (!J.$eq(this.game.get$input().get$multiInputOverride(), 0))
            if (!J.$eq(this.game.get$input().get$multiInputOverride(), 2))
              t1 = J.$eq(this.game.get$input().get$multiInputOverride(), 1) && J.$eq(this.game.get$input().get$currentPointers(), 0);
            else
              t1 = true;
          else
            t1 = true;
          if (t1)
            this.game.get$input().get$onHold().dispatch$1(this);
          this._holdSent = true;
        }
        if (this.game.get$input().get$recordPointerHistory() === true && J.$ge$n(J.get$now$x(this.game.get$time()), this._nextDrop)) {
          this._nextDrop = J.$add$ns(J.get$now$x(this.game.get$time()), this.game.get$input().get$recordRate());
          t1 = this._history;
          t2 = J.get$x$x(this.position);
          t3 = this.x;
          t4 = J.get$y$x(this.position);
          J.add$1$ax(t1, P.LinkedHashMap_LinkedHashMap$_literal([t3, t2, this.y, t4], null, null));
          if (J.$gt$n(J.get$length$asx(this._history), this.game.get$input().get$recordLimit()))
            J.removeAt$1$ax(this._history, 0);
        }
      }
    }, "call$0", "get$update", 0, 0, 54, "update"],
    move$2: [function($event, fromClick) {
      var t1, t2, i, i0;
      if (this.game.get$input().get$pollLocked())
        return this;
      t1 = J.getInterceptor($event);
      if (!!t1.$isMouseEvent && $event.button != null)
        this.button = t1.get$button($event);
      if (!!t1.$isJsObject) {
        this.clientX = t1.$index($event, "clientX");
        this.clientY = t1.$index($event, "clientY");
        this.pageX = t1.$index($event, "pageX");
        this.pageY = t1.$index($event, "pageY");
        this.screenX = t1.$index($event, "screenX");
        this.screenY = t1.$index($event, "screenY");
      } else {
        t2 = t1.get$client($event);
        this.clientX = t2.get$x(t2);
        t2 = t1.get$client($event);
        this.clientY = t2.get$y(t2);
        this.pageX = J.get$x$x(t1.get$page($event));
        this.pageY = J.get$y$x(t1.get$page($event));
        this.screenX = J.get$x$x(t1.get$screen($event));
        this.screenY = J.get$y$x(t1.get$screen($event));
      }
      if (this.isMouse === true && this.game.get$input().get$mouse().get$locked() === true && fromClick !== true) {
        this.rawMovementX = t1.get$movement($event).x;
        this.rawMovementY = t1.get$movement($event).y;
        this.movementX = J.$add$ns(this.movementX, this.rawMovementX);
        this.movementY = J.$add$ns(this.movementY, this.rawMovementY);
      }
      this.x = J.$mul$ns(J.$sub$n(this.pageX, J.get$x$x(J.get$offset$x(J.get$scale$x(this.game)))), J.get$x$x(J.get$scale$x(this.game.get$input())));
      t1 = J.$mul$ns(J.$sub$n(this.pageY, J.get$y$x(J.get$offset$x(J.get$scale$x(this.game)))), J.get$y$x(J.get$scale$x(this.game.get$input())));
      this.y = t1;
      this.position.setTo$2(this.x, t1);
      J.set$x$x(this.circle, this.x);
      J.set$y$x(this.circle, this.y);
      if (!J.$eq(this.game.get$input().get$multiInputOverride(), 0))
        if (!J.$eq(this.game.get$input().get$multiInputOverride(), 2))
          t1 = J.$eq(this.game.get$input().get$multiInputOverride(), 1) && J.$eq(this.game.get$input().get$currentPointers(), 0);
        else
          t1 = true;
      else
        t1 = true;
      if (t1) {
        this.game.get$input().set$activePointer(this);
        J.set$x$x(this.game.get$input(), this.x);
        J.set$y$x(this.game.get$input(), this.y);
        J.get$position$x(this.game.get$input()).setTo$2(J.get$x$x(this.game.get$input()), J.get$y$x(this.game.get$input()));
        J.set$x$x(this.game.get$input().get$circle(), J.get$x$x(this.game.get$input()));
        J.set$y$x(this.game.get$input().get$circle(), J.get$y$x(this.game.get$input()));
      }
      this.withinGame = J.contains$2$asx(J.get$scale$x(this.game).get$bounds(), this.pageX, this.pageY);
      if (J.get$paused$x(this.game) === true)
        return this;
      i = J.get$length$asx(this.game.get$input().get$moveCallbacks());
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(J.$index$asx(this.game.get$input().get$moveCallbacks(), i0), "callback").call$3(this.x, this.y, fromClick);
      t1 = this.targetObject;
      if (t1 != null && J.$eq(t1.get$isDragged(), true)) {
        if (J.$eq(this.targetObject.update$1(this), false))
          this.targetObject = null;
      } else if (J.$gt$n(J.get$length$asx(this.game.get$input().get$interactiveItems()), 0))
        this.processInteractiveObjects$1(fromClick);
      return this;
    }, function(event) {
      return this.move$2(event, false);
    }, "move$1", "call$2", "call$1", "get$move", 2, 2, 1380, 19, 666, [], 1381, [], "move"],
    processInteractiveObjects$1: [function(fromClick) {
      var t1, t2;
      J.forEach$1$ax(this.game.get$input().get$interactiveItems(), new R.Pointer_processInteractiveObjects_closure());
      this._highestRenderOrderID = C.JSInt_methods.toInt$0(179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368);
      this._highestRenderObject = null;
      this._highestInputPriorityID = -1;
      J.forEach$1$ax(this.game.get$input().get$interactiveItems(), new R.Pointer_processInteractiveObjects_closure0(this, fromClick));
      J.forEach$1$ax(this.game.get$input().get$interactiveItems(), new R.Pointer_processInteractiveObjects_closure1(this, fromClick));
      t1 = this._highestRenderObject;
      if (t1 == null) {
        t1 = this.targetObject;
        if (t1 != null) {
          t1._pointerOutHandler$1(this);
          this.targetObject = null;
        }
      } else {
        t2 = this.targetObject;
        if (t2 == null) {
          this.targetObject = t1;
          t1._pointerOverHandler$1(this);
        } else if (J.$eq(t2, t1)) {
          if (J.$eq(this._highestRenderObject.update$1(this), false))
            this.targetObject = null;
        } else {
          this.targetObject._pointerOutHandler$1(this);
          t1 = this._highestRenderObject;
          this.targetObject = t1;
          t1._pointerOverHandler$1(this);
        }
      }
      return this.targetObject != null;
    }, function() {
      return this.processInteractiveObjects$1(false);
    }, "processInteractiveObjects$0", "call$1", "call$0", "get$processInteractiveObjects", 0, 2, 1382, 19, 1381, [], "processInteractiveObjects"],
    leave$1: [function($event) {
      this.withinGame = false;
      this.move$2($event, false);
    }, "call$1", "get$leave", 2, 0, 102, 666, [], "leave"],
    stop$1: [function(_, $event) {
      var t1, t2, i, i0;
      if (this._stateReset === true) {
        J.preventDefault$0$x($event);
        return this;
      }
      this.timeUp = J.get$now$x(this.game.get$time());
      if (!J.$eq(this.game.get$input().get$multiInputOverride(), 0))
        if (!J.$eq(this.game.get$input().get$multiInputOverride(), 2))
          t1 = J.$eq(this.game.get$input().get$multiInputOverride(), 1) && J.$eq(this.game.get$input().get$currentPointers(), 0);
        else
          t1 = true;
      else
        t1 = true;
      if (t1) {
        this.game.get$input().get$onUp().dispatch$1([this, $event]);
        if (J.$ge$n(this.get$duration(this), 0) && J.$le$n(this.get$duration(this), this.game.get$input().get$tapRate())) {
          t1 = J.$lt$n(J.$sub$n(this.timeUp, this.previousTapTime), this.game.get$input().get$doubleTapRate());
          t2 = this.game;
          if (t1)
            t2.get$input().get$onTap().dispatch$1([this, true]);
          else
            t2.get$input().get$onTap().dispatch$1([this, false]);
          this.previousTapTime = this.timeUp;
        }
      }
      if (J.$gt$n(this.id, 0))
        this.active = false;
      this.withinGame = false;
      this.isDown = false;
      this.isUp = true;
      this.pointerId = null;
      this.identifier = null;
      this.positionUp.setTo$2(this.x, this.y);
      if (J.$eq(this.isMouse, false)) {
        t1 = this.game.get$input();
        t1.set$currentPointers(J.$sub$n(t1.get$currentPointers(), 1));
      }
      i = J.get$length$asx(this.game.get$input().get$interactiveItems());
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this.game.get$input().get$interactiveItems(), i0)._releasedHandler$1(this);
      this.targetObject = null;
      return this;
    }, "call$1", "get$stop", 2, 0, 1325, 666, [], "stop"],
    justPressed$1: [function(duration) {
      if (duration == null)
        duration = this.game.get$input().get$justPressedRate();
      return J.$eq(this.isDown, true) && J.$gt$n(J.$add$ns(this.timeDown, duration), J.get$now$x(this.game.get$time()));
    }, function() {
      return this.justPressed$1(null);
    }, "justPressed$0", "call$1", "call$0", "get$justPressed", 0, 2, 1341, 12, 94, [], "justPressed"],
    justReleased$1: [function(duration) {
      if (duration == null)
        duration = this.game.get$input().get$justPressedRate();
      return J.$eq(this.isUp, true) && J.$gt$n(J.$add$ns(this.timeUp, duration), J.get$now$x(this.game.get$time()));
    }, function() {
      return this.justReleased$1(null);
    }, "justReleased$0", "call$1", "call$0", "get$justReleased", 0, 2, 1341, 12, 94, [], "justReleased"],
    reset$0: [function(_) {
      var t1;
      if (J.$eq(this.isMouse, false))
        this.active = false;
      this.pointerId = null;
      this.identifier = null;
      this.dirty = false;
      this.isDown = false;
      this.isUp = true;
      this.totalTouches = 0;
      this._holdSent = false;
      J.set$length$asx(this._history, 0);
      this._stateReset = true;
      t1 = this.targetObject;
      if (t1 != null)
        t1._releasedHandler$1(this);
      this.targetObject = null;
    }, "call$0", "get$reset", 0, 0, 54, "reset"],
    resetMovement$0: [function() {
      this.movementX = 0;
      this.movementY = 0;
    }, "call$0", "get$resetMovement", 0, 0, 54, "resetMovement"],
    Pointer$2: function(game, id) {
      var t1;
      this.game = this.game;
      this.id = this.id;
      this.type = 19;
      this.exists = true;
      this.identifier = 0;
      this.pointerId = null;
      this.target = null;
      this.button = null;
      this._holdSent = false;
      this._history = [];
      this._nextDrop = 0;
      this._stateReset = false;
      this.withinGame = false;
      this.clientX = -1;
      this.clientY = -1;
      this.pageX = -1;
      this.pageY = -1;
      this.screenX = -1;
      this.screenY = -1;
      this.rawMovementX = 0;
      this.rawMovementY = 0;
      this.movementX = 0;
      this.movementY = 0;
      this.x = -1;
      this.y = -1;
      this.isMouse = false;
      this.isDown = false;
      this.isUp = true;
      this.timeDown = 0;
      this.timeUp = 0;
      this.previousTapTime = 0;
      this.totalTouches = 0;
      this.msSinceLastClick = 999999999;
      this.targetObject = null;
      this.active = false;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.position = t1;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.positionDown = t1;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.positionUp = t1;
      this.circle = R.Circle$(0, 0, 44);
      if (J.$eq(this.id, 0))
        this.isMouse = true;
    },
    $isPointer: true,
    static: {Pointer$: [function(game, id) {
        var t1 = new R.Pointer(game, id, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 999999999, null, null, null, null, null, null, null, null, null, false);
        t1.Pointer$2(game, id);
        return t1;
      }, null, null, 4, 0, 367, 252, [], 221, [], "new Pointer"]}
  },
  "+Pointer": [674],
  Pointer_processInteractiveObjects_closure: {
    "^": "Closure:1383;",
    call$1: [function(i) {
      J.set$checked$x(i, false);
    }, "call$1", null, 2, 0, 1383, 424, [], "call"]
  },
  Pointer_processInteractiveObjects_closure0: {
    "^": "Closure:1383;this_0,fromClick_1",
    call$1: [function(currentNode) {
      var t1;
      if (currentNode != null) {
        t1 = this.this_0;
        t1 = currentNode.validForInput$3(t1._highestInputPriorityID, t1._highestRenderOrderID, false);
      } else
        t1 = false;
      if (t1) {
        J.set$checked$x(currentNode, true);
        t1 = this.fromClick_1 === true;
        if (!(t1 && currentNode.checkPointerDown$2(this.this_0, true)))
          t1 = !t1 && currentNode.checkPointerOver$2(this.this_0, true);
        else
          t1 = true;
        if (t1) {
          t1 = this.this_0;
          t1._highestRenderOrderID = J.$index$asx(currentNode.get$sprite().get$_cache(), 3);
          t1._highestInputPriorityID = currentNode.get$priorityID();
          t1._highestRenderObject = currentNode;
        }
      }
    }, "call$1", null, 2, 0, 1383, 1384, [], "call"]
  },
  Pointer_processInteractiveObjects_closure1: {
    "^": "Closure:1383;this_2,fromClick_3",
    call$1: [function(currentNode) {
      var t1;
      if (currentNode != null)
        if (J.get$checked$x(currentNode) !== true) {
          t1 = this.this_2;
          t1 = currentNode.validForInput$3(t1._highestInputPriorityID, t1._highestRenderOrderID, true);
        } else
          t1 = false;
      else
        t1 = false;
      if (t1) {
        t1 = this.fromClick_3 === true;
        if (!(t1 && currentNode.checkPointerDown$2(this.this_2, false)))
          t1 = !t1 && currentNode.checkPointerOver$2(this.this_2, false);
        else
          t1 = true;
        if (t1) {
          t1 = this.this_2;
          t1._highestRenderOrderID = J.$index$asx(currentNode.get$sprite().get$_cache(), 3);
          t1._highestInputPriorityID = currentNode.get$priorityID();
          t1._highestRenderObject = currentNode;
        }
      }
    }, "call$1", null, 2, 0, 1383, 1384, [], "call"]
  },
  SinglePad: {
    "^": "Object;",
    static: {SinglePad$: [function() {
        return new R.SinglePad();
      }, null, null, 0, 0, 54, "new SinglePad"]}
  },
  "+SinglePad": [674],
  Touch: {
    "^": "Object;game@-613,disabled*-617,touchStartCallback@-0,touchMoveCallback@-0,touchEndCallback@-0,touchEnterCallback@-0,touchLeaveCallback@-0,touchCancelCallback@-0,preventDefault*-617,event@-1385,onTouchStartListener@-1386,onTouchMoveListener@-1386,onTouchEndListener@-1386,onTouchCancelListener@-1386,onTouchEnterListener@-1386,onTouchLeaveListener@-1386",
    touchStartCallback$1: function(arg0) {
      return this.touchStartCallback.call$1(arg0);
    },
    touchMoveCallback$1: function(arg0) {
      return this.touchMoveCallback.call$1(arg0);
    },
    touchEndCallback$1: function(arg0) {
      return this.touchEndCallback.call$1(arg0);
    },
    touchEnterCallback$1: function(arg0) {
      return this.touchEnterCallback.call$1(arg0);
    },
    touchLeaveCallback$1: function(arg0) {
      return this.touchLeaveCallback.call$1(arg0);
    },
    touchCancelCallback$1: function(arg0) {
      return this.touchCancelCallback.call$1(arg0);
    },
    preventDefault$0: function($receiver) {
      return this.preventDefault.call$0();
    },
    start$0: [function(_) {
      var t1;
      if (this.game.get$device().get$touch() === true) {
        P.print("touch enabled!");
        t1 = C.EventStreamProvider_touchstart.forTarget$1(document);
        t1 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$onTouchStart(this)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
        t1._tryResume$0();
        this.onTouchStartListener = t1;
        t1 = C.EventStreamProvider_touchmove.forTarget$1(document);
        t1 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$onTouchMove(this)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
        t1._tryResume$0();
        this.onTouchMoveListener = t1;
        t1 = C.EventStreamProvider_touchend.forTarget$1(document);
        t1 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$onTouchEnd(this)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
        t1._tryResume$0();
        this.onTouchEndListener = t1;
        t1 = C.EventStreamProvider_touchcancel.forTarget$1(document);
        t1 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$onTouchCancel(this)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
        t1._tryResume$0();
        this.onTouchCancelListener = t1;
        if (this.game.get$device().get$cocoonJS() !== true) {
          this.onTouchEnterListener = J.get$onTouchEnter$x(J.get$canvas$x(this.game)).listen$1(this.get$onTouchEnter(this));
          this.onTouchLeaveListener = J.get$onTouchLeave$x(J.get$canvas$x(this.game)).listen$1(this.get$onTouchLeave(this));
        }
      }
    }, "call$0", "get$start", 0, 0, 54, "start"],
    consumeDocumentTouches$0: [function() {
    }, "call$0", "get$consumeDocumentTouches", 0, 0, 54, "consumeDocumentTouches"],
    onTouchStart$1: [function(_, $event) {
      var t1, changedTouches, i, touchEvent;
      this.event = $event;
      if (this.touchStartCallback != null)
        this.touchStartCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      if (this.preventDefault === true)
        J.preventDefault$0$x($event);
      if (this.game.get$device().get$cocoonJS() === true) {
        t1 = [];
        C.JSArray_methods.addAll$1(t1, J.map$1$ax(J.$index$asx(P.JsObject_JsObject$fromBrowserObject($event), "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t1), [null]);
        for (i = 0; i < changedTouches.get$length(changedTouches); ++i) {
          if (i === C.JSInt_methods.toInt$0(i))
            if (i >= changedTouches.get$length(changedTouches))
              H.throwExpression(P.RangeError$range(i, 0, changedTouches.get$length(changedTouches), null, null));
          touchEvent = P.JsObject_JsObject$fromBrowserObject(P.JsObject.prototype.$index.call(changedTouches, changedTouches, i));
          this.game.get$input().startPointer$1(touchEvent);
        }
      } else {
        changedTouches = J.get$changedTouches$x($event);
        for (i = 0; i < changedTouches.length; ++i) {
          t1 = this.game.get$input();
          if (i >= changedTouches.length)
            return H.ioore(changedTouches, i);
          t1.startPointer$1(changedTouches[i]);
        }
      }
    }, "call$1", "get$onTouchStart", 2, 0, 1387, 666, [], "onTouchStart"],
    onTouchCancel$1: [function(_, $event) {
      var t1, changedTouches, i, touchEvent;
      this.event = $event;
      if (this.touchCancelCallback != null)
        this.touchCancelCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      if (this.preventDefault === true)
        J.preventDefault$0$x($event);
      if (this.game.get$device().get$cocoonJS() === true) {
        t1 = [];
        C.JSArray_methods.addAll$1(t1, J.map$1$ax(J.$index$asx(P.JsObject_JsObject$fromBrowserObject($event), "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t1), [null]);
        for (i = 0; i < changedTouches.get$length(changedTouches); ++i) {
          if (i === C.JSInt_methods.toInt$0(i))
            if (i >= changedTouches.get$length(changedTouches))
              H.throwExpression(P.RangeError$range(i, 0, changedTouches.get$length(changedTouches), null, null));
          touchEvent = P.JsObject_JsObject$fromBrowserObject(P.JsObject.prototype.$index.call(changedTouches, changedTouches, i));
          this.game.get$input().stopPointer$1(touchEvent);
        }
      } else {
        changedTouches = J.get$changedTouches$x($event);
        for (i = 0; i < changedTouches.length; ++i) {
          t1 = this.game.get$input();
          if (i >= changedTouches.length)
            return H.ioore(changedTouches, i);
          t1.stopPointer$1(changedTouches[i]);
        }
      }
    }, "call$1", "get$onTouchCancel", 2, 0, 1387, 666, [], "onTouchCancel"],
    onTouchEnter$1: [function(_, $event) {
      this.event = $event;
      if (this.touchEnterCallback != null)
        this.touchEnterCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      if (this.preventDefault === true)
        J.preventDefault$0$x($event);
    }, "call$1", "get$onTouchEnter", 2, 0, 1387, 666, [], "onTouchEnter"],
    onTouchLeave$1: [function(_, $event) {
      this.event = $event;
      if (this.touchLeaveCallback != null)
        this.touchLeaveCallback$1($event);
      if (this.preventDefault === true)
        J.preventDefault$0$x($event);
    }, "call$1", "get$onTouchLeave", 2, 0, 1387, 666, [], "onTouchLeave"],
    onTouchMove$1: [function(_, $event) {
      var t1, changedTouches, i, touchEvent;
      this.event = $event;
      if (this.touchMoveCallback != null)
        this.touchMoveCallback$1($event);
      if (this.preventDefault === true)
        J.preventDefault$0$x($event);
      if (this.game.get$device().get$cocoonJS() === true) {
        t1 = [];
        C.JSArray_methods.addAll$1(t1, J.map$1$ax(J.$index$asx(P.JsObject_JsObject$fromBrowserObject($event), "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t1), [null]);
        for (i = 0; i < changedTouches.get$length(changedTouches); ++i) {
          if (i === C.JSInt_methods.toInt$0(i))
            if (i >= changedTouches.get$length(changedTouches))
              H.throwExpression(P.RangeError$range(i, 0, changedTouches.get$length(changedTouches), null, null));
          touchEvent = P.JsObject_JsObject$fromBrowserObject(P.JsObject.prototype.$index.call(changedTouches, changedTouches, i));
          this.game.get$input().updatePointer$1(touchEvent);
        }
      } else {
        changedTouches = J.get$changedTouches$x($event);
        for (i = 0; i < changedTouches.length; ++i) {
          t1 = this.game.get$input();
          if (i >= changedTouches.length)
            return H.ioore(changedTouches, i);
          t1.updatePointer$1(changedTouches[i]);
        }
      }
    }, "call$1", "get$onTouchMove", 2, 0, 1387, 666, [], "onTouchMove"],
    onTouchEnd$1: [function(_, $event) {
      var t1, changedTouches, i, touchEvent;
      this.event = $event;
      if (this.touchEndCallback != null)
        this.touchEndCallback$1($event);
      if (this.preventDefault === true)
        J.preventDefault$0$x($event);
      if (this.game.get$device().get$cocoonJS() === true) {
        t1 = [];
        C.JSArray_methods.addAll$1(t1, J.map$1$ax(J.$index$asx(P.JsObject_JsObject$fromBrowserObject($event), "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t1), [null]);
        for (i = 0; i < changedTouches.get$length(changedTouches); ++i) {
          if (i === C.JSInt_methods.toInt$0(i))
            if (i >= changedTouches.get$length(changedTouches))
              H.throwExpression(P.RangeError$range(i, 0, changedTouches.get$length(changedTouches), null, null));
          touchEvent = P.JsObject_JsObject$fromBrowserObject(P.JsObject.prototype.$index.call(changedTouches, changedTouches, i));
          this.game.get$input().stopPointer$1(touchEvent);
        }
      } else {
        changedTouches = J.get$changedTouches$x($event);
        for (i = 0; i < changedTouches.length; ++i) {
          t1 = this.game.get$input();
          if (i >= changedTouches.length)
            return H.ioore(changedTouches, i);
          t1.stopPointer$1(changedTouches[i]);
        }
      }
    }, "call$1", "get$onTouchEnd", 2, 0, 1387, 666, [], "onTouchEnd"],
    stop$0: [function(_) {
      if (this.game.get$device().get$touch() === true) {
        this.onTouchStartListener.cancel$0();
        this.onTouchMoveListener.cancel$0();
        this.onTouchEndListener.cancel$0();
        this.onTouchCancelListener.cancel$0();
        if (this.game.get$device().get$cocoonJS() !== true) {
          this.onTouchEnterListener.cancel$0();
          this.onTouchLeaveListener.cancel$0();
        }
      }
    }, "call$0", "get$stop", 0, 0, 54, "stop"],
    Touch$1: function(game) {
      this.disabled = false;
      this.touchStartCallback = null;
      this.touchMoveCallback = null;
      this.touchEndCallback = null;
      this.touchEnterCallback = null;
      this.touchLeaveCallback = null;
      this.touchCancelCallback = null;
      this.preventDefault = true;
      this.event = null;
    },
    static: {Touch$: [function(game) {
        var t1 = new R.Touch(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Touch$1(game);
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new Touch"]}
  },
  "+Touch": [674],
  Cache: {
    "^": "Object;game@-613,_canvases@-783,_images@-783,_textures@-783,_sounds@-783,_text@-783,_json@-783,_xml@-783,_physics@-783,_tilemaps@-783,_binary@-783,_bitmapDatas@-783,_bitmapFont@-783,_urlMap@-783,_urlResolver@-1224,_urlTemp@-644,onSoundUnlock@-1388,_cacheMap@-645",
    addCanvas$3: [function(key, canvas, context) {
      J.$indexSet$ax(this._canvases, key, P.LinkedHashMap_LinkedHashMap$_literal(["canvas", canvas, "context", context], null, null));
    }, "call$3", "get$addCanvas", 6, 0, 1389, 269, [], 154, [], 142, [], "addCanvas"],
    addBinary$2: [function(key, binaryData) {
      J.$indexSet$ax(this._binary, key, binaryData);
    }, "call$2", "get$addBinary", 4, 0, 119, 269, [], 1390, [], "addBinary"],
    addBitmapData$3: [function(key, bitmapData, frameData) {
      J.set$key$x(bitmapData, key);
      J.$indexSet$ax(this._bitmapDatas, key, P.LinkedHashMap_LinkedHashMap$_literal(["data", bitmapData, "frameData", frameData], null, null));
      return bitmapData;
    }, function(key, bitmapData) {
      return this.addBitmapData$3(key, bitmapData, null);
    }, "addBitmapData$2", "call$3", "call$2", "get$addBitmapData", 4, 2, 1391, 12, 269, [], 1392, [], 976, [], "addBitmapData"],
    addRenderTexture$2: [function(key, texture) {
      var t1, frame;
      t1 = J.getInterceptor$x(texture);
      frame = R.Frame$(0, 0, 0, t1.get$width(texture), t1.get$height(texture), "", "");
      J.$indexSet$ax(this._textures, key, P.LinkedHashMap_LinkedHashMap$_literal(["texture", texture, "frame", frame], null, null));
    }, "call$2", "get$addRenderTexture", 4, 0, 1393, 269, [], 68, [], "addRenderTexture"],
    addSpriteSheet$8: [function(key, url, data, frameWidth, frameHeight, frameMax, margin, spacing) {
      J.$indexSet$ax(this._images, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data, "frameWidth", frameWidth, "frameHeight", frameHeight, "margin", margin, "spacing", spacing], null, null));
      J.$indexSet$ax($.get$BaseTextureCache(), key, M.BaseTexture$(data, C.scaleModes_0));
      J.$indexSet$ax(J.$index$asx(this._images, key), "frameData", R.AnimationParser_spriteSheet(this.game, key, frameWidth, frameHeight, frameMax, margin, spacing));
      J.$indexSet$ax(this._urlMap, this._resolveUrl$1(url), J.$index$asx(this._images, key));
    }, function(key, url, data, frameWidth, frameHeight, frameMax) {
      return this.addSpriteSheet$8(key, url, data, frameWidth, frameHeight, frameMax, 0, 0);
    }, "addSpriteSheet$6", function(key, url, data, frameWidth, frameHeight) {
      return this.addSpriteSheet$8(key, url, data, frameWidth, frameHeight, -1, 0, 0);
    }, "addSpriteSheet$5", function(key, url, data, frameWidth, frameHeight, frameMax, margin) {
      return this.addSpriteSheet$8(key, url, data, frameWidth, frameHeight, frameMax, margin, 0);
    }, "addSpriteSheet$7", "call$8", "call$6", "call$5", "call$7", "get$addSpriteSheet", 10, 6, 1394, 268, 49, 49, 269, [], 127, [], 87, [], 270, [], 271, [], 272, [], 273, [], 274, [], "addSpriteSheet"],
    addTilemap$4: [function(key, url, mapData, format) {
      J.$indexSet$ax(this._tilemaps, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", mapData, "format", format], null, null));
      J.$indexSet$ax(this._urlMap, this._resolveUrl$1(url), J.$index$asx(this._tilemaps, key));
    }, "call$4", "get$addTilemap", 8, 0, 1395, 269, [], 127, [], 1396, [], 1397, [], "addTilemap"],
    addTextureAtlas$5: [function(key, url, data, atlasData, format) {
      var t1;
      J.$indexSet$ax(this._images, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data], null, null));
      J.$indexSet$ax($.get$BaseTextureCache(), key, M.BaseTexture$(data, C.scaleModes_0));
      t1 = J.getInterceptor(format);
      if (t1.$eq(format, 0))
        J.$indexSet$ax(J.$index$asx(this._images, key), "frameData", R.AnimationParser_JSONData(this.game, atlasData, key));
      else if (t1.$eq(format, 1))
        J.$indexSet$ax(J.$index$asx(this._images, key), "frameData", R.AnimationParser_JSONDataHash(this.game, atlasData, key));
      else if (t1.$eq(format, 2))
        J.$indexSet$ax(J.$index$asx(this._images, key), "frameData", R.AnimationParser_XMLData(this.game, atlasData, key));
      J.$indexSet$ax(this._urlMap, this._resolveUrl$1(url), J.$index$asx(this._images, key));
    }, "call$5", "get$addTextureAtlas", 10, 0, 1398, 269, [], 127, [], 87, [], 1399, [], 1397, [], "addTextureAtlas"],
    addBitmapFont$6: [function(key, url, data, xmlData, xSpacing, ySpacing) {
      J.$indexSet$ax(this._images, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data], null, null));
      J.$indexSet$ax($.get$BaseTextureCache(), key, M.BaseTexture$(data, C.scaleModes_0));
      R.LoaderParser_bitmapFont(this.game, xmlData, key, xSpacing, ySpacing);
      J.$indexSet$ax(this._bitmapFont, key, J.$index$asx($.get$BitmapText_fonts(), key));
      J.$indexSet$ax(this._urlMap, this._resolveUrl$1(url), J.$index$asx(this._bitmapFont, key));
    }, function(key, url, data, xmlData) {
      return this.addBitmapFont$6(key, url, data, xmlData, 0, 0);
    }, "addBitmapFont$4", function(key, url, data, xmlData, xSpacing) {
      return this.addBitmapFont$6(key, url, data, xmlData, xSpacing, 0);
    }, "addBitmapFont$5", "call$6", "call$4", "call$5", "get$addBitmapFont", 8, 4, 1400, 49, 49, 269, [], 127, [], 87, [], 1401, [], 334, [], 335, [], "addBitmapFont"],
    addPhysicsData$4: [function(key, url, JSONData, format) {
      J.$indexSet$ax(this._physics, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", JSONData, "format", format], null, null));
      J.$indexSet$ax(this._urlMap, this._resolveUrl$1(url), J.$index$asx(this._physics, key));
    }, "call$4", "get$addPhysicsData", 8, 0, 1395, 269, [], 127, [], 1402, [], 1397, [], "addPhysicsData"],
    addDefaultImage$0: [function() {
      var img = W.ImageElement_ImageElement(null, null, null);
      J.set$src$x(img, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==");
      J.$indexSet$ax(this._images, "__default", P.LinkedHashMap_LinkedHashMap$_literal(["url", null, "data", img], null, null));
      J.$indexSet$ax(this._images, "__default", P.LinkedHashMap_LinkedHashMap$_literal(["url", null, "data", img], null, null));
      J.$indexSet$ax(J.$index$asx(this._images, "__default"), "frame", R.Frame$(0, 0, 0, 32, 32, "", ""));
      J.$indexSet$ax(J.$index$asx(this._images, "__default"), "frameData", new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null)));
      J.$index$asx(J.$index$asx(this._images, "__default"), "frameData").addFrame$1(R.Frame$(0, 0, 0, 32, 32, null, this.game.get$rnd().uuid$0()));
      J.$indexSet$ax($.get$BaseTextureCache(), "__default", M.BaseTexture$(img, C.scaleModes_0));
      J.$indexSet$ax($.get$TextureCache(), "__default", M.Texture$(J.$index$asx($.get$BaseTextureCache(), "__default"), null));
    }, "call$0", "get$addDefaultImage", 0, 0, 54, "addDefaultImage"],
    addMissingImage$0: [function() {
      var img = W.ImageElement_ImageElement(null, null, null);
      J.set$src$x(img, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==");
      J.$indexSet$ax(this._images, "__missing", P.LinkedHashMap_LinkedHashMap$_literal(["url", null, "data", img], null, null));
      J.$indexSet$ax(this._images, "__missing", P.LinkedHashMap_LinkedHashMap$_literal(["url", null, "data", img], null, null));
      J.$indexSet$ax(J.$index$asx(this._images, "__missing"), "frame", R.Frame$(0, 0, 0, 32, 32, "", ""));
      J.$indexSet$ax(J.$index$asx(this._images, "__missing"), "frameData", new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null)));
      J.$index$asx(J.$index$asx(this._images, "__missing"), "frameData").addFrame$1(R.Frame$(0, 0, 0, 32, 32, null, this.game.get$rnd().uuid$0()));
      J.$indexSet$ax($.get$BaseTextureCache(), "__missing", M.BaseTexture$(img, C.scaleModes_0));
      J.$indexSet$ax($.get$TextureCache(), "__missing", M.Texture$(J.$index$asx($.get$BaseTextureCache(), "__missing"), null));
    }, "call$0", "get$addMissingImage", 0, 0, 54, "addMissingImage"],
    addText$3: [function(key, url, data) {
      J.$indexSet$ax(this._text, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data], null, null));
      J.$indexSet$ax(this._urlMap, this._resolveUrl$1(url), J.$index$asx(this._text, key));
    }, "call$3", "get$addText", 6, 0, 1403, 269, [], 127, [], 87, [], "addText"],
    addJSON$3: [function(key, url, data) {
      J.$indexSet$ax(this._json, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data], null, null));
      J.$indexSet$ax(this._urlMap, this._resolveUrl$1(url), J.$index$asx(this._json, key));
    }, "call$3", "get$addJSON", 6, 0, 1403, 269, [], 127, [], 87, [], "addJSON"],
    addXML$3: [function(key, url, data) {
      J.$indexSet$ax(this._xml, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data], null, null));
    }, "call$3", "get$addXML", 6, 0, 1403, 269, [], 127, [], 87, [], "addXML"],
    addImage$3: [function(key, url, data) {
      var t1;
      J.$indexSet$ax(this._images, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data], null, null));
      t1 = J.getInterceptor$x(data);
      J.$indexSet$ax(J.$index$asx(this._images, key), "frame", R.Frame$(0, 0, 0, t1.get$width(data), t1.get$height(data), key, this.game.get$rnd().uuid$0()));
      J.$indexSet$ax(J.$index$asx(this._images, key), "frameData", new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null)));
      J.$index$asx(J.$index$asx(this._images, key), "frameData").addFrame$1(R.Frame$(0, 0, 0, t1.get$width(data), t1.get$height(data), url, this.game.get$rnd().uuid$0()));
      J.$indexSet$ax($.get$BaseTextureCache(), key, M.BaseTexture$(data, C.scaleModes_0));
      J.$indexSet$ax($.get$TextureCache(), key, M.Texture$(J.$index$asx($.get$BaseTextureCache(), key), null));
      J.$indexSet$ax(this._urlMap, this._resolveUrl$1(url), J.$index$asx(this._images, key));
    }, "call$3", "get$addImage", 6, 0, 1403, 269, [], 127, [], 87, [], "addImage"],
    addSound$5: [function(key, url, data, webAudio, audioTag) {
      var decoded = audioTag === true && true;
      J.$indexSet$ax(this._sounds, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data, "isDecoding", false, "decoded", decoded, "webAudio", webAudio, "audioTag", audioTag, "locked", this.game.get$sound().get$touchLocked()], null, null));
      J.$indexSet$ax(this._urlMap, this._resolveUrl$1(url), J.$index$asx(this._sounds, key));
    }, function(key, url, data) {
      return this.addSound$5(key, url, data, true, false);
    }, "addSound$3", function(key, url, data, webAudio) {
      return this.addSound$5(key, url, data, webAudio, false);
    }, "addSound$4", "call$5", "call$3", "call$4", "get$addSound", 6, 4, 1404, 78, 19, 269, [], 127, [], 87, [], 1405, [], 1406, [], "addSound"],
    reloadSound$1: [function(key) {
      if (J.$index$asx(this._sounds, key) != null) {
        J.set$src$x(J.$index$asx(J.$index$asx(this._sounds, key), "data"), J.get$url$x(J.$index$asx(this._sounds, key)));
        J.addEventListener$3$x(J.$index$asx(J.$index$asx(this._sounds, key), "data"), "canplaythrough", new R.Cache_reloadSound_closure(this, key), false);
        J.load$0$x(J.$index$asx(J.$index$asx(this._sounds, key), "data"));
      }
    }, "call$1", "get$reloadSound", 2, 0, 91, 269, [], "reloadSound"],
    reloadSoundComplete$1: [function(key) {
      if (J.$index$asx(this._sounds, key) != null) {
        J.$indexSet$ax(J.$index$asx(this._sounds, key), "locked", false);
        this.onSoundUnlock.dispatch$1(key);
      }
    }, "call$1", "get$reloadSoundComplete", 2, 0, 91, 269, [], "reloadSoundComplete"],
    updateSound$3: [function(key, property, value) {
      if (J.$index$asx(this._sounds, key) != null)
        J.$indexSet$ax(J.$index$asx(this._sounds, key), property, value);
    }, "call$3", "get$updateSound", 6, 0, 1403, 269, [], 1407, [], 138, [], "updateSound"],
    decodedSound$2: [function(key, data) {
      J.$indexSet$ax(J.$index$asx(this._sounds, key), "data", data);
      J.$indexSet$ax(J.$index$asx(this._sounds, key), "decoded", true);
      J.$indexSet$ax(J.$index$asx(this._sounds, key), "isDecoding", false);
    }, "call$2", "get$decodedSound", 4, 0, 119, 269, [], 87, [], "decodedSound"],
    getCanvas$1: [function(key) {
      var t1;
      if (J.$index$asx(this._canvases, key) != null)
        return J.$index$asx(J.$index$asx(this._canvases, key), "canvas");
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getCanvas: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
      }
    }, "call$1", "get$getCanvas", 2, 0, 91, 269, [], "getCanvas"],
    getBitmapData$1: [function(key) {
      var t1;
      if (J.$index$asx(this._bitmapDatas, key) != null)
        return J.$index$asx(J.$index$asx(this._bitmapDatas, key), "data");
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getBitmapData: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getBitmapData", 2, 0, 1408, 269, [], "getBitmapData"],
    getBitmapFont$1: [function(key) {
      var t1;
      if (J.$index$asx(this._bitmapFont, key) != null)
        return J.$index$asx(this._bitmapFont, key);
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getBitmapFont: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getBitmapFont", 2, 0, 1409, 269, [], "getBitmapFont"],
    getPhysicsData$3: [function(key, object, fixtureKey) {
      var t1, fixtures, fixture;
      if (object == null)
        if (J.$index$asx(this._physics, key) === true)
          return J.get$data$x(J.$index$asx(this._physics, key));
        else {
          window;
          t1 = C.JSString_methods.$add("Phaser.Cache.getPhysicsData: Invalid key: \"", key) + "\"";
          if (typeof console != "undefined")
            console.warn(t1);
        }
      else if (J.containsKey$1$x(this._physics, key) === true && J.containsKey$1$x(J.$index$asx(J.$index$asx(this._physics, key), "data"), object) === true) {
        fixtures = J.$index$asx(J.$index$asx(J.$index$asx(this._physics, key), "data"), object);
        if (fixtures != null && fixtureKey != null) {
          for (t1 = J.get$iterator$ax(fixtures); t1.moveNext$0();) {
            fixture = t1.get$current();
            if (J.$eq(J.$index$asx(fixture, "fixtureKey"), fixtureKey))
              return fixture;
          }
          window;
          t1 = C.JSString_methods.$add(C.JSString_methods.$add("Phaser.Cache.getPhysicsData: Could not find given fixtureKey: \"", fixtureKey) + " in ", key) + "\"";
          if (typeof console != "undefined")
            console.warn(t1);
        } else
          return fixtures;
      } else {
        window;
        t1 = C.JSString_methods.$add(C.JSString_methods.$add("Phaser.Cache.getPhysicsData: Invalid key/object: \"", key) + " / ", object) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
      }
      return;
    }, function(key) {
      return this.getPhysicsData$3(key, null, null);
    }, "getPhysicsData$1", function(key, object) {
      return this.getPhysicsData$3(key, object, null);
    }, "getPhysicsData$2", "call$3", "call$1", "call$2", "get$getPhysicsData", 2, 4, 1410, 12, 12, 269, [], 584, [], 1411, [], "getPhysicsData"],
    checkKey$2: [function(type, key) {
      if (J.$index$asx(J.$index$asx(this._cacheMap, type), key) != null)
        return true;
      return false;
    }, "call$2", "get$checkKey", 4, 0, 1412, 137, [], 269, [], "checkKey"],
    checkCanvasKey$1: [function(key) {
      return this.checkKey$2(1, key);
    }, "call$1", "get$checkCanvasKey", 2, 0, 1413, 269, [], "checkCanvasKey"],
    checkImageKey$1: [function(key) {
      return this.checkKey$2(2, key);
    }, "call$1", "get$checkImageKey", 2, 0, 1413, 269, [], "checkImageKey"],
    checkTextureKey$1: [function(key) {
      return this.checkKey$2(3, key);
    }, "call$1", "get$checkTextureKey", 2, 0, 1413, 269, [], "checkTextureKey"],
    checkSoundKey$1: [function(key) {
      return this.checkKey$2(4, key);
    }, "call$1", "get$checkSoundKey", 2, 0, 1413, 269, [], "checkSoundKey"],
    checkTextKey$1: [function(key) {
      return this.checkKey$2(5, key);
    }, "call$1", "get$checkTextKey", 2, 0, 1413, 269, [], "checkTextKey"],
    checkPhysicsKey$1: [function(key) {
      return this.checkKey$2(6, key);
    }, "call$1", "get$checkPhysicsKey", 2, 0, 1413, 269, [], "checkPhysicsKey"],
    checkTilemapKey$1: [function(key) {
      return this.checkKey$2(7, key);
    }, "call$1", "get$checkTilemapKey", 2, 0, 1413, 269, [], "checkTilemapKey"],
    checkBinaryKey$1: [function(key) {
      return this.checkKey$2(8, key);
    }, "call$1", "get$checkBinaryKey", 2, 0, 1413, 269, [], "checkBinaryKey"],
    checkBitmapDataKey$1: [function(key) {
      return this.checkKey$2(9, key);
    }, "call$1", "get$checkBitmapDataKey", 2, 0, 1413, 269, [], "checkBitmapDataKey"],
    checkBitmapFontKey$1: [function(key) {
      return this.checkKey$2(10, key);
    }, "call$1", "get$checkBitmapFontKey", 2, 0, 1413, 269, [], "checkBitmapFontKey"],
    checkJSONKey$1: [function(key) {
      return this.checkKey$2(11, key);
    }, "call$1", "get$checkJSONKey", 2, 0, 1413, 269, [], "checkJSONKey"],
    checkXMLKey$1: [function(key) {
      return this.checkKey$2(12, key);
    }, "call$1", "get$checkXMLKey", 2, 0, 1413, 269, [], "checkXMLKey"],
    checkUrl$1: [function(url) {
      if (J.$index$asx(this._urlMap, this._resolveUrl$1(url)) === true)
        return true;
      return false;
    }, "call$1", "get$checkUrl", 2, 0, 91, 127, [], "checkUrl"],
    getImage$1: [function(key) {
      var t1;
      if (J.$index$asx(this._images, key) != null)
        return J.$index$asx(J.$index$asx(this._images, key), "data");
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getImage: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getImage", 2, 0, 1414, 269, [], "getImage"],
    getTilemapData$1: [function(key) {
      var t1;
      if (J.$index$asx(this._tilemaps, key) != null)
        return J.$index$asx(this._tilemaps, key);
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getTilemapData: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getTilemapData", 2, 0, 1409, 269, [], "getTilemapData"],
    getFrameData$2: [function(key, map) {
      if (J.$index$asx(J.$index$asx(this._cacheMap, map), key) != null)
        return J.$index$asx(J.$index$asx(J.$index$asx(this._cacheMap, map), key), "frameData");
      return;
    }, function(key) {
      return this.getFrameData$2(key, 2);
    }, "getFrameData$1", "call$2", "call$1", "get$getFrameData", 2, 2, 1415, 441, 269, [], 803, [], "getFrameData"],
    updateFrameData$2: [function(key, frameData) {
      if (J.$index$asx(this._images, key) != null)
        J.$indexSet$ax(J.$index$asx(this._images, key), "frameData", frameData);
    }, "call$2", "get$updateFrameData", 4, 0, 1416, 269, [], 976, [], "updateFrameData"],
    getFrameByIndex$2: [function(key, frame) {
      if (J.$index$asx(this._images, key) != null)
        return J.$index$asx(J.$index$asx(this._images, key), "frameData").getFrame$1(frame);
      return;
    }, "call$2", "get$getFrameByIndex", 4, 0, 1417, 269, [], 216, [], "getFrameByIndex"],
    getFrameByName$2: [function(key, frame) {
      if (J.$index$asx(this._images, key) != null)
        return J.$index$asx(J.$index$asx(this._images, key), "frameData").getFrameByName$1(frame);
      return;
    }, "call$2", "get$getFrameByName", 4, 0, 1417, 269, [], 216, [], "getFrameByName"],
    getFrame$1: [function(key) {
      if (J.$index$asx(this._images, key) != null)
        return J.$index$asx(J.$index$asx(this._images, key), "frame");
      return;
    }, "call$1", "get$getFrame", 2, 0, 1003, 269, [], "getFrame"],
    getTextureFrame$1: [function(key) {
      if (J.$index$asx(this._textures, key) != null)
        return J.$index$asx(J.$index$asx(this._textures, key), "frame");
      return;
    }, "call$1", "get$getTextureFrame", 2, 0, 1003, 269, [], "getTextureFrame"],
    getTexture$1: [function(key) {
      var t1;
      if (J.$index$asx(this._textures, key) != null)
        return J.$index$asx(this._textures, key);
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getTexture: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getTexture", 2, 0, 1418, 269, [], "getTexture"],
    getSound$1: [function(key) {
      var t1;
      if (J.$index$asx(this._sounds, key) != null)
        return J.$index$asx(this._sounds, key);
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getSound: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getSound", 2, 0, 1409, 269, [], "getSound"],
    getSoundData$1: [function(key) {
      var t1;
      if (J.$index$asx(this._sounds, key) != null)
        return J.$index$asx(J.$index$asx(this._sounds, key), "data");
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getSoundData: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getSoundData", 2, 0, 91, 269, [], "getSoundData"],
    isSoundDecoded$1: [function(key) {
      if (J.$index$asx(this._sounds, key) != null)
        return J.$index$asx(J.$index$asx(this._sounds, key), "decoded");
      return;
    }, "call$1", "get$isSoundDecoded", 2, 0, 1413, 269, [], "isSoundDecoded"],
    isSoundReady$1: [function(key) {
      return J.$index$asx(this._sounds, key) != null && J.$index$asx(J.$index$asx(this._sounds, key), "decoded") === true && J.$eq(this.game.get$sound().get$touchLocked(), false);
    }, "call$1", "get$isSoundReady", 2, 0, 1413, 269, [], "isSoundReady"],
    getFrameCount$1: [function(key) {
      if (J.$index$asx(this._images, key) != null)
        return J.get$length$asx(J.$index$asx(J.$index$asx(this._images, key), "frameData"));
      return 0;
    }, "call$1", "get$getFrameCount", 2, 0, 557, 269, [], "getFrameCount"],
    getText$1: [function(key) {
      var t1;
      if (J.$index$asx(this._text, key) != null)
        return J.$index$asx(J.$index$asx(this._text, key), "data");
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getText: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getText", 2, 0, 1409, 269, [], "getText"],
    getJSON$1: [function(key) {
      var t1;
      if (J.$index$asx(this._json, key) != null)
        return J.$index$asx(J.$index$asx(this._json, key), "data");
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getJSON: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getJSON", 2, 0, 1409, 269, [], "getJSON"],
    getXML$1: [function(key) {
      var t1;
      if (J.$index$asx(this._xml, key) === true)
        return J.get$data$x(J.$index$asx(this._xml, key));
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getXML: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getXML", 2, 0, 1419, 269, [], "getXML"],
    getBinary$1: [function(key) {
      var t1;
      if (J.$index$asx(this._binary, key) != null)
        return J.$index$asx(this._binary, key);
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getBinary: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getBinary", 2, 0, 1409, 269, [], "getBinary"],
    getUrl$1: [function(url) {
      var t1;
      if (J.$index$asx(this._urlMap, this._resolveUrl$1(url)) === true)
        return J.$index$asx(this._urlMap, this._resolveUrl$1(url));
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getUrl: Invalid url: \"", url) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getUrl", 2, 0, 91, 127, [], "getUrl"],
    getKeys$1: [function(type) {
      var array;
      switch (type) {
        case 1:
          array = this._canvases;
          break;
        case 2:
          return J.where$1$ax(J.get$keys$x(this._images), new R.Cache_getKeys_closure()).toList$0(0);
        case 3:
          array = this._textures;
          break;
        case 4:
          array = this._sounds;
          break;
        case 5:
          array = this._text;
          break;
        case 6:
          array = this._physics;
          break;
        case 7:
          array = this._tilemaps;
          break;
        case 8:
          array = this._binary;
          break;
        case 9:
          array = this._bitmapDatas;
          break;
        case 10:
          array = this._bitmapFont;
          break;
        case 11:
          array = this._json;
          break;
        case 12:
          array = this._xml;
          break;
        default:
          array = null;
      }
      if (array == null)
        return [];
      return J.toList$0$ax(J.get$keys$x(array));
    }, "call$1", "get$getKeys", 2, 0, 1420, 137, [], "getKeys"],
    removeCanvas$1: [function(key) {
      J.remove$1$ax(this._canvases, key);
    }, "call$1", "get$removeCanvas", 2, 0, 91, 269, [], "removeCanvas"],
    removeImage$2: [function(key, removeFromPixi) {
      J.remove$1$ax(this._images, key);
      if (removeFromPixi === true)
        J.$index$asx($.get$BaseTextureCache(), key).destroy$0();
    }, function(key) {
      return this.removeImage$2(key, true);
    }, "removeImage$1", "call$2", "call$1", "get$removeImage", 2, 2, 1421, 78, 269, [], 1422, [], "removeImage"],
    removeSound$1: [function(key) {
      J.remove$1$ax(this._sounds, key);
    }, "call$1", "get$removeSound", 2, 0, 91, 269, [], "removeSound"],
    removeText$1: [function(key) {
      J.remove$1$ax(this._text, key);
    }, "call$1", "get$removeText", 2, 0, 91, 269, [], "removeText"],
    removeJSON$1: [function(key) {
      J.remove$1$ax(this._json, key);
    }, "call$1", "get$removeJSON", 2, 0, 91, 269, [], "removeJSON"],
    removeXML$1: [function(key) {
      J.remove$1$ax(this._xml, key);
    }, "call$1", "get$removeXML", 2, 0, 91, 269, [], "removeXML"],
    removePhysics$1: [function(key) {
      J.remove$1$ax(this._physics, key);
    }, "call$1", "get$removePhysics", 2, 0, 91, 269, [], "removePhysics"],
    removeTilemap$1: [function(key) {
      J.remove$1$ax(this._tilemaps, key);
    }, "call$1", "get$removeTilemap", 2, 0, 91, 269, [], "removeTilemap"],
    removeBinary$1: [function(key) {
      J.remove$1$ax(this._binary, key);
    }, "call$1", "get$removeBinary", 2, 0, 91, 269, [], "removeBinary"],
    removeBitmapData$1: [function(key) {
      J.remove$1$ax(this._bitmapDatas, key);
    }, "call$1", "get$removeBitmapData", 2, 0, 91, 269, [], "removeBitmapData"],
    removeBitmapFont$1: [function(key) {
      J.remove$1$ax(this._bitmapFont, key);
    }, "call$1", "get$removeBitmapFont", 2, 0, 91, 269, [], "removeBitmapFont"],
    _resolveUrl$1: [function(url) {
      J.set$src$x(this._urlResolver, J.$add$ns(J.get$load$x(this.game).get$baseURL(), url));
      this._urlTemp = J.get$src$x(this._urlResolver);
      J.set$src$x(this._urlResolver, "");
      return this._urlTemp;
    }, "call$1", "get$_resolveUrl", 2, 0, 91, 127, [], "_resolveUrl"],
    destroy$0: [function() {
      var t1, item, t2;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._canvases)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._canvases, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._images)); t1.moveNext$0();) {
        item = t1.get$current();
        t2 = J.getInterceptor(item);
        if (!t2.$eq(item, "__default") && !t2.$eq(item, "__missing"))
          J.remove$1$ax(this._images, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._sounds)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._sounds, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._text)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._text, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._json)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._json, item);
      }
      for (t1 = J.get$iterator$ax(this._xml); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._xml, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._textures)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._textures, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._physics)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._physics, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._tilemaps)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._tilemaps, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._binary)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._binary, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._bitmapDatas)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._bitmapDatas, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._bitmapFont)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._bitmapFont, item);
      }
      this._urlMap = null;
      this._urlResolver = null;
      this._urlTemp = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    Cache$1: function(game) {
      var img, t1, t2;
      this._canvases = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._images = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._textures = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._sounds = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._text = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._json = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._xml = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._physics = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._tilemaps = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._binary = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._bitmapDatas = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._bitmapFont = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._urlMap = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._urlResolver = W.ImageElement_ImageElement(null, null, null);
      this._urlTemp = null;
      img = W.ImageElement_ImageElement(null, null, null);
      J.set$src$x(img, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==");
      J.$indexSet$ax(this._images, "__default", P.LinkedHashMap_LinkedHashMap$_literal(["url", null, "data", img], null, null));
      J.$indexSet$ax(this._images, "__default", P.LinkedHashMap_LinkedHashMap$_literal(["url", null, "data", img], null, null));
      J.$indexSet$ax(J.$index$asx(this._images, "__default"), "frame", R.Frame$(0, 0, 0, 32, 32, "", ""));
      J.$indexSet$ax(J.$index$asx(this._images, "__default"), "frameData", new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null)));
      J.$index$asx(J.$index$asx(this._images, "__default"), "frameData").addFrame$1(R.Frame$(0, 0, 0, 32, 32, null, this.game.get$rnd().uuid$0()));
      J.$indexSet$ax($.get$BaseTextureCache(), "__default", M.BaseTexture$(img, C.scaleModes_0));
      J.$indexSet$ax($.get$TextureCache(), "__default", M.Texture$(J.$index$asx($.get$BaseTextureCache(), "__default"), null));
      img = W.ImageElement_ImageElement(null, null, null);
      J.set$src$x(img, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==");
      J.$indexSet$ax(this._images, "__missing", P.LinkedHashMap_LinkedHashMap$_literal(["url", null, "data", img], null, null));
      J.$indexSet$ax(this._images, "__missing", P.LinkedHashMap_LinkedHashMap$_literal(["url", null, "data", img], null, null));
      J.$indexSet$ax(J.$index$asx(this._images, "__missing"), "frame", R.Frame$(0, 0, 0, 32, 32, "", ""));
      J.$indexSet$ax(J.$index$asx(this._images, "__missing"), "frameData", new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null)));
      J.$index$asx(J.$index$asx(this._images, "__missing"), "frameData").addFrame$1(R.Frame$(0, 0, 0, 32, 32, null, this.game.get$rnd().uuid$0()));
      J.$indexSet$ax($.get$BaseTextureCache(), "__missing", M.BaseTexture$(img, C.scaleModes_0));
      J.$indexSet$ax($.get$TextureCache(), "__missing", M.Texture$(J.$index$asx($.get$BaseTextureCache(), "__missing"), null));
      this.onSoundUnlock = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      t1 = Array(13);
      t1.fixed$length = init;
      this._cacheMap = t1;
      t2 = this._canvases;
      if (1 < 0 || 1 >= 13)
        return H.ioore(t1, 1);
      t1[1] = t2;
      J.$indexSet$ax(this._cacheMap, 2, this._images);
      J.$indexSet$ax(this._cacheMap, 3, this._textures);
      J.$indexSet$ax(this._cacheMap, 4, this._sounds);
      J.$indexSet$ax(this._cacheMap, 5, this._text);
      J.$indexSet$ax(this._cacheMap, 6, this._physics);
      J.$indexSet$ax(this._cacheMap, 7, this._tilemaps);
      J.$indexSet$ax(this._cacheMap, 8, this._binary);
      J.$indexSet$ax(this._cacheMap, 9, this._bitmapDatas);
      J.$indexSet$ax(this._cacheMap, 10, this._bitmapFont);
      J.$indexSet$ax(this._cacheMap, 11, this._json);
      J.$indexSet$ax(this._cacheMap, 12, this._xml);
    },
    static: {"^": "Cache_CANVAS<-614,Cache_IMAGE<-614,Cache_TEXTURE<-614,Cache_SOUND<-614,Cache_TEXT<-614,Cache_PHYSICS<-614,Cache_TILEMAP<-614,Cache_BINARY<-614,Cache_BITMAPDATA<-614,Cache_BITMAPFONT<-614,Cache_JSON<-614,Cache_XML<-614", Cache$: [function(game) {
        var t1 = new R.Cache(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), null);
        t1.Cache$1(game);
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new Cache"]}
  },
  "+Cache": [674],
  Cache_reloadSound_closure: {
    "^": "Closure:102;this_0,key_1",
    call$1: [function(e) {
      var t1, t2;
      t1 = this.this_0;
      t2 = this.key_1;
      if (J.$index$asx(t1._sounds, t2) != null) {
        J.$indexSet$ax(J.$index$asx(t1._sounds, t2), "locked", false);
        t1.onSoundUnlock.dispatch$1(t2);
      }
      return;
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  Cache_getKeys_closure: {
    "^": "Closure:102;",
    call$1: [function(s) {
      var t1 = J.getInterceptor(s);
      return !t1.$eq(s, "__default") && !t1.$eq(s, "__missing");
    }, "call$1", null, 2, 0, 102, 545, [], "call"]
  },
  Loader: {
    "^": "Object;game@-613,isLoading@-617,hasLoaded@-617,progress@-614,progressFloat@-671,preloadSprite@-783,crossOrigin*-644,baseURL@-644,onLoadStart*-1423,onFileStart@-1424,onFileComplete@-1425,onFileError@-1426,onLoadComplete@-1049,onPackComplete@-1427,_packList@-1428,_packIndex@-614,_fileList@-1428,_fileIndex@-614,_progressChunk@-616,_xhr@-852",
    setPreloadSprite$2: [function(sprite, direction) {
      var t1, t2, t3;
      t1 = J.getInterceptor$x(sprite);
      this.preloadSprite = P.LinkedHashMap_LinkedHashMap$_literal(["sprite", sprite, "direction", direction, "width", t1.get$width(sprite), "height", t1.get$height(sprite), "rect", null], null, null);
      t2 = J.$eq(direction, 0);
      t3 = this.preloadSprite;
      if (t2)
        J.$indexSet$ax(t3, "rect", new R.Rectangle1(0, 0, 1, t1.get$height(sprite), 0, 0, 0, 0));
      else
        J.$indexSet$ax(t3, "rect", new R.Rectangle1(0, 0, t1.get$width(sprite), 1, 0, 0, 0, 0));
      sprite.crop$1(J.$index$asx(this.preloadSprite, "rect"));
      sprite.set$visible(true);
    }, function(sprite) {
      return this.setPreloadSprite$2(sprite, 0);
    }, "setPreloadSprite$1", "call$2", "call$1", "get$setPreloadSprite", 2, 2, 1012, 49, 151, [], 581, [], "setPreloadSprite"],
    checkKeyExists$2: [function(type, key) {
      var i, t1;
      if (J.$gt$n(J.get$length$asx(this._fileList), 0)) {
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this._fileList);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "type"), type) && J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "key"), key))
            return true;
          ++i;
        }
      }
      return false;
    }, "call$2", "get$checkKeyExists", 4, 0, 1429, 137, [], 269, [], "checkKeyExists"],
    getAssetIndex$2: [function(type, key) {
      var i, t1;
      if (J.$gt$n(J.get$length$asx(this._fileList), 0)) {
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this._fileList);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "type"), type) && J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "key"), key))
            return i;
          ++i;
        }
      }
      return -1;
    }, "call$2", "get$getAssetIndex", 4, 0, 1430, 137, [], 269, [], "getAssetIndex"],
    getAsset$2: [function(type, key) {
      var i, t1;
      if (J.$gt$n(J.get$length$asx(this._fileList), 0)) {
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this._fileList);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "type"), type) && J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "key"), key))
            return P.LinkedHashMap_LinkedHashMap$_literal([["index"], i, ["file"], J.$index$asx(this._fileList, i)], null, null);
          ++i;
        }
      }
      return;
    }, "call$2", "get$getAsset", 4, 0, 1431, 137, [], 269, [], "getAsset"],
    reset$0: [function(_) {
      this.preloadSprite = null;
      this.isLoading = false;
      J.clear$0$ax(this._packList);
      this._packIndex = 0;
      J.clear$0$ax(this._fileList);
      this._fileIndex = 0;
    }, "call$0", "get$reset", 0, 0, 54, "reset"],
    addToFileList$4: [function(type, key, url, properties) {
      var entry, t1, t2, prop;
      entry = P.LinkedHashMap_LinkedHashMap$_literal(["type", type, "key", key, "url", url, "data", null, "error", false, "loaded", false], null, null);
      if (properties != null)
        for (t1 = J.getInterceptor$x(properties), t2 = J.get$iterator$ax(t1.get$keys(properties)); t2.moveNext$0();) {
          prop = t2.get$current();
          entry.$indexSet(0, prop, t1.$index(properties, prop));
        }
      if (!this.checkKeyExists$2(type, key))
        J.add$1$ax(this._fileList, entry);
    }, function(type, key, url) {
      return this.addToFileList$4(type, key, url, null);
    }, "addToFileList$3", "call$4", "call$3", "get$addToFileList", 6, 2, 1432, 12, 137, [], 269, [], 127, [], 512, [], "addToFileList"],
    replaceInFileList$4: [function(type, key, url, properties) {
      var entry, t1, t2, prop, index;
      entry = P.LinkedHashMap_LinkedHashMap$_literal(["type", type, "key", key, "url", url, "data", null, "error", false, "loaded", false], null, null);
      if (properties != null)
        for (t1 = J.getInterceptor$x(properties), t2 = J.get$iterator$ax(t1.get$keys(properties)); t2.moveNext$0();) {
          prop = t2.get$current();
          entry.$indexSet(0, prop, t1.$index(properties, prop));
        }
      index = this.getAssetIndex$2(type, key);
      t1 = this._fileList;
      if (index === -1)
        J.add$1$ax(t1, entry);
      else
        J.$indexSet$ax(t1, index, entry);
    }, function(type, key, url) {
      return this.replaceInFileList$4(type, key, url, null);
    }, "replaceInFileList$3", "call$4", "call$3", "get$replaceInFileList", 6, 2, 1433, 12, 137, [], 269, [], 127, [], 512, [], "replaceInFileList"],
    pack$3: [function(key, url, data) {
      if (url == null && data == null) {
        window;
        if (typeof console != "undefined")
          console.warn("Phaser.Loader.pack - Both url and data are null. One must be set.");
        return this;
      }
      if (data != null)
        data = typeof data === "string" ? C.JsonCodec_null_null.decode$1(data) : data;
      J.add$1$ax(this._packList, P.LinkedHashMap_LinkedHashMap$_literal(["key", key, "url", url, "data", data, "loaded", false, "error", false], null, null));
      return this;
    }, function(key) {
      return this.pack$3(key, null, null);
    }, "pack$1", function(key, url) {
      return this.pack$3(key, url, null);
    }, "pack$2", "call$3", "call$1", "call$2", "get$pack", 2, 4, 1434, 12, 12, 269, [], 127, [], 87, [], "pack"],
    image$3: [function(key, url, overwrite) {
      if ((overwrite == null ? false : overwrite) === true)
        this.replaceInFileList$3("image", key, url);
      else
        this.addToFileList$3("image", key, url);
      return this;
    }, function(key, url) {
      return this.image$3(key, url, false);
    }, "image$2", "call$3", "call$2", "get$image", 4, 2, 1435, 19, 269, [], 127, [], 1436, [], "image"],
    text$3: [function(_, key, url, overwrite) {
      if ((overwrite == null ? false : overwrite) === true)
        this.replaceInFileList$3("text", key, url);
      else
        this.addToFileList$3("text", key, url);
      return this;
    }, function($receiver, key, url) {
      return this.text$3($receiver, key, url, false);
    }, "text$2", "call$3", "call$2", "get$text", 4, 2, 1435, 19, 269, [], 127, [], 1436, [], "text"],
    json$3: [function(key, url, overwrite) {
      if ((overwrite == null ? false : overwrite) === true)
        this.replaceInFileList$3("json", key, url);
      else
        this.addToFileList$3("json", key, url);
      return this;
    }, function(key, url) {
      return this.json$3(key, url, false);
    }, "json$2", "call$3", "call$2", "get$json", 4, 2, 1435, 19, 269, [], 127, [], 1436, [], "json"],
    xml$3: [function(key, url, overwrite) {
      if (overwrite === true)
        this.replaceInFileList$3("xml", key, url);
      else
        this.addToFileList$3("xml", key, url);
      return this;
    }, function(key, url) {
      return this.xml$3(key, url, false);
    }, "xml$2", "call$3", "call$2", "get$xml", 4, 2, 1435, 19, 269, [], 127, [], 1436, [], "xml"],
    script$3: [function(key, url, callback) {
      if (callback != null)
        this.addToFileList$4("script", key, url, P.LinkedHashMap_LinkedHashMap$_literal(["callback", callback], null, null));
      return this;
    }, function(key, url) {
      return this.script$3(key, url, null);
    }, "script$2", "call$3", "call$2", "get$script", 4, 2, 1437, 12, 269, [], 127, [], 26, [], "script"],
    binary$3: [function(key, url, callback) {
      if (callback != null)
        this.addToFileList$4("binary", key, url, P.LinkedHashMap_LinkedHashMap$_literal(["callback", callback], null, null));
      return this;
    }, function(key, url) {
      return this.binary$3(key, url, null);
    }, "binary$2", "call$3", "call$2", "get$binary", 4, 2, 1437, 12, 269, [], 127, [], 26, [], "binary"],
    spritesheet$7: [function(key, url, frameWidth, frameHeight, frameMax, margin, spacing) {
      this.addToFileList$4("spritesheet", key, url, P.LinkedHashMap_LinkedHashMap$_literal(["frameWidth", frameWidth, "frameHeight", frameHeight == null ? frameWidth : frameHeight, "frameMax", frameMax, "margin", margin, "spacing", spacing], null, null));
      return this;
    }, function(key, url, frameWidth) {
      return this.spritesheet$7(key, url, frameWidth, null, -1, 0, 0);
    }, "spritesheet$3", function(key, url, frameWidth, frameHeight) {
      return this.spritesheet$7(key, url, frameWidth, frameHeight, -1, 0, 0);
    }, "spritesheet$4", function(key, url, frameWidth, frameHeight, frameMax, margin) {
      return this.spritesheet$7(key, url, frameWidth, frameHeight, frameMax, margin, 0);
    }, "spritesheet$6", function(key, url, frameWidth, frameHeight, frameMax) {
      return this.spritesheet$7(key, url, frameWidth, frameHeight, frameMax, 0, 0);
    }, "spritesheet$5", "call$7", "call$3", "call$4", "call$6", "call$5", "get$spritesheet", 6, 8, 1438, 12, 268, 49, 49, 269, [], 127, [], 270, [], 271, [], 272, [], 273, [], 274, [], "spritesheet"],
    audio$3: [function(_, key, url, autoDecode) {
      this.addToFileList$4("audio", key, url, P.LinkedHashMap_LinkedHashMap$_literal(["buffer", null, "autoDecode", autoDecode], null, null));
      return this;
    }, function($receiver, key, url) {
      return this.audio$3($receiver, key, url, true);
    }, "audio$2", "call$3", "call$2", "get$audio", 4, 2, 1439, 78, 269, [], 127, [], 1440, [], "audio"],
    audiosprite$3: [function(key, urls, atlasURL) {
      this.addToFileList$4("audio", key, urls, P.LinkedHashMap_LinkedHashMap$_literal(["buffer", null, "autoDecode", true], null, null));
      this.json$2(J.$add$ns(key, "-audioatlas"), atlasURL);
      return this;
    }, "call$3", "get$audiosprite", 6, 0, 1441, 269, [], 1442, [], 1443, [], "audiosprite"],
    tilemap$4: [function(key, url, data, format) {
      if (format == null)
        format = 0;
      if (url == null && data == null) {
        window;
        if (typeof console != "undefined")
          console.warn("Phaser.Loader.tilemap - Both url and data are null. One must be set.");
        return this;
      }
      if (data != null) {
        switch (format) {
          case 0:
            break;
          case 1:
            if (typeof data === "string")
              data = C.JsonCodec_null_null.decode$1(data);
            break;
        }
        this.game.get$cache().addTilemap$4(key, null, data, format);
      } else
        this.addToFileList$4("tilemap", key, url, P.LinkedHashMap_LinkedHashMap$_literal(["format", format], null, null));
      return this;
    }, function(key) {
      return this.tilemap$4(key, null, null, null);
    }, "tilemap$1", function(key, url) {
      return this.tilemap$4(key, url, null, null);
    }, "tilemap$2", function(key, url, data) {
      return this.tilemap$4(key, url, data, null);
    }, "tilemap$3", "call$4", "call$1", "call$2", "call$3", "get$tilemap", 2, 6, 1444, 12, 12, 12, 269, [], 127, [], 87, [], 1397, [], "tilemap"],
    physics$4: [function(key, url, data, format) {
      if (format == null)
        format = 0;
      if (url == null && data == null) {
        window;
        if (typeof console != "undefined")
          console.warn("Phaser.Loader.physics - Both url and data are null. One must be set.");
        return this;
      }
      if (data != null) {
        if (J.$eq(data, C.Type_Ejg))
          data = C.JsonCodec_null_null.decode$1(data);
        this.game.get$cache().addPhysicsData$4(key, null, data, format);
      } else
        this.addToFileList$4("physics", key, url, P.LinkedHashMap_LinkedHashMap$_literal(["format", format], null, null));
      return this;
    }, function(key) {
      return this.physics$4(key, null, null, null);
    }, "physics$1", function(key, url) {
      return this.physics$4(key, url, null, null);
    }, "physics$2", function(key, url, data) {
      return this.physics$4(key, url, data, null);
    }, "physics$3", "call$4", "call$1", "call$2", "call$3", "get$physics", 2, 6, 1444, 12, 12, 12, 269, [], 127, [], 87, [], 1397, [], "physics"],
    bitmapFont$6: [function(key, textureURL, xmlURL, xmlData, xSpacing, ySpacing) {
      var xml, domparser, t1, exception;
      if (xmlURL != null)
        this.addToFileList$4("bitmapfont", key, textureURL, P.LinkedHashMap_LinkedHashMap$_literal(["xmlURL", xmlURL, "xSpacing", xSpacing, "ySpacing", ySpacing], null, null));
      else {
        t1 = xmlData;
        if (typeof t1 === "string") {
          xml = null;
          try {
            domparser = new DOMParser();
            xml = J.parseFromString$2$x(domparser, xmlData, "text/xml");
          } catch (exception) {
            H.unwrapException(exception);
            xml = null;
          }

          if (xml == null)
            throw H.wrapException(P.Exception_Exception("Phaser.Loader. Invalid Bitmap Font XML given"));
          else
            this.addToFileList$4("bitmapfont", key, textureURL, P.LinkedHashMap_LinkedHashMap$_literal(["xmlURL", null, "xmlData", xml, "xSpacing", xSpacing, "ySpacing", ySpacing], null, null));
        }
      }
      return this;
    }, function(key, textureURL) {
      return this.bitmapFont$6(key, textureURL, null, null, 0, 0);
    }, "bitmapFont$2", function(key, textureURL, xmlURL) {
      return this.bitmapFont$6(key, textureURL, xmlURL, null, 0, 0);
    }, "bitmapFont$3", function(key, textureURL, xmlURL, xmlData) {
      return this.bitmapFont$6(key, textureURL, xmlURL, xmlData, 0, 0);
    }, "bitmapFont$4", function(key, textureURL, xmlURL, xmlData, xSpacing) {
      return this.bitmapFont$6(key, textureURL, xmlURL, xmlData, xSpacing, 0);
    }, "bitmapFont$5", "call$6", "call$2", "call$3", "call$4", "call$5", "get$bitmapFont", 4, 8, 1445, 12, 12, 49, 49, 269, [], 1446, [], 1447, [], 1401, [], 334, [], 335, [], "bitmapFont"],
    atlasJSONArray$4: [function(key, textureURL, atlasURL, atlasData) {
      return this.atlas$5(key, textureURL, atlasURL, atlasData, 0);
    }, function(key, textureURL) {
      return this.atlasJSONArray$4(key, textureURL, null, null);
    }, "atlasJSONArray$2", function(key, textureURL, atlasURL) {
      return this.atlasJSONArray$4(key, textureURL, atlasURL, null);
    }, "atlasJSONArray$3", "call$4", "call$2", "call$3", "get$atlasJSONArray", 4, 4, 1448, 12, 12, 269, [], 1446, [], 1443, [], 1399, [], "atlasJSONArray"],
    atlasJSONHash$4: [function(key, textureURL, atlasURL, atlasData) {
      return this.atlas$5(key, textureURL, atlasURL, atlasData, 1);
    }, function(key, textureURL) {
      return this.atlasJSONHash$4(key, textureURL, null, null);
    }, "atlasJSONHash$2", function(key, textureURL, atlasURL) {
      return this.atlasJSONHash$4(key, textureURL, atlasURL, null);
    }, "atlasJSONHash$3", "call$4", "call$2", "call$3", "get$atlasJSONHash", 4, 4, 1448, 12, 12, 269, [], 1446, [], 1443, [], 1399, [], "atlasJSONHash"],
    atlasXML$4: [function(key, textureURL, atlasURL, atlasData) {
      return this.atlas$5(key, textureURL, atlasURL, atlasData, 2);
    }, function(key, textureURL) {
      return this.atlasXML$4(key, textureURL, null, null);
    }, "atlasXML$2", function(key, textureURL, atlasURL) {
      return this.atlasXML$4(key, textureURL, atlasURL, null);
    }, "atlasXML$3", "call$4", "call$2", "call$3", "get$atlasXML", 4, 4, 1448, 12, 12, 269, [], 1446, [], 1443, [], 1399, [], "atlasXML"],
    atlas$5: [function(key, textureURL, atlasURL, atlasData, format) {
      var xml, domparser, t1, exception;
      if (format == null)
        format = 0;
      if (atlasURL != null)
        this.addToFileList$4("textureatlas", key, textureURL, P.LinkedHashMap_LinkedHashMap$_literal(["atlasURL", atlasURL, "format", format], null, null));
      else {
        switch (format) {
          case 0:
            t1 = atlasData;
            if (typeof t1 === "string")
              atlasData = C.JsonCodec_null_null.decode$1(atlasData);
            break;
          case 2:
            t1 = atlasData;
            if (typeof t1 === "string") {
              xml = null;
              try {
                domparser = new DOMParser();
                xml = J.parseFromString$2$x(domparser, atlasData, "text/xml");
              } catch (exception) {
                H.unwrapException(exception);
                xml = null;
              }

              if (xml == null)
                throw H.wrapException(P.Exception_Exception("Phaser.Loader. Invalid Texture Atlas XML given"));
              else
                atlasData = xml;
            }
            break;
        }
        this.addToFileList$4("textureatlas", key, textureURL, P.LinkedHashMap_LinkedHashMap$_literal(["atlasURL", null, "atlasData", atlasData, "format", format], null, null));
      }
      return this;
    }, function(key, textureURL) {
      return this.atlas$5(key, textureURL, null, null, null);
    }, "atlas$2", function(key, textureURL, atlasURL) {
      return this.atlas$5(key, textureURL, atlasURL, null, null);
    }, "atlas$3", function(key, textureURL, atlasURL, atlasData) {
      return this.atlas$5(key, textureURL, atlasURL, atlasData, null);
    }, "atlas$4", "call$5", "call$2", "call$3", "call$4", "get$atlas", 4, 6, 1449, 12, 12, 12, 269, [], 1446, [], 1443, [], 1399, [], 1397, [], "atlas"],
    removeFile$2: [function(type, key) {
      var file = this.getAsset$2(type, key);
      if (file != null)
        J.removeAt$1$ax(this._fileList, file.$index(0, "index"));
    }, "call$2", "get$removeFile", 4, 0, 772, 137, [], 269, [], "removeFile"],
    removeAll$0: [function() {
      J.clear$0$ax(this._fileList);
    }, "call$0", "get$removeAll", 0, 0, 54, "removeAll"],
    start$0: [function(_) {
      if (this.isLoading === true)
        return;
      if (J.$gt$n(J.get$length$asx(this._packList), 0)) {
        this._packIndex = 0;
        this.loadPack$0();
      } else
        this.beginLoad$0();
    }, "call$0", "get$start", 0, 0, 54, "start"],
    beginLoad$0: [function() {
      this.progress = 0;
      this.progressFloat = 0;
      this.hasLoaded = false;
      this.isLoading = true;
      this.onLoadStart.dispatch$1(J.get$length$asx(this._fileList));
      if (J.$gt$n(J.get$length$asx(this._fileList), 0)) {
        this._fileIndex = 0;
        var t1 = J.get$length$asx(this._fileList);
        if (typeof t1 !== "number")
          return H.iae(t1);
        this._progressChunk = 100 / t1;
        this.loadFile$0();
      } else {
        this.progress = 100;
        this.progressFloat = 100;
        this.hasLoaded = true;
        this.isLoading = false;
        this.onLoadComplete.dispatch$0();
      }
    }, "call$0", "get$beginLoad", 0, 0, 54, "beginLoad"],
    loadPack$0: [function() {
      var t1, pack, t2, t3;
      if (J.$index$asx(this._packList, this._packIndex) == null) {
        window;
        t1 = C.JSString_methods.$add("Phaser.Loader loadPackList invalid index ", J.toString$0(this._packIndex));
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      pack = J.$index$asx(this._packList, this._packIndex);
      t1 = J.getInterceptor$asx(pack);
      t2 = t1.$index(pack, "data");
      t3 = this._packIndex;
      if (t2 != null)
        this.packLoadComplete$2(t3, false);
      else
        this.xhrLoad$5(t3, J.$add$ns(this.baseURL, t1.$index(pack, "url")), "text", this.get$packLoadComplete(), this.get$packError());
    }, "call$0", "get$loadPack", 0, 0, 54, "loadPack"],
    packLoadComplete$2: [function(index, parse) {
      var t1, pack, data, t2, i, t3, file, t4, t5, overwrite, frameHeight, frameHeight0, t6, t7;
      if (J.$index$asx(this._packList, index) == null) {
        window;
        t1 = C.JSString_methods.$add("Phaser.Loader packLoadComplete invalid index ", J.toString$0(index));
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      pack = J.$index$asx(this._packList, index);
      t1 = J.getInterceptor$ax(pack);
      t1.$indexSet(pack, "loaded", true);
      data = parse === true ? C.JsonCodec_null_null.decode$1(J.get$responseText$x(this._xhr)) : J.$index$asx(J.$index$asx(this._packList, index), "data");
      t2 = J.getInterceptor$asx(data);
      if (t2.$index(data, t1.$index(pack, "key")) != null) {
        i = 0;
        while (true) {
          t3 = J.get$length$asx(t2.$index(data, t1.$index(pack, "key")));
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          file = J.$index$asx(t2.$index(data, t1.$index(pack, "key")), i);
          t3 = J.getInterceptor$asx(file);
          switch (t3.$index(file, "type")) {
            case "image":
              t4 = t3.$index(file, "key");
              t5 = t3.$index(file, "url");
              overwrite = t3.$index(file, "overwrite");
              if ((overwrite == null ? false : overwrite) === true)
                this.replaceInFileList$3("image", t4, t5);
              else
                this.addToFileList$3("image", t4, t5);
              break;
            case "text":
              t4 = t3.$index(file, "key");
              t5 = t3.$index(file, "url");
              overwrite = t3.$index(file, "overwrite");
              if ((overwrite == null ? false : overwrite) === true)
                this.replaceInFileList$3("text", t4, t5);
              else
                this.addToFileList$3("text", t4, t5);
              break;
            case "json":
              t4 = t3.$index(file, "key");
              t5 = t3.$index(file, "url");
              overwrite = t3.$index(file, "overwrite");
              if ((overwrite == null ? false : overwrite) === true)
                this.replaceInFileList$3("json", t4, t5);
              else
                this.addToFileList$3("json", t4, t5);
              break;
            case "xml":
              t4 = t3.$index(file, "key");
              t5 = t3.$index(file, "url");
              if (t3.$index(file, "overwrite") === true)
                this.replaceInFileList$3("xml", t4, t5);
              else
                this.addToFileList$3("xml", t4, t5);
              break;
            case "script":
              t4 = t3.$index(file, "key");
              t5 = t3.$index(file, "url");
              t3 = t3.$index(file, "callback");
              if (t3 != null)
                this.addToFileList$4("script", t4, t5, P.LinkedHashMap_LinkedHashMap$_literal(["callback", t3], null, null));
              break;
            case "binary":
              t4 = t3.$index(file, "key");
              t5 = t3.$index(file, "url");
              t3 = t3.$index(file, "callback");
              if (t3 != null)
                this.addToFileList$4("binary", t4, t5, P.LinkedHashMap_LinkedHashMap$_literal(["callback", t3], null, null));
              break;
            case "spritesheet":
              t4 = t3.$index(file, "key");
              t5 = t3.$index(file, "url");
              frameHeight = t3.$index(file, "frameWidth");
              frameHeight0 = t3.$index(file, "frameHeight");
              t6 = t3.$index(file, "frameMax");
              t7 = t3.$index(file, "margin");
              t3 = t3.$index(file, "spacing");
              this.addToFileList$4("spritesheet", t4, t5, P.LinkedHashMap_LinkedHashMap$_literal(["frameWidth", frameHeight, "frameHeight", frameHeight0 == null ? frameHeight : frameHeight0, "frameMax", t6, "margin", t7, "spacing", t3], null, null));
              break;
            case "audio":
              this.addToFileList$4("audio", t3.$index(file, "key"), t3.$index(file, "urls"), P.LinkedHashMap_LinkedHashMap$_literal(["buffer", null, "autoDecode", t3.$index(file, "autoDecode")], null, null));
              break;
            case "tilemap":
              this.tilemap$4(t3.$index(file, "key"), t3.$index(file, "url"), t3.$index(file, "data"), C.Map_do86y.$index(0, t3.$index(file, "format")));
              break;
            case "physics":
              this.physics$4(t3.$index(file, "key"), t3.$index(file, "url"), t3.$index(file, "data"), C.Map_F9OTV.$index(0, t3.$index(file, "format")));
              break;
            case "bitmapFont":
              this.bitmapFont$6(t3.$index(file, "key"), t3.$index(file, "textureURL"), t3.$index(file, "xmlURL"), t3.$index(file, "xmlData"), t3.$index(file, "xSpacing"), t3.$index(file, "ySpacing"));
              break;
            case "atlasJSONArray":
              this.atlas$5(t3.$index(file, "key"), t3.$index(file, "textureURL"), t3.$index(file, "atlasURL"), t3.$index(file, "atlasData"), 0);
              break;
            case "atlasJSONHash":
              this.atlas$5(t3.$index(file, "key"), t3.$index(file, "textureURL"), t3.$index(file, "atlasURL"), t3.$index(file, "atlasData"), 1);
              break;
            case "atlasXML":
              this.atlas$5(t3.$index(file, "key"), t3.$index(file, "textureURL"), t3.$index(file, "atlasURL"), t3.$index(file, "atlasData"), 2);
              break;
            case "atlas":
              this.atlas$5(t3.$index(file, "key"), t3.$index(file, "textureURL"), t3.$index(file, "atlasURL"), t3.$index(file, "atlasData"), C.Map_F9OTV.$index(0, t3.$index(file, "format")));
              break;
          }
          ++i;
        }
      }
      this.nextPack$2(index, true);
    }, function(index) {
      return this.packLoadComplete$2(index, true);
    }, "packLoadComplete$1", "call$2", "call$1", "get$packLoadComplete", 2, 2, 1450, 78, 281, [], 1451, [], "packLoadComplete"],
    packError$1: [function(index) {
      var t1;
      J.$indexSet$ax(J.$index$asx(this._packList, index), "loaded", true);
      J.$indexSet$ax(J.$index$asx(this._packList, index), "error", true);
      this.onFileError.dispatch$1([J.$index$asx(J.$index$asx(this._packList, index), "key"), J.$index$asx(this._packList, index)]);
      window;
      t1 = C.JSString_methods.$add(C.JSString_methods.$add("Phaser.Loader error loading pack file: ", J.$index$asx(J.$index$asx(this._packList, index), "key")) + " from URL ", J.$index$asx(J.$index$asx(this._packList, index), "url"));
      if (typeof console != "undefined")
        console.warn(t1);
      this.nextPack$2(index, false);
    }, "call$1", "get$packError", 2, 0, 99, 281, [], "packError"],
    nextPack$2: [function(index, success) {
      var t1;
      this.onPackComplete.dispatch$1([J.$index$asx(J.$index$asx(this._packList, index), "key"), success, this.totalLoadedPacks$0(), J.get$length$asx(this._packList)]);
      t1 = J.$add$ns(this._packIndex, 1);
      this._packIndex = t1;
      if (J.$lt$n(t1, J.get$length$asx(this._packList)))
        this.loadPack$0();
      else
        this.beginLoad$0();
    }, "call$2", "get$nextPack", 4, 0, 1452, 281, [], 1453, [], "nextPack"],
    loadFile$0: [function() {
      var t1, file, t2, t3, t4;
      if (J.$index$asx(this._fileList, this._fileIndex) == null) {
        window;
        t1 = "Phaser.Loader loadFile invalid index " + H.Primitives_objectToString(this) + "._fileIndex";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      file = J.$index$asx(this._fileList, this._fileIndex);
      t1 = J.getInterceptor$asx(file);
      this.onFileStart.dispatch$1([this.progress, t1.$index(file, "key"), t1.$index(file, "url")]);
      switch (t1.$index(file, "type")) {
        case "image":
        case "spritesheet":
        case "textureatlas":
        case "bitmapfont":
          t2 = W.ImageElement_ImageElement(null, null, null);
          t2.toString;
          t3 = t1.$index(file, "key");
          t2.setAttribute("data-" + H.S(new W._DataAttributeMap(new W._ElementAttributeMap(t2))._toHyphenedName$1("name")), t3);
          t3 = J.getInterceptor$x(t2);
          t4 = t3.get$onLoad(t2);
          H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t4._target, t4._eventType, W._wrapZone(new R.Loader_loadFile_closure(this)), t4._useCapture), [H.getTypeArgumentByIndex(t4, 0)])._tryResume$0();
          t3 = t3.get$onError(t2);
          H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t3._target, t3._eventType, W._wrapZone(new R.Loader_loadFile_closure0(this)), t3._useCapture), [H.getTypeArgumentByIndex(t3, 0)])._tryResume$0();
          t1.$indexSet(file, "data", t2);
          if (this.crossOrigin != null)
            J.set$crossOrigin$x(t1.$index(file, "data"), this.crossOrigin);
          J.set$src$x(t1.$index(file, "data"), J.$add$ns(this.baseURL, t1.$index(file, "url")));
          break;
        case "audio":
          t1.$indexSet(file, "url", this.getAudioURL$1(t1.$index(file, "url")));
          if (t1.$index(file, "url") != null) {
            if (this.game.get$sound().get$usingWebAudio() === true)
              this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "url")), "arraybuffer", this.get$fileComplete(), this.get$fileError());
            else if (this.game.get$sound().get$usingAudioTag() === true)
              if (this.game.get$sound().get$touchLocked() === true) {
                t2 = W.AudioElement_AudioElement(null);
                t3 = t1.$index(file, "key");
                t2.setAttribute("data-" + H.S(new W._DataAttributeMap(new W._ElementAttributeMap(t2))._toHyphenedName$1("name")), t3);
                t2.preload = "auto";
                t2.src = J.$add$ns(this.baseURL, t1.$index(file, "url"));
                t1.$indexSet(file, "data", t2);
                this.fileComplete$1(this._fileIndex);
              } else {
                t2 = W.AudioElement_AudioElement(null);
                t3 = t1.$index(file, "key");
                t2.setAttribute("data-" + H.S(new W._DataAttributeMap(new W._ElementAttributeMap(t2))._toHyphenedName$1("name")), t3);
                t3 = C.EventStreamProvider_error.forElement$1(t2);
                H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t3._target, t3._eventType, W._wrapZone(new R.Loader_loadFile_closure1(this)), t3._useCapture), [H.getTypeArgumentByIndex(t3, 0)])._tryResume$0();
                t2.preload = "auto";
                t3 = C.EventStreamProvider_canplaythrough.forElement$1(t2);
                H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t3._target, t3._eventType, W._wrapZone(new R.Loader_loadFile_closure2(this)), t3._useCapture), [H.getTypeArgumentByIndex(t3, 0)])._tryResume$0();
                t2.src = J.$add$ns(this.baseURL, t1.$index(file, "url"));
                t2.load();
                t1.$indexSet(file, "data", t2);
              }
          } else
            this.fileError$1(this._fileIndex);
          break;
        case "json":
          this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "url")), "text", this.get$jsonLoadComplete(), this.get$dataLoadError());
          break;
        case "xml":
          this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "url")), "text", this.get$xmlLoadComplete(), this.get$dataLoadError());
          break;
        case "tilemap":
          if (J.$eq(t1.$index(file, "format"), 1))
            this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "url")), "text", this.get$jsonLoadComplete(), this.get$dataLoadError());
          else if (J.$eq(t1.$index(file, "format"), 0))
            this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "url")), "text", this.get$csvLoadComplete(), this.get$dataLoadError());
          else
            throw H.wrapException(P.Exception_Exception(C.JSString_methods.$add("Phaser.Loader. Invalid Tilemap format: ", t1.$index(file, "format"))));
          break;
        case "text":
        case "script":
        case "physics":
          this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "url")), "text", this.get$fileComplete(), this.get$fileError());
          break;
        case "binary":
          this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "url")), "arraybuffer", this.get$fileComplete(), this.get$fileError());
          break;
      }
    }, "call$0", "get$loadFile", 0, 0, 54, "loadFile"],
    xhrLoad$5: [function(index, url, type, onLoad, onError) {
      var t1 = new XMLHttpRequest();
      this._xhr = t1;
      C.HttpRequest_methods.open$3$async(t1, "GET", url, true);
      J.set$responseType$x(this._xhr, type);
      J.get$onLoad$x(this._xhr).listen$1(new R.Loader_xhrLoad_closure(index, onLoad));
      J.get$onError$x(this._xhr).listen$1(new R.Loader_xhrLoad_closure0(index, onError));
      J.send$0$x(this._xhr);
    }, "call$5", "get$xhrLoad", 10, 0, 1454, 281, [], 127, [], 137, [], 1455, [], 1456, [], "xhrLoad"],
    getAudioURL$1: [function(urls) {
      var t1, i, t2, url;
      if (typeof urls === "string")
        urls = [urls];
      t1 = J.getInterceptor$asx(urls);
      i = 0;
      while (true) {
        t2 = t1.get$length(urls);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        url = t1.$index(urls, i);
        if (this.game.get$device().canPlayAudio$1(C.JSArray_methods.get$last(J.split$1$s(url, "."))))
          return url;
        ++i;
      }
      return;
    }, "call$1", "get$getAudioURL", 2, 0, 102, 1442, [], "getAudioURL"],
    fileError$1: [function(index) {
      var t1;
      J.$indexSet$ax(J.$index$asx(this._fileList, index), "loaded", true);
      J.$indexSet$ax(J.$index$asx(this._fileList, index), "error", true);
      this.onFileError.dispatch$1([J.$index$asx(J.$index$asx(this._fileList, index), "key"), J.$index$asx(this._fileList, index)]);
      window;
      t1 = C.JSString_methods.$add(C.JSString_methods.$add("Phaser.Loader error loading file: ", J.$index$asx(J.$index$asx(this._fileList, index), "key")) + " from URL ", J.$index$asx(J.$index$asx(this._fileList, index), "url"));
      if (typeof console != "undefined")
        console.warn(t1);
      this.nextFile$2(index, false);
    }, "call$1", "get$fileError", 2, 0, 99, 281, [], "fileError"],
    fileComplete$1: [function(index) {
      var t1, file, loadNext, key, buffer, t2, data;
      if (J.$index$asx(this._fileList, index) == null) {
        window;
        t1 = C.JSString_methods.$add("Phaser.Loader fileComplete invalid index ", J.toString$0(index));
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      file = J.$index$asx(this._fileList, index);
      t1 = J.getInterceptor$ax(file);
      t1.$indexSet(file, "loaded", true);
      switch (t1.$index(file, "type")) {
        case "image":
          this.game.get$cache().addImage$3(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"));
          loadNext = true;
          break;
        case "spritesheet":
          this.game.get$cache().addSpriteSheet$8(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), t1.$index(file, "frameWidth"), t1.$index(file, "frameHeight"), t1.$index(file, "frameMax"), t1.$index(file, "margin"), t1.$index(file, "spacing"));
          loadNext = true;
          break;
        case "textureatlas":
          if (t1.$index(file, "atlasURL") == null) {
            this.game.get$cache().addTextureAtlas$5(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), t1.$index(file, "atlasData"), t1.$index(file, "format"));
            loadNext = true;
          } else {
            if (J.$eq(t1.$index(file, "format"), 0) || J.$eq(t1.$index(file, "format"), 1))
              this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "atlasURL")), "text", this.get$jsonLoadComplete(), this.get$dataLoadError());
            else if (J.$eq(t1.$index(file, "format"), 2))
              this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "atlasURL")), "text", this.get$xmlLoadComplete(), this.get$dataLoadError());
            else
              throw H.wrapException(P.Exception_Exception(C.JSString_methods.$add("Phaser.Loader. Invalid Texture Atlas format: ", t1.$index(file, "format"))));
            loadNext = false;
          }
          break;
        case "bitmapfont":
          if (t1.$index(file, "xmlURL") == null) {
            this.game.get$cache().addBitmapFont$6(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), t1.$index(file, "xmlData"), t1.$index(file, "xSpacing"), t1.$index(file, "ySpacing"));
            loadNext = true;
          } else {
            this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "xmlURL")), "text", this.get$xmlLoadComplete(), this.get$dataLoadError());
            loadNext = false;
          }
          break;
        case "audio":
          if (this.game.get$sound().get$usingWebAudio() === true) {
            t1.$indexSet(file, "data", J.get$response$x(this._xhr));
            this.game.get$cache().addSound$5(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), true, false);
            if (t1.$index(file, "autoDecode") === true) {
              key = t1.$index(file, "key");
              this.game.get$cache().updateSound$3(key, "isDecoding", true);
              buffer = t1.$index(file, "data");
              J.decodeAudioData$1$x(J.get$context$x(this.game.get$sound()), buffer).then$1(new R.Loader_fileComplete_closure(this, key));
            }
          } else {
            t2 = H.interceptedTypeCast(t1.$index(file, "data"), "$isAudioElement");
            t2.toString;
            t2 = C.EventStreamProvider_canplaythrough.forElement$1(t2);
            H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t2._target, t2._eventType, W._wrapZone(new R.Loader_fileComplete_closure0(this, index)), t2._useCapture), [H.getTypeArgumentByIndex(t2, 0)])._tryResume$0();
            this.game.get$cache().addSound$5(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), false, true);
          }
          loadNext = true;
          break;
        case "text":
          t1.$indexSet(file, "data", J.get$responseText$x(this._xhr));
          this.game.get$cache().addText$3(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"));
          loadNext = true;
          break;
        case "physics":
          data = C.JsonCodec_null_null.decode$1(J.get$responseText$x(this._xhr));
          this.game.get$cache().addPhysicsData$4(t1.$index(file, "key"), t1.$index(file, "url"), data, t1.$index(file, "format"));
          loadNext = true;
          break;
        case "binary":
          if (t1.$index(file, "callback") != null)
            t1.$indexSet(file, "data", t1.$index(file, "callback").call$2(t1.$index(file, "key"), J.get$response$x(this._xhr)));
          else
            t1.$indexSet(file, "data", J.get$response$x(this._xhr));
          this.game.get$cache().addBinary$2(t1.$index(file, "key"), t1.$index(file, "data"));
          loadNext = true;
          break;
        default:
          loadNext = true;
      }
      if (loadNext)
        this.nextFile$2(index, true);
    }, "call$1", "get$fileComplete", 2, 0, 99, 281, [], "fileComplete"],
    jsonLoadComplete$1: [function(index) {
      var t1, file, data, t2, t3;
      if (J.$index$asx(this._fileList, index) == null) {
        window;
        t1 = "Phaser.Loader jsonLoadComplete invalid index " + H.S(index);
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      file = J.$index$asx(this._fileList, index);
      data = C.JsonCodec_null_null.decode$1(J.get$responseText$x(this._xhr));
      t1 = J.getInterceptor$ax(file);
      t1.$indexSet(file, "loaded", true);
      if (J.$eq(t1.$index(file, "type"), "tilemap"))
        this.game.get$cache().addTilemap$4(t1.$index(file, "key"), t1.$index(file, "url"), data, t1.$index(file, "format"));
      else {
        t2 = J.$eq(t1.$index(file, "type"), "json");
        t3 = this.game;
        if (t2)
          t3.get$cache().addJSON$3(t1.$index(file, "key"), t1.$index(file, "url"), data);
        else
          t3.get$cache().addTextureAtlas$5(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), data, t1.$index(file, "format"));
      }
      this.nextFile$2(index, true);
    }, "call$1", "get$jsonLoadComplete", 2, 0, 99, 281, [], "jsonLoadComplete"],
    csvLoadComplete$1: [function(index) {
      var t1, file, data;
      if (J.$index$asx(this._fileList, index) == null) {
        window;
        t1 = C.JSString_methods.$add("Phaser.Loader csvLoadComplete invalid index ", J.toString$0(index));
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      file = J.$index$asx(this._fileList, index);
      data = J.get$responseText$x(this._xhr);
      t1 = J.getInterceptor$ax(file);
      t1.$indexSet(file, "loaded", true);
      this.game.get$cache().addTilemap$4(t1.$index(file, "key"), t1.$index(file, "url"), data, t1.$index(file, "format"));
      this.nextFile$2(index, true);
    }, "call$1", "get$csvLoadComplete", 2, 0, 99, 281, [], "csvLoadComplete"],
    dataLoadError$1: [function(index) {
      var file, t1;
      file = J.$index$asx(this._fileList, index);
      t1 = J.getInterceptor$ax(file);
      t1.$indexSet(file, "loaded", true);
      t1.$indexSet(file, "error", true);
      window;
      t1 = C.JSString_methods.$add("Phaser.Loader dataLoadError: ", t1.$index(file, "key"));
      if (typeof console != "undefined")
        console.warn(t1);
      this.nextFile$2(index, true);
    }, "call$1", "get$dataLoadError", 2, 0, 99, 281, [], "dataLoadError"],
    xmlLoadComplete$1: [function(index) {
      var data, xml, domparser, t1, exception, file;
      if (J.get$responseType$x(this._xhr) !== "" && J.get$responseType$x(this._xhr) !== "text") {
        window;
        t1 = C.JSString_methods.$add("Invalid XML Response Type", J.toString$0(J.$index$asx(this._fileList, index)));
        if (typeof console != "undefined")
          console.warn(t1);
        window;
        t1 = this._xhr;
        if (typeof console != "undefined")
          console.warn(t1);
      }
      data = J.get$responseText$x(this._xhr);
      xml = null;
      try {
        domparser = new DOMParser();
        xml = J.parseFromString$2$x(domparser, data, "text/xml");
      } catch (exception) {
        H.unwrapException(exception);
        xml = null;
      }

      if (xml == null)
        throw H.wrapException(P.Exception_Exception("Phaser.Loader. Invalid XML given"));
      file = J.$index$asx(this._fileList, index);
      t1 = J.getInterceptor$ax(file);
      t1.$indexSet(file, "loaded", true);
      if (J.$eq(t1.$index(file, "type"), "bitmapfont"))
        this.game.get$cache().addBitmapFont$6(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), xml, t1.$index(file, "xSpacing"), t1.$index(file, "ySpacing"));
      else if (J.$eq(t1.$index(file, "type"), "textureatlas"))
        this.game.get$cache().addTextureAtlas$5(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), xml, t1.$index(file, "format"));
      else if (J.$eq(t1.$index(file, "type"), "xml"))
        this.game.get$cache().addXML$3(t1.$index(file, "key"), t1.$index(file, "url"), xml);
      this.nextFile$2(index, true);
    }, "call$1", "get$xmlLoadComplete", 2, 0, 99, 281, [], "xmlLoadComplete"],
    nextFile$2: [function(previousIndex, success) {
      var t1, t2;
      t1 = J.$add$ns(this.progressFloat, this._progressChunk);
      this.progressFloat = t1;
      t1 = J.round$0$n(t1);
      this.progress = t1;
      if (t1 > 100)
        this.progress = 100;
      t1 = this.preloadSprite;
      if (t1 != null) {
        t1 = J.$eq(J.$index$asx(t1, "direction"), 0);
        t2 = this.preloadSprite;
        if (t1)
          J.set$width$x(J.$index$asx(t2, "rect"), J.floor$0$n(J.$mul$ns(J.$div$n(J.$index$asx(this.preloadSprite, "width"), 100), this.progress)));
        else
          J.set$height$x(J.$index$asx(t2, "rect"), J.floor$0$n(J.$mul$ns(J.$div$n(J.$index$asx(this.preloadSprite, "height"), 100), this.progress)));
        J.$index$asx(this.preloadSprite, "sprite").updateCrop$0();
      }
      this.onFileComplete.dispatch$1([this.progress, J.$index$asx(J.$index$asx(this._fileList, previousIndex), "key"), success, this.totalLoadedFiles$0(), J.get$length$asx(this._fileList)]);
      if (this.totalQueuedFiles$0() > 0) {
        this._fileIndex = J.$add$ns(this._fileIndex, 1);
        this.loadFile$0();
      } else {
        this.hasLoaded = true;
        this.isLoading = false;
        J.clear$0$ax(this._fileList);
        this.onLoadComplete.dispatch$0();
      }
    }, "call$2", "get$nextFile", 4, 0, 1452, 1457, [], 1453, [], "nextFile"],
    totalLoadedFiles$0: [function() {
      var total, i, t1;
      total = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._fileList);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(J.$index$asx(this._fileList, i), "loaded") === true)
          ++total;
        ++i;
      }
      return total;
    }, "call$0", "get$totalLoadedFiles", 0, 0, 54, "totalLoadedFiles"],
    totalQueuedFiles$0: [function() {
      var total, i, t1;
      total = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._fileList);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "loaded"), false))
          ++total;
        ++i;
      }
      return total;
    }, "call$0", "get$totalQueuedFiles", 0, 0, 412, "totalQueuedFiles"],
    totalLoadedPacks$0: [function() {
      var total, i, t1;
      total = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._packList);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(J.$index$asx(this._packList, i), "loaded") === true)
          ++total;
        ++i;
      }
      return total;
    }, "call$0", "get$totalLoadedPacks", 0, 0, 54, "totalLoadedPacks"],
    totalQueuedPacks$0: [function() {
      var total, i, t1;
      total = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._packList);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$eq(J.$index$asx(J.$index$asx(this._packList, i), "loaded"), false))
          ++total;
        ++i;
      }
      return total;
    }, "call$0", "get$totalQueuedPacks", 0, 0, 54, "totalQueuedPacks"],
    Loader$1: function(game) {
      this.isLoading = false;
      this.hasLoaded = false;
      this.progress = 0;
      this.progressFloat = 0;
      this.preloadSprite = null;
      this.crossOrigin = null;
      this.baseURL = "";
      this.onLoadStart = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onFileStart = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onFileComplete = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onFileError = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onLoadComplete = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onPackComplete = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this._packList = [];
      this._packIndex = 0;
      this._fileList = [];
      this._fileIndex = 0;
      this._progressChunk = 0;
      this._xhr = new XMLHttpRequest();
    },
    static: {"^": "Loader_TEXTURE_ATLAS_JSON_ARRAY<-614,Loader_TEXTURE_ATLAS_JSON_HASH<-614,Loader_TEXTURE_ATLAS_XML_STARLING<-614,Loader_PHYSICS_LIME_CORONA_JSON<-614,Loader_PHYSICS_PHASER_JSON<-614,Loader_Format<-946", Loader$0: [function(game) {
        var t1 = new R.Loader(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Loader$1(game);
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new Loader"]}
  },
  "+Loader": [674],
  Loader_loadFile_closure: {
    "^": "Closure:102;_this_0",
    call$1: [function(e) {
      var t1 = this._this_0;
      return t1.fileComplete$1(t1._fileIndex);
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  Loader_loadFile_closure0: {
    "^": "Closure:102;_this_1",
    call$1: [function(e) {
      var t1 = this._this_1;
      return t1.fileError$1(t1._fileIndex);
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  Loader_loadFile_closure1: {
    "^": "Closure:102;_this_2",
    call$1: [function(e) {
      var t1 = this._this_2;
      return t1.fileError$1(t1._fileIndex);
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  Loader_loadFile_closure2: {
    "^": "Closure:102;this_3",
    call$1: [function(e) {
      var t1, t2, t3;
      t1 = $.get$GAMES();
      t2 = this.this_3;
      t3 = J.get$id$x(t2.game);
      if (t3 >>> 0 !== t3 || t3 >= t1.length)
        return H.ioore(t1, t3);
      t1[t3].load.fileComplete$1(t2._fileIndex);
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  Loader_xhrLoad_closure: {
    "^": "Closure:102;index_0,onLoad_1",
    call$1: [function(e) {
      return this.onLoad_1.call$1(this.index_0);
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  Loader_xhrLoad_closure0: {
    "^": "Closure:102;index_2,onError_3",
    call$1: [function(e) {
      return this.onError_3.call$1(this.index_2);
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  Loader_fileComplete_closure: {
    "^": "Closure:1458;that_0,key_1",
    call$1: [function(buffer) {
      var t1, t2;
      if (buffer != null) {
        t1 = this.that_0;
        t2 = this.key_1;
        t1.game.get$cache().decodedSound$2(t2, buffer);
        t1.game.get$sound().get$onSoundDecode().dispatch$1([t2, t1.game.get$cache().getSound$1(t2)]);
      }
    }, "call$1", null, 2, 0, 1458, 886, [], "call"]
  },
  Loader_fileComplete_closure0: {
    "^": "Closure:102;this_2,index_3",
    call$1: [function(e) {
      var t1, t2;
      t1 = $.get$GAMES();
      t2 = J.get$id$x(this.this_2.game);
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2].load.fileComplete$1(this.index_3);
    }, "call$1", null, 2, 0, 102, 356, [], "call"]
  },
  LoaderParser: {
    "^": "Object;",
    static: {LoaderParser$: [function() {
        return new R.LoaderParser();
      }, null, null, 0, 0, 370, "new LoaderParser"], LoaderParser_bitmapFont: [function(game, xml, cacheKey, xSpacing, ySpacing) {
        var data, t1, t2, info, common, letters, i, charCode, t3, t4, t5, t6, t7, t8, kernings, first, second, amount;
        data = new M.ChartData(null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1 = J.getInterceptor$x(xml);
        t2 = t1.getElementsByTagName$1(xml, "info");
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        info = t2[0];
        t2 = t1.getElementsByTagName$1(xml, "common");
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        common = t2[0];
        t2 = J.getInterceptor$x(info);
        data.font = t2.getAttribute$1(info, "face");
        data.size = H.Primitives_parseInt(t2.getAttribute$1(info, "size"), null, null);
        data.lineHeight = J.$add$ns(H.Primitives_parseInt(J.getAttribute$1$x(common, "lineHeight"), null, null), ySpacing);
        data.chars = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        letters = t1.getElementsByTagName$1(xml, "char");
        for (i = 0; i < letters.length; ++i) {
          charCode = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "id"), null, null);
          if (i >= letters.length)
            return H.ioore(letters, i);
          t2 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "x"), null, null);
          if (i >= letters.length)
            return H.ioore(letters, i);
          t3 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "y"), null, null);
          if (i >= letters.length)
            return H.ioore(letters, i);
          t4 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "width"), null, null);
          if (i >= letters.length)
            return H.ioore(letters, i);
          t5 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "height"), null, null);
          t6 = data.chars;
          t7 = new M.Char(null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
          if (i >= letters.length)
            return H.ioore(letters, i);
          t7.xOffset = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "xoffset"), null, null);
          if (i >= letters.length)
            return H.ioore(letters, i);
          t7.yOffset = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "yoffset"), null, null);
          if (i >= letters.length)
            return H.ioore(letters, i);
          t7.xAdvance = J.$add$ns(H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "xadvance"), null, null), xSpacing);
          t7.kernings = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
          t8 = $.get$TextureCache();
          t5 = M.Texture$(J.$index$asx($.get$BaseTextureCache(), cacheKey), new M.Rectangle0(t2, t3, t4, t5));
          J.$indexSet$ax(t8, cacheKey, t5);
          t7.texture = t5;
          J.$indexSet$ax(t6, charCode, t7);
        }
        kernings = t1.getElementsByTagName$1(xml, "kerning");
        for (i = 0; i < kernings.length; ++i) {
          first = H.Primitives_parseInt(J.getAttribute$1$x(kernings[i], "first"), null, null);
          if (i >= kernings.length)
            return H.ioore(kernings, i);
          second = H.Primitives_parseInt(J.getAttribute$1$x(kernings[i], "second"), null, null);
          if (i >= kernings.length)
            return H.ioore(kernings, i);
          amount = H.Primitives_parseInt(J.getAttribute$1$x(kernings[i], "amount"), null, null);
          J.$indexSet$ax(J.$index$asx(data.chars, second).get$kernings(), first, amount);
        }
        J.$indexSet$ax($.get$BitmapText_fonts(), cacheKey, data);
      }, "call$5", "LoaderParser_bitmapFont$closure", 10, 0, 371, 252, [], 279, [], 277, [], 334, [], 335, [], "bitmapFont"]}
  },
  "+LoaderParser": [674],
  SinCosTable: {
    "^": "Object;sin@-1459,cos@-1459,length*-614",
    static: {SinCosTable$: [function() {
        return new R.SinCosTable(null, null, null);
      }, null, null, 0, 0, 372, "new SinCosTable"]}
  },
  "+SinCosTable": [674],
  Math: {
    "^": "Object;",
    numberArrayStep$3: [function(start, end, step) {
      var $length, result, t1, index;
      if (end == null) {
        end = start;
        start = 0;
      }
      $length = P.max(J.ceil$0$n(J.$div$n(J.$sub$n(end, start), step)), 0);
      result = Array($length);
      result.fixed$length = init;
      for (t1 = result.length, index = -1; ++index, index < $length;) {
        if (index >= t1)
          return H.ioore(result, index);
        result[index] = start;
        start = J.$add$ns(start, step);
      }
      return result;
    }, function(start) {
      return this.numberArrayStep$3(start, null, 1);
    }, "numberArrayStep$1", function(start, end) {
      return this.numberArrayStep$3(start, end, 1);
    }, "numberArrayStep$2", function() {
      return this.numberArrayStep$3(0, null, 1);
    }, "numberArrayStep$0", "call$3", "call$1", "call$2", "call$0", "get$numberArrayStep", 0, 6, 1460, 49, 12, 433, 261, [], 694, [], 98, [], "numberArrayStep"],
    static: {"^": "Math_SQRT1_2<-671,Math_SQRT2<-671,Math_PI<-671,Math_PI2<-671,Math_random<-1461,Math__degreeToRadiansFactor<-671,Math__radianToDegreesFactor<-671", Math$_: [function() {
        return new R.Math();
      }, null, null, 0, 0, 54, "new Math$_"], Math_pow: [function(th, exp) {
        H.checkNum(th);
        H.checkNum(exp);
        return Math.pow(th, exp);
      }, "call$2", "Math_pow$closure", 4, 0, 373, 374, [], 375, [], "pow"], Math_cos: [function(th) {
        return Math.cos(H.checkNum(th));
      }, "call$1", "Math_cos$closure", 2, 0, 376, 374, [], "cos"], Math_sin: [function(th) {
        return Math.sin(H.checkNum(th));
      }, "call$1", "Math_sin$closure", 2, 0, 376, 374, [], "sin"], Math_abs: [function(val) {
        return J.abs$0$n(val);
      }, "call$1", "Math_abs$closure", 2, 0, 376, 377, [], "abs"], Math_sqrt: [function(val) {
        return Math.sqrt(H.checkNum(val));
      }, "call$1", "Math_sqrt$closure", 2, 0, 376, 377, [], "sqrt"], Math_atan2: [function(a, b) {
        return Math.atan2(H.checkNum(a), H.checkNum(b));
      }, "call$2", "Math_atan2$closure", 4, 0, 373, 348, [], 349, [], "atan2"], Math_round: [function(val) {
        return J.round$0$n(val);
      }, "call$1", "Math_round$closure", 2, 0, 376, 377, [], "round"], Math_fuzzyEqual: [function(a, b, epsilon) {
        return J.$lt$n(J.abs$0$n(J.$sub$n(a, b)), epsilon);
      }, function(a, b) {
        return R.Math_fuzzyEqual(a, b, 0.0001);
      }, null, "call$3", "call$2", "Math_fuzzyEqual$closure", 4, 2, 378, 379, 348, [], 349, [], 380, [], "fuzzyEqual"], Math_fuzzyLessThan: [function(a, b, epsilon) {
        return J.$lt$n(a, J.$add$ns(b, epsilon));
      }, function(a, b) {
        return R.Math_fuzzyLessThan(a, b, 0.0001);
      }, null, "call$3", "call$2", "Math_fuzzyLessThan$closure", 4, 2, 378, 379, 348, [], 349, [], 380, [], "fuzzyLessThan"], Math_fuzzyGreaterThan: [function(a, b, epsilon) {
        return J.$gt$n(a, J.$sub$n(b, epsilon));
      }, function(a, b) {
        return R.Math_fuzzyGreaterThan(a, b, 0.0001);
      }, null, "call$3", "call$2", "Math_fuzzyGreaterThan$closure", 4, 2, 378, 379, 348, [], 349, [], 380, [], "fuzzyGreaterThan"], Math_fuzzyCeil: [function(val, epsilon) {
        return J.ceil$0$n(J.$sub$n(val, epsilon));
      }, function(val) {
        return R.Math_fuzzyCeil(val, 0.0001);
      }, null, "call$2", "call$1", "Math_fuzzyCeil$closure", 2, 2, 381, 379, 377, [], 380, [], "fuzzyCeil"], Math_fuzzyFloor: [function(val, epsilon) {
        return J.floor$0$n(J.$add$ns(val, epsilon));
      }, function(val) {
        return R.Math_fuzzyFloor(val, 0.0001);
      }, null, "call$2", "call$1", "Math_fuzzyFloor$closure", 2, 2, 381, 379, 377, [], 380, [], "fuzzyFloor"], Math_average: [function(args) {
        var t1 = J.getInterceptor$ax(args);
        return J.$div$n(t1.fold$2(args, 0, new R.Math_average_closure()), t1.get$length(args));
      }, "call$1", "Math_average$closure", 2, 0, 382, 383, [], "average"], Math_truncate: [function(n) {
        var t1 = J.getInterceptor$n(n);
        return t1.$gt(n, 0) ? t1.floor$0(n) : t1.ceil$0(n);
      }, "call$1", "Math_truncate$closure", 2, 0, 384, 385, [], "truncate"], Math_shear: [function(n) {
        return J.$mod$n(n, 1);
      }, "call$1", "Math_shear$closure", 2, 0, 248, 385, [], "shear"], Math_snapTo: [function(input, gap, start) {
        var t1 = J.getInterceptor(gap);
        if (t1.$eq(gap, 0))
          return input;
        return J.$add$ns(start, t1.$mul(gap, J.round$0$n(J.$div$n(J.$sub$n(input, start), gap))));
      }, function(input, gap) {
        return R.Math_snapTo(input, gap, 0);
      }, null, "call$3", "call$2", "Math_snapTo$closure", 4, 2, 386, 49, 387, [], 388, [], 261, [], "snapTo"], Math_snapToFloor: [function(input, gap, start) {
        var t1 = J.getInterceptor(gap);
        if (t1.$eq(gap, 0))
          return input;
        return J.$add$ns(start, t1.$mul(gap, J.floor$0$n(J.$div$n(J.$sub$n(input, start), gap))));
      }, function(input, gap) {
        return R.Math_snapToFloor(input, gap, 0);
      }, null, "call$3", "call$2", "Math_snapToFloor$closure", 4, 2, 386, 49, 387, [], 388, [], 261, [], "snapToFloor"], Math_snapToCeil: [function(input, gap, start) {
        var t1 = J.getInterceptor(gap);
        if (t1.$eq(gap, 0))
          return input;
        return J.$add$ns(start, t1.$mul(gap, J.ceil$0$n(J.$div$n(J.$sub$n(input, start), gap))));
      }, function(input, gap) {
        return R.Math_snapToCeil(input, gap, 0);
      }, null, "call$3", "call$2", "Math_snapToCeil$closure", 4, 2, 386, 49, 387, [], 388, [], 261, [], "snapToCeil"], Math_snapToInArray: [function(input, arr, sort) {
        var t1, t2, i, low, t3, high;
        if (sort === true)
          J.sort$0$ax(arr);
        t1 = J.getInterceptor$asx(arr);
        t2 = J.getInterceptor$n(input);
        if (t2.$lt(input, t1.$index(arr, 0)))
          return t1.$index(arr, 0);
        for (i = 1; J.$lt$n(t1.$index(arr, i), input);)
          ++i;
        low = t1.$index(arr, i - 1);
        t3 = t1.get$length(arr);
        if (typeof t3 !== "number")
          return H.iae(t3);
        high = i < t3 ? t1.$index(arr, i) : 1 / 0;
        return J.$le$n(J.$sub$n(high, input), t2.$sub(input, low)) ? high : low;
      }, function(input, arr) {
        return R.Math_snapToInArray(input, arr, true);
      }, null, "call$3", "call$2", "Math_snapToInArray$closure", 4, 2, 389, 78, 387, [], 390, [], 391, [], "snapToInArray"], Math_roundTo: [function(value, place, base) {
        var t1, p;
        t1 = J.$negate$n(place);
        H.checkNum(base);
        H.checkNum(t1);
        p = Math.pow(base, t1);
        return J.round$0$n(J.$div$n(J.$mul$ns(value, p), p));
      }, function(value) {
        return R.Math_roundTo(value, 0, 10);
      }, null, function(value, place) {
        return R.Math_roundTo(value, place, 10);
      }, null, "call$3", "call$1", "call$2", "Math_roundTo$closure", 2, 4, 392, 49, 393, 138, [], 394, [], 395, [], "roundTo"], Math_floorTo: [function(value, place, base) {
        var t1, p;
        t1 = J.$negate$n(place);
        H.checkNum(base);
        H.checkNum(t1);
        p = Math.pow(base, t1);
        return J.floor$0$n(J.$div$n(J.$mul$ns(value, p), p));
      }, function(value) {
        return R.Math_floorTo(value, 0, 10);
      }, null, function(value, place) {
        return R.Math_floorTo(value, place, 10);
      }, null, "call$3", "call$1", "call$2", "Math_floorTo$closure", 2, 4, 392, 49, 393, 138, [], 394, [], 395, [], "floorTo"], Math_ceilTo: [function(value, place, base) {
        var t1, p;
        t1 = J.$negate$n(place);
        H.checkNum(base);
        H.checkNum(t1);
        p = Math.pow(base, t1);
        return J.floor$0$n(J.$div$n(J.$mul$ns(value, p), p));
      }, function(value) {
        return R.Math_ceilTo(value, 0, 10);
      }, null, function(value, place) {
        return R.Math_ceilTo(value, place, 10);
      }, null, "call$3", "call$1", "call$2", "Math_ceilTo$closure", 2, 4, 392, 49, 393, 138, [], 394, [], 395, [], "ceilTo"], Math_interpolateFloat: [function(a, b, weight) {
        return J.$add$ns(J.$mul$ns(J.$sub$n(b, a), weight), a);
      }, "call$3", "Math_interpolateFloat$closure", 6, 0, 396, 348, [], 349, [], 397, [], "interpolateFloat"], Math_angleBetween: [function(x1, y1, x2, y2) {
        var t1, t2;
        t1 = J.$sub$n(y2, y1);
        t2 = J.$sub$n(x2, x1);
        return Math.atan2(H.checkNum(t1), H.checkNum(t2));
      }, "call$4", "Math_angleBetween$closure", 8, 0, 398, 351, [], 352, [], 353, [], 354, [], "angleBetween"], Math_angleBetweenY: [function(x1, y1, x2, y2) {
        var t1, t2;
        t1 = J.$sub$n(x2, x1);
        t2 = J.$sub$n(y2, y1);
        return Math.atan2(H.checkNum(t1), H.checkNum(t2));
      }, "call$4", "Math_angleBetweenY$closure", 8, 0, 398, 351, [], 352, [], 353, [], 354, [], "angleBetweenY"], Math_angleBetweenPoints: [function(point1, point2) {
        var t1, t2, t3;
        t1 = J.getInterceptor$x(point2);
        t2 = J.getInterceptor$x(point1);
        t3 = J.$sub$n(t1.get$y(point2), t2.get$y(point1));
        point1 = J.$sub$n(t1.get$x(point2), t2.get$x(point1));
        return Math.atan2(H.checkNum(t3), H.checkNum(point1));
      }, "call$2", "Math_angleBetweenPoints$closure", 4, 0, 399, 400, [], 401, [], "angleBetweenPoints"], Math_angleBetweenPointsY: [function(point1, point2) {
        var t1, t2, t3;
        t1 = J.getInterceptor$x(point2);
        t2 = J.getInterceptor$x(point1);
        t3 = J.$sub$n(t1.get$x(point2), t2.get$x(point1));
        point1 = J.$sub$n(t1.get$y(point2), t2.get$y(point1));
        return Math.atan2(H.checkNum(t3), H.checkNum(point1));
      }, "call$2", "Math_angleBetweenPointsY$closure", 4, 0, 399, 400, [], 401, [], "angleBetweenPointsY"], Math_reverseAngle: [function(angleRad) {
        angleRad = J.$mod$n(J.$add$ns(angleRad, 3.141592653589793), 6.283185307179586);
        return angleRad >= 0 ? angleRad : angleRad + 6.283185307179586;
      }, "call$1", "Math_reverseAngle$closure", 2, 0, 376, 402, [], "reverseAngle"], Math_normalizeAngle: [function(angleRad) {
        angleRad = J.$mod$n(angleRad, 6.283185307179586);
        return angleRad >= 0 ? angleRad : angleRad + 6.283185307179586;
      }, "call$1", "Math_normalizeAngle$closure", 2, 0, 376, 402, [], "normalizeAngle"], Math_normalizeLatitude: [function(lat) {
        return P.max(-90, P.min(90, lat));
      }, "call$1", "Math_normalizeLatitude$closure", 2, 0, 376, 403, [], "normalizeLatitude"], Math_normalizeLongitude: [function(lng) {
        var t1 = J.getInterceptor$n(lng);
        if (t1.$mod(lng, 360) === 180)
          return 180;
        lng = t1.$mod(lng, 360);
        if (lng < -180)
          t1 = lng + 360;
        else
          t1 = lng > 180 ? lng - 360 : lng;
        return t1;
      }, "call$1", "Math_normalizeLongitude$closure", 2, 0, 376, 404, [], "normalizeLongitude"], Math_chanceRoll: [function(chance) {
        var t1 = J.getInterceptor$n(chance);
        if (t1.$le(chance, 0))
          return false;
        else if (t1.$ge(chance, 100))
          return true;
        else if (J.$ge$n(J.$mul$ns($.get$Math_random().call$0(), 100), chance))
          return false;
        else
          return true;
      }, function() {
        return R.Math_chanceRoll(50);
      }, null, "call$1", "call$0", "Math_chanceRoll$closure", 0, 2, 405, 406, 407, [], "chanceRoll"], Math_numberArray: [function(min, max) {
        var result, i, t1;
        result = [];
        for (i = min; t1 = J.getInterceptor$n(i), t1.$le(i, max); i = t1.$add(i, 1))
          result.push(i);
        return result;
      }, "call$2", "Math_numberArray$closure", 4, 0, 408, 409, [], 410, [], "numberArray"], Math_maxAdd: [function(value, amount, max) {
        value = J.$add$ns(value, amount);
        return J.$gt$n(value, max) ? max : value;
      }, "call$3", "Math_maxAdd$closure", 6, 0, 396, 138, [], 411, [], 410, [], "maxAdd"], Math_minSub: [function(value, amount, min) {
        value = J.$sub$n(value, amount);
        return J.$lt$n(value, min) ? min : value;
      }, "call$3", "Math_minSub$closure", 6, 0, 396, 138, [], 411, [], 409, [], "minSub"], Math_wrap: [function(value, min, max) {
        var range, result;
        range = J.$sub$n(max, min);
        if (J.$le$n(range, 0))
          return 0;
        result = J.$mod$n(J.$sub$n(value, min), range);
        if (result < 0) {
          if (typeof range !== "number")
            return H.iae(range);
          result += range;
        }
        if (typeof min !== "number")
          return H.iae(min);
        return result + min;
      }, "call$3", "Math_wrap$closure", 6, 0, 396, 138, [], 409, [], 410, [], "wrap"], Math_wrapValue: [function(value, amount, max) {
        value = J.abs$0$n(value);
        amount = J.abs$0$n(amount);
        max = J.abs$0$n(max);
        return J.$mod$n(J.$add$ns(value, amount), max);
      }, "call$3", "Math_wrapValue$closure", 6, 0, 396, 138, [], 411, [], 410, [], "wrapValue"], Math_limitValue: [function(value, min, max) {
        var t1 = J.getInterceptor$n(value);
        if (t1.$lt(value, min))
          t1 = min;
        else
          t1 = t1.$gt(value, max) ? max : value;
        return t1;
      }, "call$3", "Math_limitValue$closure", 6, 0, 396, 138, [], 409, [], 410, [], "limitValue"], Math_randomSign: [function() {
        return J.$gt$n($.get$Math_random().call$0(), 0.5) ? 1 : -1;
      }, "call$0", "Math_randomSign$closure", 0, 0, 412, "randomSign"], Math_isOdd: [function(n) {
        return J.$mod$n(n, 2) === 1;
      }, "call$1", "Math_isOdd$closure", 2, 0, 413, 385, [], "isOdd"], Math_isEven: [function(n) {
        return J.$mod$n(n, 2) === 0;
      }, "call$1", "Math_isEven$closure", 2, 0, 413, 385, [], "isEven"], Math_min: [function(a, b) {
        return P.min(a, b);
      }, "call$2", "Math_min$closure", 4, 0, 373, 348, [], 349, [], "min"], Math_max: [function(a, b) {
        return P.max(a, b);
      }, "call$2", "Math_max$closure", 4, 0, 373, 348, [], 349, [], "max"], Math_minList: [function(args) {
        return J.fold$2$ax(args, 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368, new R.Math_minList_closure());
      }, "call$1", "Math_minList$closure", 2, 0, 414, 383, [], "minList"], Math_maxList: [function(args) {
        return J.fold$2$ax(args, -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368, new R.Math_maxList_closure());
      }, "call$1", "Math_maxList$closure", 2, 0, 414, 383, [], "maxList"], Math_minProperty: [function(args, prop) {
        return J.fold$2$ax(J.map$1$ax(args, prop), 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368, new R.Math_minProperty_closure());
      }, "call$2", "Math_minProperty$closure", 4, 0, 415, 383, [], 416, [], "minProperty"], Math_maxProperty: [function(args, prop) {
        return J.fold$2$ax(J.map$1$ax(args, prop), -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368, new R.Math_maxProperty_closure());
      }, "call$2", "Math_maxProperty$closure", 4, 0, 415, 383, [], 416, [], "maxProperty"], Math_wrapAngle: [function(angle, radians) {
        var radianFactor = radians === true ? 0.017453292519943295 : 1;
        return R.Math_wrap(angle, -180 * radianFactor, 180 * radianFactor);
      }, function(angle) {
        return R.Math_wrapAngle(angle, false);
      }, null, "call$2", "call$1", "Math_wrapAngle$closure", 2, 2, 417, 19, 7, [], 418, [], "wrapAngle"], Math_angleLimit: [function(angle, min, max) {
        var t1, result;
        t1 = J.getInterceptor$n(angle);
        if (t1.$gt(angle, max))
          result = max;
        else
          result = t1.$lt(angle, min) ? min : angle;
        return result;
      }, "call$3", "Math_angleLimit$closure", 6, 0, 396, 7, [], 409, [], 410, [], "angleLimit"], Math_linearInterpolation: [function(v, k) {
        var t1, m, t2, f, t3, i, t4;
        t1 = J.getInterceptor$asx(v);
        m = J.$sub$n(t1.get$length(v), 1);
        t2 = J.getInterceptor$ns(m);
        f = t2.$mul(m, k);
        t3 = J.getInterceptor$n(f);
        i = t3.floor$0(f);
        t4 = J.getInterceptor$n(k);
        if (t4.$lt(k, 0)) {
          t2 = t1.$index(v, 0);
          return J.$add$ns(J.$mul$ns(J.$sub$n(t1.$index(v, 1), t2), f), t2);
        }
        if (t4.$gt(k, 1)) {
          t3 = t1.$index(v, m);
          t1 = t1.$index(v, t2.$sub(m, 1));
          t2 = t2.$sub(m, f);
          return J.$add$ns(J.$mul$ns(J.$sub$n(t1, t3), t2), t3);
        }
        t2 = t1.$index(v, i);
        t4 = i + 1;
        if (typeof m !== "number")
          return H.iae(m);
        if (t4 > m)
          t4 = m;
        t4 = t1.$index(v, t4);
        t3 = t3.$sub(f, i);
        return J.$add$ns(J.$mul$ns(J.$sub$n(t4, t2), t3), t2);
      }, "call$2", "Math_linearInterpolation$closure", 4, 0, 419, 37, [], 420, [], "linearInterpolation"], Math_bezierInterpolation: [function(v, k) {
        var t1, n, b, i, t2, t3, t4, t5;
        t1 = J.getInterceptor$asx(v);
        n = J.$sub$n(t1.get$length(v), 1);
        if (typeof n !== "number")
          return H.iae(n);
        b = 0;
        i = 0;
        for (; i <= n; ++i) {
          if (typeof k !== "number")
            return H.iae(k);
          t2 = n - i;
          t3 = Math.pow(1 - k, t2);
          t4 = Math.pow(k, i);
          t5 = t1.$index(v, i);
          if (typeof t5 !== "number")
            return H.iae(t5);
          t2 = J.$div$n(J.$div$n(R.Math_factorial(n), R.Math_factorial(i)), R.Math_factorial(t2));
          if (typeof t2 !== "number")
            return H.iae(t2);
          b += t3 * t4 * t5 * t2;
        }
        return b;
      }, "call$2", "Math_bezierInterpolation$closure", 4, 0, 419, 37, [], 420, [], "bezierInterpolation"], Math_catmullRomInterpolation: [function(v, k) {
        var t1, m, t2, f, t3, i, t4, t5, t6, t7;
        t1 = J.getInterceptor$asx(v);
        m = J.$sub$n(t1.get$length(v), 1);
        t2 = J.getInterceptor$ns(m);
        f = t2.$mul(m, k);
        t3 = J.getInterceptor$n(f);
        i = t3.floor$0(f);
        if (J.$eq(t1.$index(v, 0), t1.$index(v, m))) {
          if (J.$lt$n(k, 0)) {
            if (typeof k !== "number")
              return H.iae(k);
            f = t2.$mul(m, 1 + k);
            i = J.floor$0$n(f);
          }
          if (typeof m !== "number")
            return H.iae(m);
          return R.Math_catmullRom(t1.$index(v, C.JSNumber_methods.$mod(i - 1 + m, m)), t1.$index(v, i), t1.$index(v, C.JSInt_methods.$mod(i + 1, m)), t1.$index(v, C.JSInt_methods.$mod(i + 2, m)), J.$sub$n(f, i));
        } else {
          t4 = J.getInterceptor$n(k);
          if (t4.$lt(k, 0)) {
            t2 = t1.$index(v, 0);
            t3 = R.Math_catmullRom(t1.$index(v, 0), t1.$index(v, 0), t1.$index(v, 1), t1.$index(v, 1), t3.$negate(f));
            t1 = t1.$index(v, 0);
            if (typeof t1 !== "number")
              return H.iae(t1);
            return J.$sub$n(t2, t3 - t1);
          }
          if (t4.$gt(k, 1)) {
            t4 = t1.$index(v, m);
            t3 = R.Math_catmullRom(t1.$index(v, m), t1.$index(v, m), t1.$index(v, t2.$sub(m, 1)), t1.$index(v, t2.$sub(m, 1)), t3.$sub(f, m));
            t1 = t1.$index(v, m);
            if (typeof t1 !== "number")
              return H.iae(t1);
            return J.$sub$n(t4, t3 - t1);
          }
          t4 = t1.$index(v, 0);
          t5 = t1.$index(v, i);
          t6 = i + 1;
          t6 = t1.$index(v, t2.$lt(m, t6) ? m : t6);
          t7 = i + 2;
          return R.Math_catmullRom(t4, t5, t6, t1.$index(v, t2.$lt(m, t7) ? m : t7), t3.$sub(f, i));
        }
      }, "call$2", "Math_catmullRomInterpolation$closure", 4, 0, 419, 37, [], 420, [], "catmullRomInterpolation"], Math_linear: [function(p0, p1, t) {
        return J.$add$ns(J.$mul$ns(J.$sub$n(p1, p0), t), p0);
      }, "call$3", "Math_linear$closure", 6, 0, 396, 421, [], 422, [], 423, [], "linear"], Math_bernstein: [function(n, i) {
        return J.$div$n(J.$div$n(R.Math_factorial(n), R.Math_factorial(i)), R.Math_factorial(J.$sub$n(n, i)));
      }, "call$2", "Math_bernstein$closure", 4, 0, 373, 385, [], 424, [], "bernstein"], Math_factorial: [function(value) {
        var res;
        if (J.$eq(value, 0))
          return 1;
        for (res = value; value = J.$sub$n(value, 1), J.$ge$n(value, 0);)
          res = J.$mul$ns(res, value);
        return res;
      }, "call$1", "Math_factorial$closure", 2, 0, 376, 138, [], "factorial"], Math_catmullRom: [function(p0, p1, p2, p3, t) {
        var v0, v1, t1, t2, t3;
        v0 = J.$mul$ns(J.$sub$n(p2, p0), 0.5);
        v1 = J.$mul$ns(J.$sub$n(p3, p1), 0.5);
        t1 = J.getInterceptor$ns(t);
        t2 = t1.$mul(t, t);
        t3 = t1.$mul(t, t2);
        if (typeof p1 !== "number")
          return H.iae(p1);
        if (typeof p2 !== "number")
          return H.iae(p2);
        if (typeof v0 !== "number")
          return H.iae(v0);
        if (typeof v1 !== "number")
          return H.iae(v1);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (typeof t !== "number")
          return H.iae(t);
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
      }, "call$5", "Math_catmullRom$closure", 10, 0, 425, 421, [], 422, [], 426, [], 427, [], 423, [], "catmullRom"], Math_difference: [function(a, b) {
        return J.abs$0$n(J.$sub$n(a, b));
      }, "call$2", "Math_difference$closure", 4, 0, 373, 348, [], 349, [], "difference"], Math_getRandom: [function(objects, startIndex, $length) {
        var t1, l;
        if (objects != null) {
          t1 = J.getInterceptor($length);
          l = t1.$eq($length, 0) || t1.$gt($length, J.$sub$n(J.get$length$asx(objects), startIndex)) ? J.$sub$n(J.get$length$asx(objects), startIndex) : $length;
          if (J.$gt$n(l, 0))
            return J.$index$asx(objects, J.$add$ns(startIndex, J.floor$0$n(J.$mul$ns($.get$Math_random().call$0(), l))));
        }
        return;
      }, function(objects) {
        return R.Math_getRandom(objects, 0, 0);
      }, null, function(objects, startIndex) {
        return R.Math_getRandom(objects, startIndex, 0);
      }, null, "call$3", "call$1", "call$2", "Math_getRandom$closure", 2, 4, 428, 49, 49, 429, [], 430, [], 431, [], "getRandom"], Math_removeRandom: [function(objects, startIndex, $length) {
        var t1, l;
        if (objects != null) {
          t1 = J.getInterceptor($length);
          l = t1.$eq($length, 0) || t1.$gt($length, J.$sub$n(J.get$length$asx(objects), startIndex)) ? J.$sub$n(J.get$length$asx(objects), startIndex) : $length;
          if (J.$gt$n(l, 0))
            return J.$index$asx(J.removeAt$1$ax(objects, J.toInt$0$n(J.$add$ns(startIndex, J.$mul$ns($.get$Math_random().call$0(), l)))), 0);
        }
        return;
      }, function(objects) {
        return R.Math_removeRandom(objects, 0, 0);
      }, null, function(objects, startIndex) {
        return R.Math_removeRandom(objects, startIndex, 0);
      }, null, "call$3", "call$1", "call$2", "Math_removeRandom$closure", 2, 4, 428, 49, 49, 429, [], 430, [], 431, [], "removeRandom"], Math_floor: [function(value) {
        return J.floor$0$n(value);
      }, "call$1", "Math_floor$closure", 2, 0, 384, 138, [], "floor"], Math_ceil: [function(value) {
        return J.ceil$0$n(value);
      }, "call$1", "Math_ceil$closure", 2, 0, 384, 138, [], "ceil"], Math_sinCosGenerator: [function($length, sinAmplitude, cosAmplitude, frequency) {
        var frq, t1, cosTable, sinTable, cos, sin, c, t2, t3;
        frq = J.$div$n(J.$mul$ns(frequency, 3.141592653589793), $length);
        t1 = P.num;
        cosTable = H.setRuntimeTypeInfo(new P.DoubleLinkedQueue(null, 0), [t1]);
        t1 = H.setRuntimeTypeInfo(new P._DoubleLinkedQueueEntrySentinel(null, null, null), [t1]);
        t1._link$2(t1, t1);
        cosTable._sentinel = t1;
        t1 = P.num;
        sinTable = H.setRuntimeTypeInfo(new P.DoubleLinkedQueue(null, 0), [t1]);
        t1 = H.setRuntimeTypeInfo(new P._DoubleLinkedQueueEntrySentinel(null, null, null), [t1]);
        t1._link$2(t1, t1);
        sinTable._sentinel = t1;
        if (typeof $length !== "number")
          return H.iae($length);
        cos = cosAmplitude;
        sin = sinAmplitude;
        c = 0;
        for (; c < $length; ++c) {
          t1 = J.getInterceptor$ns(sin);
          cos = J.$sub$n(cos, t1.$mul(sin, frq));
          sin = t1.$add(sin, J.$mul$ns(cos, frq));
          t1 = cosTable._sentinel;
          t2 = new P.DoubleLinkedQueueEntry(null, null, cos);
          t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
          t3 = t1._previous;
          t2._next = t1;
          t2._previous = t3;
          t3.set$_next(t2);
          t1._previous = t2;
          ++cosTable._elementCount;
          t2 = sinTable._sentinel;
          t1 = new P.DoubleLinkedQueueEntry(null, null, sin);
          t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
          t3 = t2._previous;
          t1._next = t2;
          t1._previous = t3;
          t3.set$_next(t1);
          t2._previous = t1;
          ++sinTable._elementCount;
        }
        t1 = new R.SinCosTable(null, null, null);
        t1.sin = sinTable;
        t1.cos = cosTable;
        t1.length = $length;
        return t1;
      }, function(length) {
        return R.Math_sinCosGenerator(length, 1, 1, 1);
      }, null, function(length, sinAmplitude) {
        return R.Math_sinCosGenerator(length, sinAmplitude, 1, 1);
      }, null, function(length, sinAmplitude, cosAmplitude) {
        return R.Math_sinCosGenerator(length, sinAmplitude, cosAmplitude, 1);
      }, null, "call$4", "call$1", "call$2", "call$3", "Math_sinCosGenerator$closure", 2, 6, 432, 433, 433, 433, 431, [], 434, [], 435, [], 436, [], "sinCosGenerator"], Math_shift: [function(stack) {
        var s = stack.removeFirst$0();
        J.add$1$ax(stack, s);
        return s;
      }, "call$1", "Math_shift$closure", 2, 0, 437, 438, [], "shift"], Math_shuffleArray: [function(array) {
        var t1 = P.List_List$from(array, true, null);
        H.IterableMixinWorkaround_shuffleList(t1, null);
        return t1;
      }, "call$1", "Math_shuffleArray$closure", 2, 0, 439, 47, [], "shuffleArray"], Math_distance: [function(x1, y1, x2, y2) {
        var dx, dy;
        dx = J.$sub$n(x1, x2);
        dy = J.$sub$n(y1, y2);
        return Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(dx, dx), J.$mul$ns(dy, dy))));
      }, "call$4", "Math_distance$closure", 8, 0, 398, 351, [], 352, [], 353, [], 354, [], "distance"], Math_distancePow: [function(x1, y1, x2, y2, power) {
        var t1, t2;
        t1 = J.$sub$n(x2, x1);
        H.checkNum(t1);
        H.checkNum(power);
        t1 = Math.pow(t1, power);
        t2 = J.$sub$n(y2, y1);
        H.checkNum(t2);
        H.checkNum(power);
        return Math.sqrt(H.checkNum(t1 + Math.pow(t2, power)));
      }, function(x1, y1, x2, y2) {
        return R.Math_distancePow(x1, y1, x2, y2, 2);
      }, null, "call$5", "call$4", "Math_distancePow$closure", 8, 2, 440, 441, 351, [], 352, [], 353, [], 354, [], 442, [], "distancePow"], Math_distanceRounded: [function(x1, y1, x2, y2) {
        return C.JSNumber_methods.toInt$0(C.JSDouble_methods.roundToDouble$0(R.Math_distance(x1, y1, x2, y2)));
      }, "call$4", "Math_distanceRounded$closure", 8, 0, 398, 351, [], 352, [], 353, [], 354, [], "distanceRounded"], Math_clamp: [function(x, a, b) {
        var t1 = J.getInterceptor$n(x);
        if (t1.$lt(x, a))
          t1 = a;
        else
          t1 = t1.$gt(x, b) ? b : x;
        return t1;
      }, "call$3", "Math_clamp$closure", 6, 0, 396, 9, [], 348, [], 349, [], "clamp"], Math_clampBottom: [function(x, a) {
        return J.$lt$n(x, a) ? a : x;
      }, "call$2", "Math_clampBottom$closure", 4, 0, 373, 9, [], 348, [], "clampBottom"], Math_within: [function(a, b, tolerance) {
        return J.$le$n(J.abs$0$n(J.$sub$n(a, b)), tolerance);
      }, "call$3", "Math_within$closure", 6, 0, 443, 348, [], 349, [], 444, [], "within"], Math_mapLinear: [function(x, a1, a2, b1, b2) {
        return J.$add$ns(b1, J.$div$n(J.$mul$ns(J.$sub$n(x, a1), J.$sub$n(b2, b1)), J.$sub$n(a2, a1)));
      }, "call$5", "Math_mapLinear$closure", 10, 0, 425, 9, [], 445, [], 446, [], 447, [], 448, [], "mapLinear"], Math_smoothstep: [function(x, min, max) {
        x = P.max(0, P.min(1, J.$div$n(J.$sub$n(x, min), J.$sub$n(max, min))));
        return x * x * (3 - 2 * x);
      }, "call$3", "Math_smoothstep$closure", 6, 0, 396, 9, [], 409, [], 410, [], "smoothstep"], Math_smootherstep: [function(x, min, max) {
        x = P.max(0, P.min(1, J.$div$n(J.$sub$n(x, min), J.$sub$n(max, min))));
        return x * x * x * (x * (x * 6 - 15) + 10);
      }, "call$3", "Math_smootherstep$closure", 6, 0, 396, 9, [], 409, [], 410, [], "smootherstep"], Math_sign: [function(x) {
        return J.get$sign$n(x);
      }, "call$1", "Math_sign$closure", 2, 0, 376, 9, [], "sign"], Math_percent: [function(a, b, base) {
        var t1 = J.getInterceptor$n(a);
        if (t1.$gt(a, b) || J.$gt$n(base, b))
          return 1;
        else if (t1.$lt(a, base) || J.$gt$n(base, a))
          return 0;
        else
          return J.$div$n(t1.$sub(a, base), b);
      }, function(a, b) {
        return R.Math_percent(a, b, 0);
      }, null, "call$3", "call$2", "Math_percent$closure", 4, 2, 449, 49, 348, [], 349, [], 395, [], "percent"], Math_degToRad: [function(degrees) {
        return J.$mul$ns(degrees, 0.017453292519943295);
      }, "call$1", "Math_degToRad$closure", 2, 0, 376, 450, [], "degToRad"], Math_radToDeg: [function(radians) {
        return J.$mul$ns(radians, 57.29577951308232);
      }, "call$1", "Math_radToDeg$closure", 2, 0, 376, 418, [], "radToDeg"]}
  },
  "+Math": [674],
  Math_average_closure: {
    "^": "Closure:959;",
    call$2: [function(a, b) {
      return J.$add$ns(a, b);
    }, "call$2", null, 4, 0, 959, 348, [], 349, [], "call"]
  },
  Math_minList_closure: {
    "^": "Closure:959;",
    call$2: [function(i, n) {
      return J.$lt$n(i, n) ? i : n;
    }, "call$2", null, 4, 0, 959, 424, [], 385, [], "call"]
  },
  Math_maxList_closure: {
    "^": "Closure:959;",
    call$2: [function(i, n) {
      return J.$gt$n(i, n) ? i : n;
    }, "call$2", null, 4, 0, 959, 424, [], 385, [], "call"]
  },
  Math_minProperty_closure: {
    "^": "Closure:959;",
    call$2: [function(i, n) {
      return J.$lt$n(i, n) ? i : n;
    }, "call$2", null, 4, 0, 959, 424, [], 385, [], "call"]
  },
  Math_maxProperty_closure: {
    "^": "Closure:959;",
    call$2: [function(i, n) {
      return J.$gt$n(i, n) ? i : n;
    }, "call$2", null, 4, 0, 959, 424, [], 385, [], "call"]
  },
  Bounds: {
    "^": "Object;x*-614,y*-614,width*-614,height*-614,subWidth@-614,subHeight@-614,right*-614,bottom*-614",
    static: {Bounds$: [function() {
        return new R.Bounds(null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 451, "new Bounds"]}
  },
  "+Bounds": [674],
  QuadTree: {
    "^": "Object;maxObjects@-614,maxLevels@-614,level@-614,bounds@-1462,objects<-1463,nodes>-1464",
    reset$7: [function(_, x, y, width, height, maxObjects, maxLevels, level) {
      var t1, t2, t3, t4, t5;
      this.maxObjects = maxObjects == null ? 10 : maxObjects;
      this.maxLevels = maxLevels == null ? 4 : maxLevels;
      this.level = level == null ? 0 : level;
      t1 = new R.Bounds(null, null, null, null, null, null, null, null);
      t2 = J.getInterceptor$n(x);
      t1.x = t2.round$0(x);
      t3 = J.getInterceptor$n(y);
      t1.y = t3.round$0(y);
      t1.width = width;
      t1.height = height;
      t4 = J.getInterceptor$n(width);
      t1.subWidth = J.floor$0$n(t4.$div(width, 2));
      t5 = J.getInterceptor$n(height);
      t1.subHeight = J.floor$0$n(t5.$div(height, 2));
      t1.right = t2.round$0(x) + J.floor$0$n(t4.$div(width, 2));
      t1.bottom = t3.round$0(y) + J.floor$0$n(t5.$div(height, 2));
      this.bounds = t1;
      J.clear$0$ax(this.objects);
      t1 = this.nodes;
      t5 = J.getInterceptor$ax(t1);
      t5.$indexSet(t1, 3, null);
      t5.$indexSet(t1, 2, null);
      t5.$indexSet(t1, 1, null);
      t5.$indexSet(t1, 0, null);
    }, function($receiver, x, y, width, height) {
      return this.reset$7($receiver, x, y, width, height, null, null, null);
    }, "reset$4", function($receiver, x, y, width, height, maxObjects, maxLevels) {
      return this.reset$7($receiver, x, y, width, height, maxObjects, maxLevels, null);
    }, "reset$6", function($receiver, x, y, width, height, maxObjects) {
      return this.reset$7($receiver, x, y, width, height, maxObjects, null, null);
    }, "reset$5", "call$7", "call$4", "call$6", "call$5", "get$reset", 8, 6, 1465, 12, 12, 12, 9, [], 10, [], 31, [], 52, [], 453, [], 454, [], 455, [], "reset"],
    populate$1: [function(group) {
      J.forEach$2$ax(group, this.get$populateHandler(), true);
    }, "call$1", "get$populate", 2, 0, 1466, 297, [], "populate"],
    populateHandler$1: [function(sprite) {
      var t1 = J.getInterceptor$x(sprite);
      if (t1.get$body(sprite) != null && sprite.get$exists() === true)
        this.insert$1(0, t1.get$body(sprite));
    }, "call$1", "get$populateHandler", 2, 0, 612, 151, [], "populateHandler"],
    split$0: [function(_) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11;
      this.level = J.$add$ns(this.level, 1);
      t1 = this.nodes;
      t2 = J.get$right$x(this.bounds);
      t3 = J.get$y$x(this.bounds);
      t4 = this.bounds.get$subWidth();
      t5 = this.bounds.get$subHeight();
      t6 = this.maxObjects;
      t7 = this.maxLevels;
      t8 = this.level;
      t9 = H.setRuntimeTypeInfo([], [R.Body]);
      t10 = Array(4);
      t10.fixed$length = init;
      t10 = new R.QuadTree(10, 4, 0, null, t9, H.setRuntimeTypeInfo(t10, [R.QuadTree]));
      t10.reset$7(0, J.toInt$0$n(t2), J.toInt$0$n(t3), J.toInt$0$n(t4), J.toInt$0$n(t5), t6, t7, t8);
      t8 = J.getInterceptor$ax(t1);
      t8.$indexSet(t1, 0, t10);
      t10 = J.get$x$x(this.bounds);
      t7 = J.get$y$x(this.bounds);
      t6 = this.bounds.get$subWidth();
      t5 = this.bounds.get$subHeight();
      t4 = this.maxObjects;
      t3 = this.maxLevels;
      t2 = this.level;
      t9 = H.setRuntimeTypeInfo([], [R.Body]);
      t11 = Array(4);
      t11.fixed$length = init;
      t11 = new R.QuadTree(10, 4, 0, null, t9, H.setRuntimeTypeInfo(t11, [R.QuadTree]));
      t11.reset$7(0, J.toInt$0$n(t10), J.toInt$0$n(t7), J.toInt$0$n(t6), J.toInt$0$n(t5), t4, t3, t2);
      t8.$indexSet(t1, 1, t11);
      t11 = J.get$x$x(this.bounds);
      t2 = J.get$bottom$x(this.bounds);
      t3 = this.bounds.get$subWidth();
      t4 = this.bounds.get$subHeight();
      t5 = this.maxObjects;
      t6 = this.maxLevels;
      t7 = this.level;
      t10 = H.setRuntimeTypeInfo([], [R.Body]);
      t9 = Array(4);
      t9.fixed$length = init;
      t9 = new R.QuadTree(10, 4, 0, null, t10, H.setRuntimeTypeInfo(t9, [R.QuadTree]));
      t9.reset$7(0, J.toInt$0$n(t11), J.toInt$0$n(t2), J.toInt$0$n(t3), J.toInt$0$n(t4), t5, t6, t7);
      t8.$indexSet(t1, 2, t9);
      t9 = J.get$right$x(this.bounds);
      t7 = J.get$bottom$x(this.bounds);
      t6 = this.bounds.get$subWidth();
      t5 = this.bounds.get$subHeight();
      t4 = this.maxObjects;
      t3 = this.maxLevels;
      t2 = this.level;
      t11 = H.setRuntimeTypeInfo([], [R.Body]);
      t10 = Array(4);
      t10.fixed$length = init;
      t10 = new R.QuadTree(10, 4, 0, null, t11, H.setRuntimeTypeInfo(t10, [R.QuadTree]));
      t10.reset$7(0, J.toInt$0$n(t9), J.toInt$0$n(t7), J.toInt$0$n(t6), J.toInt$0$n(t5), t4, t3, t2);
      t8.$indexSet(t1, 3, t10);
    }, "call$0", "get$split", 0, 0, 54, "split"],
    insert$1: [function(_, body) {
      var t1, t2, index, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, i;
      t1 = this.nodes;
      t2 = J.getInterceptor$asx(t1);
      if (t2.$index(t1, 0) != null) {
        index = this.getIndex$1(body);
        if (index !== -1) {
          J.insert$1$ax(t2.$index(t1, index), body);
          return;
        }
      }
      t3 = this.objects;
      t4 = J.getInterceptor$ax(t3);
      t4.add$1(t3, body);
      if (J.$gt$n(t4.get$length(t3), this.maxObjects) && J.$lt$n(this.level, this.maxLevels)) {
        if (t2.$index(t1, 0) == null) {
          this.level = J.$add$ns(this.level, 1);
          t5 = J.get$right$x(this.bounds);
          t6 = J.get$y$x(this.bounds);
          t7 = this.bounds.get$subWidth();
          t8 = this.bounds.get$subHeight();
          t9 = this.maxObjects;
          t10 = this.maxLevels;
          t11 = this.level;
          t12 = H.setRuntimeTypeInfo([], [R.Body]);
          t13 = Array(4);
          t13.fixed$length = init;
          t13 = new R.QuadTree(10, 4, 0, null, t12, H.setRuntimeTypeInfo(t13, [R.QuadTree]));
          t13.reset$7(0, J.toInt$0$n(t5), J.toInt$0$n(t6), J.toInt$0$n(t7), J.toInt$0$n(t8), t9, t10, t11);
          t2.$indexSet(t1, 0, t13);
          t13 = J.get$x$x(this.bounds);
          t11 = J.get$y$x(this.bounds);
          t10 = this.bounds.get$subWidth();
          t9 = this.bounds.get$subHeight();
          t8 = this.maxObjects;
          t7 = this.maxLevels;
          t6 = this.level;
          t5 = H.setRuntimeTypeInfo([], [R.Body]);
          t12 = Array(4);
          t12.fixed$length = init;
          t12 = new R.QuadTree(10, 4, 0, null, t5, H.setRuntimeTypeInfo(t12, [R.QuadTree]));
          t12.reset$7(0, J.toInt$0$n(t13), J.toInt$0$n(t11), J.toInt$0$n(t10), J.toInt$0$n(t9), t8, t7, t6);
          t2.$indexSet(t1, 1, t12);
          t12 = J.get$x$x(this.bounds);
          t6 = J.get$bottom$x(this.bounds);
          t7 = this.bounds.get$subWidth();
          t8 = this.bounds.get$subHeight();
          t9 = this.maxObjects;
          t10 = this.maxLevels;
          t11 = this.level;
          t13 = H.setRuntimeTypeInfo([], [R.Body]);
          t5 = Array(4);
          t5.fixed$length = init;
          t5 = new R.QuadTree(10, 4, 0, null, t13, H.setRuntimeTypeInfo(t5, [R.QuadTree]));
          t5.reset$7(0, J.toInt$0$n(t12), J.toInt$0$n(t6), J.toInt$0$n(t7), J.toInt$0$n(t8), t9, t10, t11);
          t2.$indexSet(t1, 2, t5);
          t5 = J.get$right$x(this.bounds);
          t11 = J.get$bottom$x(this.bounds);
          t10 = this.bounds.get$subWidth();
          t9 = this.bounds.get$subHeight();
          t8 = this.maxObjects;
          t7 = this.maxLevels;
          t6 = this.level;
          t12 = H.setRuntimeTypeInfo([], [R.Body]);
          t13 = Array(4);
          t13.fixed$length = init;
          t13 = new R.QuadTree(10, 4, 0, null, t12, H.setRuntimeTypeInfo(t13, [R.QuadTree]));
          t13.reset$7(0, J.toInt$0$n(t5), J.toInt$0$n(t11), J.toInt$0$n(t10), J.toInt$0$n(t9), t8, t7, t6);
          t2.$indexSet(t1, 3, t13);
        }
        i = 0;
        while (true) {
          t5 = t4.get$length(t3);
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (!(i < t5))
            break;
          index = this.getIndex$1(t4.$index(t3, i));
          if (index !== -1)
            J.insert$1$ax(t2.$index(t1, index), t4.removeAt$1(t3, i));
          else
            ++i;
        }
      }
    }, "call$1", "get$insert", 2, 0, 1467, 1468, [], "insert"],
    getIndex$1: [function(rect) {
      var t1, index;
      t1 = J.getInterceptor$x(rect);
      if (J.$lt$n(t1.get$x(rect), J.get$right$x(this.bounds)) && J.$lt$n(t1.get$right(rect), J.get$right$x(this.bounds)))
        if (J.$lt$n(t1.get$y(rect), J.get$bottom$x(this.bounds)) && J.$lt$n(t1.get$bottom(rect), J.get$bottom$x(this.bounds)))
          index = 1;
        else
          index = J.$gt$n(t1.get$y(rect), J.get$bottom$x(this.bounds)) ? 2 : -1;
      else if (J.$gt$n(t1.get$x(rect), J.get$right$x(this.bounds)))
        if (J.$lt$n(t1.get$y(rect), J.get$bottom$x(this.bounds)) && J.$lt$n(t1.get$bottom(rect), J.get$bottom$x(this.bounds)))
          index = 0;
        else
          index = J.$gt$n(t1.get$y(rect), J.get$bottom$x(this.bounds)) ? 3 : -1;
      else
        index = -1;
      return index;
    }, "call$1", "get$getIndex", 2, 0, 1305, 1125, [], "getIndex"],
    retrieve$1: [function(source) {
      var t1, returnObjects, index, t2, t3;
      t1 = J.getInterceptor(source);
      if (!!t1.$isRectangle1) {
        returnObjects = this.objects;
        index = this.getIndex$1(source);
      } else {
        if (t1.get$body(source) == null)
          return C.List_empty;
        returnObjects = this.objects;
        index = this.getIndex$1(t1.get$body(source));
      }
      t1 = this.nodes;
      t2 = J.getInterceptor$asx(t1);
      if (J.$gt$n(t2.get$length(t1), 0) && t2.$index(t1, 0) != null) {
        t3 = J.getInterceptor$ax(returnObjects);
        if (index !== -1)
          t3.addAll$1(returnObjects, t2.$index(t1, index).retrieve$1(source));
        else {
          t3.addAll$1(returnObjects, t2.$index(t1, 0).retrieve$1(source));
          t3.addAll$1(returnObjects, t2.$index(t1, 1).retrieve$1(source));
          t3.addAll$1(returnObjects, t2.$index(t1, 2).retrieve$1(source));
          t3.addAll$1(returnObjects, t2.$index(t1, 3).retrieve$1(source));
        }
      }
      return returnObjects;
    }, "call$1", "get$retrieve", 2, 0, 1469, 208, [], "retrieve"],
    clear$0: [function(_) {
      var t1, t2, i, t3, i0;
      J.clear$0$ax(this.objects);
      t1 = this.nodes;
      t2 = J.getInterceptor$asx(t1);
      i = t2.get$length(t1);
      for (; t3 = J.getInterceptor$n(i), i0 = t3.$sub(i, 1), t3.$gt(i, 0); i = i0)
        if (t2.$index(t1, i0) != null) {
          J.clear$0$ax(t2.$index(t1, i0));
          t2.$indexSet(t1, i0, null);
        }
    }, "call$0", "get$clear", 0, 0, 54, "clear"],
    $isQuadTree: true,
    static: {"^": "QuadTree__empty<-645", QuadTree$: [function(x, y, width, height, maxObjects, maxLevels, level) {
        var t1, t2;
        t1 = H.setRuntimeTypeInfo([], [R.Body]);
        t2 = Array(4);
        t2.fixed$length = init;
        t2 = new R.QuadTree(10, 4, 0, null, t1, H.setRuntimeTypeInfo(t2, [R.QuadTree]));
        t2.reset$7(0, J.toInt$0$n(x), J.toInt$0$n(y), J.toInt$0$n(width), J.toInt$0$n(height), maxObjects, maxLevels, level);
        return t2;
      }, null, null, 8, 6, 452, 12, 12, 12, 9, [], 10, [], 31, [], 52, [], 453, [], 454, [], 455, [], "new QuadTree"]}
  },
  "+QuadTree": [674],
  RandomDataGenerator: {
    "^": "Object;c@-614,s0@-671,s1@-671,s2@-671",
    rnd$0: [function() {
      var t1, t2, t;
      t1 = this.s0;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = J.$mul$ns(this.c, 2.3283064365386963e-10);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t = 2091639 * t1 + t2;
      t2 = C.JSNumber_methods.toInt$0(Math.floor(t));
      this.c = t2;
      this.s0 = this.s1;
      this.s1 = this.s2;
      t2 = t - t2;
      this.s2 = t2;
      return t2;
    }, "call$0", "get$rnd", 0, 0, 21, "rnd"],
    sow$1: [function(seeds) {
      var t1, i, i0, seed;
      if (seeds == null)
        seeds = [];
      t1 = this.hash$1(0, " ");
      this.s0 = t1;
      t1 = this.hash$1(0, t1);
      this.s1 = t1;
      this.s2 = this.hash$1(0, t1);
      this.c = 1;
      for (t1 = J.getInterceptor$asx(seeds), i = 0; i0 = i + 1, seed = t1.$index(seeds, i), seed === true; i = i0) {
        this.s0 = J.$sub$n(this.s0, this.hash$1(0, seed));
        this.s1 = J.$sub$n(this.s1, this.hash$1(0, seed));
        this.s2 = J.$sub$n(this.s2, this.hash$1(0, seed));
      }
    }, "call$1", "get$sow", 2, 0, 102, 456, [], "sow"],
    hash$1: [function(_, data) {
      var t1, i, n, t2, h;
      data = J.toString$0(data);
      t1 = J.getInterceptor$asx(data);
      i = 0;
      n = 4022871197;
      while (true) {
        t2 = t1.get$length(data);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        h = C.JSDouble_methods.toInt$0(0.02519603282416938 * (n + t1.codeUnitAt$1(data, i)));
        n = C.JSInt_methods._shrOtherPositive$1(h, 0);
        h = (h - n) * n;
        n = C.JSInt_methods._shrOtherPositive$1(h, 0);
        n += (h - n) * 4294967296;
        ++i;
      }
      return C.JSInt_methods._shrOtherPositive$1(n, 0) * 2.3283064365386963e-10;
    }, "call$1", "get$hash", 2, 0, 102, 87, [], "hash"],
    integer$0: [function() {
      return J.floor$0$n(J.$mul$ns(this.rnd$0(), 4294967296));
    }, "call$0", "get$integer", 0, 0, 412, "integer"],
    frac$0: [function() {
      return J.$add$ns(this.rnd$0(), J.toInt$0$n(J.$mul$ns(this.rnd$0(), 2097152)) * 1.1102230246251565e-16);
    }, "call$0", "get$frac", 0, 0, 21, "frac"],
    real$0: [function() {
      var t1, t2;
      t1 = J.floor$0$n(J.$mul$ns(this.rnd$0(), 4294967296));
      t2 = this.frac$0();
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 + t2;
    }, "call$0", "get$real", 0, 0, 21, "real"],
    integerInRange$2: [function(min, max) {
      var t1 = J.$add$ns(J.$sub$n(max, min), 1);
      return J.floor$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(this.frac$0(), J.$sub$n(t1, 0)), 0), min));
    }, "call$2", "get$integerInRange", 4, 0, 1470, 409, [], 410, [], "integerInRange"],
    realInRange$2: [function(min, max) {
      return J.$add$ns(J.$mul$ns(this.frac$0(), J.$sub$n(max, min)), min);
    }, "call$2", "get$realInRange", 4, 0, 373, 409, [], 410, [], "realInRange"],
    normal$0: [function() {
      var t1 = this.frac$0();
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 1 - 2 * t1;
    }, "call$0", "get$normal", 0, 0, 619, "normal"],
    uuid$0: [function() {
      var t1 = $.RandomDataGenerator_UUID;
      $.RandomDataGenerator_UUID = J.$add$ns(t1, 1);
      return H.S(t1);
    }, "call$0", "get$uuid", 0, 0, 810, "uuid"],
    pick$1: [function(ary) {
      var t1 = J.getInterceptor$asx(ary);
      return t1.$index(ary, this.integerInRange$2(0, J.$sub$n(t1.get$length(ary), 1)));
    }, "call$1", "get$pick", 2, 0, 55, 1471, [], "pick"],
    weightedPick$1: [function(ary) {
      var t1, t2, t3;
      t1 = this.frac$0();
      H.checkNum(t1);
      H.checkNum(2);
      t1 = Math.pow(t1, 2);
      t2 = J.getInterceptor$asx(ary);
      t3 = J.$sub$n(t2.get$length(ary), 1);
      if (typeof t3 !== "number")
        return H.iae(t3);
      return t2.$index(ary, t1 * t3);
    }, "call$1", "get$weightedPick", 2, 0, 55, 1471, [], "weightedPick"],
    timestamp$2: [function(min, max) {
      return J.$add$ns(J.$mul$ns(this.frac$0(), J.$sub$n(max, min)), min);
    }, function(min) {
      return this.timestamp$2(min, 1577862000000);
    }, "timestamp$1", function() {
      return this.timestamp$2(946684800000, 1577862000000);
    }, "timestamp$0", "call$2", "call$1", "call$0", "get$timestamp", 0, 4, 1472, 1473, 1474, 409, [], 410, [], "timestamp"],
    angle$0: [function(_) {
      return this.integerInRange$2(-180, 180);
    }, "call$0", "get$angle", 0, 0, 619, "angle"],
    static: {"^": "RandomDataGenerator_UUID@-614", RandomDataGenerator$: [function(seeds) {
        return new R.RandomDataGenerator(1, 0, 0, 0);
      }, null, null, 2, 0, 55, 456, [], "new RandomDataGenerator"]}
  },
  "+RandomDataGenerator": [674],
  Net: {
    "^": "Object;game@-613",
    getHostName$0: [function() {
      return window.location.hostname;
    }, "call$0", "get$getHostName", 0, 0, 810, "getHostName"],
    checkDomainName$1: [function(domain) {
      return J.indexOf$1$asx(window.location.hostname, domain) !== -1;
    }, "call$1", "get$checkDomainName", 2, 0, 1413, 1475, [], "checkDomainName"],
    updateQueryString$4: [function(key, value, redirect, url) {
      var t1, t2, re, t3, output, separator, hash;
      if (redirect == null)
        redirect = false;
      if (url == null || J.$eq(url, ""))
        url = window.location.href;
      t1 = C.JSString_methods.$add("([?|&])", key) + "=.*?(&|#|$)(.*)";
      t2 = H.JSSyntaxRegExp_makeNative(t1, true, true, false);
      re = new H.JSSyntaxRegExp(t1, t2, null, null);
      t1 = H.JSSyntaxRegExp_makeNative("(&|?)$", false, true, false);
      if (t2.test(H.checkString(url))) {
        t2 = value != null && true;
        t3 = J.getInterceptor$s(url);
        output = t2 ? t3.replaceAll$2(url, re, "$1" + H.S(key) + "=" + H.S(value) + "$2$3") : J.replaceAll$2$s(t3.replaceAll$2(url, re, "$1$3"), new H.JSSyntaxRegExp("(&|?)$", t1, null, null), "");
      } else if (value != null) {
        t1 = J.getInterceptor$asx(url);
        separator = !J.$eq(t1.indexOf$1(url, "?"), -1) ? "&" : "?";
        hash = t1.split$1(url, "#");
        if (0 >= hash.length)
          return H.ioore(hash, 0);
        url = J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(hash[0], separator), key), "="), value);
        if (1 >= hash.length)
          return H.ioore(hash, 1);
        t1 = hash[1];
        if (t1 === true)
          url = J.$add$ns(url, C.JSString_methods.$add("#", t1));
        output = url;
      } else
        output = url;
      if (redirect === true) {
        window.location.href = output;
        return;
      } else
        return output;
    }, "call$4", "get$updateQueryString", 8, 0, 1476, 269, [], 138, [], 1477, [], 127, [], "updateQueryString"],
    getQueryString$1: [function(parameter) {
      var output, keyValues, t1, t2, i, key, t3, t4;
      if (parameter == null)
        parameter = "";
      output = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      keyValues = J.substring$1$s(window.location.search, 1).split("&");
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(keyValues, keyValues.length, 0, null), [H.getTypeArgumentByIndex(keyValues, 0)]), t2 = parameter != null; t1.moveNext$0();) {
        i = t1.__internal$_current;
        if (i >>> 0 !== i || i >= keyValues.length)
          return H.ioore(keyValues, i);
        key = J.split$1$s(keyValues[i], "=");
        if (key.length > 1) {
          t3 = t2 && J.$eq(parameter, P.Uri__uriDecode(J.replaceAll$2$s(key[0], "+", " "), C.Utf8Codec_false, false));
          t4 = key.length;
          if (t3) {
            if (1 >= t4)
              return H.ioore(key, 1);
            return P.Uri__uriDecode(J.replaceAll$2$s(key[1], "+", " "), C.Utf8Codec_false, false);
          } else {
            if (0 >= t4)
              return H.ioore(key, 0);
            t3 = P.Uri__uriDecode(J.replaceAll$2$s(key[0], "+", " "), C.Utf8Codec_false, false);
            if (1 >= key.length)
              return H.ioore(key, 1);
            output.$indexSet(0, t3, P.Uri__uriDecode(J.replaceAll$2$s(key[1], "+", " "), C.Utf8Codec_false, false));
          }
        }
      }
      return output;
    }, "call$1", "get$getQueryString", 2, 0, 91, 1478, [], "getQueryString"],
    decodeURI$1: [function(value) {
      return P.Uri__uriDecode(J.replaceAll$2$s(value, "+", " "), C.Utf8Codec_false, false);
    }, "call$1", "get$decodeURI", 2, 0, 943, 138, [], "decodeURI"],
    static: {Net$: [function(game) {
        return new R.Net(game);
      }, null, null, 2, 0, 302, 252, [], "new Net"]}
  },
  "+Net": [674],
  Emitter: {
    "^": "Group;maxParticles@-614,area@-649,minParticleSpeed@-615,maxParticleSpeed@-615,minParticleScale@-616,maxParticleScale@-616,scaleData@-1218,minRotation@-616,maxRotation@-616,minParticleAlpha@-616,maxParticleAlpha@-616,alphaData@-1218,gravity@-616,particleClass@-1090,particleDrag@-615,angularDrag@-616,frequency@-616,lifespan@-616,bounce@-615,on*-617,particleAnchor@-615,emitX@-616,emitY@-616,autoScale@-617,autoAlpha@-617,particleBringToTop@-617,particleSendToBack@-617,_minParticleScale@-615,_maxParticleScale@-615,_quantity@-616,_timer@-616,_counter@-616,_explode@-617,_frames@-12,blendMode@-702,game-613,name-644,addToStage-617,enableBody-617,physicsBodyType-616,z-614,type-614,alive-617,exists-617,ignoreDestroy-617,_Phaser$_dirty-617,cursor-12,cameraOffset-615,_sortProperty-644,enableBodyDebug-617,_cache-645,creator-646,renderOrderID-614,Phaser$Group$children-647,autoCull-617,events-648,_anchor-615,_Phaser$_currentBounds-649,Phaser$Group$position-615,onDestroy-650,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    on$2: function($receiver, arg0, arg1) {
      return this.on.call$2(arg0, arg1);
    },
    get$width: [function(_) {
      return J.get$width$x(this.area);
    }, null, null, 1, 0, 619, "width"],
    set$width: [function(_, value) {
      J.set$width$x(this.area, value);
    }, null, null, 3, 0, 620, 138, [], "width"],
    get$height: [function(_) {
      return J.get$height$x(this.area);
    }, null, null, 1, 0, 619, "height"],
    set$height: [function(_, value) {
      J.set$height$x(this.area, value);
    }, null, null, 3, 0, 620, 138, [], "height"],
    get$x: [function(_) {
      return this.emitX;
    }, null, null, 1, 0, 619, "x"],
    set$x: [function(_, value) {
      this.emitX = value;
    }, null, null, 3, 0, 620, 138, [], "x"],
    get$y: [function(_) {
      return this.emitY;
    }, null, null, 1, 0, 619, "y"],
    set$y: [function(_, value) {
      this.emitY = value;
    }, null, null, 3, 0, 620, 138, [], "y"],
    get$left: [function(_) {
      return J.floor$0$n(J.$sub$n(this.emitX, J.$div$n(J.get$width$x(this.area), 2)));
    }, null, null, 1, 0, 619, "left"],
    get$right: [function(_) {
      return J.floor$0$n(J.$add$ns(this.emitX, J.$div$n(J.get$width$x(this.area), 2)));
    }, null, null, 1, 0, 619, "right"],
    get$top: [function(_) {
      return J.floor$0$n(J.$sub$n(this.emitY, J.$div$n(J.get$height$x(this.area), 2)));
    }, null, null, 1, 0, 619, "top"],
    get$bottom: [function(_) {
      return J.floor$0$n(J.$add$ns(this.emitY, J.$div$n(J.get$height$x(this.area), 2)));
    }, null, null, 1, 0, 619, "bottom"],
    update$0: [function() {
      var t1, i, i0;
      if (this.on === true)
        if (this._explode === true) {
          this._counter = 0;
          do {
            this.emitParticle$0();
            t1 = J.$add$ns(this._counter, 1);
            this._counter = t1;
          } while (J.$lt$n(t1, this._quantity));
          this.on = false;
        } else if (J.$ge$n(J.get$now$x(this.game.get$time()), this._timer)) {
          this.emitParticle$0();
          this._counter = J.$add$ns(this._counter, 1);
          if (J.$gt$n(this._quantity, 0))
            if (J.$ge$n(this._counter, this._quantity))
              this.on = false;
          this._timer = J.$add$ns(J.get$now$x(this.game.get$time()), this.frequency);
        }
      i = J.get$length$asx(this.Phaser$Group$children);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        if (J.$index$asx(this.Phaser$Group$children, i0).get$exists() === true)
          J.$index$asx(this.Phaser$Group$children, i0).update$0();
    }, "call$0", "get$update", 0, 0, 54, "update"],
    makeParticles$5: [function(keys, $frames, quantity, collide, collideWorldBounds) {
      var t1, t2, t3, rndFrame, rndKey, i, particle, t4;
      if ($frames == null)
        $frames = 0;
      if (quantity == null)
        quantity = this.maxParticles;
      if (collide == null)
        collide = false;
      if (collideWorldBounds == null)
        collideWorldBounds = false;
      this._frames = $frames;
      if (typeof quantity !== "number")
        return H.iae(quantity);
      t1 = collide === true;
      t2 = !!J.getInterceptor($frames).$isList;
      t3 = !!J.getInterceptor(keys).$isList;
      rndFrame = $frames;
      rndKey = keys;
      i = 0;
      for (; i < quantity;) {
        if (t3)
          rndKey = this.game.get$rnd().pick$1(keys);
        if (t2)
          rndFrame = this.game.get$rnd().pick$1($frames);
        particle = P.reflectClass(this.particleClass).newInstance$2(C.Symbol_0c4, [this.game, 0, 0, rndKey, rndFrame]).reflectee;
        J.enable$2$x(this.game.get$physics().get$arcade(), particle, false);
        t4 = J.getInterceptor$x(particle);
        if (t1) {
          t4.get$body(particle).get$checkCollision().any = true;
          t4.get$body(particle).get$checkCollision().none = false;
        } else
          t4.get$body(particle).get$checkCollision().none = true;
        J.get$body$x(particle).set$collideWorldBounds(collideWorldBounds);
        particle.set$exists(false);
        particle.set$visible(false);
        particle.get$anchor().copyFrom$1(this.particleAnchor);
        this.add$1(0, particle);
        ++i;
      }
      return this;
    }, function(keys) {
      return this.makeParticles$5(keys, 0, null, false, false);
    }, "makeParticles$1", function(keys, frames) {
      return this.makeParticles$5(keys, frames, null, false, false);
    }, "makeParticles$2", function(keys, frames, quantity) {
      return this.makeParticles$5(keys, frames, quantity, false, false);
    }, "makeParticles$3", function(keys, frames, quantity, collide) {
      return this.makeParticles$5(keys, frames, quantity, collide, false);
    }, "makeParticles$4", "call$5", "call$1", "call$2", "call$3", "call$4", "get$makeParticles", 2, 8, 1479, 49, 12, 19, 19, 1480, [], 65, [], 974, [], 1481, [], 1482, [], "makeParticles"],
    kill$0: [function() {
      this.on = false;
      this.alive = false;
      this.exists = false;
    }, "call$0", "get$kill", 0, 0, 54, "kill"],
    revive$0: [function() {
      this.alive = true;
      this.exists = true;
    }, "call$0", "get$revive", 0, 0, 54, "revive"],
    explode$2: [function(lifespan, quantity) {
      this.start$5(0, true, lifespan, 0, quantity, false);
    }, function(lifespan) {
      return this.explode$2(lifespan, 0);
    }, "explode$1", function() {
      return this.explode$2(0, 0);
    }, "explode$0", "call$2", "call$1", "call$0", "get$explode", 0, 4, 56, 49, 49, 1483, [], 974, [], "explode"],
    flow$3: [function(lifespan, frequency, quantity) {
      this.start$5(0, false, lifespan, frequency, quantity, true);
    }, function(lifespan) {
      return this.flow$3(lifespan, 0, 0);
    }, "flow$1", function(lifespan, frequency) {
      return this.flow$3(lifespan, frequency, 0);
    }, "flow$2", function() {
      return this.flow$3(0, 0, 0);
    }, "flow$0", "call$3", "call$1", "call$2", "call$0", "get$flow", 0, 6, 48, 49, 49, 49, 1483, [], 436, [], 974, [], "flow"],
    start$5: [function(_, explode, lifespan, frequency, quantity, forceQuantity) {
      if (explode == null)
        explode = true;
      if (lifespan == null)
        lifespan = 0;
      if (frequency == null)
        frequency = 250;
      if (quantity == null)
        quantity = 0;
      if (forceQuantity == null)
        forceQuantity = false;
      this.alive = true;
      this.exists = true;
      this.visible = true;
      this.on = true;
      this._explode = explode;
      this.lifespan = lifespan;
      this.frequency = frequency;
      if (explode === true || forceQuantity === true)
        this._quantity = quantity;
      else
        this._quantity = J.$add$ns(this._quantity, quantity);
      this._counter = 0;
      this._timer = J.$add$ns(J.get$now$x(this.game.get$time()), frequency);
    }, function($receiver, explode) {
      return this.start$5($receiver, explode, 0, 250, 0, false);
    }, "start$1", function($receiver) {
      return this.start$5($receiver, true, 0, 250, 0, false);
    }, "start$0", function($receiver, explode, lifespan) {
      return this.start$5($receiver, explode, lifespan, 250, 0, false);
    }, "start$2", function($receiver, explode, lifespan, frequency) {
      return this.start$5($receiver, explode, lifespan, frequency, 0, false);
    }, "start$3", function($receiver, explode, lifespan, frequency, quantity) {
      return this.start$5($receiver, explode, lifespan, frequency, quantity, false);
    }, "start$4", "call$5", "call$1", "call$0", "call$2", "call$3", "call$4", "get$start", 0, 10, 1484, 78, 49, 1485, 49, 19, 1486, [], 1483, [], 436, [], 974, [], 1487, [], "start"],
    emitParticle$0: [function() {
      var particle, t1, t2;
      particle = this.getFirstExists$1(false);
      if (particle == null)
        return;
      t1 = J.$gt$n(J.get$width$x(this.area), 1) || J.$gt$n(J.get$height$x(this.area), 1);
      t2 = J.getInterceptor$x(particle);
      if (t1)
        t2.reset$2(particle, this.game.get$rnd().integerInRange$2(J.floor$0$n(J.$sub$n(this.emitX, J.$div$n(J.get$width$x(this.area), 2))), J.floor$0$n(J.$add$ns(this.emitX, J.$div$n(J.get$width$x(this.area), 2)))), this.game.get$rnd().integerInRange$2(J.floor$0$n(J.$sub$n(this.emitY, J.$div$n(J.get$height$x(this.area), 2))), J.floor$0$n(J.$add$ns(this.emitY, J.$div$n(J.get$height$x(this.area), 2)))));
      else
        t2.reset$2(particle, this.emitX, this.emitY);
      t1 = J.getInterceptor$x(particle);
      t1.set$angle(particle, 0);
      particle.set$lifespan(this.lifespan);
      if (this.particleBringToTop === true)
        this.bringToTop$1(particle);
      else if (this.particleSendToBack === true)
        if (J.$eq(t1.get$parent(particle), this) && J.$gt$n(J.indexOf$1$asx(this.Phaser$Group$children, particle), 0)) {
          this.remove$3(0, particle, false, true);
          this.addAt$3(particle, 0, true);
        }
      if (this.autoScale === true)
        particle.setScaleData$1(this.scaleData);
      else if (!J.$eq(this.minParticleScale, 1) || !J.$eq(this.maxParticleScale, 1))
        t1.get$scale(particle).set$1(this.game.get$rnd().realInRange$2(this.minParticleScale, this.maxParticleScale));
      else if (!J.$eq(J.get$x$x(this._minParticleScale), J.get$x$x(this._maxParticleScale)) || !J.$eq(J.get$y$x(this._minParticleScale), J.get$y$x(this._maxParticleScale)))
        t1.get$scale(particle).set$2(this.game.get$rnd().realInRange$2(J.get$x$x(this._minParticleScale), J.get$x$x(this._maxParticleScale)), this.game.get$rnd().realInRange$2(J.get$y$x(this._minParticleScale), J.get$y$x(this._maxParticleScale)));
      t2 = this._frames;
      if (t2 != null && !!J.getInterceptor(t2).$isList)
        particle.set$frame(this.game.get$rnd().pick$1(this._frames));
      else
        particle.set$frame(t2);
      if (this.autoAlpha === true)
        particle.setAlphaData$1(this.alphaData);
      else
        t1.set$alpha(particle, this.game.get$rnd().realInRange$2(this.minParticleAlpha, this.maxParticleAlpha));
      particle.set$blendMode(this.blendMode);
      t1.get$body(particle).updateBounds$0();
      t1.get$body(particle).get$bounce().setTo$2(J.get$x$x(this.bounce), J.get$y$x(this.bounce));
      J.set$x$x(t1.get$body(particle).get$velocity(), this.game.get$rnd().integerInRange$2(J.get$x$x(this.minParticleSpeed), J.get$x$x(this.maxParticleSpeed)));
      J.set$y$x(t1.get$body(particle).get$velocity(), this.game.get$rnd().integerInRange$2(J.get$y$x(this.minParticleSpeed), J.get$y$x(this.maxParticleSpeed)));
      t1.get$body(particle).set$angularVelocity(this.game.get$rnd().integerInRange$2(this.minRotation, this.maxRotation));
      J.set$y$x(t1.get$body(particle).get$gravity(), this.gravity);
      J.set$x$x(t1.get$body(particle).get$drag(), J.get$x$x(this.particleDrag));
      J.set$y$x(t1.get$body(particle).get$drag(), J.get$y$x(this.particleDrag));
      t1.get$body(particle).set$angularDrag(this.angularDrag);
      particle.onEmit$0();
    }, "call$0", "get$emitParticle", 0, 0, 54, "emitParticle"],
    setSize$2: [function(width, height) {
      J.set$width$x(this.area, width);
      J.set$height$x(this.area, height);
    }, "call$2", "get$setSize", 4, 0, 149, 31, [], 52, [], "setSize"],
    setXSpeed$2: [function(min, max) {
      J.set$x$x(this.minParticleSpeed, min);
      J.set$x$x(this.maxParticleSpeed, max);
    }, function(min) {
      return this.setXSpeed$2(min, 0);
    }, "setXSpeed$1", function() {
      return this.setXSpeed$2(0, 0);
    }, "setXSpeed$0", "call$2", "call$1", "call$0", "get$setXSpeed", 0, 4, 56, 49, 49, 409, [], 410, [], "setXSpeed"],
    setYSpeed$2: [function(min, max) {
      J.set$y$x(this.minParticleSpeed, min);
      J.set$y$x(this.maxParticleSpeed, max);
    }, function(min) {
      return this.setYSpeed$2(min, 0);
    }, "setYSpeed$1", function() {
      return this.setYSpeed$2(0, 0);
    }, "setYSpeed$0", "call$2", "call$1", "call$0", "get$setYSpeed", 0, 4, 56, 49, 49, 409, [], 410, [], "setYSpeed"],
    setRotation$2: [function(min, max) {
      this.minRotation = min;
      this.maxRotation = max;
    }, function(min) {
      return this.setRotation$2(min, 0);
    }, "setRotation$1", function() {
      return this.setRotation$2(0, 0);
    }, "setRotation$0", "call$2", "call$1", "call$0", "get$setRotation", 0, 4, 56, 49, 49, 409, [], 410, [], "setRotation"],
    setAlpha$5: [function(min, max, rate, ease, yoyo) {
      var tweenData, tween, t1;
      if (min == null)
        min = 1;
      if (max == null)
        max = 1;
      if (rate == null)
        rate = 0;
      if (ease == null)
        ease = $.get$Easing_Linear().get$None();
      if (yoyo == null)
        yoyo = false;
      this.minParticleAlpha = min;
      this.maxParticleAlpha = max;
      this.autoAlpha = false;
      if (J.$gt$n(rate, 0) && !J.$eq(min, max)) {
        tweenData = P.LinkedHashMap_LinkedHashMap$_literal(["v", min], null, null);
        tween = this.game.get$make().tween$1(tweenData).to$3(P.LinkedHashMap_LinkedHashMap$_literal(["v", max], null, null), rate, ease);
        tween.yoyo$1(yoyo);
        t1 = tween.generateData$1(60);
        this.alphaData = t1;
        this.alphaData = J.toList$0$ax(J.get$reversed$ax(t1));
        this.autoAlpha = true;
      }
    }, function(min) {
      return this.setAlpha$5(min, 1, 0, null, false);
    }, "setAlpha$1", function(min, max) {
      return this.setAlpha$5(min, max, 0, null, false);
    }, "setAlpha$2", function() {
      return this.setAlpha$5(1, 1, 0, null, false);
    }, "setAlpha$0", function(min, max, rate) {
      return this.setAlpha$5(min, max, rate, null, false);
    }, "setAlpha$3", function(min, max, rate, ease) {
      return this.setAlpha$5(min, max, rate, ease, false);
    }, "setAlpha$4", "call$5", "call$1", "call$2", "call$0", "call$3", "call$4", "get$setAlpha", 0, 10, 1488, 433, 433, 49, 12, 19, 409, [], 410, [], 1489, [], 1490, [], 1491, [], "setAlpha"],
    setScale$7: [function(minX, maxX, minY, maxY, rate, ease, yoyo) {
      var tweenData, tween, t1;
      if (minX == null)
        minX = 1;
      if (maxX == null)
        maxX = 1;
      if (minY == null)
        minY = 1;
      if (maxY == null)
        maxY = 1;
      if (rate == null)
        rate = 0;
      if (ease == null)
        ease = $.get$Easing_Linear().get$None();
      if (yoyo == null)
        yoyo = false;
      this.minParticleScale = 1;
      this.maxParticleScale = 1;
      this._minParticleScale.set$2(minX, minY);
      this._maxParticleScale.set$2(maxX, maxY);
      this.autoScale = false;
      if (J.$gt$n(rate, 0) && !J.$eq(minX, maxX) || !J.$eq(minY, maxY)) {
        tweenData = P.LinkedHashMap_LinkedHashMap$_literal(["x", minX, "y", minY], null, null);
        tween = this.game.get$make().tween$1(tweenData).to$3(P.LinkedHashMap_LinkedHashMap$_literal(["x", maxX, "y", maxY], null, null), rate, ease);
        tween.yoyo$1(yoyo);
        t1 = tween.generateData$1(60);
        this.scaleData = t1;
        this.scaleData = J.toList$0$ax(J.get$reversed$ax(t1));
        this.autoScale = true;
      }
    }, function(minX) {
      return this.setScale$7(minX, 1, 1, 1, 0, null, false);
    }, "setScale$1", function(minX, maxX) {
      return this.setScale$7(minX, maxX, 1, 1, 0, null, false);
    }, "setScale$2", function() {
      return this.setScale$7(1, 1, 1, 1, 0, null, false);
    }, "setScale$0", function(minX, maxX, minY) {
      return this.setScale$7(minX, maxX, minY, 1, 0, null, false);
    }, "setScale$3", function(minX, maxX, minY, maxY) {
      return this.setScale$7(minX, maxX, minY, maxY, 0, null, false);
    }, "setScale$4", function(minX, maxX, minY, maxY, rate, ease) {
      return this.setScale$7(minX, maxX, minY, maxY, rate, ease, false);
    }, "setScale$6", function(minX, maxX, minY, maxY, rate) {
      return this.setScale$7(minX, maxX, minY, maxY, rate, null, false);
    }, "setScale$5", "call$7", "call$1", "call$2", "call$0", "call$3", "call$4", "call$6", "call$5", "get$setScale", 0, 14, 1492, 433, 433, 433, 433, 49, 12, 19, 1493, [], 1494, [], 1495, [], 1496, [], 1489, [], 1490, [], 1491, [], "setScale"],
    at$1: [function(object) {
      var t1;
      if (object.get$center() != null) {
        this.emitX = J.get$x$x(object.get$center());
        this.emitY = J.get$y$x(object.get$center());
      } else {
        t1 = J.getInterceptor$x(object);
        this.emitX = J.$add$ns(J.get$x$x(object.get$world()), J.$mul$ns(J.get$x$x(object.get$anchor()), t1.get$width(object)));
        this.emitY = J.$add$ns(J.get$y$x(object.get$world()), J.$mul$ns(J.get$y$x(object.get$anchor()), t1.get$height(object)));
      }
    }, "call$1", "get$at", 2, 0, 320, 584, [], "at"],
    Emitter$4: function(game, x, y, maxParticles) {
      var t1, t2;
      this.maxParticles = maxParticles;
      t1 = $.Particles_ID;
      t2 = J.getInterceptor$ns(t1);
      $.Particles_ID = t2.$add(t1, 1);
      this.name = C.JSString_methods.$add("emitter", t2.toString$0(t1));
      this.type = 11;
      this.area = new R.Rectangle1(x, y, 1, 1, 0, 0, 0, 0);
      t1 = new R.Point(null, null);
      t1.x = -100;
      t1.y = -100;
      this.minParticleSpeed = t1;
      t1 = new R.Point(null, null);
      t1.x = 100;
      t1.y = 100;
      this.maxParticleSpeed = t1;
      this.minParticleScale = 1;
      this.maxParticleScale = 1;
      this.scaleData = null;
      this.minRotation = -360;
      this.maxRotation = 360;
      this.minParticleAlpha = 1;
      this.maxParticleAlpha = 1;
      this.alphaData = null;
      this.gravity = 100;
      this.particleClass = C.Type_1Od;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.particleDrag = t1;
      this.angularDrag = 0;
      this.frequency = 100;
      this.lifespan = 2000;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.bounce = t1;
      this.on = false;
      t1 = new R.Point(null, null);
      t1.x = 0.5;
      t1.y = 0.5;
      this.particleAnchor = t1;
      this.blendMode = C.BlendModes_0;
      this.emitX = x;
      this.emitY = y;
      this.autoScale = false;
      this.autoAlpha = false;
      this.particleBringToTop = false;
      this.particleSendToBack = false;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this._minParticleScale = t1;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this._maxParticleScale = t1;
      this._quantity = 0;
      this._timer = 0;
      this._counter = 0;
      this._explode = true;
      this._frames = null;
    },
    $asGroup: function() {
      return [null];
    },
    $asGroup: function() {
      return [null];
    },
    "<>": [],
    static: {Emitter$: [function(game, x, y, maxParticles) {
        var t1, t2, t3, t4, t5;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = new R.Emitter(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "group", false, false, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, t1, null, t2, null, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t5.Group$6(game, null, "group", false, false, 0, null);
        t5.Emitter$4(game, x, y, maxParticles);
        return t5;
      }, null, null, 2, 6, 457, 49, 49, 406, 252, [], 9, [], 10, [], 458, [], "new Emitter"]}
  },
  "+Emitter": [1029],
  Particles: {
    "^": "Object;Arcade@-783,game@-613,emitters@-1497",
    add$1: [function(_, emitter) {
      J.$indexSet$ax(this.emitters, J.get$name$x(emitter), emitter);
      return emitter;
    }, "call$1", "get$add", 2, 0, 1498, 1499, [], "add"],
    remove$1: [function(_, emitter) {
      J.remove$1$ax(this.emitters, J.get$name$x(emitter));
    }, "call$1", "get$remove", 2, 0, 102, 1499, [], "remove"],
    update$0: [function() {
      var t1, key;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this.emitters)); t1.moveNext$0();) {
        key = t1.get$current();
        if (J.$index$asx(this.emitters, key).get$exists() === true)
          J.$index$asx(this.emitters, key).update$0();
      }
    }, "call$0", "get$update", 0, 0, 54, "update"],
    static: {"^": "Particles_ID@-614", Particles$: [function(game) {
        var t1 = new R.Particles(P.LinkedHashMap_LinkedHashMap$_empty(null, null), game, null);
        t1.emitters = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new Particles"]}
  },
  "+Particles": [674],
  CollisionInfo: {
    "^": "Object;up@-617,down@-617,left*-617,right*-617,none@-617,any*-617",
    any$1: function($receiver, arg0) {
      return this.any.call$1(arg0);
    },
    CollisionInfo$4$down$left$right$up: function(down, left, right, up) {
      var t1 = this.up;
      this.none = !(t1 === true || this.down === true || this.left === true || this.right === true);
      this.any = t1 === true || this.down === true || this.left === true || this.right === true;
    },
    static: {CollisionInfo$: [function(down, left, right, up) {
        var t1 = new R.CollisionInfo(up, down, left, right, null, null);
        t1.CollisionInfo$4$down$left$right$up(down, left, right, up);
        return t1;
      }, null, null, 0, 9, 459, 19, 19, 19, 19, 460, [], 461, [], 198, [], 462, [], "new CollisionInfo"]}
  },
  "+CollisionInfo": [674],
  Body: {
    "^": "Rectangle1;game@-613,position*-615,tilePadding@-615,width:Phaser$Body$width*-616,height:Phaser$Body$height*-616,velocity@-615,acceleration*-615,maxVelocity@-615,collideWorldBounds@-617,bounce@-12,type*-614,angularVelocity@-616,gravity@-615,drag@-12,angularDrag@-616,immovable@-617,x:Phaser$Body$x*-616,y:Phaser$Body$y*-616,speed@-616,blocked@-618,angle*-616,moves@-617,phase@-614,_reset@-617,safeRemove@-617,touching@-618,Phaser$Rectangle1$x-616,Phaser$Rectangle1$y-616,Phaser$Rectangle1$width-616,Phaser$Rectangle1$height-616,x-616,y-616,width-616,height-616",
    angle$0: function($receiver) {
      return this.angle.call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.angle.call$2(arg0, arg1);
    },
    $isBody: true,
    static: {Body$1: [function() {
        return new R.Body(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, 0, 0, 0);
      }, null, null, 0, 0, 463, "new Body"]}
  },
  "+Body": [649],
  Physics: {
    "^": "Object;game@-613,config@-783,arcade@-1500,ninja@-1501,p2@-1502,box2d@-12,chipmunk@-12",
    parseConfig$0: [function() {
      if (J.containsKey$1$x(this.config, "arcade") !== true || J.$eq(J.$index$asx(this.config, "arcade"), true)) {
        this.arcade = O.Arcade$(this.game);
        this.game.get$time().set$deltaCap(0.2);
      }
    }, "call$0", "get$parseConfig", 0, 0, 54, "parseConfig"],
    startSystem$7$broadphase$doProfiling$fake$gravity$islandSplit$solver: [function(system, broadphase, doProfiling, fake, gravity, islandSplit, solver) {
      var t1, t2;
      t1 = J.getInterceptor(system);
      if (t1.$eq(system, 0))
        this.arcade = O.Arcade$(this.game);
      else if (t1.$eq(system, 1)) {
        t2 = new L.P2(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t2.P2$7$broadphase$doProfiling$fake$gravity$islandSplit$solver(this.game, broadphase, doProfiling, fake, gravity, islandSplit, solver);
        this.p2 = t2;
      }
      if (t1.$eq(system, 2)) {
        t1 = new E.Ninja(null, null, null, null, 10, 4, null, false, 0);
        t1.Ninja$1(this.game);
        this.ninja = t1;
      }
    }, function(system) {
      return this.startSystem$7$broadphase$doProfiling$fake$gravity$islandSplit$solver(system, null, false, false, C.List_0_0, false, null);
    }, "startSystem$1", "call$7$broadphase$doProfiling$fake$gravity$islandSplit$solver", "call$1", "get$startSystem", 2, 13, 1503, 12, 1504, 19, 12, 19, 19, 1505, [], 1506, [], 1507, [], 1508, [], 1509, [], 1510, [], 1511, [], "startSystem"],
    enable$3: [function(_, object, system, debug) {
      var t1;
      if (system == null)
        system = 0;
      if (debug == null)
        debug = false;
      t1 = J.getInterceptor(system);
      if (t1.$eq(system, 0))
        J.enable$1$x(this.arcade, object);
      else if (t1.$eq(system, 1) && this.p2 != null)
        J.enable$2$x(this.p2, object, debug);
      else if (t1.$eq(system, 2) && this.ninja != null)
        this.ninja.enableAABB$1(object);
    }, function($receiver, object, system) {
      return this.enable$3($receiver, object, system, null);
    }, "enable$2", function($receiver, object) {
      return this.enable$3($receiver, object, null, null);
    }, "enable$1", "call$3", "call$2", "call$1", "get$enable", 2, 4, 1512, 12, 12, 584, [], 1505, [], 1513, [], "enable"],
    preUpdate$0: [function() {
      var t1 = this.p2;
      if (t1 != null)
        t1.preUpdate$0();
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    update$0: [function() {
      var t1 = this.p2;
      if (t1 != null)
        t1.update$0();
    }, "call$0", "get$update", 0, 0, 54, "update"],
    setBoundsToWorld$0: [function() {
      var t1 = this.arcade;
      if (t1 != null)
        t1.setBoundsToWorld$0();
      t1 = this.ninja;
      if (t1 != null)
        t1.setBoundsToWorld$0();
      t1 = this.p2;
      if (t1 != null)
        t1.setBoundsToWorld$0();
    }, "call$0", "get$setBoundsToWorld", 0, 0, 54, "setBoundsToWorld"],
    clear$0: [function(_) {
      var t1 = this.p2;
      if (t1 != null)
        J.clear$0$ax(t1);
    }, "call$0", "get$clear", 0, 0, 54, "clear"],
    destroy$0: [function() {
      var t1 = this.p2;
      if (t1 != null)
        t1.destroy$0();
      this.arcade = null;
      this.ninja = null;
      this.p2 = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    Physics$2: function(game, config) {
      if (config == null)
        config = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this.game = game;
      this.config = config;
      this.arcade = null;
      this.p2 = null;
      if (J.containsKey$1$x(config, "arcade") !== true || J.$eq(J.$index$asx(this.config, "arcade"), true)) {
        this.arcade = O.Arcade$(this.game);
        this.game.get$time().set$deltaCap(0.2);
      }
    },
    static: {"^": "Physics_ARCADE<-614,Physics_P2JS<-614,Physics_NINJA<-614,Physics_BOX2D<-614,Physics_CHIPMUNK<-614", Physics$: [function(game, config) {
        var t1 = new R.Physics(null, null, null, null, null, null, null);
        t1.Physics$2(game, config);
        return t1;
      }, null, null, 2, 2, 464, 465, 252, [], 466, [], "new Physics"]}
  },
  "+Physics": [674],
  AudioSprite: {
    "^": "Object;game@-613,key*-644,config@-783,autoplayKey@-644,autoplay*-617,sounds@-1514",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    play$2: [function(_, marker, volume) {
      if (volume == null)
        volume = 1;
      return J.play$3$x(J.$index$asx(this.sounds, marker), marker, null, volume);
    }, function($receiver, marker) {
      return this.play$2($receiver, marker, null);
    }, "play$1", function($receiver) {
      return this.play$2($receiver, null, null);
    }, "play$0", "call$2", "call$1", "call$0", "get$play", 0, 4, 1515, 12, 12, 1160, [], 470, [], "play"],
    stop$1: [function(_, marker) {
      var t1, key;
      if (marker == null)
        for (t1 = J.get$iterator$ax(J.get$keys$x(this.sounds)); t1.moveNext$0();) {
          key = t1.get$current();
          J.stop$0$x(J.$index$asx(this.sounds, key));
        }
      else
        J.stop$0$x(J.$index$asx(this.sounds, marker));
    }, function($receiver) {
      return this.stop$1($receiver, null);
    }, "stop$0", "call$1", "call$0", "get$stop", 0, 2, 106, 12, 1160, [], "stop"],
    get$1: [function(marker) {
      return J.$index$asx(this.sounds, marker);
    }, "call$1", "get$get", 2, 0, 91, 1160, [], "get"],
    AudioSprite$2: function(game, key) {
      var t1, k, marker, sound, t2;
      this.game = game;
      this.key = key;
      t1 = game.get$cache().getJSON$1(J.$add$ns(key, "-audioatlas"));
      this.config = t1;
      this.autoplayKey = null;
      this.autoplay = false;
      this.sounds = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      for (t1 = J.get$iterator$ax(J.get$keys$x(J.$index$asx(t1, "spritemap"))); t1.moveNext$0();) {
        k = t1.get$current();
        marker = J.$index$asx(J.$index$asx(this.config, "spritemap"), k);
        sound = J.get$add$ax(this.game).sound$1(this.key);
        t2 = J.getInterceptor$x(marker);
        if (t2.get$loop(marker) === true)
          sound.addMarker$5(k, t2.get$start(marker), J.$sub$n(marker.get$end(), t2.get$start(marker)), null, true);
        else
          sound.addMarker$5(k, t2.get$start(marker), J.$sub$n(marker.get$end(), t2.get$start(marker)), null, false);
        J.$indexSet$ax(this.sounds, k, sound);
      }
      if (J.$index$asx(this.config, "autoplay") === true) {
        t1 = J.$index$asx(this.config, "autoplay");
        this.autoplayKey = t1;
        this.play$1(0, t1);
        this.autoplay = J.$index$asx(this.sounds, this.autoplayKey) != null;
      }
    },
    static: {AudioSprite$: [function(game, key) {
        var t1 = new R.AudioSprite(null, null, null, null, null, null);
        t1.AudioSprite$2(game, key);
        return t1;
      }, null, null, 4, 0, 467, 252, [], 269, [], "new AudioSprite"]}
  },
  "+AudioSprite": [674],
  Marker: {
    "^": "Object;name*-644,start*-616,stop*-616,volume*-616,duration*-616,durationMS@-616,loop*-617,end@-616",
    start$1: function($receiver, arg0) {
      return this.start.call$1(arg0);
    },
    start$0: function($receiver) {
      return this.start.call$0();
    },
    start$2: function($receiver, arg0, arg1) {
      return this.start.call$2(arg0, arg1);
    },
    start$3: function($receiver, arg0, arg1, arg2) {
      return this.start.call$3(arg0, arg1, arg2);
    },
    start$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.start.call$4(arg0, arg1, arg2, arg3);
    },
    start$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.start.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    stop$0: function($receiver) {
      return this.stop.call$0();
    },
    stop$1: function($receiver, arg0) {
      return this.stop.call$1(arg0);
    },
    stop$2: function($receiver, arg0, arg1) {
      return this.stop.call$2(arg0, arg1);
    },
    loop$0: function($receiver) {
      return this.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return this.loop.call$3(arg0, arg1, arg2);
    },
    end$0: function() {
      return this.end.call$0();
    },
    static: {Marker$: [function() {
        return new R.Marker(null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 468, "new Marker"]}
  },
  "+Marker": [674],
  Sound: {
    "^": "Object;game@-613,name*-644,key*-644,markers@-1516,context*-1517,autoplay*-617,totalDuration@-616,startTime@-616,currentTime*-616,duration*-616,durationMS@-616,position*-614,stopTime@-616,paused*-617,pausedPosition@-616,pausedTime@-616,isPlaying@-617,currentMarker@-644,pendingPlayback@-617,override@-617,allowMultiple@-617,usingWebAudio@-617,usingAudioTag@-617,externalNode@-783,masterGainNode@-1518,gainNode@-1519,loop*-617,onDecoded@-1388,onPlay*-1388,onPause*-1388,onResume@-1388,onLoop@-1388,onStop@-1388,onMute@-1388,onMarkerComplete@-1388,onFadeComplete@-1388,_volume@-616,_Phaser$_buffer@-12,_muted@-617,_tempMarker@-644,_tempPosition@-614,_tempVolume@-671,_tempLoop@-617,_paused@-617,_onDecodedEventDispatched@-617,_muteVolume@-671,_sound@-12",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    paused$0: function($receiver) {
      return this.paused.call$0();
    },
    loop$0: function($receiver) {
      return this.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return this.loop.call$3(arg0, arg1, arg2);
    },
    get$isDecoding: [function() {
      return J.$index$asx(this.game.get$cache().getSound$1(this.key), "isDecoding");
    }, null, null, 1, 0, 247, "isDecoding"],
    get$isDecoded: [function() {
      return this.game.get$cache().isSoundDecoded$1(this.key);
    }, null, null, 1, 0, 247, "isDecoded"],
    get$mute: [function() {
      return this._muted === true || this.game.get$sound().get$mute() === true;
    }, null, null, 1, 0, 247, "mute"],
    set$mute: [function(value) {
      if (value === true) {
        this._muted = true;
        if (this.usingWebAudio === true) {
          this._muteVolume = J.get$gain$x(this.gainNode).value;
          J.get$gain$x(this.gainNode).value = 0;
        } else if (this.usingAudioTag === true && this._sound === true) {
          this._muteVolume = J.$index$asx(this._sound, "volume");
          J.$indexSet$ax(this._sound, "volume", 0);
        }
      } else {
        this._muted = false;
        if (this.usingWebAudio === true)
          J.get$gain$x(this.gainNode).value = this._muteVolume;
        else if (this.usingAudioTag === true && this._sound === true)
          J.$indexSet$ax(this._sound, "volume", this._muteVolume);
      }
      this.onMute.dispatch$1(this);
    }, null, null, 3, 0, 639, 138, [], "mute"],
    get$volume: [function(_) {
      return this._volume;
    }, null, null, 1, 0, 619, "volume"],
    set$volume: [function(_, value) {
      var t1;
      if (this.usingWebAudio === true) {
        this._volume = value;
        J.get$gain$x(this.gainNode).value = value;
      } else if (this.usingAudioTag === true && this._sound === true) {
        t1 = J.getInterceptor$n(value);
        if (t1.$ge(value, 0) && t1.$le(value, 1)) {
          this._volume = value;
          J.$indexSet$ax(this._sound, "volume", value);
        }
      }
    }, null, null, 3, 0, 620, 138, [], "volume"],
    soundHasUnlocked$1: [function(key) {
      var t1;
      if (J.$eq(key, this.key)) {
        t1 = this.game.get$cache().getSoundData$1(this.key);
        this._sound = t1;
        if (!!J.getInterceptor(t1).$isAudioElement)
          this.totalDuration = H.interceptedTypeCast(t1, "$isAudioElement").duration;
        else
          this.totalDuration = H.interceptedTypeCast(t1, "$isAudioBuffer").duration;
      }
    }, "call$1", "get$soundHasUnlocked", 2, 0, 102, 269, [], "soundHasUnlocked"],
    addMarker$5: [function($name, start, duration, volume, loop) {
      var t1, t2;
      if (volume == null)
        volume = 1;
      if (loop == null)
        loop = false;
      t1 = this.markers;
      t2 = new R.Marker(null, null, null, null, null, null, null, null);
      t2.name = $name;
      t2.start = start;
      t2.stop = J.$add$ns(start, duration);
      t2.volume = volume;
      t2.duration = duration;
      t2.durationMS = J.$mul$ns(duration, 1000);
      t2.loop = loop;
      J.$indexSet$ax(t1, $name, t2);
    }, function(name, start, duration) {
      return this.addMarker$5(name, start, duration, 1, false);
    }, "addMarker$3", function(name, start, duration, volume) {
      return this.addMarker$5(name, start, duration, volume, false);
    }, "addMarker$4", "call$5", "call$3", "call$4", "get$addMarker", 6, 4, 1520, 433, 19, 83, [], 261, [], 94, [], 470, [], 257, [], "addMarker"],
    removeMarker$1: [function($name) {
      J.remove$1$ax(this.markers, $name);
    }, "call$1", "get$removeMarker", 2, 0, 102, 83, [], "removeMarker"],
    update$0: [function() {
      if (this.game.get$cache().isSoundDecoded$1(this.key) === true && this._onDecodedEventDispatched !== true) {
        this.onDecoded.dispatch$1(this);
        this._onDecodedEventDispatched = true;
      }
      if (this.pendingPlayback === true && this.game.get$cache().isSoundReady$1(this.key)) {
        this.pendingPlayback = false;
        this.play$4(0, this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop);
      }
      if (this.isPlaying === true) {
        var t1 = J.$sub$n(J.get$now$x(this.game.get$time()), this.startTime);
        this.currentTime = t1;
        if (J.$ge$n(t1, this.durationMS))
          if (this.usingWebAudio === true)
            if (this.loop === true) {
              this.onLoop.dispatch$1(this);
              if (J.$eq(this.currentMarker, "")) {
                this.currentTime = 0;
                this.startTime = J.get$now$x(this.game.get$time());
              } else {
                this.onMarkerComplete.dispatch$1([this.currentMarker, this]);
                this.play$5(0, this.currentMarker, 0, this._volume, true, true);
              }
            } else
              this.stop$0(0);
          else if (this.loop === true) {
            this.onLoop.dispatch$1(this);
            this.play$5(0, this.currentMarker, 0, this._volume, true, true);
          } else
            this.stop$0(0);
      }
    }, "call$0", "get$update", 0, 0, 54, "update"],
    play$5: [function(_, marker, position, volume, loop, forceRestart) {
      var t1, t2, t3, t4;
      if (marker == null)
        marker = "";
      if (forceRestart == null)
        forceRestart = true;
      t1 = this.isPlaying === true;
      if (t1 && this.allowMultiple !== true && forceRestart !== true && this.override !== true)
        return this;
      if (t1)
        if (this.allowMultiple !== true)
          t1 = this.override === true || forceRestart === true;
        else
          t1 = false;
      else
        t1 = false;
      if (t1)
        if (this.usingWebAudio === true) {
          t1 = J.get$stop$x(this._sound);
          t2 = this._sound;
          if (t1 == null)
            t2.noteOff$1(0);
          else
            J.stop$1$x(t2, 0);
        } else if (this.usingAudioTag === true) {
          J.pause$0$x(this._sound);
          J.set$currentTime$x(this._sound, 0);
        }
      this.currentMarker = marker;
      t1 = J.getInterceptor(marker);
      if (!t1.$eq(marker, ""))
        if (J.$index$asx(this.markers, marker) != null) {
          this.position = J.get$start$x(J.$index$asx(this.markers, marker));
          this.set$volume(0, J.get$volume$x(J.$index$asx(this.markers, marker)));
          this.loop = J.get$loop$x(J.$index$asx(this.markers, marker));
          this.duration = J.get$duration$x(J.$index$asx(this.markers, marker));
          this.durationMS = J.$index$asx(this.markers, marker).get$durationMS();
          if (volume != null)
            this.set$volume(0, volume);
          if (loop != null)
            this.loop = loop;
          this._tempMarker = marker;
          this._tempPosition = this.position;
          this._tempVolume = this._volume;
          this._tempLoop = this.loop;
        } else {
          window;
          t1 = C.JSString_methods.$add("Phaser.Sound.play: audio marker ", marker) + " doesn't exist";
          if (typeof console != "undefined")
            console.warn(t1);
          return this;
        }
      else {
        if (volume == null)
          volume = this._volume;
        if (loop == null)
          loop = this.loop;
        this.position = position;
        this.set$volume(0, volume);
        this.loop = loop;
        this.duration = 0;
        this.durationMS = 0;
        this._tempMarker = marker;
        this._tempPosition = position;
        this._tempVolume = volume;
        this._tempLoop = loop;
      }
      if (this.usingWebAudio === true)
        if (this.game.get$cache().isSoundDecoded$1(this.key) === true) {
          if (this._Phaser$_buffer == null)
            this._Phaser$_buffer = this.game.get$cache().getSoundData$1(this.key);
          t2 = J.createBufferSource$0$x(this.context);
          this._sound = t2;
          t2.buffer = this._Phaser$_buffer;
          t2 = this.externalNode;
          t3 = this._sound;
          if (t2 != null)
            J.connectNode$1$x(t3, t2);
          else
            J.connectNode$1$x(t3, this.gainNode);
          this.totalDuration = J.get$duration$x(J.get$buffer$x(this._sound));
          if (J.$eq(this.duration, 0)) {
            t2 = this.totalDuration;
            this.duration = t2;
            this.durationMS = J.$mul$ns(t2, 1000);
          }
          if (this.loop === true && t1.$eq(marker, ""))
            J.set$loop$x(this._sound, true);
          t1 = J.get$start$x(this._sound);
          t2 = this._sound;
          t3 = this.position;
          t4 = this.duration;
          if (t1 == null)
            t2.noteGrainOn$3(0, t3, t4);
          else
            J.start$3$x(t2, 0, t3, t4);
          this.isPlaying = true;
          t1 = J.get$now$x(this.game.get$time());
          this.startTime = t1;
          this.currentTime = 0;
          this.stopTime = J.$add$ns(t1, this.durationMS);
          this.onPlay.dispatch$1(this);
        } else {
          this.pendingPlayback = true;
          if (this.game.get$cache().getSound$1(this.key) != null && J.$eq(J.$index$asx(this.game.get$cache().getSound$1(this.key), "isDecoding"), false))
            this.game.get$sound().decode$2(this.key, this);
        }
      else if (this.game.get$cache().getSound$1(this.key) != null && J.$index$asx(this.game.get$cache().getSound$1(this.key), "locked") === true) {
        this.game.get$cache().reloadSound$1(this.key);
        this.pendingPlayback = true;
      } else {
        if (this._sound != null)
          t1 = this.game.get$device().get$cocoonJS() === true || J.get$readyState$x(this._sound) === 4;
        else
          t1 = false;
        if (t1) {
          J.play$0$x(this._sound);
          this.totalDuration = J.get$duration$x(this._sound);
          if (J.$eq(this.duration, 0)) {
            t1 = this.totalDuration;
            this.duration = t1;
            this.durationMS = J.$mul$ns(t1, 1000);
          }
          J.set$currentTime$x(this._sound, this.position);
          J.set$muted$x(this._sound, this._muted);
          t1 = this._muted;
          t2 = this._sound;
          if (t1 === true)
            J.set$volume$x(t2, 0);
          else
            J.set$volume$x(t2, this._volume);
          this.isPlaying = true;
          t1 = J.get$now$x(this.game.get$time());
          this.startTime = t1;
          this.currentTime = 0;
          this.stopTime = J.$add$ns(t1, this.durationMS);
          this.onPlay.dispatch$1(this);
        } else
          this.pendingPlayback = true;
      }
      return this;
    }, function($receiver, marker) {
      return this.play$5($receiver, marker, 0, 1, false, true);
    }, "play$1", function($receiver, marker, position, volume, loop) {
      return this.play$5($receiver, marker, position, volume, loop, true);
    }, "play$4", function($receiver) {
      return this.play$5($receiver, null, 0, 1, false, true);
    }, "play$0", function($receiver, marker, position, volume) {
      return this.play$5($receiver, marker, position, volume, false, true);
    }, "play$3", function($receiver, marker, position) {
      return this.play$5($receiver, marker, position, 1, false, true);
    }, "play$2", "call$5", "call$1", "call$4", "call$0", "call$3", "call$2", "get$play", 0, 10, 1521, 12, 49, 433, 19, 78, 1160, [], 290, [], 470, [], 257, [], 1522, [], "play"],
    restart$4: [function(marker, position, volume, loop) {
      this.play$5(0, marker, position, volume, loop == null ? false : loop, true);
    }, function(marker, position, volume) {
      return this.restart$4(marker, position, volume, false);
    }, "restart$3", function() {
      return this.restart$4("", 0, 1, false);
    }, "restart$0", function(marker) {
      return this.restart$4(marker, 0, 1, false);
    }, "restart$1", function(marker, position) {
      return this.restart$4(marker, position, 1, false);
    }, "restart$2", "call$4", "call$3", "call$0", "call$1", "call$2", "get$restart", 0, 8, 1523, 259, 49, 433, 19, 1160, [], 290, [], 470, [], 257, [], "restart"],
    pause$0: [function(_) {
      if (this.isPlaying === true && this._sound != null) {
        this.paused = true;
        this.pausedPosition = this.currentTime;
        this.pausedTime = J.get$now$x(this.game.get$time());
        this.onPause.dispatch$1(this);
        this.stop$0(0);
      }
    }, "call$0", "get$pause", 0, 0, 54, "pause"],
    resume$0: [function() {
      var p, t1, t2, t3;
      if (this.paused === true && this._sound === true) {
        if (this.usingWebAudio === true) {
          p = J.$add$ns(this.position, J.$div$n(this.pausedPosition, 1000));
          t1 = J.createBufferSource$0$x(this.context);
          this._sound = t1;
          t1.buffer = this._Phaser$_buffer;
          t1 = this.externalNode;
          t2 = this._sound;
          if (t1 != null)
            J.connectNode$1$x(t2, t1);
          else
            J.connectNode$1$x(t2, this.gainNode);
          if (this.loop === true)
            J.set$loop$x(this._sound, true);
          t1 = J.get$start$x(this._sound);
          t2 = this._sound;
          t3 = this.duration;
          if (t1 == null)
            t2.noteGrainOn$3(0, p, t3);
          else
            J.start$3$x(t2, 0, p, t3);
        } else
          J.play$0$x(this._sound);
        this.isPlaying = true;
        this.paused = false;
        this.startTime = J.$add$ns(this.startTime, J.$sub$n(J.get$now$x(this.game.get$time()), this.pausedTime));
        this.onResume.dispatch$1(this);
      }
    }, "call$0", "get$resume", 0, 0, 54, "resume"],
    stop$0: [function(_) {
      var exception, prevMarker;
      if (this.isPlaying === true && this._sound != null)
        if (this.usingWebAudio === true)
          if (J.get$stop$x(this._sound) == null)
            this._sound.noteOff$1(0);
          else
            try {
              J.stop$1$x(this._sound, 0);
            } catch (exception) {
              H.unwrapException(exception);
            }

        else if (this.usingAudioTag === true) {
          J.pause$0$x(this._sound);
          J.set$currentTime$x(this._sound, 0);
        }
      this.isPlaying = false;
      prevMarker = this.currentMarker;
      if (!J.$eq(prevMarker, ""))
        this.onMarkerComplete.dispatch$1([this.currentMarker, this]);
      this.currentMarker = "";
      if (this.paused !== true)
        this.onStop.dispatch$1([this, prevMarker]);
    }, "call$0", "get$stop", 0, 0, 54, "stop"],
    fadeIn$2: [function(duration, loop) {
      if (this.paused === true)
        return;
      this.play$4(0, "", 0, 0, loop);
      J.add$1$ax(J.get$add$ax(this.game).tween$1(this).to$4(P.LinkedHashMap_LinkedHashMap$_literal([this._volume, 1], null, null), duration, $.get$Easing_Linear().get$None(), true).onComplete, this.get$fadeComplete());
    }, function(duration) {
      return this.fadeIn$2(duration, false);
    }, "fadeIn$1", function() {
      return this.fadeIn$2(1000, false);
    }, "fadeIn$0", "call$2", "call$1", "call$0", "get$fadeIn", 0, 4, 1524, 1525, 19, 94, [], 257, [], "fadeIn"],
    fadeOut$1: [function(duration) {
      if (duration == null)
        duration = 1000;
      if (this.isPlaying !== true || this.paused === true || J.$le$n(this._volume, 0))
        return;
      J.add$1$ax(J.get$add$ax(this.game).tween$1(this).to$4(P.LinkedHashMap_LinkedHashMap$_literal([this._volume, 0], null, null), duration, $.get$Easing_Linear().get$None(), true).onComplete, this.get$fadeComplete());
    }, function() {
      return this.fadeOut$1(1000);
    }, "fadeOut$0", "call$1", "call$0", "get$fadeOut", 0, 2, 1526, 1525, 94, [], "fadeOut"],
    fadeComplete$1: [function(sound) {
      this.onFadeComplete.dispatch$1([this, this._volume]);
      if (J.$eq(this._volume, 0))
        this.stop$0(0);
    }, "call$1", "get$fadeComplete", 2, 0, 1527, 1159, [], "fadeComplete"],
    destroy$1: [function(remove) {
      this.stop$0(0);
      if (remove === true)
        J.remove$1$ax(this.game.get$sound(), this);
      else {
        this.markers = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        this.context = null;
        this._Phaser$_buffer = null;
        this.externalNode = null;
        this.onDecoded.dispose$0();
        this.onPlay.dispose$0();
        this.onPause.dispose$0();
        this.onResume.dispose$0();
        this.onLoop.dispose$0();
        this.onStop.dispose$0();
        this.onMute.dispose$0();
        this.onMarkerComplete.dispose$0();
      }
    }, function() {
      return this.destroy$1(true);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 956, 78, 1528, [], "destroy"],
    Sound$5: function(game, key, volume, loop, connect) {
      var t1, t2;
      if (connect == null)
        connect = this.game.get$sound().get$connectToMaster();
      this.name = key;
      this.key = key;
      this.markers = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this.context = null;
      this.autoplay = false;
      this.totalDuration = 0;
      this.startTime = 0;
      this.currentTime = 0;
      this.duration = 0;
      this.durationMS = 0;
      this.position = 0;
      this.stopTime = 0;
      this.paused = false;
      this.pausedPosition = 0;
      this.pausedTime = 0;
      this.isPlaying = false;
      this.currentMarker = "";
      this.pendingPlayback = false;
      this.override = false;
      this.allowMultiple = false;
      this.usingWebAudio = this.game.get$sound().get$usingWebAudio();
      this.usingAudioTag = this.game.get$sound().get$usingAudioTag();
      this.externalNode = null;
      this.masterGainNode = null;
      this.gainNode = null;
      this.loop = loop;
      if (this.usingWebAudio === true) {
        this.context = J.get$context$x(this.game.get$sound());
        this.masterGainNode = this.game.get$sound().get$masterGain();
        t1 = J.createGain$0$x(this.context);
        this.gainNode = t1;
        t1.gain.value = J.$mul$ns(volume, J.get$volume$x(this.game.get$sound()));
        if (connect === true)
          J.connectNode$1$x(this.gainNode, this.masterGainNode);
      } else {
        t1 = this.game.get$cache().getSound$1(key) != null && this.game.get$cache().isSoundReady$1(key);
        t2 = this.game;
        if (t1) {
          t1 = t2.get$cache().getSoundData$1(key);
          this._sound = t1;
          this.totalDuration = 0;
          this.totalDuration = H.interceptedTypeCast(t1, "$isAudioElement").duration;
        } else
          J.add$1$ax(t2.get$cache().get$onSoundUnlock(), this.get$soundHasUnlocked());
      }
      this.onDecoded = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onPlay = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onPause = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onResume = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onLoop = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onStop = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onMute = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onMarkerComplete = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onFadeComplete = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this._volume = volume;
      this._Phaser$_buffer = null;
      this._muted = false;
      this._tempMarker = "";
      this._tempPosition = 0;
      this._tempVolume = 0;
      this._tempLoop = false;
      this._paused = false;
      this._onDecodedEventDispatched = false;
    },
    static: {Sound$: [function(game, key, volume, loop, connect) {
        var t1 = new R.Sound(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false, null, null, null, null);
        t1.Sound$5(game, key, volume, loop, connect);
        return t1;
      }, null, null, 4, 6, 469, 433, 19, 12, 252, [], 269, [], 470, [], 257, [], 471, [], "new Sound"]}
  },
  "+Sound": [674],
  SoundManager: {
    "^": "Object;game@-613,onSoundDecode@-1388,_codeMuted@-617,_muted@-617,_volume@-671,_sounds@-1529,context*-1517,usingWebAudio@-617,usingAudioTag@-617,noAudio@-617,connectToMaster@-617,touchLocked@-617,channels@-614,masterGain@-1519,_unlockSource@-1530,_muteVolume@-616",
    get$mute: [function() {
      return this._muted;
    }, null, null, 1, 0, 247, "mute"],
    set$mute: [function(value) {
      if (value === true) {
        if (this._muted === true)
          return;
        this._codeMuted = true;
        this.setMute$0();
      } else {
        if (this._muted !== true)
          return;
        this._codeMuted = false;
        this.unsetMute$0();
      }
    }, null, null, 3, 0, 639, 138, [], "mute"],
    get$volume: [function(_) {
      if (this.usingWebAudio === true && this.masterGain != null)
        return J.get$gain$x(this.masterGain).value;
      else
        return this._volume;
    }, null, null, 1, 0, 21, "volume"],
    set$volume: [function(_, value) {
      var i, t1;
      this._volume = value;
      if (this.usingWebAudio === true && this.masterGain != null)
        J.get$gain$x(this.masterGain).value = value;
      else {
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this._sounds);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$index$asx(this._sounds, i).get$usingAudioTag() === true)
            J.set$volume$x(J.$index$asx(this._sounds, i), J.$mul$ns(J.get$volume$x(J.$index$asx(this._sounds, i)), value));
          ++i;
        }
      }
    }, null, null, 3, 0, 1531, 138, [], "volume"],
    boot$0: [function() {
      var exception, t1;
      if (this.game.get$device().get$iOS() === true && J.$eq(this.game.get$device().get$webAudio(), false))
        this.channels = 1;
      if (this.game.get$device().get$cocoonJS() !== true && this.game.get$device().get$iOS() === true) {
        this.game.get$input().get$touch().set$touchStartCallback(this.get$unlock(this));
        this.game.get$input().get$mouse().set$mouseDownCallback(this.get$unlock(this));
        this.touchLocked = true;
      } else
        this.touchLocked = false;
      try {
        this.context = new (window.AudioContext || window.webkitAudioContext)();
      } catch (exception) {
        H.unwrapException(exception);
        this.context = null;
        this.usingWebAudio = false;
        this.noAudio = true;
      }

      if (this.game.get$device().get$audioData() === true && this.context == null) {
        this.usingWebAudio = false;
        this.usingAudioTag = true;
        this.noAudio = false;
      }
      t1 = this.context;
      if (t1 == null)
        return;
      t1 = J.createGain$0$x(t1);
      this.masterGain = t1;
      if (this.context == null)
        return;
      t1.gain.value = 1;
      J.connectNode$1$x(this.masterGain, J.get$destination$x(this.context));
    }, "call$0", "get$boot", 0, 0, 54, "boot"],
    unlock$0: [function(_) {
      var buffer, t1;
      if (J.$eq(this.touchLocked, false))
        return;
      if (J.$eq(this.game.get$device().get$webAudio(), false)) {
        this.touchLocked = false;
        this._unlockSource = null;
        this.game.get$input().get$touch().set$touchStartCallback(null);
        this.game.get$input().get$mouse().set$mouseDownCallback(null);
      } else {
        buffer = J.createBuffer$3$x(this.context, 1, 1, 22050);
        t1 = J.createBufferSource$0$x(this.context);
        this._unlockSource = t1;
        t1.buffer = buffer;
        J.connectNode$1$x(this._unlockSource, J.get$destination$x(this.context));
        J.start$1$x(this._unlockSource, 0);
      }
    }, "call$0", "get$unlock", 0, 0, 54, "unlock"],
    stopAll$0: [function() {
      var i, t1;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._sounds);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(this._sounds, i) != null)
          J.stop$0$x(J.$index$asx(this._sounds, i));
        ++i;
      }
    }, "call$0", "get$stopAll", 0, 0, 54, "stopAll"],
    pauseAll$0: [function() {
      var i, t1;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._sounds);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(this._sounds, i) != null)
          J.pause$0$x(J.$index$asx(this._sounds, i));
        ++i;
      }
    }, "call$0", "get$pauseAll", 0, 0, 54, "pauseAll"],
    resumeAll$0: [function() {
      var i, t1;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._sounds);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(this._sounds, i) != null)
          J.$index$asx(this._sounds, i).resume$0();
        ++i;
      }
    }, "call$0", "get$resumeAll", 0, 0, 54, "resumeAll"],
    decode$2: [function(key, sound) {
      var soundData = this.game.get$cache().getSoundData$1(key);
      if (soundData != null)
        if (J.$eq(this.game.get$cache().isSoundDecoded$1(key), false)) {
          this.game.get$cache().updateSound$3(key, "isDecoding", true);
          J.decodeAudioData$1$x(this.context, soundData).then$1(new R.SoundManager_decode_closure(key, sound, this));
        }
    }, function(key) {
      return this.decode$2(key, null);
    }, "decode$1", "call$2", "call$1", "get$decode", 2, 2, 1532, 12, 269, [], 1159, [], "decode"],
    update$0: [function() {
      var i, t1;
      if (this.touchLocked === true)
        ;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._sounds);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$index$asx(this._sounds, i).update$0();
        ++i;
      }
    }, "call$0", "get$update", 0, 0, 54, "update"],
    add$4: [function(_, key, volume, loop, connect) {
      var t1, sound;
      if (connect == null)
        connect = this.connectToMaster;
      t1 = this.game;
      sound = new R.Sound(t1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false, null, null, null, null);
      sound.Sound$5(t1, key, volume, loop, connect);
      J.add$1$ax(this._sounds, sound);
      return sound;
    }, function($receiver, key, volume) {
      return this.add$4($receiver, key, volume, false, null);
    }, "add$2", function($receiver, key) {
      return this.add$4($receiver, key, 1, false, null);
    }, "add$1", function($receiver, key, volume, loop) {
      return this.add$4($receiver, key, volume, loop, null);
    }, "add$3", "call$4", "call$2", "call$1", "call$3", "get$add", 2, 6, 1533, 433, 19, 12, 269, [], 470, [], 257, [], 471, [], "add"],
    addSprite$1: [function(key) {
      return R.AudioSprite$(this.game, key);
    }, "call$1", "get$addSprite", 2, 0, 91, 269, [], "addSprite"],
    remove$1: [function(_, sound) {
      var i, i0;
      i = J.get$length$asx(this._sounds);
      for (; i0 = J.$sub$n(i, 1), i === true; i = i0)
        if (J.$eq(J.$index$asx(this._sounds, i0), sound)) {
          J.$index$asx(this._sounds, i0).destroy$1(false);
          J.removeAt$1$ax(this._sounds, i0);
          return true;
        }
      return false;
    }, "call$1", "get$remove", 2, 0, 1534, 1159, [], "remove"],
    removeByKey$1: [function(key) {
      var i, removed, t1, i0;
      i = J.get$length$asx(this._sounds);
      for (removed = 0; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        if (J.$eq(J.get$key$x(J.$index$asx(this._sounds, i0)), key)) {
          J.$index$asx(this._sounds, i0).destroy$1(false);
          J.removeAt$1$ax(this._sounds, i0);
          ++removed;
        }
      return removed;
    }, "call$1", "get$removeByKey", 2, 0, 557, 269, [], "removeByKey"],
    play$3: [function(_, key, volume, loop) {
      var sound = this.add$3(0, key, volume, loop);
      sound.play$0(0);
      return sound;
    }, function($receiver, key) {
      return this.play$3($receiver, key, 1, false);
    }, "play$1", function($receiver, key, volume) {
      return this.play$3($receiver, key, volume, false);
    }, "play$2", "call$3", "call$1", "call$2", "get$play", 2, 4, 1535, 433, 19, 269, [], 470, [], 257, [], "play"],
    setMute$0: [function() {
      var i, t1;
      if (this._muted === true)
        return;
      this._muted = true;
      if (this.usingWebAudio === true && this.masterGain != null) {
        this._muteVolume = J.get$gain$x(this.masterGain).value;
        J.get$gain$x(this.masterGain).value = 0;
      }
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._sounds);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(this._sounds, i).get$usingAudioTag() === true)
          J.$index$asx(this._sounds, i).set$mute(true);
        ++i;
      }
    }, "call$0", "get$setMute", 0, 0, 54, "setMute"],
    unsetMute$0: [function() {
      var i, t1;
      if (this._muted !== true || this._codeMuted === true)
        return;
      this._muted = false;
      if (this.usingWebAudio === true && this.masterGain != null)
        J.get$gain$x(this.masterGain).value = this._muteVolume;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._sounds);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(this._sounds, i).get$usingAudioTag() === true)
          J.$index$asx(this._sounds, i).set$mute(false);
        ++i;
      }
    }, "call$0", "get$unsetMute", 0, 0, 54, "unsetMute"],
    destroy$0: [function() {
      var i, t1;
      this.stopAll$0();
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._sounds);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(this._sounds, i) != null)
          J.$index$asx(this._sounds, i).destroy$0();
        ++i;
      }
      this._sounds = [];
      this.onSoundDecode.dispose$0();
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    SoundManager$1: function(game) {
      this.onSoundDecode = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this._codeMuted = false;
      this._muted = false;
      this._unlockSource = null;
      this._volume = 1;
      this._sounds = [];
      this.context = null;
      this.usingWebAudio = true;
      this.usingAudioTag = false;
      this.noAudio = false;
      this.connectToMaster = true;
      this.touchLocked = false;
      this.channels = 32;
    },
    static: {SoundManager$: [function(game) {
        var t1 = new R.SoundManager(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.SoundManager$1(game);
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new SoundManager"]}
  },
  "+SoundManager": [674],
  SoundManager_decode_closure: {
    "^": "Closure:102;key_0,sound_1,that_2",
    call$1: [function(buffer) {
      var t1, t2, t3;
      t1 = this.that_2;
      t2 = this.key_0;
      t1.game.get$cache().decodedSound$2(t2, buffer);
      t3 = this.sound_1;
      if (t3 != null)
        t1.onSoundDecode.dispatch$1([t2, t3]);
    }, "call$1", null, 2, 0, 102, 886, [], "call"]
  },
  Canvas: {
    "^": "Object;",
    getSmoothingEnabled$1: [function(context) {
      var t1 = J.getInterceptor$asx(context);
      return t1.$index(context, "imageSmoothingEnabled") === true || t1.$index(context, "mozImageSmoothingEnabled") === true || t1.$index(context, "oImageSmoothingEnabled") === true || t1.$index(context, "webkitImageSmoothingEnabled") === true || t1.$index(context, "msImageSmoothingEnabled") === true;
    }, "call$1", "get$getSmoothingEnabled", 2, 0, 665, 142, [], "getSmoothingEnabled"],
    static: {Canvas$: [function() {
        return new R.Canvas();
      }, null, null, 0, 0, 472, "new Canvas"], Canvas_create: [function(width, height, id) {
        var canvas, t1;
        canvas = W.CanvasElement_CanvasElement(null, null);
        if (id != null) {
          canvas.toString;
          canvas.setAttribute("data-" + H.S(new W._DataAttributeMap(new W._ElementAttributeMap(canvas))._toHyphenedName$1("id")), id);
        }
        t1 = J.getInterceptor$x(canvas);
        t1.set$width(canvas, J.toInt$0$n(width));
        t1.set$height(canvas, J.toInt$0$n(height));
        J.set$display$x(canvas.style, "block");
        return canvas;
      }, function(width) {
        return R.Canvas_create(width, 256, null);
      }, null, function(width, height) {
        return R.Canvas_create(width, height, null);
      }, null, function() {
        return R.Canvas_create(256, 256, null);
      }, null, "call$3", "call$1", "call$2", "call$0", "Canvas_create$closure", 0, 6, 473, 342, 342, 12, 31, [], 52, [], 221, [], "create"], Canvas_getOffset: [function(element, point) {
        var box, clientTop, clientLeft, scrollTop, scrollLeft, point0, t1, exception;
        if (point == null) {
          point0 = new R.Point(null, null);
          point0.x = 0;
          point0.y = 0;
          point = point0;
        }
        t1 = J.getInterceptor$x(element);
        box = t1.getBoundingClientRect$0(element);
        clientTop = t1.get$clientTop(element);
        clientLeft = t1.get$clientLeft(element);
        scrollTop = 0;
        scrollLeft = 0;
        scrollTop = window.pageYOffset;
        scrollLeft = window.pageXOffset;
        try {
          J.set$x$x(point, J.$sub$n(J.$add$ns(J.get$left$x(box), scrollLeft), clientLeft));
          J.set$y$x(point, J.$sub$n(J.$add$ns(J.get$top$x(box), scrollTop), clientTop));
        } catch (exception) {
          H.unwrapException(exception);
          J.set$x$x(point, J.$sub$n(scrollLeft, clientLeft));
          J.set$y$x(point, J.$sub$n(scrollTop, clientTop));
        }

        return point;
      }, function(element) {
        return R.Canvas_getOffset(element, null);
      }, null, "call$2", "call$1", "Canvas_getOffset$closure", 2, 2, 474, 12, 23, [], 475, [], "getOffset"], Canvas_getAspectRatio: [function(canvas) {
        var t1 = J.getInterceptor$x(canvas);
        return J.$div$n(t1.get$width(canvas), t1.get$height(canvas));
      }, "call$1", "Canvas_getAspectRatio$closure", 2, 0, 476, 154, [], "getAspectRatio"], Canvas_setBackgroundColor: [function(canvas, color) {
        J.set$backgroundColor$x(J.get$style$x(canvas), color);
        return canvas;
      }, function(canvas) {
        return R.Canvas_setBackgroundColor(canvas, "rgb(0,0,0)");
      }, null, "call$2", "call$1", "Canvas_setBackgroundColor$closure", 2, 2, 477, 478, 154, [], 152, [], "setBackgroundColor"], Canvas_setTouchAction: [function(canvas, value) {
        J.set$touchAction$x(J.get$style$x(canvas), value);
        return canvas;
      }, function(canvas) {
        return R.Canvas_setTouchAction(canvas, "none");
      }, null, "call$2", "call$1", "Canvas_setTouchAction$closure", 2, 2, 477, 479, 154, [], 138, [], "setTouchAction"], Canvas_setUserSelect: [function(canvas, value) {
        var t1 = J.getInterceptor$x(canvas);
        J.set$userSelect$x(t1.get$style(canvas), value);
        J.set$tapHighlightColor$x(t1.get$style(canvas), "rgba(0, 0, 0, 0)");
        return canvas;
      }, function(canvas) {
        return R.Canvas_setUserSelect(canvas, "none");
      }, null, "call$2", "call$1", "Canvas_setUserSelect$closure", 2, 2, 477, 479, 154, [], 138, [], "setUserSelect"], Canvas_addToDOM: [function(canvas, $parent, overflowHidden) {
        var target;
        if ($parent != null)
          if (typeof $parent === "string")
            target = document.getElementById($parent);
          else
            target = !!J.getInterceptor($parent).$isHtmlElement ? $parent : null;
        else
          target = null;
        if (target == null)
          target = document.body;
        if (overflowHidden === true)
          J.set$overflow$x(J.get$style$x(target), "hidden");
        J.append$1$x(target, canvas);
        return canvas;
      }, function(canvas) {
        return R.Canvas_addToDOM(canvas, null, true);
      }, null, function(canvas, parent) {
        return R.Canvas_addToDOM(canvas, parent, true);
      }, null, "call$3", "call$1", "call$2", "Canvas_addToDOM$closure", 2, 4, 480, 12, 78, 154, [], 84, [], 481, [], "addToDOM"], Canvas_setTransform: [function(context, translateX, translateY, scaleX, scaleY, skewX, skewY) {
        J.setTransform$6$x(context, scaleX, skewX, skewY, scaleY, translateX, translateY);
        return context;
      }, "call$7", "Canvas_setTransform$closure", 14, 0, 482, 142, [], 483, [], 484, [], 485, [], 486, [], 487, [], 488, [], "setTransform"], Canvas_setSmoothingEnabled: [function(context, value) {
        J.set$imageSmoothingEnabled$x(context, value);
        return context;
      }, function(context) {
        return R.Canvas_setSmoothingEnabled(context, false);
      }, null, "call$2", "call$1", "Canvas_setSmoothingEnabled$closure", 2, 2, 489, 19, 142, [], 138, [], "setSmoothingEnabled"], Canvas_setImageRenderingCrisp: [function(canvas) {
        J.set$imageRendering$x(J.get$style$x(canvas), "optimize-contrast");
        return canvas;
      }, "call$1", "Canvas_setImageRenderingCrisp$closure", 2, 0, 490, 154, [], "setImageRenderingCrisp"], Canvas_setImageRenderingBicubic: [function(canvas) {
        J.set$imageRendering$x(J.get$style$x(canvas), "auto");
        return canvas;
      }, "call$1", "Canvas_setImageRenderingBicubic$closure", 2, 0, 490, 154, [], "setImageRenderingBicubic"], Canvas_removeFromDOM: [function(canvas) {
        J.remove$0$ax(canvas);
      }, "call$1", "Canvas_removeFromDOM$closure", 2, 0, 491, 154, [], "removeFromDOM"]}
  },
  "+Canvas": [674],
  Device: {
    "^": "Object;game@-613,desktop@-617,iOS@-617,cocoonJS@-617,ejecta@-617,crosswalk@-617,android@-617,chromeOS@-617,linux@-617,macOS@-617,windows@-617,windowsPhone@-617,canvas*-617,file@-617,fileSystem@-617,localStorage*-617,webGL@-617,worker@-617,touch@-617,mspointer@-617,css3D@-617,pointerLock@-617,typedArray@-617,vibration@-617,getUserMedia*-617,quirksMode@-617,arora@-617,chrome@-617,epiphany@-617,firefox@-617,ie@-617,ieVersion@-616,trident@-617,tridentVersion@-616,mobileSafari@-617,midori@-617,opera@-617,safari@-617,webApp@-617,silk@-617,audioData@-617,webAudio@-617,ogg@-617,opus@-617,mp3@-617,wav@-617,m4a@-617,webm@-617,iPhone@-617,iPhone4@-617,iPad@-617,pixelRatio@-671,littleEndian@-617,support32bit@-617,fullscreen@-617,requestFullscreen*-644,cancelFullscreen@-644,fullscreenKeyboard@-617",
    requestFullscreen$0: function($receiver) {
      return this.requestFullscreen.call$0();
    },
    _checkOS$0: [function() {
      var ua, t1;
      ua = window.navigator.userAgent;
      if (J.getInterceptor$asx(ua).contains$1(ua, "Android"))
        this.android = true;
      else if (C.JSString_methods.contains$1(ua, "CrOS"))
        this.chromeOS = true;
      else if (C.JSString_methods.contains$1(ua, "iPad") || C.JSString_methods.contains$1(ua, "iPod") || C.JSString_methods.contains$1(ua, "iPhone"))
        this.iOS = true;
      else if (C.JSString_methods.contains$1(ua, "Linux"))
        this.linux = true;
      else if (C.JSString_methods.contains$1(ua, "Map OS"))
        this.macOS = true;
      else if (C.JSString_methods.contains$1(ua, "Windows")) {
        this.windows = true;
        if (C.JSString_methods.contains$1(ua, "Windows Phone"))
          this.windowsPhone = true;
      }
      if (this.windows !== true)
        if (this.macOS !== true)
          t1 = this.linux === true && J.$eq(this.silk, false);
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        this.desktop = true;
      if (this.windowsPhone !== true)
        t1 = C.JSString_methods.contains$1(ua, "Windows NT") && C.JSString_methods.contains$1(ua, "Touch");
      else
        t1 = true;
      if (t1)
        this.desktop = false;
    }, "call$0", "get$_checkOS", 0, 0, 54, "_checkOS"],
    _checkFeatures$0: [function() {
      var exception, t1;
      this.canvas = J.getContext$1$x(W.CanvasElement_CanvasElement(null, null), "2d") != null || this.cocoonJS === true;
      try {
        this.localStorage = window.localStorage != null;
      } catch (exception) {
        H.unwrapException(exception);
        this.localStorage = false;
      }

      this.webGL = true;
      P.print("check Touch");
      P.print(window.navigator.maxTouchPoints);
      this.touch = true;
      if (window.navigator.maxTouchPoints != null) {
        t1 = window.navigator.maxTouchPoints;
        if (typeof t1 !== "number")
          return t1.$ge();
        t1 = t1 >= 1;
      } else
        t1 = false;
      if (t1)
        this.touch = true;
      this.pointerLock = true;
      this.getUserMedia = true;
    }, "call$0", "get$_checkFeatures", 0, 0, 54, "_checkFeatures"],
    checkFullScreenSupport$0: [function() {
      this.fullscreen = true;
      this.cancelFullscreen = "cancelFullScreen";
      this.fullscreenKeyboard = true;
    }, "call$0", "get$checkFullScreenSupport", 0, 0, 54, "checkFullScreenSupport"],
    _checkBrowser$0: [function() {
      var ua = window.navigator.userAgent;
      if (J.getInterceptor$asx(ua).contains$1(ua, "Arora"))
        this.arora = true;
      else if (C.JSString_methods.contains$1(ua, "Chrome"))
        this.chrome = true;
      else if (C.JSString_methods.contains$1(ua, "Epiphany"))
        this.epiphany = true;
      else if (C.JSString_methods.contains$1(ua, "Firefox"))
        this.firefox = true;
      else if (C.JSString_methods.contains$1(ua, "AppleWebKit") && this.iOS === true)
        this.mobileSafari = true;
      else if (C.JSString_methods.contains$1(ua, "MSIE")) {
        this.ie = true;
        this.ieVersion = 10;
      } else if (C.JSString_methods.contains$1(ua, "Midori"))
        this.midori = true;
      else if (C.JSString_methods.contains$1(ua, "Opera"))
        this.opera = true;
      else if (C.JSString_methods.contains$1(ua, "Safari"))
        this.safari = true;
      else if (C.JSString_methods.contains$1(ua, "Trident")) {
        this.ie = true;
        this.trident = true;
        this.tridentVersion = 10;
        this.ieVersion = 10;
      }
      if (C.JSString_methods.contains$1(ua, "Silk"))
        this.silk = true;
      if (J.contains$1$asx(window.navigator.appVersion, "CocoonJS"))
        this.cocoonJS = true;
      if (C.JSString_methods.contains$1(ua, "Crosswalk"))
        this.crosswalk = true;
    }, "call$0", "get$_checkBrowser", 0, 0, 54, "_checkBrowser"],
    _checkAudio$0: [function() {
      var audio = W.AudioElement_AudioElement(null);
      this.audioData = true;
      this.webAudio = true;
      if (audio.canPlayType("audio/ogg") !== "")
        this.ogg = true;
      if (audio.canPlayType("audio/opus") !== "")
        this.opus = true;
      if (audio.canPlayType("audio/mp3") !== "")
        this.mp3 = true;
      if (audio.canPlayType("audio/wav") !== "")
        this.wav = true;
      if (audio.canPlayType("audio/m4a") !== "")
        this.m4a = true;
      if (audio.canPlayType("audio/webm") !== "")
        this.webm = true;
    }, "call$0", "get$_checkAudio", 0, 0, 54, "_checkAudio"],
    _checkDevice$0: [function() {
      this.pixelRatio = window.devicePixelRatio;
      var t1 = window.navigator.userAgent;
      t1.toString;
      this.iPhone = C.JSString_methods.indexOf$1(t1.toLowerCase(), "iphone") !== -1;
      this.iPhone4 = J.$eq(this.pixelRatio, 2) && this.iPhone === true;
      t1 = window.navigator.userAgent;
      t1.toString;
      this.iPad = C.JSString_methods.indexOf$1(t1.toLowerCase(), "ipad") !== -1;
      this.typedArray = true;
      this.littleEndian = false;
      $.Device_LITTLE_ENDIAN = false;
      this.support32bit = true;
      this.vibration = true;
    }, "call$0", "get$_checkDevice", 0, 0, 54, "_checkDevice"],
    _checkIsLittleEndian$0: [function() {
      return false;
    }, "call$0", "get$_checkIsLittleEndian", 0, 0, 54, "_checkIsLittleEndian"],
    _checkIsUint8ClampedImageData$0: [function() {
      return true;
    }, "call$0", "get$_checkIsUint8ClampedImageData", 0, 0, 54, "_checkIsUint8ClampedImageData"],
    _checkCSS3D$0: [function() {
      return true;
    }, "call$0", "get$_checkCSS3D", 0, 0, 54, "_checkCSS3D"],
    canPlayAudio$1: [function(type) {
      var t1, t2;
      t1 = J.getInterceptor(type);
      if (t1.$eq(type, "mp3") && this.mp3 === true)
        return true;
      else {
        if (t1.$eq(type, "ogg"))
          t2 = this.ogg === true || this.opus === true;
        else
          t2 = false;
        if (t2)
          return true;
        else if (t1.$eq(type, "m4a") && this.m4a === true)
          return true;
        else if (t1.$eq(type, "wav") && this.wav === true)
          return true;
        else if (t1.$eq(type, "webm") && this.webm === true)
          return true;
      }
      return false;
    }, "call$1", "get$canPlayAudio", 2, 0, 1413, 137, [], "canPlayAudio"],
    isConsoleOpen$0: [function() {
      return false;
    }, "call$0", "get$isConsoleOpen", 0, 0, 54, "isConsoleOpen"],
    Device$1: function(game) {
      var ua, t1, audio;
      this.desktop = false;
      this.iOS = false;
      this.cocoonJS = false;
      this.ejecta = false;
      this.crosswalk = false;
      this.android = false;
      this.chromeOS = false;
      this.linux = false;
      this.macOS = false;
      this.windows = false;
      this.windowsPhone = false;
      this.canvas = false;
      this.file = false;
      this.fileSystem = false;
      this.localStorage = false;
      this.webGL = false;
      this.worker = false;
      this.touch = false;
      this.mspointer = false;
      this.css3D = false;
      this.pointerLock = false;
      this.typedArray = false;
      this.vibration = false;
      this.getUserMedia = false;
      this.quirksMode = false;
      this.arora = false;
      this.chrome = false;
      this.epiphany = false;
      this.firefox = false;
      this.ie = false;
      this.ieVersion = 0;
      this.trident = false;
      this.tridentVersion = 0;
      this.mobileSafari = false;
      this.midori = false;
      this.opera = false;
      this.safari = false;
      this.webApp = false;
      this.silk = false;
      this.audioData = false;
      this.webAudio = false;
      this.ogg = false;
      this.opus = false;
      this.mp3 = false;
      this.wav = false;
      this.m4a = false;
      this.webm = false;
      this.iPhone = false;
      this.iPhone4 = false;
      this.iPad = false;
      this.pixelRatio = 0;
      this.littleEndian = false;
      this.support32bit = false;
      this.fullscreen = false;
      this.requestFullscreen = "requestFullscreen";
      this.cancelFullscreen = "";
      this.fullscreenKeyboard = false;
      ua = window.navigator.userAgent;
      if (J.getInterceptor$asx(ua).contains$1(ua, "Android"))
        this.android = true;
      else if (C.JSString_methods.contains$1(ua, "CrOS"))
        this.chromeOS = true;
      else if (C.JSString_methods.contains$1(ua, "iPad") || C.JSString_methods.contains$1(ua, "iPod") || C.JSString_methods.contains$1(ua, "iPhone"))
        this.iOS = true;
      else if (C.JSString_methods.contains$1(ua, "Linux"))
        this.linux = true;
      else if (C.JSString_methods.contains$1(ua, "Map OS"))
        this.macOS = true;
      else if (C.JSString_methods.contains$1(ua, "Windows")) {
        this.windows = true;
        if (C.JSString_methods.contains$1(ua, "Windows Phone"))
          this.windowsPhone = true;
      }
      if (this.windows !== true)
        if (this.macOS !== true)
          t1 = this.linux === true && J.$eq(this.silk, false);
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        this.desktop = true;
      if (this.windowsPhone !== true)
        t1 = C.JSString_methods.contains$1(ua, "Windows NT") && C.JSString_methods.contains$1(ua, "Touch");
      else
        t1 = true;
      if (t1)
        this.desktop = false;
      audio = W.AudioElement_AudioElement(null);
      this.audioData = true;
      this.webAudio = true;
      if (audio.canPlayType("audio/ogg") !== "")
        this.ogg = true;
      if (audio.canPlayType("audio/opus") !== "")
        this.opus = true;
      if (audio.canPlayType("audio/mp3") !== "")
        this.mp3 = true;
      if (audio.canPlayType("audio/wav") !== "")
        this.wav = true;
      if (audio.canPlayType("audio/m4a") !== "")
        this.m4a = true;
      if (audio.canPlayType("audio/webm") !== "")
        this.webm = true;
      ua = window.navigator.userAgent;
      if (J.getInterceptor$asx(ua).contains$1(ua, "Arora"))
        this.arora = true;
      else if (C.JSString_methods.contains$1(ua, "Chrome"))
        this.chrome = true;
      else if (C.JSString_methods.contains$1(ua, "Epiphany"))
        this.epiphany = true;
      else if (C.JSString_methods.contains$1(ua, "Firefox"))
        this.firefox = true;
      else if (C.JSString_methods.contains$1(ua, "AppleWebKit") && this.iOS === true)
        this.mobileSafari = true;
      else if (C.JSString_methods.contains$1(ua, "MSIE")) {
        this.ie = true;
        this.ieVersion = 10;
      } else if (C.JSString_methods.contains$1(ua, "Midori"))
        this.midori = true;
      else if (C.JSString_methods.contains$1(ua, "Opera"))
        this.opera = true;
      else if (C.JSString_methods.contains$1(ua, "Safari"))
        this.safari = true;
      else if (C.JSString_methods.contains$1(ua, "Trident")) {
        this.ie = true;
        this.trident = true;
        this.tridentVersion = 10;
        this.ieVersion = 10;
      }
      if (C.JSString_methods.contains$1(ua, "Silk"))
        this.silk = true;
      if (J.contains$1$asx(window.navigator.appVersion, "CocoonJS"))
        this.cocoonJS = true;
      if (C.JSString_methods.contains$1(ua, "Crosswalk"))
        this.crosswalk = true;
      this.pixelRatio = window.devicePixelRatio;
      t1 = window.navigator.userAgent;
      t1.toString;
      this.iPhone = C.JSString_methods.indexOf$1(t1.toLowerCase(), "iphone") !== -1;
      this.iPhone4 = J.$eq(this.pixelRatio, 2) && this.iPhone === true;
      t1 = window.navigator.userAgent;
      t1.toString;
      this.iPad = C.JSString_methods.indexOf$1(t1.toLowerCase(), "ipad") !== -1;
      this.typedArray = true;
      this.littleEndian = false;
      $.Device_LITTLE_ENDIAN = false;
      this.support32bit = true;
      this.vibration = true;
      this._checkFeatures$0();
    },
    static: {"^": "Device_LITTLE_ENDIAN@-617", Device$: [function(game) {
        var t1 = new R.Device(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Device$1(game);
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new Device"]}
  },
  "+Device": [674],
  RequestAnimationFrame: {
    "^": "Object;game@-613,isRunning@-617,forceSetTimeOut@-617,_isSetTimeOut@-617,_onLoop@-0,_timeOutID@-614",
    start$0: [function(_) {
      var t1, t2;
      this.isRunning = true;
      this._isSetTimeOut = false;
      t1 = this.get$updateRAF();
      this._onLoop = t1;
      t2 = window;
      C.Window_methods._ensureRequestAnimationFrame$0(t2);
      this._timeOutID = C.Window_methods._requestAnimationFrame$1(t2, W._wrapZone(t1));
    }, "call$0", "get$start", 0, 0, 54, "start"],
    updateRAF$1: [function(time) {
      var t1, t2;
      this.game.update$1(Date.now());
      t1 = window;
      t2 = this._onLoop;
      C.Window_methods._ensureRequestAnimationFrame$0(t1);
      this._timeOutID = C.Window_methods._requestAnimationFrame$1(t1, W._wrapZone(t2));
    }, "call$1", "get$updateRAF", 2, 0, 1531, 727, [], "updateRAF"],
    stop$0: [function(_) {
      var t1, t2;
      t1 = window;
      t2 = this._timeOutID;
      C.Window_methods._ensureRequestAnimationFrame$0(t1);
      t1.cancelAnimationFrame(t2);
      this.isRunning = false;
    }, "call$0", "get$stop", 0, 0, 54, "stop"],
    isSetTimeOut$0: [function() {
      return this._isSetTimeOut;
    }, "call$0", "get$isSetTimeOut", 0, 0, 54, "isSetTimeOut"],
    isRAF$0: [function() {
      return J.$eq(this._isSetTimeOut, false);
    }, "call$0", "get$isRAF", 0, 0, 54, "isRAF"],
    RequestAnimationFrame$2: function(game, forceSetTimeOut) {
      this.isRunning = false;
      this.forceSetTimeOut = forceSetTimeOut;
      this._isSetTimeOut = false;
      this._onLoop = null;
      this._timeOutID = null;
    },
    static: {RequestAnimationFrame$: [function(game, forceSetTimeOut) {
        var t1 = new R.RequestAnimationFrame(game, null, null, null, null, null);
        t1.RequestAnimationFrame$2(game, forceSetTimeOut);
        return t1;
      }, null, null, 2, 2, 492, 19, 252, [], 493, [], "new RequestAnimationFrame"]}
  },
  "+RequestAnimationFrame": [674],
  Tile0: {
    "^": "Object;layer*-1536,index*-614,x*-616,y*-616,worldX@-616,worldY@-616,width*-616,height*-616,centerX@-616,centerY@-616,alpha*-616,properties@-1537,scanned@-617,faceTop@-617,faceBottom@-617,faceLeft@-617,faceRight@-617,collideLeft@-617,collideRight@-617,collideUp@-617,collideDown@-617,collides@-617,debug@-617,collisionCallback@-0",
    debug$0: function() {
      return this.debug.call$0();
    },
    get$canCollide: [function() {
      return this.collideLeft != null || this.collideRight != null || this.collideUp != null || this.collideDown != null || this.collisionCallback != null;
    }, null, null, 1, 0, 54, "canCollide"],
    get$left: [function(_) {
      return this.worldX;
    }, null, null, 1, 0, 619, "left"],
    get$right: [function(_) {
      return J.$add$ns(this.worldX, this.width);
    }, null, null, 1, 0, 619, "right"],
    get$top: [function(_) {
      return this.worldY;
    }, null, null, 1, 0, 619, "top"],
    get$bottom: [function(_) {
      return J.$add$ns(this.worldY, this.height);
    }, null, null, 1, 0, 619, "bottom"],
    containsPoint$2: [function(_, x, y) {
      var t1, t2;
      t1 = J.getInterceptor$n(x);
      if (!t1.$lt(x, this.worldX)) {
        t2 = J.getInterceptor$n(y);
        t1 = t2.$lt(y, this.worldY) || t1.$gt(x, J.$add$ns(this.worldX, this.width)) || t2.$gt(y, J.$add$ns(this.worldY, this.height));
      } else
        t1 = true;
      return !t1;
    }, "call$2", "get$containsPoint", 4, 0, 668, 9, [], 10, [], "containsPoint"],
    intersects$4: [function(_, x, y, right, bottom) {
      if (J.$le$n(right, this.worldX))
        return false;
      if (J.$le$n(bottom, this.worldY))
        return false;
      if (J.$ge$n(x, J.$add$ns(this.worldX, this.width)))
        return false;
      if (J.$ge$n(y, J.$add$ns(this.worldY, this.height)))
        return false;
      return true;
    }, "call$4", "get$intersects", 8, 0, 350, 9, [], 10, [], 462, [], 1311, [], "intersects"],
    destroy$0: [function() {
      this.collisionCallback = null;
      this.properties = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    setCollision$4: [function(left, right, up, down) {
      this.collideLeft = left;
      this.collideRight = right;
      this.collideUp = up;
      this.collideDown = down;
      this.faceLeft = left;
      this.faceRight = right;
      this.faceTop = up;
      this.faceBottom = down;
    }, "call$4", "get$setCollision", 8, 0, 1538, 198, [], 462, [], 460, [], 461, [], "setCollision"],
    resetCollision$0: [function() {
      this.collideLeft = false;
      this.collideRight = false;
      this.collideUp = false;
      this.collideDown = false;
      this.faceTop = false;
      this.faceBottom = false;
      this.faceLeft = false;
      this.faceRight = false;
    }, "call$0", "get$resetCollision", 0, 0, 54, "resetCollision"],
    isInteresting$2: [function(collides, faces) {
      var t1 = collides === true;
      if (t1 && faces === true)
        return this.collideLeft === true || this.collideRight === true || this.collideUp === true || this.collideDown === true || this.faceTop === true || this.faceBottom === true || this.faceLeft === true || this.faceRight === true || this.collisionCallback != null;
      else if (t1)
        return this.collideLeft === true || this.collideRight === true || this.collideUp === true || this.collideDown === true;
      else if (faces === true)
        return this.faceTop === true || this.faceBottom === true || this.faceLeft === true || this.faceRight === true;
      return false;
    }, "call$2", "get$isInteresting", 4, 0, 1539, 1540, [], 1541, [], "isInteresting"],
    copy$1: [function(tile) {
      var t1 = J.getInterceptor$x(tile);
      this.index = t1.get$index(tile);
      this.alpha = t1.get$alpha(tile);
      this.properties = tile.get$properties();
      this.collideUp = tile.get$collideUp();
      this.collideDown = tile.get$collideDown();
      this.collideLeft = tile.get$collideLeft();
      this.collideRight = tile.get$collideRight();
      this.collisionCallback = tile.get$collisionCallback();
    }, "call$1", "get$copy", 2, 0, 1542, 1543, [], "copy"],
    Tile$6: function(layer, index, x, y, width, height) {
      this.layer = layer;
      this.index = index;
      this.x = x;
      this.y = y;
      this.worldX = J.$mul$ns(x, width);
      this.worldY = J.$mul$ns(y, height);
      this.width = width;
      this.height = height;
      this.centerX = J.abs$0$n(J.$div$n(width, 2));
      this.centerY = J.abs$0$n(J.$div$n(height, 2));
      this.alpha = 1;
      this.properties = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this.scanned = false;
      this.faceTop = false;
      this.faceBottom = false;
      this.faceLeft = false;
      this.faceRight = false;
      this.collideLeft = false;
      this.collideRight = false;
      this.collideUp = false;
      this.collideDown = false;
      this.collisionCallback = null;
    },
    $isTile0: true,
    static: {Tile$0: [function(layer, index, x, y, width, height) {
        var t1 = new R.Tile0(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false, false, null);
        t1.Tile$6(layer, index, x, y, width, height);
        return t1;
      }, null, null, 12, 0, 494, 495, [], 281, [], 9, [], 10, [], 31, [], 52, [], "new Tile"]}
  },
  "+Tile": [674],
  TilemapData: {
    "^": "Object;name*-644,width*-616,height*-616,tileWidth@-616,tileHeight@-616,orientation*-644,objects@-1544,collision@-1544,images@-1545,format*-616,version*-614,properties@-783,widthInPixels@-616,heightInPixels@-616,layers@-1546,tilesets@-1547,tiles@-1548",
    static: {TilemapData$: [function() {
        return new R.TilemapData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 496, "new TilemapData"]}
  },
  "+TilemapData": [674],
  Tilemap: {
    "^": "Object;game@-613,key*-644,width*-616,height*-616,tileWidth@-616,tileHeight@-616,orientation*-644,format*-616,version*-616,properties@-783,widthInPixels@-616,heightInPixels@-616,layers@-1546,tilesets@-1547,tiles@-1548,objects@-1544,collision@-1544,collideIndexes@-745,images@-1545,currentLayer@-614,debugMap@-1549,_results@-645,_tempA@-616,_tempB@-616,preventingRecalculate@-617,needToRecalculate@-783,data*-645",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    get$layer: [function(_) {
      return this.getLayer$0();
    }, null, null, 1, 0, 412, "layer"],
    set$layer: [function(_, value) {
      var layer;
      if (!J.$eq(value, this.currentLayer)) {
        layer = this.getLayer$1(value);
        if (J.$index$asx(this.layers, layer) != null)
          this.currentLayer = layer;
      }
    }, null, null, 3, 0, 99, 138, [], "layer"],
    create$6: [function($name, width, height, tileWidth, tileHeight, group) {
      if (group == null)
        group = this.game.get$world();
      this.width = width;
      this.height = height;
      this.tileWidth = tileWidth;
      this.tileHeight = tileHeight;
      this.widthInPixels = J.$mul$ns(width, tileWidth);
      this.heightInPixels = J.$mul$ns(this.height, tileHeight);
      J.set$length$asx(this.layers, 0);
      return this.createBlankLayer$6($name, width, height, tileWidth, tileHeight, group);
    }, function(name, width, height, tileWidth, tileHeight) {
      return this.create$6(name, width, height, tileWidth, tileHeight, null);
    }, "create$5", "call$6", "call$5", "get$create", 10, 2, 1550, 12, 83, [], 31, [], 52, [], 498, [], 499, [], 297, [], "create"],
    setTileSize$2: [function(tileWidth, tileHeight) {
      this.tileWidth = tileWidth;
      this.tileHeight = tileHeight;
      this.widthInPixels = J.$mul$ns(this.width, tileWidth);
      this.heightInPixels = J.$mul$ns(this.height, tileHeight);
    }, "call$2", "get$setTileSize", 4, 0, 149, 498, [], 499, [], "setTileSize"],
    addTilesetImage$7: [function(tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {
      var t1, newSet, i, t2, t3, t, y, x, count, countX, countY, t4, t5, t6;
      if (tileWidth == null)
        tileWidth = this.tileWidth;
      if (tileHeight == null)
        tileHeight = this.tileHeight;
      if (tileMargin == null)
        tileMargin = 0;
      if (tileSpacing == null)
        tileSpacing = 0;
      if (gid == null)
        gid = 0;
      if (J.$eq(tileWidth, 0))
        tileWidth = 32;
      if (J.$eq(tileHeight, 0))
        tileHeight = 32;
      if (key == null) {
        if (typeof tileset === "string")
          this.game.get$cache().checkImageKey$1(tileset);
        else
          return;
        key = tileset;
      }
      if (typeof tileset === "string") {
        tileset = this.getIndex$2(this.tilesets, tileset);
        if (tileset == null && J.$eq(this.format, 1)) {
          window;
          t1 = C.JSString_methods.$add("Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: \"", key) + "\"";
          if (typeof console != "undefined")
            console.warn(t1);
          return;
        }
      }
      if (tileset != null && J.$index$asx(this.tilesets, tileset) != null) {
        J.$index$asx(this.tilesets, tileset).setImage$1(this.game.get$cache().getImage$1(key));
        return J.$index$asx(this.tilesets, tileset);
      } else {
        newSet = R.Tileset$(key, gid, tileWidth, tileHeight, tileMargin, tileSpacing, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        newSet.setImage$1(this.game.get$cache().getImage$1(key));
        J.add$1$ax(this.tilesets, newSet);
        i = J.$sub$n(J.get$length$asx(this.tilesets), 1);
        for (t1 = J.getInterceptor$ns(gid), t2 = J.getInterceptor$ns(tileWidth), t3 = J.getInterceptor$ns(tileHeight), t = gid, y = tileMargin, x = y, count = 0, countX = 0, countY = 0; t4 = J.getInterceptor$n(t), t4.$lt(t, t1.$add(gid, newSet.total)); t = t4.$add(t, 1)) {
          t5 = J.$gt$n(J.get$length$asx(this.tiles), t);
          t6 = this.tiles;
          if (t5)
            J.$indexSet$ax(t6, t, [x, y, i]);
          else
            J.add$1$ax(t6, [x, y, i]);
          x = J.$add$ns(x, t2.$add(tileWidth, tileSpacing));
          ++count;
          if (count === newSet.total)
            break;
          ++countX;
          if (countX === newSet.columns) {
            y = J.$add$ns(y, t3.$add(tileHeight, tileSpacing));
            ++countY;
            if (countY === newSet.rows)
              break;
            x = tileMargin;
            countX = 0;
          }
        }
        return newSet;
      }
    }, function(tileset) {
      return this.addTilesetImage$7(tileset, null, null, null, null, null, null);
    }, "addTilesetImage$1", function(tileset, key) {
      return this.addTilesetImage$7(tileset, key, null, null, null, null, null);
    }, "addTilesetImage$2", function(tileset, key, tileWidth) {
      return this.addTilesetImage$7(tileset, key, tileWidth, null, null, null, null);
    }, "addTilesetImage$3", function(tileset, key, tileWidth, tileHeight) {
      return this.addTilesetImage$7(tileset, key, tileWidth, tileHeight, null, null, null);
    }, "addTilesetImage$4", function(tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing) {
      return this.addTilesetImage$7(tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing, null);
    }, "addTilesetImage$6", function(tileset, key, tileWidth, tileHeight, tileMargin) {
      return this.addTilesetImage$7(tileset, key, tileWidth, tileHeight, tileMargin, null, null);
    }, "addTilesetImage$5", "call$7", "call$1", "call$2", "call$3", "call$4", "call$6", "call$5", "get$addTilesetImage", 2, 12, 1551, 12, 12, 12, 12, 12, 12, 1552, [], 269, [], 498, [], 499, [], 1553, [], 1554, [], 1555, [], "addTilesetImage"],
    createFromObjects$9: [function($name, gid, key, frame, exists, autoCull, group, CustomClass, adjustY) {
      var t1, len, sprite, i;
      if (exists == null)
        ;
      if (autoCull == null)
        ;
      if (group == null)
        this.game.get$world();
      if (CustomClass == null)
        ;
      if (adjustY == null)
        ;
      if (J.$index$asx(this.objects, $name) == null) {
        window;
        t1 = C.JSString_methods.$add("Tilemap.createFromObjects: Invalid objectgroup name given: ", $name);
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      len = J.get$length$asx(J.$index$asx(this.objects, $name));
      if (typeof len !== "number")
        return H.iae(len);
      sprite = null;
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(J.$index$asx(this.objects, $name), i).get$gid();
    }, function(name, gid, key) {
      return this.createFromObjects$9(name, gid, key, null, null, null, null, null, null);
    }, "createFromObjects$3", function(name, gid, key, frame) {
      return this.createFromObjects$9(name, gid, key, frame, null, null, null, null, null);
    }, "createFromObjects$4", function(name, gid, key, frame, exists, autoCull) {
      return this.createFromObjects$9(name, gid, key, frame, exists, autoCull, null, null, null);
    }, "createFromObjects$6", function(name, gid, key, frame, exists) {
      return this.createFromObjects$9(name, gid, key, frame, exists, null, null, null, null);
    }, "createFromObjects$5", function(name, gid, key, frame, exists, autoCull, group) {
      return this.createFromObjects$9(name, gid, key, frame, exists, autoCull, group, null, null);
    }, "createFromObjects$7", function(name, gid, key, frame, exists, autoCull, group, CustomClass) {
      return this.createFromObjects$9(name, gid, key, frame, exists, autoCull, group, CustomClass, null);
    }, "createFromObjects$8", "call$9", "call$3", "call$4", "call$6", "call$5", "call$7", "call$8", "get$createFromObjects", 6, 12, 1556, 12, 12, 12, 12, 12, 12, 83, [], 1555, [], 269, [], 216, [], 1053, [], 1557, [], 297, [], 1558, [], 1559, [], "createFromObjects"],
    createLayer$4: [function(layer, width, height, group) {
      var index, t1;
      if (width == null)
        width = J.get$width$x(this.game);
      if (height == null)
        height = J.get$height$x(this.game);
      if (group == null)
        group = this.game.get$world();
      index = typeof layer === "string" ? this.getIndex$2(this.layers, layer) : layer;
      if (index == null || J.$gt$n(index, J.get$length$asx(this.layers))) {
        window;
        t1 = C.JSString_methods.$add("Tilemap.createLayer: Invalid layer ID given: ", index);
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      return J.add$1$ax(group, R.TilemapLayer$(this.game, this, index, width, height));
    }, function(layer) {
      return this.createLayer$4(layer, null, null, null);
    }, "createLayer$1", function(layer, width) {
      return this.createLayer$4(layer, width, null, null);
    }, "createLayer$2", function(layer, width, height) {
      return this.createLayer$4(layer, width, height, null);
    }, "createLayer$3", "call$4", "call$1", "call$2", "call$3", "get$createLayer", 2, 6, 1560, 12, 12, 12, 495, [], 31, [], 52, [], 297, [], "createLayer"],
    createBlankLayer$6: [function($name, width, height, tileWidth, tileHeight, group) {
      var layer, output, y, row, x, w, h, outputLayer;
      if (group == null)
        group = this.game.get$world();
      if (this.getIndex$2(this.layers, $name) != null) {
        window;
        if (typeof console != "undefined")
          console.warn("Tilemap.createBlankLayer: Layer with matching name already exists");
        return;
      }
      layer = new R.TilemapLayerData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);
      layer.name = $name;
      layer.x = 0;
      layer.y = 0;
      layer.width = width;
      layer.height = height;
      layer.widthInPixels = J.$mul$ns(width, tileWidth);
      layer.heightInPixels = J.$mul$ns(height, tileHeight);
      layer.alpha = 1;
      layer.visible = true;
      layer.properties = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      layer.indexes = [];
      layer.callbacks = [];
      layer.bodies = [];
      layer.data = null;
      output = [];
      if (typeof height !== "number")
        return H.iae(height);
      y = 0;
      for (; y < height; ++y) {
        row = [];
        if (typeof width !== "number")
          return H.iae(width);
        x = 0;
        for (; x < width; ++x)
          row.push(R.Tile$0(layer, -1, x, y, tileWidth, tileHeight));
        output.push(row);
      }
      layer.data = output;
      J.add$1$ax(this.layers, layer);
      this.currentLayer = J.$sub$n(J.get$length$asx(this.layers), 1);
      w = layer.widthInPixels;
      h = layer.heightInPixels;
      if (J.$gt$n(w, J.get$width$x(this.game)))
        w = J.get$width$x(this.game);
      if (J.$gt$n(h, J.get$height$x(this.game)))
        h = J.get$height$x(this.game);
      outputLayer = R.TilemapLayer$(this.game, this, J.$sub$n(J.get$length$asx(this.layers), 1), w, h);
      outputLayer.Phaser$TilemapLayer$name = $name;
      return J.add$1$ax(group, outputLayer);
    }, function(name, width, height, tileWidth, tileHeight) {
      return this.createBlankLayer$6(name, width, height, tileWidth, tileHeight, null);
    }, "createBlankLayer$5", "call$6", "call$5", "get$createBlankLayer", 10, 2, 1550, 12, 83, [], 31, [], 52, [], 498, [], 499, [], 297, [], "createBlankLayer"],
    getIndex$2: [function($location, $name) {
      var t1, i, t2;
      t1 = J.getInterceptor$asx($location);
      i = 0;
      while (true) {
        t2 = t1.get$length($location);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        if (J.$eq(J.get$name$x(t1.$index($location, i)), $name))
          return i;
        ++i;
      }
      return;
    }, "call$2", "get$getIndex", 4, 0, 1561, 33, [], 83, [], "getIndex"],
    getLayerIndex$1: [function($name) {
      return this.getIndex$2(this.layers, $name);
    }, "call$1", "get$getLayerIndex", 2, 0, 557, 83, [], "getLayerIndex"],
    getTilesetIndex$1: [function($name) {
      return this.getIndex$2(this.tilesets, $name);
    }, "call$1", "get$getTilesetIndex", 2, 0, 557, 83, [], "getTilesetIndex"],
    getImageIndex$1: [function($name) {
      return this.getIndex$2(this.images, $name);
    }, "call$1", "get$getImageIndex", 2, 0, 557, 83, [], "getImageIndex"],
    getObjectIndex$1: [function($name) {
      return this.getIndex$2(J.get$values$x(this.objects), $name);
    }, "call$1", "get$getObjectIndex", 2, 0, 557, 83, [], "getObjectIndex"],
    setTileIndexCallback$3: [function(indexes, callback, layer) {
      var t1, len, i;
      layer = this.getLayer$1(layer);
      if (typeof indexes === "number" && Math.floor(indexes) === indexes)
        J.$indexSet$ax(J.$index$asx(this.layers, layer).get$callbacks(), indexes, callback);
      else {
        t1 = J.getInterceptor$asx(indexes);
        len = t1.get$length(indexes);
        if (typeof len !== "number")
          return H.iae(len);
        i = 0;
        for (; i < len; ++i)
          J.$indexSet$ax(J.$index$asx(this.layers, layer).get$callbacks(), t1.$index(indexes, i), callback);
      }
    }, function(indexes, callback) {
      return this.setTileIndexCallback$3(indexes, callback, null);
    }, "setTileIndexCallback$2", "call$3", "call$2", "get$setTileIndexCallback", 4, 2, 1562, 12, 1563, [], 26, [], 495, [], "setTileIndexCallback"],
    setTileLocationCallback$6: [function(x, y, width, height, callback, layer) {
      var i, t1;
      this.copy$5(x, y, width, height, this.getLayer$1(layer));
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      i = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$index$asx(this._results, i).setCollisionCallback$1(callback);
        ++i;
      }
    }, function(x, y, width, height, callback) {
      return this.setTileLocationCallback$6(x, y, width, height, callback, null);
    }, "setTileLocationCallback$5", "call$6", "call$5", "get$setTileLocationCallback", 10, 2, 1564, 12, 9, [], 10, [], 31, [], 52, [], 26, [], 495, [], "setTileLocationCallback"],
    setCollision$4: [function(indexes, collides, layer, recalculate) {
      var t1, len, i;
      if (collides == null)
        collides = true;
      if (recalculate == null)
        recalculate = true;
      layer = this.getLayer$1(layer);
      if (typeof indexes === "number" && Math.floor(indexes) === indexes)
        return this.setCollisionByIndex$4(indexes, collides, layer, true);
      else {
        t1 = J.getInterceptor$asx(indexes);
        len = t1.get$length(indexes);
        if (typeof len !== "number")
          return H.iae(len);
        i = 0;
        for (; i < len; ++i)
          this.setCollisionByIndex$4(t1.$index(indexes, i), collides, layer, false);
        if (recalculate === true)
          this.calculateFaces$1(layer);
      }
    }, function(indexes) {
      return this.setCollision$4(indexes, true, null, true);
    }, "setCollision$1", function(indexes, collides) {
      return this.setCollision$4(indexes, collides, null, true);
    }, "setCollision$2", function(indexes, collides, layer) {
      return this.setCollision$4(indexes, collides, layer, true);
    }, "setCollision$3", "call$4", "call$1", "call$2", "call$3", "get$setCollision", 2, 6, 1565, 78, 12, 78, 1563, [], 1540, [], 495, [], 1566, [], "setCollision"],
    setCollisionBetween$5: [function(start, $stop, collides, layer, recalculate) {
      var index, t1;
      if (collides == null)
        collides = true;
      if (recalculate == null)
        recalculate = true;
      layer = this.getLayer$1(layer);
      if (J.$gt$n(start, $stop))
        return;
      for (index = start; t1 = J.getInterceptor$n(index), t1.$le(index, $stop); index = t1.$add(index, 1))
        this.setCollisionByIndex$4(index, collides, layer, false);
      if (recalculate === true)
        this.calculateFaces$1(layer);
    }, function(start, stop) {
      return this.setCollisionBetween$5(start, stop, true, null, true);
    }, "setCollisionBetween$2", function(start, stop, collides) {
      return this.setCollisionBetween$5(start, stop, collides, null, true);
    }, "setCollisionBetween$3", function(start, stop, collides, layer) {
      return this.setCollisionBetween$5(start, stop, collides, layer, true);
    }, "setCollisionBetween$4", "call$5", "call$2", "call$3", "call$4", "get$setCollisionBetween", 4, 6, 1567, 78, 12, 78, 261, [], 262, [], 1540, [], 495, [], 1566, [], "setCollisionBetween"],
    setCollisionByExclusion$4: [function(indexes, collides, layer, recalculate) {
      var len, t1, i;
      if (collides == null)
        collides = true;
      if (recalculate == null)
        recalculate = true;
      layer = this.getLayer$1(layer);
      len = J.get$length$asx(this.tiles);
      if (typeof len !== "number")
        return H.iae(len);
      t1 = J.getInterceptor$asx(indexes);
      i = 0;
      for (; i < len; ++i)
        if (J.$eq(t1.indexOf$1(indexes, i), -1))
          this.setCollisionByIndex$4(i, collides, layer, false);
      if (recalculate === true)
        this.calculateFaces$1(layer);
    }, function(indexes) {
      return this.setCollisionByExclusion$4(indexes, null, null, null);
    }, "setCollisionByExclusion$1", function(indexes, collides) {
      return this.setCollisionByExclusion$4(indexes, collides, null, null);
    }, "setCollisionByExclusion$2", function(indexes, collides, layer) {
      return this.setCollisionByExclusion$4(indexes, collides, layer, null);
    }, "setCollisionByExclusion$3", "call$4", "call$1", "call$2", "call$3", "get$setCollisionByExclusion", 2, 6, 1568, 12, 12, 12, 1563, [], 1540, [], 495, [], 1566, [], "setCollisionByExclusion"],
    setCollisionByIndex$4: [function(index, collides, layer, recalculate) {
      var t1, t2, i, y, x, tile;
      if (layer == null)
        layer = this.currentLayer;
      if (collides == null)
        collides = true;
      if (recalculate == null)
        recalculate = true;
      t1 = collides === true;
      t2 = this.collideIndexes;
      if (t1)
        J.add$1$ax(t2, index);
      else {
        i = J.indexOf$1$asx(t2, index);
        if (J.$gt$n(i, -1))
          J.removeAt$1$ax(this.collideIndexes, i);
      }
      y = 0;
      while (true) {
        t2 = J.get$height$x(J.$index$asx(this.layers, layer));
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(y < t2))
          break;
        x = 0;
        while (true) {
          t2 = J.get$width$x(J.$index$asx(this.layers, layer));
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(x < t2))
            break;
          tile = J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
          if (tile != null && J.$eq(J.get$index$x(tile), index)) {
            if (t1)
              tile.setCollision$4(true, true, true, true);
            else
              tile.resetCollision$0();
            tile.set$faceTop(collides);
            tile.set$faceBottom(collides);
            tile.set$faceLeft(collides);
            tile.set$faceRight(collides);
          }
          ++x;
        }
        ++y;
      }
      if (recalculate === true)
        this.calculateFaces$1(layer);
      return layer;
    }, function(index) {
      return this.setCollisionByIndex$4(index, null, null, null);
    }, "setCollisionByIndex$1", function(index, collides) {
      return this.setCollisionByIndex$4(index, collides, null, null);
    }, "setCollisionByIndex$2", function(index, collides, layer) {
      return this.setCollisionByIndex$4(index, collides, layer, null);
    }, "setCollisionByIndex$3", "call$4", "call$1", "call$2", "call$3", "get$setCollisionByIndex", 2, 6, 1569, 12, 12, 12, 281, [], 1540, [], 495, [], 1566, [], "setCollisionByIndex"],
    getLayer$1: [function(layer) {
      if (layer == null)
        layer = this.currentLayer;
      else if (typeof layer === "string")
        layer = this.getIndex$2(this.layers, layer);
      else if (!!J.getInterceptor(layer).$isTilemapLayer)
        layer = layer.index;
      return layer;
    }, function() {
      return this.getLayer$1(null);
    }, "getLayer$0", "call$1", "call$0", "get$getLayer", 0, 2, 1570, 12, 495, [], "getLayer"],
    setPreventRecalculate$1: [function(value) {
      var t1 = J.getInterceptor(value);
      if (t1.$eq(value, true) && !J.$eq(this.preventingRecalculate, true)) {
        this.preventingRecalculate = true;
        this.needToRecalculate = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      }
      if (t1.$eq(value, false) && J.$eq(this.preventingRecalculate, true)) {
        this.preventingRecalculate = false;
        for (t1 = J.get$iterator$ax(J.get$keys$x(this.needToRecalculate)); t1.moveNext$0();)
          this.calculateFaces$1(t1.get$current());
        J.clear$0$ax(this.needToRecalculate);
      }
    }, "call$1", "get$setPreventRecalculate", 2, 0, 639, 138, [], "setPreventRecalculate"],
    calculateFaces$1: [function(layer) {
      var h, above, below, left, right, y, w, x, tile;
      if (this.preventingRecalculate === true) {
        J.$indexSet$ax(this.needToRecalculate, layer, true);
        return;
      }
      h = J.get$height$x(J.$index$asx(this.layers, layer));
      if (typeof h !== "number")
        return H.iae(h);
      above = null;
      below = null;
      left = null;
      right = null;
      y = 0;
      for (; y < h; ++y) {
        w = J.get$width$x(J.$index$asx(this.layers, layer));
        if (typeof w !== "number")
          return H.iae(w);
        x = 0;
        for (; x < w; ++x) {
          tile = J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
          if (tile != null) {
            above = this.getTileAbove$3(layer, x, y);
            below = this.getTileBelow$3(layer, x, y);
            left = this.getTileLeft$3(layer, x, y);
            right = this.getTileRight$3(layer, x, y);
            if (tile.get$collides() != null) {
              tile.set$faceTop(true);
              tile.set$faceBottom(true);
              tile.set$faceLeft(true);
              tile.set$faceRight(true);
            }
            if (above != null && above.get$collides() === true)
              tile.set$faceTop(false);
            if (below != null && below.get$collides() === true)
              tile.set$faceBottom(false);
            if (left != null && left.get$collides() === true)
              tile.set$faceLeft(false);
            if (right != null && right.get$collides() === true)
              tile.set$faceRight(false);
          }
        }
      }
    }, "call$1", "get$calculateFaces", 2, 0, 99, 495, [], "calculateFaces"],
    getTileAbove$3: [function(layer, x, y) {
      var t1 = J.getInterceptor$n(y);
      if (t1.$gt(y, 0))
        return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), t1.$sub(y, 1)), x);
      return;
    }, "call$3", "get$getTileAbove", 6, 0, 1571, 495, [], 9, [], 10, [], "getTileAbove"],
    getTileBelow$3: [function(layer, x, y) {
      var t1 = J.getInterceptor$n(y);
      if (t1.$lt(y, J.$sub$n(J.get$height$x(J.$index$asx(this.layers, layer)), 1)))
        return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), t1.$add(y, 1)), x);
      return;
    }, "call$3", "get$getTileBelow", 6, 0, 1571, 495, [], 9, [], 10, [], "getTileBelow"],
    getTileLeft$3: [function(layer, x, y) {
      var t1 = J.getInterceptor$n(x);
      if (t1.$gt(x, 0))
        return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), t1.$sub(x, 1));
      return;
    }, "call$3", "get$getTileLeft", 6, 0, 1571, 495, [], 9, [], 10, [], "getTileLeft"],
    getTileRight$3: [function(layer, x, y) {
      var t1 = J.getInterceptor$n(x);
      if (t1.$lt(x, J.$sub$n(J.get$width$x(J.$index$asx(this.layers, layer)), 1)))
        return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), t1.$add(x, 1));
      return;
    }, "call$3", "get$getTileRight", 6, 0, 1571, 495, [], 9, [], 10, [], "getTileRight"],
    setLayer$1: [function(layer) {
      layer = this.getLayer$1(layer);
      if (J.$index$asx(this.layers, layer) != null)
        this.currentLayer = layer;
    }, "call$1", "get$setLayer", 2, 0, 102, 495, [], "setLayer"],
    hasTile$3: [function(x, y, layer) {
      layer = this.getLayer$1(layer);
      return J.$gt$n(J.get$index$x(J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x)), -1);
    }, "call$3", "get$hasTile", 6, 0, 1572, 9, [], 10, [], 495, [], "hasTile"],
    removeTile$3: [function(x, y, layer) {
      var t1, tile;
      layer = this.getLayer$1(layer);
      t1 = J.getInterceptor$n(x);
      if (t1.$ge(x, 0))
        if (t1.$lt(x, J.get$width$x(J.$index$asx(this.layers, layer)))) {
          t1 = J.getInterceptor$n(y);
          t1 = t1.$ge(y, 0) && t1.$lt(y, J.get$height$x(J.$index$asx(this.layers, layer)));
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        if (this.hasTile$3(x, y, layer)) {
          tile = J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
          J.$indexSet$ax(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x, R.Tile$0(J.$index$asx(this.layers, layer), -1, x, y, this.tileWidth, this.tileHeight));
          J.$index$asx(this.layers, layer).set$dirty(true);
          this.calculateFaces$1(layer);
          return tile;
        }
      return;
    }, "call$3", "get$removeTile", 6, 0, 1573, 9, [], 10, [], 495, [], "removeTile"],
    removeTileWorldXY$5: [function(x, y, tileWidth, tileHeight, layer) {
      layer = this.getLayer$1(layer);
      return this.removeTile$3(J.$div$n(R.Math_snapToFloor(x, tileWidth, 0), tileWidth), J.$div$n(R.Math_snapToFloor(y, tileHeight, 0), tileHeight), layer);
    }, "call$5", "get$removeTileWorldXY", 10, 0, 1574, 9, [], 10, [], 498, [], 499, [], 495, [], "removeTileWorldXY"],
    putTile$4: [function(tile, x, y, layer) {
      var t1, index, t2;
      if (tile == null)
        return this.removeTile$3(x, y, layer);
      layer = this.getLayer$1(layer);
      t1 = J.getInterceptor$n(x);
      if (t1.$ge(x, 0))
        if (t1.$lt(x, J.get$width$x(J.$index$asx(this.layers, layer)))) {
          t1 = J.getInterceptor$n(y);
          t1 = t1.$ge(y, 0) && t1.$lt(y, J.get$height$x(J.$index$asx(this.layers, layer)));
        } else
          t1 = false;
      else
        t1 = false;
      if (t1) {
        if (!!J.getInterceptor(tile).$isTile0) {
          index = tile.index;
          t1 = this.hasTile$3(x, y, layer);
          t2 = this.layers;
          if (t1)
            J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(t2, layer)), y), x).copy$1(tile);
          else
            J.$indexSet$ax(J.$index$asx(J.get$data$x(J.$index$asx(t2, layer)), y), x, R.Tile$0(J.$index$asx(this.layers, layer), index, x, y, tile.width, tile.height));
        } else {
          t1 = this.hasTile$3(x, y, layer);
          t2 = this.layers;
          if (t1)
            J.set$index$x(J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(t2, layer)), y), x), tile);
          else
            J.$indexSet$ax(J.$index$asx(J.get$data$x(J.$index$asx(t2, layer)), y), x, R.Tile$0(J.$index$asx(this.layers, layer), tile, x, y, this.tileWidth, this.tileHeight));
          index = tile;
        }
        t1 = J.$gt$n(J.indexOf$1$asx(this.collideIndexes, index), -1);
        t2 = this.layers;
        if (t1)
          J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(t2, layer)), y), x).setCollision$4(true, true, true, true);
        else
          J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(t2, layer)), y), x).resetCollision$0();
        J.$index$asx(this.layers, layer).set$dirty(true);
        this.calculateFaces$1(layer);
        return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
      }
      return;
    }, function(tile, x, y) {
      return this.putTile$4(tile, x, y, null);
    }, "putTile$3", "call$4", "call$3", "get$putTile", 6, 2, 1575, 12, 1543, [], 9, [], 10, [], 495, [], "putTile"],
    putTileWorldXY$6: [function(tile, x, y, tileWidth, tileHeight, layer) {
      layer = this.getLayer$1(layer);
      return this.putTile$4(tile, J.$div$n(R.Math_snapToFloor(x, tileWidth, 0), tileWidth), J.$div$n(R.Math_snapToFloor(y, tileHeight, 0), tileHeight), layer);
    }, function(tile, x, y, tileWidth, tileHeight) {
      return this.putTileWorldXY$6(tile, x, y, tileWidth, tileHeight, null);
    }, "putTileWorldXY$5", "call$6", "call$5", "get$putTileWorldXY", 10, 2, 1576, 12, 1543, [], 9, [], 10, [], 498, [], 499, [], 495, [], "putTileWorldXY"],
    searchTileIndex$4: [function(index, skip, reverse, layer) {
      var y, c, t1, x, t2;
      if (skip == null)
        skip = 0;
      if (reverse == null)
        reverse = false;
      layer = this.getLayer$1(layer);
      if (reverse === true) {
        for (y = J.$sub$n(J.get$height$x(J.$index$asx(this.layers, layer)), 1), c = 0; t1 = J.getInterceptor$n(y), t1.$ge(y, 0); y = t1.$sub(y, 1))
          for (x = J.$sub$n(J.get$width$x(J.$index$asx(this.layers, layer)), 1); t2 = J.getInterceptor$n(x), t2.$ge(x, 0); x = t2.$sub(x, 1))
            if (J.$eq(J.get$index$x(J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x)), index))
              if (c === skip)
                return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
              else
                ++c;
      } else {
        c = 0;
        y = 0;
        while (true) {
          t1 = J.get$height$x(J.$index$asx(this.layers, layer));
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(y < t1))
            break;
          x = 0;
          while (true) {
            t1 = J.get$width$x(J.$index$asx(this.layers, layer));
            if (typeof t1 !== "number")
              return H.iae(t1);
            if (!(x < t1))
              break;
            if (J.$eq(J.get$index$x(J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x)), index))
              if (c === skip)
                return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
              else
                ++c;
            ++x;
          }
          ++y;
        }
      }
      return;
    }, function(index) {
      return this.searchTileIndex$4(index, 0, false, null);
    }, "searchTileIndex$1", function(index, skip) {
      return this.searchTileIndex$4(index, skip, false, null);
    }, "searchTileIndex$2", function(index, skip, reverse) {
      return this.searchTileIndex$4(index, skip, reverse, null);
    }, "searchTileIndex$3", "call$4", "call$1", "call$2", "call$3", "get$searchTileIndex", 2, 6, 1577, 49, 19, 12, 281, [], 1578, [], 1579, [], 495, [], "searchTileIndex"],
    getTile$4: [function(x, y, layer, nonNull) {
      var t1;
      if (nonNull == null)
        nonNull = false;
      layer = this.getLayer$1(layer);
      t1 = J.getInterceptor$n(x);
      if (t1.$ge(x, 0))
        if (t1.$lt(x, J.get$width$x(J.$index$asx(this.layers, layer)))) {
          t1 = J.getInterceptor$n(y);
          t1 = t1.$ge(y, 0) && t1.$lt(y, J.get$height$x(J.$index$asx(this.layers, layer)));
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        if (J.$eq(J.get$index$x(J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x)), -1))
          if (nonNull === true)
            return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
          else
            return;
        else
          return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
      else
        return;
    }, function(x, y, layer) {
      return this.getTile$4(x, y, layer, null);
    }, "getTile$3", function(x, y) {
      return this.getTile$4(x, y, null, null);
    }, "getTile$2", "call$4", "call$3", "call$2", "get$getTile", 4, 4, 1580, 12, 12, 9, [], 10, [], 495, [], 1581, [], "getTile"],
    getTileWorldXY$5: [function(x, y, tileWidth, tileHeight, layer) {
      if (tileWidth == null)
        tileWidth = this.tileWidth;
      if (tileHeight == null)
        tileHeight = this.tileHeight;
      layer = this.getLayer$1(layer);
      return this.getTile$3(J.$div$n(R.Math_snapToFloor(x, tileWidth, 0), tileWidth), J.$div$n(R.Math_snapToFloor(y, tileHeight, 0), tileHeight), layer);
    }, function(x, y) {
      return this.getTileWorldXY$5(x, y, null, null, null);
    }, "getTileWorldXY$2", function(x, y, tileWidth) {
      return this.getTileWorldXY$5(x, y, tileWidth, null, null);
    }, "getTileWorldXY$3", function(x, y, tileWidth, tileHeight) {
      return this.getTileWorldXY$5(x, y, tileWidth, tileHeight, null);
    }, "getTileWorldXY$4", "call$5", "call$2", "call$3", "call$4", "get$getTileWorldXY", 4, 6, 1582, 12, 12, 12, 9, [], 10, [], 498, [], 499, [], 495, [], "getTileWorldXY"],
    copy$5: [function(x, y, width, height, layer) {
      var t1, t2, ty, t3, tx, t4;
      layer = this.getLayer$1(layer);
      if (J.$index$asx(this.layers, layer) == null) {
        J.clear$0$ax(this._results);
        return;
      }
      if (x == null)
        x = 0;
      if (y == null)
        y = 0;
      if (width == null)
        width = J.get$width$x(J.$index$asx(this.layers, layer));
      if (height == null)
        height = J.get$height$x(J.$index$asx(this.layers, layer));
      if (J.$lt$n(x, 0))
        x = 0;
      if (J.$lt$n(y, 0))
        y = 0;
      if (J.$gt$n(width, J.get$width$x(J.$index$asx(this.layers, layer))))
        width = J.get$width$x(J.$index$asx(this.layers, layer));
      if (J.$gt$n(height, J.get$height$x(J.$index$asx(this.layers, layer))))
        height = J.get$height$x(J.$index$asx(this.layers, layer));
      J.set$length$asx(this._results, 0);
      J.add$1$ax(this._results, P.LinkedHashMap_LinkedHashMap$_literal(["x", x, "y", y, "width", width, "height", height, "layer", layer], null, null));
      for (t1 = J.getInterceptor$ns(y), t2 = J.getInterceptor$ns(x), ty = y; t3 = J.getInterceptor$n(ty), t3.$lt(ty, t1.$add(y, height)); ty = t3.$add(ty, 1))
        for (tx = x; t4 = J.getInterceptor$n(tx), t4.$lt(tx, t2.$add(x, width)); tx = t4.$add(tx, 1))
          J.add$1$ax(this._results, J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), ty), tx));
      return this._results;
    }, function(x, y, width, height) {
      return this.copy$5(x, y, width, height, null);
    }, "copy$4", "call$5", "call$4", "get$copy", 8, 2, 1583, 12, 9, [], 10, [], 31, [], 52, [], 495, [], "copy"],
    paste$4: [function(x, y, tileblock, layer) {
      var t1, diffX, diffY, t2, t3, i, t4;
      if (x == null)
        x = 0;
      if (y == null)
        y = 0;
      layer = this.getLayer$1(layer);
      if (tileblock == null || J.$lt$n(J.get$length$asx(tileblock), 2))
        return;
      t1 = J.getInterceptor$asx(tileblock);
      diffX = J.$sub$n(J.get$x$x(t1.$index(tileblock, 1)), x);
      diffY = J.$sub$n(J.get$y$x(t1.$index(tileblock, 1)), y);
      t2 = J.getInterceptor$ns(diffY);
      t3 = J.getInterceptor$ns(diffX);
      i = 1;
      while (true) {
        t4 = t1.get$length(tileblock);
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (!(i < t4))
          break;
        J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), t2.$add(diffY, J.get$y$x(t1.$index(tileblock, i)))), t3.$add(diffX, J.get$x$x(t1.$index(tileblock, i)))).copy$1(t1.$index(tileblock, i));
        ++i;
      }
      J.$index$asx(this.layers, layer).set$dirty(true);
      this.calculateFaces$1(layer);
    }, function(x) {
      return this.paste$4(x, null, null, null);
    }, "paste$1", function(x, y) {
      return this.paste$4(x, y, null, null);
    }, "paste$2", function() {
      return this.paste$4(null, null, null, null);
    }, "paste$0", function(x, y, tileblock) {
      return this.paste$4(x, y, tileblock, null);
    }, "paste$3", "call$4", "call$1", "call$2", "call$0", "call$3", "get$paste", 0, 8, 1584, 12, 12, 12, 12, 9, [], 10, [], 1585, [], 495, [], "paste"],
    swap$7: [function(tileA, tileB, x, y, width, height, layer) {
      layer = this.getLayer$1(layer);
      this.copy$5(x, y, width, height, layer);
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      this._tempA = tileA;
      this._tempB = tileB;
      J.forEach$1$ax(this._results, this.get$swapHandler());
      this.paste$4(x, y, this._results, layer);
    }, function(tileA, tileB, x, y, width, height) {
      return this.swap$7(tileA, tileB, x, y, width, height, null);
    }, "swap$6", "call$7", "call$6", "get$swap", 12, 2, 1586, 12, 1587, [], 1588, [], 9, [], 10, [], 31, [], 52, [], 495, [], "swap"],
    swapHandler$1: [function(value) {
      var t1 = J.getInterceptor$x(value);
      if (J.$eq(t1.get$index(value), this._tempA))
        t1.set$index(value, this._tempB);
      else if (J.$eq(t1.get$index(value), this._tempB))
        t1.set$index(value, this._tempA);
    }, "call$1", "get$swapHandler", 2, 0, 1542, 138, [], "swapHandler"],
    forEach$6: [function(_, callback, x, y, width, height, layer) {
      layer = this.getLayer$1(layer);
      this.copy$5(x, y, width, height, layer);
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      J.forEach$1$ax(this._results, callback);
      this.paste$4(x, y, this._results, layer);
    }, function($receiver, callback, x, y, width, height) {
      return this.forEach$6($receiver, callback, x, y, width, height, null);
    }, "forEach$5", "call$6", "call$5", "get$forEach", 10, 2, 1589, 12, 26, [], 9, [], 10, [], 31, [], 52, [], 495, [], "forEach"],
    replace$7: [function(_, source, dest, x, y, width, height, layer) {
      var i, t1;
      layer = this.getLayer$1(layer);
      this.copy$5(x, y, width, height, layer);
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      i = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$eq(J.get$index$x(J.$index$asx(this._results, i)), source))
          J.set$index$x(J.$index$asx(this._results, i), dest);
        ++i;
      }
      this.paste$4(x, y, this._results, layer);
    }, function($receiver, source, dest, x, y, width, height) {
      return this.replace$7($receiver, source, dest, x, y, width, height, null);
    }, "replace$6", "call$7", "call$6", "get$replace", 12, 2, 1586, 12, 208, [], 1259, [], 9, [], 10, [], 31, [], 52, [], 495, [], "replace"],
    random$5: [function(x, y, width, height, layer) {
      var indexes, t, t1, idx, i;
      layer = this.getLayer$1(layer);
      this.copy$5(x, y, width, height, layer);
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      indexes = [];
      t = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(t < t1))
          break;
        if (J.get$index$x(J.$index$asx(this._results, t)) === true) {
          idx = J.get$index$x(J.$index$asx(this._results, t));
          if (J.$eq(H.Lists_indexOf(indexes, idx, 0, indexes.length), -1))
            indexes.push(idx);
        }
        ++t;
      }
      i = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.set$index$x(J.$index$asx(this._results, i), this.game.get$rnd().pick$1(indexes));
        ++i;
      }
      this.paste$4(x, y, this._results, layer);
    }, function(x, y, width, height) {
      return this.random$5(x, y, width, height, null);
    }, "random$4", "call$5", "call$4", "get$random", 8, 2, 1590, 12, 9, [], 10, [], 31, [], 52, [], 495, [], "random"],
    shuffle$5: [function(_, x, y, width, height, layer) {
      var indexes, t, t1, i, t2;
      layer = this.getLayer$1(layer);
      this.copy$5(x, y, width, height, layer);
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      indexes = [];
      t = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(t < t1))
          break;
        if (J.get$index$x(J.$index$asx(this._results, t)) === true)
          indexes.push(J.get$index$x(J.$index$asx(this._results, t)));
        ++t;
      }
      H.IterableMixinWorkaround_shuffleList(indexes, null);
      i = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        t1 = J.$index$asx(this._results, i);
        t2 = i - 1;
        if (t2 >= indexes.length)
          return H.ioore(indexes, t2);
        J.set$index$x(t1, indexes[t2]);
        ++i;
      }
      this.paste$4(x, y, this._results, layer);
    }, function($receiver, x, y, width, height) {
      return this.shuffle$5($receiver, x, y, width, height, null);
    }, "shuffle$4", "call$5", "call$4", "get$shuffle", 8, 2, 1590, 12, 9, [], 10, [], 31, [], 52, [], 495, [], "shuffle"],
    fill$6: [function(_, index, x, y, width, height, layer) {
      var i, t1;
      layer = this.getLayer$1(layer);
      this.copy$5(x, y, width, height, layer);
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      i = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.set$index$x(J.$index$asx(this._results, i), index);
        ++i;
      }
      this.paste$4(x, y, this._results, layer);
    }, function($receiver, index, x, y, width, height) {
      return this.fill$6($receiver, index, x, y, width, height, null);
    }, "fill$5", "call$6", "call$5", "get$fill", 10, 2, 1591, 12, 281, [], 9, [], 10, [], 31, [], 52, [], 495, [], "fill"],
    removeAllLayers$0: [function() {
      J.set$length$asx(this.layers, 0);
      this.currentLayer = 0;
    }, "call$0", "get$removeAllLayers", 0, 0, 54, "removeAllLayers"],
    dump$0: [function() {
      var args, txt, y, t1, x;
      args = [""];
      txt = "";
      y = 0;
      while (true) {
        t1 = J.get$height$x(J.$index$asx(this.layers, this.currentLayer));
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(y < t1))
          break;
        x = 0;
        while (true) {
          t1 = J.get$width$x(J.$index$asx(this.layers, this.currentLayer));
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(x < t1))
            break;
          txt += "%c  ";
          if (J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, this.currentLayer)), y), x) != null)
            if (J.$index$asx(this.debugMap, J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, this.currentLayer)), y), x)) != null)
              args.push("background: " + H.S(J.$index$asx(this.debugMap, J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, this.currentLayer)), y), x))));
            else
              args.push("background: #ffffff");
          else
            args.push("background: rgb(0, 0, 0)");
          ++x;
        }
        txt += "\n";
        ++y;
      }
      if (0 >= args.length)
        return H.ioore(args, 0);
      args[0] = txt;
      window;
      if (typeof console != "undefined")
        console.log(args);
    }, "call$0", "get$dump", 0, 0, 54, "dump"],
    destroy$0: [function() {
      J.set$length$asx(this.layers, 0);
      this.currentLayer = 0;
      this.data = [];
      this.game = null;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    Tilemap$6: function(game, key, tileWidth, tileHeight, width, height) {
      var data;
      this.game = game;
      this.key = key;
      data = R.TilemapParser_parse(game, key, tileWidth, tileHeight, width, height);
      if (data == null)
        return;
      this.width = data.width;
      this.height = data.height;
      this.tileWidth = data.tileWidth;
      this.tileHeight = data.tileHeight;
      this.orientation = data.orientation;
      this.format = data.format;
      this.version = data.version;
      this.properties = data.properties;
      this.widthInPixels = data.widthInPixels;
      this.heightInPixels = data.heightInPixels;
      this.layers = data.layers;
      this.tilesets = data.tilesets;
      this.tiles = data.tiles;
      this.objects = data.objects;
      this.collideIndexes = [];
      this.collision = data.collision;
      this.images = data.images;
      this.currentLayer = 0;
      this.debugMap = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._results = [];
      this._tempA = 0;
      this._tempB = 0;
    },
    static: {"^": "Tilemap_CSV<-614,Tilemap_TILED_JSON<-614,Tilemap_Format<-946,Tilemap_NORTH<-614,Tilemap_EAST<-614,Tilemap_SOUTH<-614,Tilemap_WEST<-614", Tilemap$: [function(game, key, tileWidth, tileHeight, width, height) {
        var t1 = new R.Tilemap(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null);
        t1.Tilemap$6(game, key, tileWidth, tileHeight, width, height);
        return t1;
      }, null, null, 2, 10, 497, 12, 313, 313, 393, 393, 252, [], 269, [], 498, [], 499, [], 31, [], 52, [], "new Tilemap"]}
  },
  "+Tilemap": [674],
  MapCache: {
    "^": "Object;cw@-616,ch@-616,ga@-616,dx*-616,dy*-616,dw@-616,dh@-616,tx@-616,ty@-616,tw@-616,th*-616,tl@-616,maxX@-616,maxY@-616,startX@-616,startY@-616,x*-616,y*-616,prevX@-616,prevY@-616",
    static: {MapCache$: [function() {
        return new R.MapCache(null, null, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }, null, null, 0, 0, 500, "new MapCache"]}
  },
  "+MapCache": [674],
  TilemapLayerData: {
    "^": "Object;name*-644,x*-616,y*-616,width*-616,height*-616,widthInPixels@-616,heightInPixels@-616,alpha*-616,visible@-617,properties@-783,indexes@-745,callbacks@-1592,bodies@-1463,data*-1593,dirty@-617",
    static: {TilemapLayerData$: [function() {
        return new R.TilemapLayerData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);
      }, null, null, 0, 0, 501, "new TilemapLayerData"]}
  },
  "+TilemapLayerData": [674],
  TilemapLayer: {
    "^": "Image;game:Phaser$TilemapLayer$game@-613,map*-1594,index*-614,layer*-1536,canvas*-836,context*-876,baseTexture@-853,texture:Phaser$TilemapLayer$texture@-698,textureFrame@-963,name:Phaser$TilemapLayer$name*-644,type:Phaser$TilemapLayer$type*-614,cameraOffset:Phaser$TilemapLayer$cameraOffset@-615,tileColor@-644,debug:Phaser$TilemapLayer$debug@-617,debugAlpha@-616,debugColor@-644,debugFill@-617,debugFillColor@-644,debugCallbackColor@-644,scrollFactorX@-616,scrollFactorY@-616,dirty@-617,rayStepRate@-616,wrap*-617,_mc@-1595,_results@-645,_column@-1596,game-613,exists-617,name-644,type-614,z-614,events-648,key-12,world-615,autoCull-617,input-1141,body-4,cameraOffset-615,Phaser$Image$anchor-615,cropRect-649,_frame-649,_cache-645,_crop-649,_Phaser$_bounds-649,_Phaser$_dirty-617,_frameName-644,alive-617,debug-617,Phaser$Image$children-1091,animations-1147,__tilePattern-822,_Phaser$_currentBounds-649,anchor-652,texture-698,updateFrame-617,PIXI$Sprite0$_PIXI$_width-616,PIXI$Sprite0$_PIXI$_height-616,_uvs-699,tintedTexture-700,buffer-701,tint-614,cachedTint-614,blendMode-702,children-651,interactiveChildren-617,_PIXI$_width-616,_PIXI$_height-616,position-652,scale-652,pivot-652,rotation-616,alpha-616,visible-617,hitArea-653,buttonMode-617,renderable-617,_parent-654,__hit-617,__isOver-617,__mouseIsDown-617,__isDown-617,_dirty-617,click-655,mousemove-655,mousedown-655,mouseout-655,mouseover-655,mouseup-655,mouseupoutside-655,touchmove-655,touchstart-655,touchend-655,tap-655,touchendoutside-655,__touchData-656,_stage-657,_worldAlpha-616,_interactive-617,defaultCursor-644,_worldTransform-658,_sr-616,_cr-616,filterArea-659,_bounds-659,_currentBounds-659,_mask-660,_cacheAsBitmap-617,_cachedSprite-661,_cacheIsDirty-617,_filterBlock-662,_filters-663,_rotationCache-616",
    map$1: function($receiver, arg0) {
      return this.map.call$1(arg0);
    },
    debug$0: function() {
      return this.Phaser$TilemapLayer$debug.call$0();
    },
    wrap$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.wrap.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    get$scrollX: [function(_) {
      return J.get$x$x(this._mc);
    }, null, null, 1, 0, 619, "scrollX"],
    set$scrollX: [function(_, value) {
      var t1;
      if (!J.$eq(value, J.get$x$x(this._mc))) {
        J.set$x$x(this._mc, value);
        t1 = this._mc;
        t1.set$startX(J.floor$0$n(J.$div$n(J.get$x$x(t1), this.map.get$tileWidth())));
        this.dirty = true;
      }
    }, null, null, 3, 0, 620, 138, [], "scrollX"],
    get$scrollY: [function(_) {
      return J.get$y$x(this._mc);
    }, null, null, 1, 0, 619, "scrollY"],
    set$scrollY: [function(_, value) {
      var t1;
      if (!J.$eq(value, J.get$y$x(this._mc))) {
        J.set$y$x(this._mc, value);
        t1 = this._mc;
        t1.set$startY(J.floor$0$n(J.$div$n(J.get$y$x(t1), this.map.get$tileHeight())));
        this.dirty = true;
      }
    }, null, null, 3, 0, 620, 138, [], "scrollY"],
    get$collisionWidth: [function() {
      return this._mc.get$cw();
    }, null, null, 1, 0, 619, "collisionWidth"],
    set$collisionWidth: [function(value) {
      this._mc.set$cw(value);
      this.dirty = true;
    }, null, null, 3, 0, 620, 138, [], "collisionWidth"],
    get$collisionHeight: [function() {
      return this._mc.get$ch();
    }, null, null, 1, 0, 619, "collisionHeight"],
    set$collisionHeight: [function(value) {
      this._mc.set$ch(value);
      this.dirty = true;
    }, null, null, 3, 0, 620, 138, [], "collisionHeight"],
    postUpdate$0: [function() {
      R.Image.prototype.postUpdate$0.call(this);
      var t1 = J.$mul$ns(J.get$x$x(this.Phaser$TilemapLayer$game.get$camera()), this.scrollFactorX);
      if (!J.$eq(t1, J.get$x$x(this._mc))) {
        J.set$x$x(this._mc, t1);
        t1 = this._mc;
        t1.set$startX(J.floor$0$n(J.$div$n(J.get$x$x(t1), this.map.get$tileWidth())));
        this.dirty = true;
      }
      t1 = J.$mul$ns(J.get$y$x(this.Phaser$TilemapLayer$game.get$camera()), this.scrollFactorY);
      if (!J.$eq(t1, J.get$y$x(this._mc))) {
        J.set$y$x(this._mc, t1);
        t1 = this._mc;
        t1.set$startY(J.floor$0$n(J.$div$n(J.get$y$x(t1), this.map.get$tileHeight())));
        this.dirty = true;
      }
      this.render$0();
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.position, J.$div$n(J.$add$ns(J.get$x$x(J.get$view$x(this.Phaser$TilemapLayer$game.get$camera())), J.get$x$x(this.Phaser$TilemapLayer$cameraOffset)), J.get$x$x(J.get$scale$x(this.Phaser$TilemapLayer$game.get$camera()))));
        J.set$y$x(this.position, J.$div$n(J.$add$ns(J.get$y$x(J.get$view$x(this.Phaser$TilemapLayer$game.get$camera())), J.get$y$x(this.Phaser$TilemapLayer$cameraOffset)), J.get$y$x(J.get$scale$x(this.Phaser$TilemapLayer$game.get$camera()))));
      }
    }, "call$0", "get$postUpdate", 0, 0, 54, "postUpdate"],
    resizeWorld$0: [function() {
      this.Phaser$TilemapLayer$game.get$world().setBounds$4(0, 0, this.layer.get$widthInPixels(), this.layer.get$heightInPixels());
    }, "call$0", "get$resizeWorld", 0, 0, 54, "resizeWorld"],
    _fixX$1: [function(x) {
      if (J.$lt$n(x, 0))
        x = 0;
      if (J.$eq(this.scrollFactorX, 1))
        return x;
      return J.$add$ns(J.get$x$x(this._mc), J.$sub$n(x, J.$div$n(J.get$x$x(this._mc), this.scrollFactorX)));
    }, "call$1", "get$_fixX", 2, 0, 376, 9, [], "_fixX"],
    _unfixX$1: [function(x) {
      if (J.$eq(this.scrollFactorX, 1))
        return x;
      return J.$add$ns(J.$div$n(J.get$x$x(this._mc), this.scrollFactorX), J.$sub$n(x, J.get$x$x(this._mc)));
    }, "call$1", "get$_unfixX", 2, 0, 376, 9, [], "_unfixX"],
    _fixY$1: [function(y) {
      if (J.$lt$n(y, 0))
        y = 0;
      if (J.$eq(this.scrollFactorY, 1))
        return y;
      return J.$add$ns(J.get$y$x(this._mc), J.$sub$n(y, J.$div$n(J.get$y$x(this._mc), this.scrollFactorY)));
    }, "call$1", "get$_fixY", 2, 0, 376, 10, [], "_fixY"],
    _unfixY$1: [function(y) {
      if (J.$eq(this.scrollFactorY, 1))
        return y;
      return J.$add$ns(J.$div$n(J.get$y$x(this._mc), this.scrollFactorY), J.$sub$n(y, J.get$y$x(this._mc)));
    }, "call$1", "get$_unfixY", 2, 0, 376, 10, [], "_unfixY"],
    getTileX$1: [function(x) {
      return J.$tdiv$n(R.Math_snapToFloor(this._fixX$1(x), this.map.get$tileWidth(), 0), this.map.get$tileWidth());
    }, "call$1", "get$getTileX", 2, 0, 384, 9, [], "getTileX"],
    getTileY$1: [function(y) {
      return J.$tdiv$n(R.Math_snapToFloor(this._fixY$1(y), this.map.get$tileHeight(), 0), this.map.get$tileHeight());
    }, "call$1", "get$getTileY", 2, 0, 384, 10, [], "getTileY"],
    getTileXY$3: [function(x, y, point) {
      var t1 = J.getInterceptor$x(point);
      t1.set$x(point, J.$tdiv$n(R.Math_snapToFloor(this._fixX$1(x), this.map.get$tileWidth(), 0), this.map.get$tileWidth()));
      t1.set$y(point, J.$tdiv$n(R.Math_snapToFloor(this._fixY$1(y), this.map.get$tileHeight(), 0), this.map.get$tileHeight()));
      return point;
    }, "call$3", "get$getTileXY", 6, 0, 1597, 9, [], 10, [], 475, [], "getTileXY"],
    getRayCastTiles$4: [function(line, stepRate, collides, interestingFace) {
      var t1, tiles, coords, t2, total, results, i, t3, t;
      if (stepRate == null)
        stepRate = this.rayStepRate;
      t1 = J.getInterceptor$x(line);
      tiles = this.getTiles$6(t1.get$x(line), t1.get$y(line), t1.get$width(line), t1.get$height(line), collides, interestingFace);
      t1 = J.getInterceptor$asx(tiles);
      if (J.$eq(t1.get$length(tiles), 0))
        return [];
      coords = line.coordinatesOnLine$1(stepRate);
      t2 = J.getInterceptor$asx(coords);
      total = t2.get$length(coords);
      results = [];
      i = 0;
      while (true) {
        t3 = t1.get$length(tiles);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        if (typeof total !== "number")
          return H.iae(total);
        t = 0;
        for (; t < total; ++t)
          if (J.containsPoint$2$x(t1.$index(tiles, i), J.$index$asx(t2.$index(coords, t), 0), J.$index$asx(t2.$index(coords, t), 1))) {
            results.push(t1.$index(tiles, i));
            break;
          }
        ++i;
      }
      return results;
    }, function(line) {
      return this.getRayCastTiles$4(line, null, false, false);
    }, "getRayCastTiles$1", function(line, stepRate) {
      return this.getRayCastTiles$4(line, stepRate, false, false);
    }, "getRayCastTiles$2", function(line, stepRate, collides) {
      return this.getRayCastTiles$4(line, stepRate, collides, false);
    }, "getRayCastTiles$3", "call$4", "call$1", "call$2", "call$3", "get$getRayCastTiles", 2, 6, 1598, 12, 19, 19, 1233, [], 1282, [], 1540, [], 1599, [], "getRayCastTiles"],
    getTiles$6: [function(x, y, width, height, collides, interestingFace) {
      var t1, wy, t2, t3, wx, t4;
      x = this._fixX$1(x);
      y = this._fixY$1(y);
      if (J.$gt$n(width, this.layer.get$widthInPixels()))
        width = this.layer.get$widthInPixels();
      if (J.$gt$n(height, this.layer.get$heightInPixels()))
        height = this.layer.get$heightInPixels();
      t1 = this._mc;
      t1.set$tx(J.$tdiv$n(R.Math_snapToFloor(x, t1.get$cw(), 0), this._mc.get$cw()));
      t1 = this._mc;
      t1.set$ty(J.$tdiv$n(R.Math_snapToFloor(y, t1.get$ch(), 0), this._mc.get$ch()));
      t1 = this._mc;
      t1.set$tw(J.$tdiv$n(J.$add$ns(R.Math_snapToCeil(width, t1.get$cw(), 0), this._mc.get$cw()), this._mc.get$cw()));
      t1 = this._mc;
      J.set$th$x(t1, J.$tdiv$n(J.$add$ns(R.Math_snapToCeil(height, t1.get$ch(), 0), this._mc.get$ch()), this._mc.get$ch()));
      J.clear$0$ax(this._results);
      for (wy = this._mc.get$ty(), t1 = collides !== true, t2 = interestingFace !== true; t3 = J.getInterceptor$n(wy), t3.$lt(wy, J.$add$ns(this._mc.get$ty(), J.get$th$x(this._mc))); wy = t3.$add(wy, 1))
        for (wx = this._mc.get$tx(); t4 = J.getInterceptor$n(wx), t4.$lt(wx, J.$add$ns(this._mc.get$tx(), this._mc.get$tw())); wx = t4.$add(wx, 1))
          if (J.$gt$n(J.get$length$asx(J.get$data$x(this.layer)), wy) && J.$gt$n(J.get$length$asx(J.$index$asx(J.get$data$x(this.layer), wy)), wx))
            if (t1 && t2 || J.$index$asx(J.$index$asx(J.get$data$x(this.layer), wy), wx).isInteresting$2(collides, interestingFace))
              J.add$1$ax(this._results, J.$index$asx(J.$index$asx(J.get$data$x(this.layer), wy), wx));
      return this._results;
    }, function(x, y, width, height) {
      return this.getTiles$6(x, y, width, height, false, false);
    }, "getTiles$4", function(x, y, width, height, collides) {
      return this.getTiles$6(x, y, width, height, collides, false);
    }, "getTiles$5", "call$6", "call$4", "call$5", "get$getTiles", 8, 4, 1600, 19, 19, 9, [], 10, [], 31, [], 52, [], 1540, [], 1599, [], "getTiles"],
    updateMax$0: [function() {
      this._mc.set$maxX(J.ceil$0$n(J.$div$n(J.get$width$x(this.canvas), this.map.get$tileWidth())) + 1);
      this._mc.set$maxY(J.ceil$0$n(J.$div$n(J.get$height$x(this.canvas), this.map.get$tileHeight())) + 1);
      this.dirty = true;
    }, "call$0", "get$updateMax", 0, 0, 54, "updateMax"],
    render$0: [function() {
      var t1, t2, y, lenY, tile, set, x, lenX, t3;
      if (this.layer.get$dirty() === true)
        this.dirty = true;
      if (this.dirty !== true || this.visible !== true)
        return false;
      t1 = this._mc;
      t1.set$prevX(J.get$dx$x(t1));
      t1 = this._mc;
      t1.set$prevY(J.get$dy$x(t1));
      t1 = this._mc;
      t2 = J.getInterceptor$x(t1);
      t2.set$dx(t1, J.$negate$n(J.$sub$n(t2.get$x(t1), J.$mul$ns(this._mc.get$startX(), this.map.get$tileWidth()))));
      t1 = this._mc;
      t2 = J.getInterceptor$x(t1);
      t2.set$dy(t1, J.$negate$n(J.$sub$n(t2.get$y(t1), J.$mul$ns(this._mc.get$startY(), this.map.get$tileHeight()))));
      t1 = this._mc;
      t1.set$tx(J.get$dx$x(t1));
      t1 = this._mc;
      t1.set$ty(J.get$dy$x(t1));
      J.clearRect$4$x(this.context, 0, 0, J.get$width$x(this.canvas), J.get$height$x(this.canvas));
      J.set$fillStyle$x(this.context, this.tileColor);
      if (this.Phaser$TilemapLayer$debug === true)
        J.set$globalAlpha$x(this.context, this.debugAlpha);
      for (y = this._mc.get$startY(), lenY = J.$add$ns(this._mc.get$startY(), this._mc.get$maxY()), tile = null, set = null; t1 = J.getInterceptor$n(y), t1.$lt(y, lenY); y = t1.$add(y, 1)) {
        this._column = null;
        if (t1.$lt(y, 0) && this.wrap === true)
          this._column = J.$index$asx(J.get$data$x(this.layer), t1.$add(y, J.get$height$x(this.map)));
        else if (t1.$ge(y, J.get$height$x(this.map)) && this.wrap === true)
          this._column = J.$index$asx(J.get$data$x(this.layer), t1.$sub(y, J.get$height$x(this.map)));
        else if (J.$gt$n(J.get$length$asx(J.get$data$x(this.layer)), y))
          this._column = J.$index$asx(J.get$data$x(this.layer), y);
        if (this._column != null)
          for (x = this._mc.get$startX(), lenX = J.$add$ns(this._mc.get$startX(), this._mc.get$maxX()); t2 = J.getInterceptor$n(x), t2.$lt(x, lenX); x = t2.$add(x, 1)) {
            if (t2.$lt(x, 0) && this.wrap === true)
              tile = J.$index$asx(this._column, t2.$add(x, J.get$width$x(this.map)));
            else if (t2.$ge(x, J.get$width$x(this.map)) && this.wrap === true)
              tile = J.$index$asx(this._column, t2.$sub(x, J.get$width$x(this.map)));
            else
              tile = J.$gt$n(J.get$length$asx(this._column), x) ? J.$index$asx(this._column, x) : null;
            if (tile != null) {
              t3 = J.getInterceptor$x(tile);
              t3 = J.$gt$n(t3.get$index(tile), -1) && J.$lt$n(t3.get$index(tile), J.get$length$asx(this.map.get$tiles()));
            } else
              t3 = false;
            if (t3) {
              t3 = J.getInterceptor$x(tile);
              set = J.$index$asx(this.map.get$tilesets(), J.$index$asx(J.$index$asx(this.map.get$tiles(), J.toInt$0$n(t3.get$index(tile))), 2));
              if (J.$eq(this.Phaser$TilemapLayer$debug, false) && !J.$eq(t3.get$alpha(tile), J.get$globalAlpha$x(this.context)))
                J.set$globalAlpha$x(this.context, t3.get$alpha(tile));
              set.draw$4(this.context, J.floor$0$n(this._mc.get$tx()), J.floor$0$n(this._mc.get$ty()), J.toInt$0$n(t3.get$index(tile)));
              if (tile.get$debug() === true) {
                J.set$fillStyle$x(this.context, "rgba(0, 255, 0, 0.4)");
                J.fillRect$4$x(this.context, J.floor$0$n(this._mc.get$tx()), J.floor$0$n(this._mc.get$ty()), this.map.get$tileWidth(), this.map.get$tileHeight());
              }
            }
            t3 = this._mc;
            t3.set$tx(J.$add$ns(t3.get$tx(), this.map.get$tileWidth()));
          }
        t2 = this._mc;
        t2.set$tx(J.get$dx$x(t2));
        t2 = this._mc;
        t2.set$ty(J.$add$ns(t2.get$ty(), this.map.get$tileHeight()));
      }
      if (this.Phaser$TilemapLayer$debug === true) {
        J.set$globalAlpha$x(this.context, 1);
        this.renderDebug$0();
      }
      if (J.$eq(this.Phaser$TilemapLayer$game.get$renderType(), 2))
        M.updateWebGLTexture(this.baseTexture, this.Phaser$TilemapLayer$game.get$renderer().get$gl());
      this.dirty = false;
      this.layer.set$dirty(false);
      return true;
    }, "call$0", "get$render", 0, 0, 54, "render"],
    renderDebug$0: [function() {
      var t1, y, lenY, x, lenX, t2, tile, t3;
      t1 = this._mc;
      t1.set$tx(J.get$dx$x(t1));
      t1 = this._mc;
      t1.set$ty(J.get$dy$x(t1));
      J.set$strokeStyle$x(this.context, this.debugColor);
      J.set$fillStyle$x(this.context, this.debugFillColor);
      for (y = this._mc.get$startY(), lenY = J.$add$ns(this._mc.get$startY(), this._mc.get$maxY()); t1 = J.getInterceptor$n(y), t1.$lt(y, lenY); y = t1.$add(y, 1)) {
        this._column = null;
        if (t1.$lt(y, 0) && this.wrap === true)
          this._column = J.$index$asx(J.get$data$x(this.layer), t1.$add(y, J.get$height$x(this.map)));
        else if (t1.$ge(y, J.get$height$x(this.map)) && this.wrap === true)
          this._column = J.$index$asx(J.get$data$x(this.layer), t1.$sub(y, J.get$height$x(this.map)));
        else if (J.$gt$n(J.get$length$asx(J.get$data$x(this.layer)), y))
          this._column = J.$index$asx(J.get$data$x(this.layer), y);
        if (this._column != null)
          for (x = this._mc.get$startX(), lenX = J.$add$ns(this._mc.get$startX(), this._mc.get$maxX()); t2 = J.getInterceptor$n(x), t2.$lt(x, lenX); x = t2.$add(x, 1)) {
            if (t2.$lt(x, 0) && this.wrap === true)
              tile = J.$index$asx(this._column, t2.$add(x, J.get$width$x(this.map)));
            else if (t2.$ge(x, J.get$width$x(this.map)) && this.wrap === true)
              tile = J.$index$asx(this._column, t2.$sub(x, J.get$width$x(this.map)));
            else
              tile = J.$gt$n(J.get$length$asx(this._column), x) ? J.$index$asx(this._column, x) : null;
            if (tile != null)
              t3 = tile.get$faceTop() === true || tile.get$faceBottom() === true || tile.get$faceLeft() === true || tile.get$faceRight() === true;
            else
              t3 = false;
            if (t3) {
              t3 = this._mc;
              t3.set$tx(J.floor$0$n(t3.get$tx()));
              if (this.debugFill === true)
                J.fillRect$4$x(this.context, this._mc.get$tx(), this._mc.get$ty(), this._mc.get$cw(), this._mc.get$ch());
              J.beginPath$0$x(this.context);
              if (tile.get$faceTop() === true) {
                J.moveTo$2$x(this.context, this._mc.get$tx(), this._mc.get$ty());
                J.lineTo$2$x(this.context, J.$add$ns(this._mc.get$tx(), this._mc.get$cw()), this._mc.get$ty());
              }
              if (tile.get$faceBottom() === true) {
                J.moveTo$2$x(this.context, this._mc.get$tx(), J.$add$ns(this._mc.get$ty(), this._mc.get$ch()));
                J.lineTo$2$x(this.context, J.$add$ns(this._mc.get$tx(), this._mc.get$cw()), J.$add$ns(this._mc.get$ty(), this._mc.get$ch()));
              }
              if (tile.get$faceLeft() === true) {
                J.moveTo$2$x(this.context, this._mc.get$tx(), this._mc.get$ty());
                J.lineTo$2$x(this.context, this._mc.get$tx(), J.$add$ns(this._mc.get$ty(), this._mc.get$ch()));
              }
              if (tile.get$faceRight() === true) {
                J.moveTo$2$x(this.context, J.$add$ns(this._mc.get$tx(), this._mc.get$cw()), this._mc.get$ty());
                J.lineTo$2$x(this.context, J.$add$ns(this._mc.get$tx(), this._mc.get$cw()), J.$add$ns(this._mc.get$ty(), this._mc.get$ch()));
              }
              J.stroke$0$x(this.context);
            }
            t3 = this._mc;
            t3.set$tx(J.$add$ns(t3.get$tx(), this.map.get$tileWidth()));
          }
        t2 = this._mc;
        t2.set$tx(J.get$dx$x(t2));
        t2 = this._mc;
        t2.set$ty(J.$add$ns(t2.get$ty(), this.map.get$tileHeight()));
      }
    }, "call$0", "get$renderDebug", 0, 0, 54, "renderDebug"],
    TilemapLayer$5: function(game, tilemap, index, width, height) {
      var t1;
      this.Phaser$TilemapLayer$game = game;
      this.map = tilemap;
      this.index = index;
      this.layer = J.$index$asx(tilemap.get$layers(), index);
      t1 = R.Canvas_create(width, height, "");
      this.canvas = t1;
      this.context = J.getContext$1$x(t1, "2d");
      t1 = M.BaseTexture$(this.canvas, C.scaleModes_0);
      this.baseTexture = t1;
      this.Phaser$TilemapLayer$texture = M.Texture$(t1, null);
      this.textureFrame = R.Frame$(0, 0, 0, width, height, "tilemapLayer", game.get$rnd().uuid$0());
      this.Phaser$TilemapLayer$name = "";
      this.Phaser$TilemapLayer$type = 10;
      J.$indexSet$ax(this._cache, 7, 1);
      this.Phaser$TilemapLayer$cameraOffset.set$2(J.get$x$x(this.position), J.get$y$x(this.position));
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.Phaser$TilemapLayer$cameraOffset = t1;
      this.tileColor = "rgb(255, 255, 255)";
      this.Phaser$TilemapLayer$debug = false;
      this.debugAlpha = 0.5;
      this.debugColor = "rgba(0, 255, 0, 1)";
      this.debugFill = false;
      this.debugFillColor = "rgba(0, 255, 0, 0.2)";
      this.debugCallbackColor = "rgba(255, 0, 0, 1)";
      this.scrollFactorX = 1;
      this.scrollFactorY = 1;
      this.dirty = true;
      this.rayStepRate = 4;
      this.wrap = false;
      t1 = new R.MapCache(null, null, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      t1.cw = tilemap.get$tileWidth();
      t1.ch = tilemap.get$tileHeight();
      this._mc = t1;
      this._results = [];
      t1.maxX = J.ceil$0$n(J.$div$n(J.get$width$x(this.canvas), this.map.get$tileWidth())) + 1;
      this._mc.set$maxY(J.ceil$0$n(J.$div$n(J.get$height$x(this.canvas), this.map.get$tileHeight())) + 1);
      this.dirty = true;
    },
    $isTilemapLayer: true,
    static: {TilemapLayer$: [function(game, tilemap, index, width, height) {
        var t1, t2, t3, t4, t5;
        t1 = J.$index$asx($.get$TextureCache(), "__default");
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t5 = new R.TilemapLayer(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, true, false, [], null, null, null, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9))), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t5.Phaser$TilemapLayer$texture = t1;
        t5._setupTexture$0();
        t5.Image$5(game, 0, 0, null, null);
        t5.TilemapLayer$5(game, tilemap, index, width, height);
        return t5;
      }, null, null, 2, 8, 502, 12, 12, 12, 12, 252, [], 503, [], 281, [], 31, [], 52, [], "new TilemapLayer"]}
  },
  "+TilemapLayer": [1165],
  TilemapImageData: {
    "^": "Object;name*-644,image@-644,x*-616,y*-616,alpha*-616,visible@-617,properties@-783",
    image$3: function(arg0, arg1, arg2) {
      return this.image.call$3(arg0, arg1, arg2);
    },
    image$2: function(arg0, arg1) {
      return this.image.call$2(arg0, arg1);
    },
    image$4: function(arg0, arg1, arg2, arg3) {
      return this.image.call$4(arg0, arg1, arg2, arg3);
    },
    image$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.image.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    static: {TilemapImageData$: [function() {
        return new R.TilemapImageData(null, null, null, null, null, null, null);
      }, null, null, 0, 0, 504, "new TilemapImageData"]}
  },
  "+TilemapImageData": [674],
  TilemapParser: {
    "^": "Object;",
    static: {TilemapParser$: [function() {
        return new R.TilemapParser();
      }, null, null, 0, 0, 505, "new TilemapParser"], TilemapParser_parse: [function(game, key, tileWidth, tileHeight, width, height) {
        var map, t1;
        if (tileWidth == null)
          tileWidth = 32;
        if (tileHeight == null)
          tileHeight = 32;
        if (width == null)
          ;
        if (height == null)
          ;
        if (key == null)
          return R.TilemapParser_getEmptyData(null, null, null, null);
        map = game.get$cache().getTilemapData$1(key);
        if (map != null) {
          t1 = J.getInterceptor$asx(map);
          if (J.$eq(t1.$index(map, "format"), 0))
            return R.TilemapParser_parseCSV(key, t1.$index(map, "data"), tileWidth, tileHeight);
          else if (t1.$index(map, "format") == null || J.$eq(t1.$index(map, "format"), 1))
            return R.TilemapParser_parseTiledJSON(t1.$index(map, "data"));
        } else {
          window;
          t1 = C.JSString_methods.$add("Phaser.TilemapParser.parse - No map data found for key ", key);
          if (typeof console != "undefined")
            console.warn(t1);
        }
        return;
      }, function(game) {
        return R.TilemapParser_parse(game, null, null, null, null, null);
      }, null, function(game, key) {
        return R.TilemapParser_parse(game, key, null, null, null, null);
      }, null, function(game, key, tileWidth) {
        return R.TilemapParser_parse(game, key, tileWidth, null, null, null);
      }, null, function(game, key, tileWidth, tileHeight) {
        return R.TilemapParser_parse(game, key, tileWidth, tileHeight, null, null);
      }, null, function(game, key, tileWidth, tileHeight, width) {
        return R.TilemapParser_parse(game, key, tileWidth, tileHeight, width, null);
      }, null, "call$6", "call$1", "call$2", "call$3", "call$4", "call$5", "TilemapParser_parse$closure", 2, 10, 506, 12, 12, 12, 12, 12, 252, [], 269, [], 498, [], 499, [], 31, [], 52, [], "parse"], TilemapParser_parseCSV: [function(key, data, tileWidth, tileHeight) {
        var map, output, rows, height, width, y, column, x, width0, t1, t2;
        map = R.TilemapParser_getEmptyData(null, null, null, null);
        output = [];
        rows = J.split$1$s(J.trim$0$s(data), "\n");
        height = rows.length;
        for (width = 0, y = 0; y < rows.length; ++y) {
          if (y >= output.length)
            return H.ioore(output, y);
          output[y] = [];
          column = J.split$1$s(rows[y], ",");
          for (x = 0; width0 = column.length, x < width0; ++x) {
            if (y >= output.length)
              return H.ioore(output, y);
            t1 = output[y];
            t2 = J.$index$asx(map.layers, 0);
            if (x >= column.length)
              return H.ioore(column, x);
            J.$indexSet$ax(t1, x, R.Tile$0(t2, H.Primitives_parseInt(column[x], null, null), x, y, tileWidth, tileHeight));
          }
          if (width === 0)
            width = width0;
        }
        map.format = 0;
        map.name = key;
        map.width = width;
        map.height = height;
        map.tileWidth = tileWidth;
        map.tileHeight = tileHeight;
        if (typeof tileWidth !== "number")
          return H.iae(tileWidth);
        map.widthInPixels = width * tileWidth;
        if (typeof tileHeight !== "number")
          return H.iae(tileHeight);
        map.heightInPixels = height * tileHeight;
        J.set$width$x(J.$index$asx(map.layers, 0), width);
        J.set$height$x(J.$index$asx(map.layers, 0), height);
        J.$index$asx(map.layers, 0).set$widthInPixels(map.widthInPixels);
        J.$index$asx(map.layers, 0).set$heightInPixels(map.heightInPixels);
        J.set$data$x(J.$index$asx(map.layers, 0), output);
        return map;
      }, function(key, data) {
        return R.TilemapParser_parseCSV(key, data, 32, 32);
      }, null, function(key, data, tileWidth) {
        return R.TilemapParser_parseCSV(key, data, tileWidth, 32);
      }, null, "call$4", "call$2", "call$3", "TilemapParser_parseCSV$closure", 4, 4, 507, 313, 313, 269, [], 87, [], 498, [], 499, [], "parseCSV"], TilemapParser_getEmptyData: [function(tileWidth, tileHeight, width, height) {
        var map, layers, layer;
        map = new R.TilemapData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        map.width = 0;
        map.height = 0;
        map.tileWidth = 0;
        map.tileHeight = 0;
        if (tileWidth != null)
          map.tileWidth = tileWidth;
        if (tileHeight != null)
          map.tileHeight = tileHeight;
        if (width != null)
          map.width = width;
        if (height != null)
          map.height = height;
        map.orientation = "orthogonal";
        map.version = 1;
        map.properties = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        map.widthInPixels = 0;
        map.heightInPixels = 0;
        layers = [];
        layer = new R.TilemapLayerData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);
        layer.name = "layer";
        layer.x = 0;
        layer.y = 0;
        layer.width = 0;
        layer.height = 0;
        layer.widthInPixels = 0;
        layer.heightInPixels = 0;
        layer.alpha = 1;
        layer.visible = true;
        layer.properties = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        layer.indexes = [];
        layer.callbacks = [];
        layer.bodies = [];
        layer.data = [];
        layers.push(layer);
        map.layers = layers;
        map.images = [];
        map.objects = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        map.collision = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        map.tilesets = [];
        map.tiles = [];
        return map;
      }, function(tileWidth) {
        return R.TilemapParser_getEmptyData(tileWidth, null, null, null);
      }, null, function(tileWidth, tileHeight) {
        return R.TilemapParser_getEmptyData(tileWidth, tileHeight, null, null);
      }, null, function() {
        return R.TilemapParser_getEmptyData(null, null, null, null);
      }, null, function(tileWidth, tileHeight, width) {
        return R.TilemapParser_getEmptyData(tileWidth, tileHeight, width, null);
      }, null, "call$4", "call$1", "call$2", "call$0", "call$3", "TilemapParser_getEmptyData$closure", 0, 8, 508, 12, 12, 12, 12, 498, [], 499, [], 31, [], 52, [], "getEmptyData"], TilemapParser_parseTiledJSON: [function(json) {
        var t1, map, t2, t3, t4, t5, layers, i, layer, row, output, len, x, t, images, image, tilesets, set, newSet, objects, collision, v, object, p, y, count, countX, countY, k, tile, sid, j;
        t1 = J.getInterceptor$asx(json);
        if (!J.$eq(t1.$index(json, "orientation"), "orthogonal")) {
          window;
          if (typeof console != "undefined")
            console.warn("TilemapParser.parseTiledJSON: Only orthogonal map types are supported in this version of Phaser");
          return;
        }
        map = new R.TilemapData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t2 = t1.$index(json, "width");
        map.width = t2;
        t3 = t1.$index(json, "height");
        map.height = t3;
        t4 = t1.$index(json, "tilewidth");
        map.tileWidth = t4;
        t5 = t1.$index(json, "tileheight");
        map.tileHeight = t5;
        map.orientation = t1.$index(json, "orientation");
        map.format = 1;
        map.version = t1.$index(json, "version");
        map.properties = t1.$index(json, "properties");
        map.widthInPixels = J.$mul$ns(t2, t4);
        map.heightInPixels = J.$mul$ns(t3, t5);
        layers = [];
        i = 0;
        while (true) {
          t2 = J.get$length$asx(t1.$index(json, "layers"));
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          c$0: {
            if (!J.$eq(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "type"), "tilelayer"))
              break c$0;
            layer = new R.TilemapLayerData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);
            layer.name = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name");
            layer.x = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "x");
            layer.y = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "y");
            layer.width = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "width");
            layer.height = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "height");
            layer.widthInPixels = J.$mul$ns(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "width"), t1.$index(json, "tilewidth"));
            layer.heightInPixels = J.$mul$ns(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "height"), t1.$index(json, "tileheight"));
            layer.alpha = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "opacity");
            layer.visible = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "visible");
            layer.properties = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
            layer.indexes = [];
            layer.callbacks = [];
            layer.bodies = [];
            if (J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "properties") != null)
              layer.properties = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "properties");
            row = [];
            output = [];
            len = J.get$length$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "data"));
            if (typeof len !== "number")
              return H.iae(len);
            x = 0;
            t = 0;
            for (; t < len; ++t) {
              if (J.$gt$n(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "data"), t), 0))
                row.push(R.Tile$0(layer, J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "data"), t), x, output.length, t1.$index(json, "tilewidth"), t1.$index(json, "tileheight")));
              else
                row.push(R.Tile$0(layer, -1, x, output.length, t1.$index(json, "tilewidth"), t1.$index(json, "tileheight")));
              ++x;
              if (x === J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "width")) {
                output.push(row);
                row = [];
                x = 0;
              }
            }
            layer.data = output;
            layers.push(layer);
          }
          ++i;
        }
        map.layers = layers;
        images = [];
        i = 0;
        while (true) {
          t2 = J.get$length$asx(t1.$index(json, "layers"));
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          c$0: {
            if (!J.$eq(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "type"), "imagelayer"))
              break c$0;
            image = new R.TilemapImageData(null, null, null, null, null, null, null);
            image.name = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name");
            image.image = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "image");
            image.x = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "x");
            image.y = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "y");
            image.alpha = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "opacity");
            image.visible = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "visible");
            image.properties = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
            if (J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "properties") != null)
              image.properties = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "properties");
            images.push(image);
          }
          ++i;
        }
        map.images = images;
        tilesets = [];
        i = 0;
        while (true) {
          t2 = J.get$length$asx(t1.$index(json, "tilesets"));
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          set = J.$index$asx(t1.$index(json, "tilesets"), i);
          t2 = J.getInterceptor$asx(set);
          newSet = R.Tileset$(t2.$index(set, "name"), t2.$index(set, "firstgid"), t2.$index(set, "tilewidth"), t2.$index(set, "tileheight"), t2.$index(set, "margin"), t2.$index(set, "spacing"), t2.$index(set, "properties"));
          if (t2.$index(set, "tileproperties") != null)
            newSet.tileProperties = t2.$index(set, "tileproperties");
          newSet.rows = J.round$0$n(J.$div$n(J.$sub$n(t2.$index(set, "imageheight"), t2.$index(set, "margin")), J.$add$ns(t2.$index(set, "tileheight"), t2.$index(set, "spacing"))));
          t2 = J.round$0$n(J.$div$n(J.$sub$n(t2.$index(set, "imagewidth"), t2.$index(set, "margin")), J.$add$ns(t2.$index(set, "tilewidth"), t2.$index(set, "spacing"))));
          newSet.columns = t2;
          newSet.total = J.$mul$ns(newSet.rows, t2);
          if (J.$mod$n(newSet.rows, 1) !== 0 || J.$mod$n(newSet.columns, 1) !== 0) {
            window;
            if (typeof console != "undefined")
              console.warn("TileSet image dimensions do not match expected dimensions. Tileset width/height must be evenly divisible by Tilemap tile width/height.");
          } else
            tilesets.push(newSet);
          ++i;
        }
        map.tilesets = tilesets;
        objects = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        collision = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t2 = new R.TilemapParser_parseTiledJSON_slice();
        i = 0;
        while (true) {
          t3 = J.get$length$asx(t1.$index(json, "layers"));
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          c$0: {
            if (!J.$eq(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "type"), "objectgroup"))
              break c$0;
            objects.$indexSet(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name"), []);
            collision.$indexSet(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name"), []);
            len = J.get$length$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"));
            if (typeof len !== "number")
              return H.iae(len);
            v = 0;
            for (; v < len; ++v)
              if (J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "gid") != null) {
                object = P.LinkedHashMap_LinkedHashMap$_literal([["gid"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "gid"), ["name"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "name"), ["x"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "x"), ["y"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "y"), ["visible"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "visible"), ["properties"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "properties")], null, null);
                J.add$1$ax(objects.$index(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name")), object);
              } else if (J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polyline") != null) {
                object = P.LinkedHashMap_LinkedHashMap$_literal([["name"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "name"), ["type"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "type"), ["x"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "x"), ["y"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "y"), ["width"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "width"), ["height"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "height"), ["visible"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "visible"), ["properties"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "properties")], null, null);
                object.$indexSet(0, "polyline", []);
                p = 0;
                while (true) {
                  t3 = J.get$length$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polyline"));
                  if (typeof t3 !== "number")
                    return H.iae(t3);
                  if (!(p < t3))
                    break;
                  J.add$1$ax(object.$index(0, "polyline"), [J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polyline"), p), "x"), J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polyline"), p), "y")]);
                  ++p;
                }
                J.add$1$ax(collision.$index(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name")), object);
                J.add$1$ax(objects.$index(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name")), object);
              } else if (J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polygon") != null) {
                object = t2.call$2(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), ["name", "type", "x", "y", "visible", "properties"]);
                t3 = J.getInterceptor$ax(object);
                t3.$indexSet(object, "polygon", []);
                p = 0;
                while (true) {
                  t4 = J.get$length$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polygon"));
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  if (!(p < t4))
                    break;
                  J.add$1$ax(t3.$index(object, "polygon"), [J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polygon"), p), "x"), J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polygon"), p), "y")]);
                  ++p;
                }
                J.add$1$ax(objects.$index(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name")), object);
              } else if (J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "ellipse") === true) {
                object = t2.call$2(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "properties"]);
                J.add$1$ax(objects.$index(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name")), object);
              } else {
                object = t2.call$2(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), ["name", "type", "x", "y", "width", "height", "visible", "properties"]);
                J.$indexSet$ax(object, "rectangle", true);
                J.add$1$ax(objects.$index(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name")), object);
              }
          }
          ++i;
        }
        map.objects = objects;
        map.collision = collision;
        map.tiles = H.setRuntimeTypeInfo([], [[P.List, P.$int]]);
        i = 0;
        while (true) {
          t1 = J.get$length$asx(map.tilesets);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          set = J.$index$asx(map.tilesets, i);
          x = set.get$tileMargin();
          y = set.get$tileMargin();
          for (t = set.get$firstgid(), t1 = J.getInterceptor$x(set), count = 0, countX = 0, countY = 0; t2 = J.getInterceptor$n(t), t2.$lt(t, J.$add$ns(set.get$firstgid(), t1.get$total(set))); t = t2.$add(t, 1)) {
            t3 = t2.$ge(t, J.get$length$asx(map.tiles));
            t4 = map.tiles;
            if (t3)
              J.add$1$ax(t4, [x, y, i]);
            else
              J.$indexSet$ax(t4, t, [x, y, i]);
            x = J.$add$ns(x, J.$add$ns(set.get$tileWidth(), set.get$tileSpacing()));
            ++count;
            if (count === t1.get$total(set))
              break;
            ++countX;
            if (countX === t1.get$columns(set)) {
              x = set.get$tileMargin();
              y = J.$add$ns(y, J.$add$ns(set.get$tileHeight(), set.get$tileSpacing()));
              ++countY;
              if (countY === t1.get$rows(set))
                break;
              countX = 0;
            }
          }
          ++i;
        }
        i = 0;
        k = null;
        tile = null;
        sid = null;
        set = null;
        while (true) {
          t1 = J.get$length$asx(map.layers);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          layer = J.$index$asx(map.layers, i);
          t1 = J.getInterceptor$x(layer);
          j = 0;
          while (true) {
            t2 = J.get$length$asx(t1.get$data(layer));
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(j < t2))
              break;
            row = J.$index$asx(t1.get$data(layer), j);
            t2 = J.getInterceptor$asx(row);
            k = 0;
            while (true) {
              t3 = t2.get$length(row);
              if (typeof t3 !== "number")
                return H.iae(t3);
              if (!(k < t3))
                break;
              c$2: {
                tile = t2.$index(row, k);
                t3 = J.getInterceptor$x(tile);
                if (J.$lt$n(t3.get$index(tile), 0))
                  break c$2;
                if (J.$ge$n(t3.get$index(tile), J.get$length$asx(map.tiles)))
                  break c$2;
                sid = J.$index$asx(J.$index$asx(map.tiles, t3.get$index(tile)), 2);
                set = J.$index$asx(map.tilesets, sid);
                if (set.get$tileProperties() != null && J.$index$asx(set.get$tileProperties(), J.$sub$n(t3.get$index(tile), set.get$firstgid())) != null)
                  tile.set$properties(J.$index$asx(set.get$tileProperties(), J.$sub$n(t3.get$index(tile), set.get$firstgid())));
              }
              ++k;
            }
            ++j;
          }
          ++i;
        }
        return map;
      }, "call$1", "TilemapParser_parseTiledJSON$closure", 2, 0, 509, 276, [], "parseTiledJSON"]}
  },
  "+TilemapParser": [674],
  TilemapParser_parseTiledJSON_slice: {
    "^": "Closure:1601;",
    call$2: [function(obj, fields) {
      var sliced, t1, t2, k;
      sliced = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      for (t1 = J.get$iterator$ax(fields), t2 = J.getInterceptor$asx(obj); t1.moveNext$0();) {
        k = t1.get$current();
        sliced.$indexSet(0, k, t2.$index(obj, k));
      }
      return sliced;
    }, "call$2", null, 4, 0, 1601, 630, [], 1602, [], "call"]
  },
  Tileset: {
    "^": "Object;name*-644,firstgid@-614,tileWidth@-616,tileHeight@-616,tileMargin@-616,tileSpacing@-616,properties@-783,tileProperties@-783,image@-12,rows*-616,columns*-616,total*-616,drawCoords@-1603",
    image$3: function(arg0, arg1, arg2) {
      return this.image.call$3(arg0, arg1, arg2);
    },
    image$2: function(arg0, arg1) {
      return this.image.call$2(arg0, arg1);
    },
    image$4: function(arg0, arg1, arg2, arg3) {
      return this.image.call$4(arg0, arg1, arg2, arg3);
    },
    image$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.image.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    draw$4: [function(context, x, y, index) {
      var t1, t2, t3, t4, t5;
      if (this.image == null || J.$index$asx(this.drawCoords, J.toInt$0$n(index)) == null)
        return;
      t1 = this.image;
      t2 = J.$index$asx(J.$index$asx(this.drawCoords, index), 0);
      t3 = J.$index$asx(J.$index$asx(this.drawCoords, index), 1);
      t4 = this.tileWidth;
      t5 = this.tileHeight;
      J.drawImageScaledFromSource$9$x(context, t1, t2, t3, t4, t5, x, y, t4, t5);
    }, "call$4", "get$draw", 8, 0, 1604, 142, [], 9, [], 10, [], 281, [], "draw"],
    setImage$1: [function(image) {
      var t1, tx, i, ty, y, x;
      this.image = image;
      t1 = J.getInterceptor$x(image);
      this.rows = J.round$0$n(J.$div$n(J.$sub$n(t1.get$height(image), this.tileMargin), J.$add$ns(this.tileHeight, this.tileSpacing)));
      t1 = J.round$0$n(J.$div$n(J.$sub$n(t1.get$width(image), this.tileMargin), J.$add$ns(this.tileWidth, this.tileSpacing)));
      this.columns = t1;
      this.total = J.$mul$ns(this.rows, t1);
      t1 = J.$add$ns(J.$mul$ns(this.rows, this.columns), 1);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = Array(t1);
      t1.fixed$length = init;
      this.drawCoords = H.setRuntimeTypeInfo(t1, [P.List]);
      tx = this.tileMargin;
      i = this.firstgid;
      ty = tx;
      y = 0;
      while (true) {
        t1 = this.rows;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(y < t1))
          break;
        x = 0;
        while (true) {
          t1 = this.columns;
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(x < t1))
            break;
          J.$indexSet$ax(this.drawCoords, i, [tx, ty]);
          tx = J.$add$ns(tx, J.$add$ns(this.tileWidth, this.tileSpacing));
          i = J.$add$ns(i, 1);
          ++x;
        }
        tx = this.tileMargin;
        ty = J.$add$ns(ty, J.$add$ns(this.tileHeight, this.tileSpacing));
        ++y;
      }
    }, "call$1", "get$setImage", 2, 0, 102, 1605, [], "setImage"],
    setSpacing$2: [function(margin, spacing) {
      this.tileMargin = margin;
      this.tileSpacing = spacing;
      this.setImage$1(this.image);
    }, function(margin) {
      return this.setSpacing$2(margin, 0);
    }, "setSpacing$1", function() {
      return this.setSpacing$2(0, 0);
    }, "setSpacing$0", "call$2", "call$1", "call$0", "get$setSpacing", 0, 4, 56, 49, 49, 273, [], 274, [], "setSpacing"],
    Tileset$7: function($name, firstgid, width, height, margin, spacing, properties) {
      if (width == null || J.$le$n(width, 0))
        width = 32;
      if (height == null || J.$le$n(height, 0))
        height = 32;
      if (margin == null)
        margin = 0;
      if (spacing == null)
        spacing = 0;
      this.name = $name;
      this.firstgid = firstgid;
      this.tileWidth = width;
      this.tileHeight = height;
      this.tileMargin = margin;
      this.tileSpacing = spacing;
      this.properties = properties;
      this.image = null;
      this.rows = 0;
      this.columns = 0;
      this.total = 0;
      this.drawCoords = [];
    },
    static: {Tileset$: [function($name, firstgid, width, height, margin, spacing, properties) {
        var t1 = new R.Tileset(null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Tileset$7($name, firstgid, width, height, margin, spacing, properties);
        return t1;
      }, null, null, 4, 10, 510, 313, 313, 49, 49, 12, 83, [], 511, [], 31, [], 52, [], 273, [], 274, [], 512, [], "new Tileset"]}
  },
  "+Tileset": [674],
  Time: {
    "^": "Object;game@-613,time@-616,now*-616,elapsed@-616,pausedTime@-616,advancedTiming@-617,fps@-616,fpsMin@-616,fpsMax@-616,msMin@-616,msMax@-616,physicsElapsed@-616,deltaCap@-616,timeCap@-616,frames@-614,pauseDuration@-616,timeToCall@-616,lastTime@-616,events@-1606,_started@-616,_timeLastSecond@-616,_pauseStarted@-616,_justResumed@-617,_timers@-1607,_len@-614,_i@-614",
    boot$0: [function() {
      this._started = Date.now();
      J.start$0$x(this.events);
    }, "call$0", "get$boot", 0, 0, 54, "boot"],
    add$1: [function(_, timer) {
      J.add$1$ax(this._timers, timer);
      return timer;
    }, "call$1", "get$add", 2, 0, 1608, 515, [], "add"],
    create$1: [function(autoDestroy) {
      var timer = new R.Timer(this.game, true, false, false, 0, [], H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), 0, 1000, false, false, 0, 0, 0, Date.now(), 0, 0, 0, 0, 0);
      J.add$1$ax(this._timers, timer);
      return timer;
    }, function() {
      return this.create$1(true);
    }, "create$0", "call$1", "call$0", "get$create", 0, 2, 1609, 78, 513, [], "create"],
    removeAll$0: [function() {
      var i, t1;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._timers);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$index$asx(this._timers, i).destroy$0();
        ++i;
      }
      this._timers = [];
      this.events.removeAll$0();
    }, "call$0", "get$removeAll", 0, 0, 54, "removeAll"],
    update$1: [function(time) {
      var t1, t2;
      this.now = time;
      t1 = J.getInterceptor$n(time);
      t2 = t1.$sub(time, this.lastTime);
      if (typeof t2 !== "number")
        return H.iae(t2);
      this.timeToCall = C.JSNumber_methods.toDouble$0(P.max(0, 16 - t2));
      t2 = J.$sub$n(this.now, this.time);
      this.elapsed = t2;
      if (J.$gt$n(t2, this.timeCap))
        this.elapsed = this.timeCap;
      t2 = J.$div$n(this.elapsed, 1000);
      this.physicsElapsed = t2;
      if (J.$eq(t2, 0))
        this.physicsElapsed = 0.016666666666666666;
      if (J.$gt$n(this.deltaCap, 0) && J.$gt$n(this.physicsElapsed, this.deltaCap))
        this.physicsElapsed = this.deltaCap;
      if (this.advancedTiming === true) {
        this.msMin = P.min(this.msMin, this.elapsed);
        this.msMax = P.max(this.msMax, this.elapsed);
        this.frames = J.$add$ns(this.frames, 1);
        if (J.$gt$n(this.now, J.$add$ns(this._timeLastSecond, 1000))) {
          t2 = J.round$0$n(J.$div$n(J.$mul$ns(this.frames, 1000), J.$sub$n(this.now, this._timeLastSecond)));
          this.fps = t2;
          this.fpsMin = P.min(this.fpsMin, t2);
          this.fpsMax = P.max(this.fpsMax, this.fps);
          this._timeLastSecond = this.now;
          this.frames = 0;
        }
      }
      this.time = this.now;
      this.lastTime = t1.$add(time, this.timeToCall);
      if (J.get$paused$x(this.game) !== true) {
        this.events.update$1(this.now);
        this._i = 0;
        this._len = J.get$length$asx(this._timers);
        for (; J.$lt$n(this._i, this._len);) {
          t1 = J.$index$asx(this._timers, this._i).update$1(this.now);
          t2 = this._i;
          if (t1 === true)
            this._i = J.$add$ns(t2, 1);
          else {
            J.removeAt$1$ax(this._timers, t2);
            this._len = J.$sub$n(this._len, 1);
          }
        }
      }
    }, "call$1", "get$update", 2, 0, 620, 727, [], "update"],
    gamePaused$0: [function() {
      var i, t1, i0;
      this._pauseStarted = this.now;
      J.pause$0$x(this.events);
      i = J.get$length$asx(this._timers);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this._timers, i0)._pause$0();
    }, "call$0", "get$gamePaused", 0, 0, 54, "gamePaused"],
    gameResumed$0: [function() {
      var t1, t2, i, i0;
      t1 = Date.now();
      this.now = t1;
      this.time = t1;
      t2 = this._pauseStarted;
      if (typeof t2 !== "number")
        return H.iae(t2);
      this.pauseDuration = t1 - t2;
      this.events.resume$0();
      i = J.get$length$asx(this._timers);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this._timers, i0)._resume$0();
    }, "call$0", "get$gameResumed", 0, 0, 54, "gameResumed"],
    totalElapsedSeconds$0: [function() {
      return J.$mul$ns(J.$sub$n(this.now, this._started), 0.001);
    }, "call$0", "get$totalElapsedSeconds", 0, 0, 54, "totalElapsedSeconds"],
    elapsedSince$1: [function(since) {
      return J.$sub$n(this.now, since);
    }, "call$1", "get$elapsedSince", 2, 0, 102, 1610, [], "elapsedSince"],
    elapsedSecondsSince$1: [function(since) {
      return J.$mul$ns(J.$sub$n(this.now, since), 0.001);
    }, "call$1", "get$elapsedSecondsSince", 2, 0, 102, 1610, [], "elapsedSecondsSince"],
    reset$0: [function(_) {
      this._started = this.now;
      this.removeAll$0();
    }, "call$0", "get$reset", 0, 0, 54, "reset"],
    static: {Time$: [function(game) {
        var t1 = new R.Time(game, 0, 0, 0, 0, false, 0, 1000, 0, 1000, 0, 0, 0, 16.666666666666668, 0, 0, 0, 0, null, 0, 0, 0, false, [], 0, 0);
        t1.events = new R.Timer(game, true, false, false, 0, [], H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), 0, 1000, false, false, 0, 0, 0, Date.now(), 0, 0, 0, 0, 0);
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new Time"]}
  },
  "+Time": [674],
  Timer: {
    "^": "Object;game@-613,autoDestroy@-617,running@-617,expired@-617,elapsed@-616,events@-1611,onComplete*-1612,nextTick@-616,timeCap@-614,paused*-617,_codePaused@-617,_started@-616,_pauseStarted@-616,_pauseTotal@-616,_now@-616,_len@-614,_marked@-614,_i@-614,_diff@-614,_newTick@-616",
    paused$0: function($receiver) {
      return this.paused.call$0();
    },
    get$next: [function() {
      return this.nextTick;
    }, null, null, 1, 0, 619, "next"],
    next$1: function(arg0) {
      return this.get$next().call$1(arg0);
    },
    next$0: function() {
      return this.get$next().call$0();
    },
    get$duration: [function(_) {
      if (this.running === true && J.$gt$n(this.nextTick, this._now))
        return J.$sub$n(this.nextTick, this._now);
      else
        return 0;
    }, null, null, 1, 0, 619, "duration"],
    get$length: [function(_) {
      return J.get$length$asx(this.events);
    }, null, null, 1, 0, 412, "length"],
    get$ms: [function() {
      if (this.running === true)
        return J.$sub$n(J.$sub$n(this._now, this._started), this._pauseTotal);
      else
        return 0;
    }, null, null, 1, 0, 619, "ms"],
    get$second: [function() {
      if (this.running === true)
        return J.$mul$ns(this.get$ms(), 0.001);
      else
        return 0;
    }, null, null, 1, 0, 619, "second"],
    create$5: [function(delay, loop, repeatCount, callback, args) {
      var tick, t1, $event;
      tick = J.round$0$n(delay);
      if (J.$eq(this._now, 0)) {
        t1 = J.get$now$x(this.game.get$time());
        if (typeof t1 !== "number")
          return H.iae(t1);
        tick += t1;
      } else {
        t1 = this._now;
        if (typeof t1 !== "number")
          return H.iae(t1);
        tick += t1;
      }
      $event = new R.TimerEvent(null, null, null, null, null, null, null, null);
      $event.TimerEvent$7(this, delay, tick, repeatCount, loop, callback, args);
      J.add$1$ax(this.events, $event);
      this.order$0(0);
      this.expired = false;
      return $event;
    }, "call$5", "get$create", 10, 0, 1613, 516, [], 257, [], 518, [], 26, [], 383, [], "create"],
    add$3: [function(_, delay, callback, args) {
      return this.create$5(delay, false, 0, callback, args);
    }, function($receiver, delay, callback) {
      return this.add$3($receiver, delay, callback, null);
    }, "add$2", "call$3", "call$2", "get$add", 4, 2, 1614, 12, 516, [], 26, [], 383, [], "add"],
    repeat$4: [function(_, delay, repeatCount, callback, args) {
      return this.create$5(delay, false, repeatCount, callback, args);
    }, "call$4", "get$repeat", 8, 0, 1615, 516, [], 518, [], 26, [], 383, [], "repeat"],
    loop$3: [function(_, delay, callback, args) {
      return this.create$5(delay, true, 0, callback, args);
    }, "call$3", "get$loop", 6, 0, 1616, 516, [], 26, [], 383, [], "loop"],
    start$1: [function(_, delay) {
      var i, t1;
      if (this.running === true)
        return;
      this._started = J.$add$ns(J.get$now$x(this.game.get$time()), delay);
      this.running = true;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.events);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$index$asx(this.events, i).set$tick(J.$add$ns(J.$index$asx(this.events, i).get$delay(), this._started));
        ++i;
      }
    }, function($receiver) {
      return this.start$1($receiver, 0);
    }, "start$0", "call$1", "call$0", "get$start", 0, 2, 973, 49, 516, [], "start"],
    stop$1: [function(_, clearEvents) {
      this.running = false;
      if (clearEvents === true)
        J.set$length$asx(this.events, 0);
    }, function($receiver) {
      return this.stop$1($receiver, true);
    }, "stop$0", "call$1", "call$0", "get$stop", 0, 2, 956, 78, 1617, [], "stop"],
    remove$1: [function(_, $event) {
      var i, t1;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.events);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$eq(J.$index$asx(this.events, i), $event)) {
          J.$index$asx(this.events, i).set$pendingDelete(true);
          return true;
        }
        ++i;
      }
      return false;
    }, "call$1", "get$remove", 2, 0, 1618, 666, [], "remove"],
    order$0: [function(_) {
      if (J.$gt$n(J.get$length$asx(this.events), 0)) {
        J.sort$1$ax(this.events, this.get$sortHandler());
        this.nextTick = J.$index$asx(this.events, 0).get$tick();
      }
    }, "call$0", "get$order", 0, 0, 54, "order"],
    sortHandler$2: [function(a, b) {
      if (J.$lt$n(a.get$tick(), b.get$tick()))
        return -1;
      else if (J.$gt$n(a.get$tick(), b.get$tick()))
        return 1;
      return 0;
    }, "call$2", "get$sortHandler", 4, 0, 959, 348, [], 349, [], "sortHandler"],
    clearPendingEvents$0: [function() {
      var t1, t2;
      this._i = J.get$length$asx(this.events);
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this.events, this._i).get$pendingDelete() === true)
          J.removeAt$1$ax(this.events, this._i);
      this._len = J.get$length$asx(this.events);
      this._i = 0;
    }, "call$0", "get$clearPendingEvents", 0, 0, 54, "clearPendingEvents"],
    callback$1: [function(events) {
      if (events.get$args() == null)
        events.callback$0();
      else
        events.callback$1(J.$index$asx(this.events, this._i).get$args());
    }, "call$1", "get$callback", 2, 0, 1618, 1619, [], "callback"],
    update$1: [function(time) {
      var t1, t2;
      if (this.paused === true)
        return true;
      t1 = J.getInterceptor$n(time);
      t2 = t1.$sub(time, this._now);
      this.elapsed = t2;
      this._now = time;
      if (J.$gt$n(t2, this.timeCap))
        this.adjustEvents$1(t1.$sub(time, this.elapsed));
      this._marked = 0;
      this.clearPendingEvents$0();
      if (this.running === true && J.$ge$n(this._now, this.nextTick) && J.$gt$n(this._len, 0)) {
        while (true) {
          if (!(J.$lt$n(this._i, this._len) && this.running === true))
            break;
          if (J.$ge$n(this._now, J.$index$asx(this.events, this._i).get$tick())) {
            t1 = J.$sub$n(J.$add$ns(this._now, J.$index$asx(this.events, this._i).get$delay()), J.$sub$n(this._now, J.$index$asx(this.events, this._i).get$tick()));
            this._newTick = t1;
            if (J.$lt$n(t1, 0))
              this._newTick = J.$add$ns(this._now, J.$index$asx(this.events, this._i).get$delay());
            if (J.$eq(J.get$loop$x(J.$index$asx(this.events, this._i)), true)) {
              J.$index$asx(this.events, this._i).set$tick(this._newTick);
              t1 = J.$index$asx(this.events, this._i);
              if (t1.get$args() == null)
                t1.callback$0();
              else
                t1.callback$1(J.$index$asx(this.events, this._i).get$args());
            } else if (J.$gt$n(J.$index$asx(this.events, this._i).get$repeatCount(), 0)) {
              t1 = J.$index$asx(this.events, this._i);
              t1.set$repeatCount(J.$sub$n(t1.get$repeatCount(), 1));
              J.$index$asx(this.events, this._i).set$tick(this._newTick);
              t1 = J.$index$asx(this.events, this._i);
              if (t1.get$args() == null)
                t1.callback$0();
              else
                t1.callback$1(J.$index$asx(this.events, this._i).get$args());
            } else {
              this._marked = J.$add$ns(this._marked, 1);
              J.$index$asx(this.events, this._i).set$pendingDelete(true);
              t1 = J.$index$asx(this.events, this._i);
              if (t1.get$args() == null)
                t1.callback$0();
              else
                t1.callback$1(J.$index$asx(this.events, this._i).get$args());
            }
            this._i = J.$add$ns(this._i, 1);
          } else
            break;
        }
        if (J.$gt$n(J.get$length$asx(this.events), this._marked))
          this.order$0(0);
        else {
          this.expired = true;
          this.onComplete.dispatch$1(this);
        }
      }
      if (this.expired === true && this.autoDestroy === true)
        return false;
      else
        return true;
    }, "call$1", "get$update", 2, 0, 1620, 727, [], "update"],
    pause$0: [function(_) {
      if (this.running !== true)
        return;
      this._codePaused = true;
      if (this.paused === true)
        return;
      this._pauseStarted = J.get$now$x(this.game.get$time());
      this.paused = true;
    }, "call$0", "get$pause", 0, 0, 54, "pause"],
    _pause$0: [function() {
      if (this.paused === true || this.running !== true)
        return;
      this._pauseStarted = J.get$now$x(this.game.get$time());
      this.paused = true;
    }, "call$0", "get$_pause", 0, 0, 54, "_pause"],
    adjustEvents$1: [function(baseTime) {
      var i, t1, t, d, t2;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.events);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(this.events, i).get$pendingDelete() !== true) {
          t = J.$sub$n(J.$index$asx(this.events, i).get$tick(), baseTime);
          if (J.$lt$n(t, 0))
            t = 0;
          J.$index$asx(this.events, i).set$tick(J.$add$ns(this._now, t));
        }
        ++i;
      }
      d = J.$sub$n(this.nextTick, baseTime);
      t1 = J.$lt$n(d, 0);
      t2 = this._now;
      if (t1)
        this.nextTick = t2;
      else
        this.nextTick = J.$add$ns(t2, d);
    }, "call$1", "get$adjustEvents", 2, 0, 620, 1621, [], "adjustEvents"],
    resume$0: [function() {
      if (this.paused !== true)
        return;
      var now = J.get$now$x(this.game.get$time());
      this._pauseTotal = J.$add$ns(this._pauseTotal, J.$sub$n(now, this._now));
      this._now = now;
      this.adjustEvents$1(this._pauseStarted);
      this.paused = false;
      this._codePaused = false;
    }, "call$0", "get$resume", 0, 0, 54, "resume"],
    _resume$0: [function() {
      if (this._codePaused === true)
        return;
      else
        this.resume$0();
    }, "call$0", "get$_resume", 0, 0, 54, "_resume"],
    removeAll$0: [function() {
      this.onComplete.removeAll$0();
      J.set$length$asx(this.events, 0);
      this._len = 0;
      this._i = 0;
    }, "call$0", "get$removeAll", 0, 0, 54, "removeAll"],
    destroy$0: [function() {
      this.onComplete.removeAll$0();
      this.running = false;
      this.events = [];
      this._len = 0;
      this._i = 0;
    }, "call$0", "get$destroy", 0, 0, 54, "destroy"],
    static: {"^": "Timer_MINUTE<-671,Timer_SECOND<-671,Timer_HALF<-671,Timer_QUARTER<-671", Timer$: [function(game, autoDestroy) {
        return new R.Timer(game, true, false, false, 0, [], H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), 0, 1000, false, false, 0, 0, 0, Date.now(), 0, 0, 0, 0, 0);
      }, null, null, 2, 2, 492, 78, 252, [], 513, [], "new Timer"]}
  },
  "+Timer": [674],
  TimerEvent: {
    "^": "Object;timer@-1606,delay@-616,tick@-616,repeatCount@-614,loop*-617,callback@-0,args@-645,pendingDelete@-617",
    timer$4: function(arg0, arg1, arg2, arg3) {
      return this.timer.call$4(arg0, arg1, arg2, arg3);
    },
    delay$1: function(arg0) {
      return this.delay.call$1(arg0);
    },
    loop$0: function($receiver) {
      return this.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return this.loop.call$3(arg0, arg1, arg2);
    },
    callback$0: function() {
      return this.callback.call$0();
    },
    callback$1: function(arg0) {
      return this.callback.call$1(arg0);
    },
    TimerEvent$7: function(timer, delay, tick, repeatCount, loop, callback, args) {
      this.timer = timer;
      this.delay = delay;
      this.tick = tick;
      this.repeatCount = J.$sub$n(repeatCount, 1);
      this.loop = loop;
      this.callback = callback;
      this.args = args;
      this.pendingDelete = false;
    },
    static: {TimerEvent$: [function(timer, delay, tick, repeatCount, loop, callback, args) {
        var t1 = new R.TimerEvent(null, null, null, null, null, null, null, null);
        t1.TimerEvent$7(timer, delay, tick, repeatCount, loop, callback, args);
        return t1;
      }, null, null, 14, 0, 514, 515, [], 516, [], 517, [], 518, [], 257, [], 26, [], 383, [], "new TimerEvent"]}
  },
  "+TimerEvent": [674],
  Linears: {
    "^": "Object;",
    get$None: [function() {
      return new R.Linears_None_closure();
    }, null, null, 1, 0, 1622, "None"],
    static: {Linears$: [function() {
        return new R.Linears();
      }, null, null, 0, 0, 519, "new Linears"]}
  },
  "+Linears": [674],
  Linears_None_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      return t;
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Quads: {
    "^": "Object;",
    get$In: [function() {
      return new R.Quads_In_closure();
    }, null, null, 1, 0, 1622, "In"],
    get$InOut: [function() {
      return new R.Quads_InOut_closure();
    }, null, null, 1, 0, 1622, "InOut"],
    get$Out: [function() {
      return new R.Quads_Out_closure();
    }, null, null, 1, 0, 1622, "Out"],
    static: {Quads$: [function() {
        return new R.Quads();
      }, null, null, 0, 0, 520, "new Quads"]}
  },
  "+Quads": [674],
  Quads_In_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      return J.$mul$ns(t, t);
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Quads_InOut_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1;
      t = J.$mul$ns(t, 2);
      t1 = J.getInterceptor$n(t);
      if (t1.$lt(t, 1)) {
        if (typeof t !== "number")
          return H.iae(t);
        return 0.5 * t * t;
      }
      t = t1.$sub(t, 1);
      t1 = J.getInterceptor$n(t);
      t1 = J.$sub$n(t1.$mul(t, t1.$sub(t, 2)), 1);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return -0.5 * t1;
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Quads_Out_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1 = J.getInterceptor$n(t);
      return J.$mul$ns(t1.$negate(t), t1.$sub(t, 2));
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Cubics: {
    "^": "Object;",
    get$In: [function() {
      return new R.Cubics_In_closure();
    }, null, null, 1, 0, 1622, "In"],
    get$InOut: [function() {
      return new R.Cubics_InOut_closure();
    }, null, null, 1, 0, 1622, "InOut"],
    get$Out: [function() {
      return new R.Cubics_Out_closure();
    }, null, null, 1, 0, 1622, "Out"],
    static: {Cubics$: [function() {
        return new R.Cubics();
      }, null, null, 0, 0, 521, "new Cubics"]}
  },
  "+Cubics": [674],
  Cubics_In_closure: {
    "^": "Closure:620;",
    call$1: [function(time) {
      return J.$mul$ns(J.$mul$ns(time, time), time);
    }, "call$1", null, 2, 0, 620, 727, [], "call"]
  },
  Cubics_InOut_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1;
      t = J.$mul$ns(t, 2);
      t1 = J.getInterceptor$n(t);
      if (t1.$lt(t, 1)) {
        if (typeof t !== "number")
          return H.iae(t);
        return 0.5 * t * t * t;
      }
      t = t1.$sub(t, 2);
      t1 = J.$add$ns(J.$mul$ns(J.$mul$ns(t, t), t), 2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 0.5 * t1;
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Cubics_Out_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      t = J.$sub$n(t, 1);
      return J.$add$ns(J.$mul$ns(J.$mul$ns(t, t), t), 1);
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Quarts: {
    "^": "Object;",
    get$In: [function() {
      return new R.Quarts_In_closure();
    }, null, null, 1, 0, 1622, "In"],
    get$InOut: [function() {
      return new R.Quarts_InOut_closure();
    }, null, null, 1, 0, 1622, "InOut"],
    get$Out: [function() {
      return new R.Quarts_Out_closure();
    }, null, null, 1, 0, 1622, "Out"],
    static: {Quarts$: [function() {
        return new R.Quarts();
      }, null, null, 0, 0, 522, "new Quarts"]}
  },
  "+Quarts": [674],
  Quarts_In_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      return J.$mul$ns(J.$mul$ns(J.$mul$ns(t, t), t), t);
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Quarts_InOut_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1;
      t = J.$mul$ns(t, 2);
      t1 = J.getInterceptor$n(t);
      if (t1.$lt(t, 1)) {
        if (typeof t !== "number")
          return H.iae(t);
        return 0.5 * t * t * t * t;
      }
      t = t1.$sub(t, 2);
      t1 = J.$sub$n(J.$mul$ns(J.$mul$ns(J.$mul$ns(t, t), t), t), 2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return -0.5 * t1;
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Quarts_Out_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      t = J.$sub$n(t, 1);
      return J.$negate$n(J.$sub$n(J.$mul$ns(J.$mul$ns(J.$mul$ns(t, t), t), t), 1));
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Circs: {
    "^": "Object;",
    get$In: [function() {
      return new R.Circs_In_closure();
    }, null, null, 1, 0, 1622, "In"],
    get$InOut: [function() {
      return new R.Circs_InOut_closure();
    }, null, null, 1, 0, 1622, "InOut"],
    get$Out: [function() {
      return new R.Circs_Out_closure();
    }, null, null, 1, 0, 1622, "Out"],
    static: {Circs$: [function() {
        return new R.Circs();
      }, null, null, 0, 0, 523, "new Circs"]}
  },
  "+Circs": [674],
  Circs_In_closure: {
    "^": "Closure:620;",
    call$1: [function(time) {
      var t1 = J.$mul$ns(time, time);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return -Math.sqrt(H.checkNum(1 - t1)) - 1;
    }, "call$1", null, 2, 0, 620, 727, [], "call"]
  },
  Circs_InOut_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1;
      t = J.$mul$ns(t, 2);
      t1 = J.getInterceptor$n(t);
      if (t1.$lt(t, 1)) {
        t1 = t1.$mul(t, t);
        if (typeof t1 !== "number")
          return H.iae(t1);
        return -0.5 * (Math.sqrt(H.checkNum(1 - t1)) - 1);
      }
      t = t1.$sub(t, 2);
      t1 = J.$mul$ns(t, t);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 0.5 * (Math.sqrt(H.checkNum(1 - t1)) + 1);
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Circs_Out_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1;
      t = J.$sub$n(t, 1);
      t1 = J.$mul$ns(t, t);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return Math.sqrt(H.checkNum(1 - t1));
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Sines: {
    "^": "Object;",
    get$In: [function() {
      return new R.Sines_In_closure();
    }, null, null, 1, 0, 1622, "In"],
    get$InOut: [function() {
      return new R.Sines_InOut_closure();
    }, null, null, 1, 0, 1622, "InOut"],
    get$Out: [function() {
      return new R.Sines_Out_closure();
    }, null, null, 1, 0, 1622, "Out"],
    static: {Sines$: [function() {
        return new R.Sines();
      }, null, null, 0, 0, 524, "new Sines"]}
  },
  "+Sines": [674],
  Sines_In_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      return -Math.cos(H.checkNum(J.$mul$ns(t, 1.5707963267948966))) + 1;
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Sines_InOut_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      if (typeof t !== "number")
        return H.iae(t);
      return -0.5 * (Math.cos(H.checkNum(3.141592653589793 * t)) - 1);
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Sines_Out_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      return Math.sin(H.checkNum(J.$mul$ns(t, 1.5707963267948966)));
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Expos: {
    "^": "Object;",
    get$In: [function() {
      return new R.Expos_In_closure();
    }, null, null, 1, 0, 1622, "In"],
    get$InOut: [function() {
      return new R.Expos_InOut_closure();
    }, null, null, 1, 0, 1622, "InOut"],
    get$Out: [function() {
      return new R.Expos_Out_closure();
    }, null, null, 1, 0, 1622, "Out"],
    static: {Expos$: [function() {
        return new R.Expos();
      }, null, null, 0, 0, 525, "new Expos"]}
  },
  "+Expos": [674],
  Expos_In_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1 = J.getInterceptor(t);
      if (t1.$eq(t, 0))
        t1 = 0;
      else {
        t1 = t1.$sub(t, 1);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = 10 * t1;
        H.checkNum(2);
        H.checkNum(t1);
        t1 = Math.pow(2, t1);
      }
      return t1;
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Expos_InOut_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1 = J.getInterceptor(t);
      if (t1.$eq(t, 0))
        return 0;
      if (t1.$eq(t, 1))
        return 1;
      t = t1.$mul(t, 2);
      t1 = J.getInterceptor$n(t);
      if (t1.$lt(t, 1)) {
        t1 = t1.$sub(t, 1);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = 10 * t1;
        H.checkNum(2);
        H.checkNum(t1);
        return 0.5 * Math.pow(2, t1);
      }
      t = t1.$sub(t, 1);
      if (typeof t !== "number")
        return H.iae(t);
      t1 = -10 * t;
      H.checkNum(2);
      H.checkNum(t1);
      return 0.5 * (-Math.pow(2, t1) + 2);
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Expos_Out_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1;
      if (J.$eq(t, 1))
        t1 = 1;
      else {
        if (typeof t !== "number")
          return H.iae(t);
        t1 = -10 * t;
        H.checkNum(2);
        H.checkNum(t1);
        t1 = -Math.pow(2, t1) + 1;
      }
      return t1;
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Backs: {
    "^": "Object;",
    get$In: [function() {
      return new R.Backs_In_closure();
    }, null, null, 1, 0, 1622, "In"],
    get$InOut: [function() {
      return new R.Backs_InOut_closure();
    }, null, null, 1, 0, 1622, "InOut"],
    get$Out: [function() {
      return new R.Backs_Out_closure();
    }, null, null, 1, 0, 1622, "Out"],
    static: {"^": "Backs__param_s<-616", Backs$: [function() {
        return new R.Backs();
      }, null, null, 0, 0, 526, "new Backs"]}
  },
  "+Backs": [674],
  Backs_In_closure: {
    "^": "Closure:620;",
    call$1: [function(time) {
      var t1 = J.$mul$ns(time, time);
      if (typeof time !== "number")
        return H.iae(time);
      return J.$mul$ns(t1, 2.70158 * time - 1.70158);
    }, "call$1", null, 2, 0, 620, 727, [], "call"]
  },
  Backs_InOut_closure: {
    "^": "Closure:620;",
    call$1: [function(time) {
      var t1;
      time = J.$mul$ns(time, 2);
      t1 = J.getInterceptor$n(time);
      if (t1.$lt(time, 1)) {
        t1 = t1.$mul(time, time);
        if (typeof time !== "number")
          return H.iae(time);
        t1 = J.$mul$ns(t1, 3.5949095 * time - 2.5949095);
        if (typeof t1 !== "number")
          return H.iae(t1);
        return 0.5 * t1;
      }
      time = t1.$sub(time, 2);
      t1 = J.$mul$ns(time, time);
      if (typeof time !== "number")
        return H.iae(time);
      t1 = J.$add$ns(J.$mul$ns(t1, 3.5949095 * time + 2.5949095), 2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 0.5 * t1;
    }, "call$1", null, 2, 0, 620, 727, [], "call"]
  },
  Backs_Out_closure: {
    "^": "Closure:620;",
    call$1: [function(time) {
      var t1;
      time = J.$sub$n(time, 1);
      t1 = J.$mul$ns(time, time);
      if (typeof time !== "number")
        return H.iae(time);
      return J.$add$ns(J.$mul$ns(t1, 2.70158 * time + 1.70158), 1);
    }, "call$1", null, 2, 0, 620, 727, [], "call"]
  },
  Bounces: {
    "^": "Object;",
    get$In: [function() {
      return new R.Bounces_In_closure(this);
    }, null, null, 1, 0, 1622, "In"],
    In$1: function(arg0) {
      return this.get$In().call$1(arg0);
    },
    get$InOut: [function() {
      return new R.Bounces_InOut_closure(this);
    }, null, null, 1, 0, 1622, "InOut"],
    get$Out: [function() {
      return new R.Bounces_Out_closure();
    }, null, null, 1, 0, 1622, "Out"],
    Out$1: function(arg0) {
      return this.get$Out().call$1(arg0);
    },
    static: {Bounces$: [function() {
        return new R.Bounces();
      }, null, null, 0, 0, 527, "new Bounces"]}
  },
  "+Bounces": [674],
  Bounces_In_closure: {
    "^": "Closure:620;this_0",
    call$1: [function(time) {
      var t1;
      if (typeof time !== "number")
        return H.iae(time);
      t1 = this.this_0.Out$1(1 - time);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 1 - t1;
    }, "call$1", null, 2, 0, 620, 727, [], "call"]
  },
  Bounces_InOut_closure: {
    "^": "Closure:620;this_0",
    call$1: [function(t) {
      var t1, t2;
      t1 = J.getInterceptor$n(t);
      t2 = this.this_0;
      if (t1.$lt(t, 0.5))
        return J.$mul$ns(t2.In$1(t1.$mul(t, 2)), 0.5);
      else
        return J.$add$ns(J.$mul$ns(t2.Out$1(J.$sub$n(t1.$mul(t, 2), 1)), 0.5), 0.5);
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Bounces_Out_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1 = J.getInterceptor$n(t);
      if (t1.$lt(t, 0.36363636363636365)) {
        if (typeof t !== "number")
          return H.iae(t);
        return 7.5625 * t * t;
      } else if (t1.$lt(t, 0.7272727272727273)) {
        t = t1.$sub(t, 0.5454545454545454);
        if (typeof t !== "number")
          return H.iae(t);
        return 7.5625 * t * t + 0.75;
      } else if (t1.$lt(t, 0.9090909090909091)) {
        t = t1.$sub(t, 0.8181818181818182);
        if (typeof t !== "number")
          return H.iae(t);
        return 7.5625 * t * t + 0.9375;
      } else {
        t = t1.$sub(t, 0.9545454545454546);
        if (typeof t !== "number")
          return H.iae(t);
        return 7.5625 * t * t + 0.984375;
      }
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Elastics: {
    "^": "Object;",
    get$In: [function() {
      return new R.Elastics_In_closure();
    }, null, null, 1, 0, 1622, "In"],
    get$InOut: [function() {
      return new R.Elastics_InOut_closure();
    }, null, null, 1, 0, 1622, "InOut"],
    get$Out: [function() {
      return new R.Elastics_Out_closure();
    }, null, null, 1, 0, 1622, "Out"],
    static: {Elastics$: [function() {
        return new R.Elastics();
      }, null, null, 0, 0, 528, "new Elastics"]}
  },
  "+Elastics": [674],
  Elastics_In_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1 = J.getInterceptor(t);
      if (t1.$eq(t, 0))
        return 0;
      if (t1.$eq(t, 1))
        return 1;
      t = t1.$sub(t, 1);
      if (typeof t !== "number")
        return H.iae(t);
      t1 = 10 * t;
      H.checkNum(2);
      H.checkNum(t1);
      return -(Math.pow(2, t1) * Math.sin(H.checkNum((t - 0.075) * 6.283185307179586 / 0.3)));
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Elastics_InOut_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1 = J.getInterceptor(t);
      if (t1.$eq(t, 0))
        return 0;
      t = t1.$mul(t, 2);
      t1 = J.getInterceptor(t);
      if (t1.$eq(t, 2))
        return 1;
      if (t1.$lt(t, 1)) {
        t = t1.$sub(t, 1);
        if (typeof t !== "number")
          return H.iae(t);
        t1 = 10 * t;
        H.checkNum(2);
        H.checkNum(t1);
        return -0.5 * (Math.pow(2, t1) * Math.sin(H.checkNum((t - 0.11249999999999999) * 6.283185307179586 / 0.44999999999999996)));
      }
      t = t1.$sub(t, 1);
      if (typeof t !== "number")
        return H.iae(t);
      t1 = -10 * t;
      H.checkNum(2);
      H.checkNum(t1);
      return Math.pow(2, t1) * Math.sin(H.checkNum((t - 0.11249999999999999) * 6.283185307179586 / 0.44999999999999996)) * 0.5 + 1;
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Elastics_Out_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1 = J.getInterceptor(t);
      if (t1.$eq(t, 0))
        return 0;
      if (t1.$eq(t, 1))
        return 1;
      if (typeof t !== "number")
        return H.iae(t);
      t1 = -10 * t;
      H.checkNum(2);
      H.checkNum(t1);
      return Math.pow(2, t1) * Math.sin(H.checkNum((t - 0.075) * 6.283185307179586 / 0.3)) + 1;
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Quints: {
    "^": "Object;",
    get$In: [function() {
      return new R.Quints_In_closure();
    }, null, null, 1, 0, 1622, "In"],
    get$InOut: [function() {
      return new R.Quints_InOut_closure();
    }, null, null, 1, 0, 1622, "InOut"],
    get$Out: [function() {
      return new R.Quints_Out_closure();
    }, null, null, 1, 0, 1622, "Out"],
    static: {Quints$: [function() {
        return new R.Quints();
      }, null, null, 0, 0, 529, "new Quints"]}
  },
  "+Quints": [674],
  Quints_In_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      return J.$mul$ns(J.$mul$ns(J.$mul$ns(J.$mul$ns(t, t), t), t), t);
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Quints_InOut_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      var t1;
      t = J.$mul$ns(t, 2);
      t1 = J.getInterceptor$n(t);
      if (t1.$lt(t, 1)) {
        if (typeof t !== "number")
          return H.iae(t);
        return 0.5 * t * t * t * t * t;
      }
      t = t1.$sub(t, 2);
      t1 = J.$add$ns(J.$mul$ns(J.$mul$ns(J.$mul$ns(J.$mul$ns(t, t), t), t), t), 2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 0.5 * t1;
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Quints_Out_closure: {
    "^": "Closure:620;",
    call$1: [function(t) {
      t = J.$sub$n(t, 1);
      return J.$add$ns(J.$mul$ns(J.$mul$ns(J.$mul$ns(J.$mul$ns(t, t), t), t), t), 1);
    }, "call$1", null, 2, 0, 620, 423, [], "call"]
  },
  Easing: {
    "^": "Object;",
    static: {"^": "Easing_Default@-1623,Easing_Linear<-1624,Easing_Quadratic<-1625,Easing_Cubic<-1626,Easing_Quartic<-1627,Easing_Circ<-1628,Easing_Quintic<-1629,Easing_Sinusoidal<-1630,Easing_Exponential<-1631,Easing_Back<-1632,Easing_Bounce<-1633,Easing_Elastic<-1634", Easing$: [function() {
        return new R.Easing();
      }, null, null, 0, 0, 530, "new Easing"]}
  },
  "+Easing": [674],
  Tween: {
    "^": "Object;_object<-12,game<-613,_manager@-1043,_valuesStart@-783,_valuesEnd@-783,_valuesStartRepeat@-783,_Phaser$_duration@-616,_repeat@-614,_yoyo@-617,_reversed@-617,_delayTime@-616,_startTime@-616,_easingFunction@-1623,_interpolationFunction@-0,_chainedTweens@-1635,_onStartCallbackFired@-617,_onUpdateCallback@-0,_onUpdateCallbackContext@-12,_paused@-617,_pausedTime@-616,_codePaused@-617,pendingDelete@-617,onStart@-1636,onLoop@-1636,onComplete*-1636,isRunning@-617,_Phaser$_parent@-1637,_lastChild@-1637",
    _easingFunction$1: function(arg0) {
      return this._easingFunction.call$1(arg0);
    },
    _interpolationFunction$2: function(arg0, arg1) {
      return this._interpolationFunction.call$2(arg0, arg1);
    },
    to$7: [function(properties, duration, ease, autoStart, delay, repeat, yoyo) {
      var $self;
      if (yoyo === true && J.$eq(repeat, 0))
        repeat = 1;
      if (this._Phaser$_parent != null) {
        $self = this._manager.create$1(this._object);
        this._lastChild.chain$1($self);
        this._lastChild = $self;
      } else {
        this._Phaser$_parent = this;
        this._lastChild = this;
        $self = this;
      }
      $self.set$_repeat(repeat);
      $self.set$_Phaser$_duration(J.toDouble$0$n(duration));
      $self.set$_valuesEnd(properties);
      if (ease != null)
        $self.set$_easingFunction(ease);
      if (J.$gt$n(delay, 0))
        $self.set$_delayTime(delay);
      $self.set$_yoyo(yoyo);
      if (autoStart === true)
        return this.start$0(0);
      else
        return this;
    }, function(properties, duration, ease) {
      return this.to$7(properties, duration, ease, false, 0, 0, false);
    }, "to$3", function(properties, duration, ease, autoStart) {
      return this.to$7(properties, duration, ease, autoStart, 0, 0, false);
    }, "to$4", function(properties) {
      return this.to$7(properties, 1000, null, false, 0, 0, false);
    }, "to$1", function(properties, duration) {
      return this.to$7(properties, duration, null, false, 0, 0, false);
    }, "to$2", function(properties, duration, ease, autoStart, delay, repeat) {
      return this.to$7(properties, duration, ease, autoStart, delay, repeat, false);
    }, "to$6", function(properties, duration, ease, autoStart, delay) {
      return this.to$7(properties, duration, ease, autoStart, delay, 0, false);
    }, "to$5", "call$7", "call$3", "call$4", "call$1", "call$2", "call$6", "call$5", "get$to", 2, 12, 1638, 1525, 12, 19, 49, 49, 19, 512, [], 94, [], 1490, [], 1097, [], 516, [], 1639, [], 1491, [], "to"],
    from$7: [function(properties, duration, ease, autoStart, delay, repeat, yoyo) {
      var _cache, instance, t1, t2, prop, t3, t4;
      _cache = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      instance = H.reflect(this._object);
      for (t1 = J.getInterceptor$x(properties), t2 = J.get$iterator$ax(t1.get$keys(properties)); t2.moveNext$0();) {
        prop = t2.get$current();
        t3 = H.Symbol_validatePublicSymbol(prop);
        _cache.$indexSet(0, prop, instance.getField$1(new H.Symbol(H.Symbol_validatePublicSymbol(prop))).get$reflectee());
        t4 = t1.$index(properties, prop);
        instance._invoke$4(new H.Symbol(t3), 2, [t4], C.Map_empty);
        H.reflect(t4);
      }
      return this.to$7(_cache, duration, ease, autoStart, delay, repeat, yoyo);
    }, function(properties) {
      return this.from$7(properties, 1000, null, false, 0, 0, false);
    }, "from$1", function(properties, duration) {
      return this.from$7(properties, duration, null, false, 0, 0, false);
    }, "from$2", function(properties, duration, ease) {
      return this.from$7(properties, duration, ease, false, 0, 0, false);
    }, "from$3", function(properties, duration, ease, autoStart) {
      return this.from$7(properties, duration, ease, autoStart, 0, 0, false);
    }, "from$4", function(properties, duration, ease, autoStart, delay, repeat) {
      return this.from$7(properties, duration, ease, autoStart, delay, repeat, false);
    }, "from$6", function(properties, duration, ease, autoStart, delay) {
      return this.from$7(properties, duration, ease, autoStart, delay, 0, false);
    }, "from$5", "call$7", "call$1", "call$2", "call$3", "call$4", "call$6", "call$5", "get$from", 2, 12, 1640, 1525, 12, 19, 49, 49, 19, 512, [], 94, [], 1490, [], 1097, [], 516, [], 1639, [], 1491, [], "from"],
    start$0: [function(_) {
      var t1, instance, t2, t3, property, t4, t5;
      t1 = this.game;
      if (t1 == null || this._object == null)
        return;
      J.add$1$ax(this._manager, this);
      this.isRunning = true;
      this._onStartCallbackFired = false;
      this._startTime = J.$add$ns(J.get$now$x(t1.get$time()), this._delayTime);
      t1 = this._object;
      instance = H.reflect(t1);
      for (t2 = J.get$iterator$ax(J.get$keys$x(this._valuesEnd)), t3 = J.getInterceptor$asx(t1); t2.moveNext$0();) {
        property = t2.get$current();
        if (!!J.getInterceptor(J.$index$asx(this._valuesEnd, property)).$isList) {
          if (J.$eq(J.get$length$asx(J.$index$asx(this._valuesEnd, property)), 0))
            continue;
          C.JSArray_methods.addAll$1([t3.$index(t1, property)], J.$index$asx(this._valuesEnd, property));
        }
        t4 = H.Symbol_validatePublicSymbol(property);
        J.$indexSet$ax(this._valuesStart, property, instance.getField$1(new H.Symbol(t4)).get$reflectee());
        if (!J.getInterceptor(J.$index$asx(this._valuesStart, property)).$isList) {
          t4 = this._valuesStart;
          t5 = J.getInterceptor$asx(t4);
          t5.$indexSet(t4, property, J.$mul$ns(t5.$index(t4, property), 1));
        }
        J.$indexSet$ax(this._valuesStartRepeat, property, J.$index$asx(this._valuesStart, property));
      }
      return this;
    }, "call$0", "get$start", 0, 0, 54, "start"],
    generateData$2: [function(frameRate, data) {
      var t1, t2, t3, property, t4, t5, total, tick, output, time, total0, elapsed, value, blob, start, end;
      if (this.game == null || this._object == null)
        return;
      this._startTime = 0;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._valuesEnd)), t2 = this._object, t3 = J.getInterceptor$asx(t2); t1.moveNext$0();) {
        property = t1.get$current();
        if (!!J.getInterceptor(J.$index$asx(this._valuesEnd, property)).$isList) {
          if (J.$eq(J.get$length$asx(J.$index$asx(this._valuesEnd, property)), 0))
            continue;
          C.JSArray_methods.addAll$1([t3.$index(t2, property)], J.$index$asx(this._valuesEnd, property));
        }
        J.$indexSet$ax(this._valuesStart, property, t3.$index(t2, property));
        if (!J.getInterceptor(J.$index$asx(this._valuesStart, property)).$isList) {
          t4 = this._valuesStart;
          t5 = J.getInterceptor$asx(t4);
          t5.$indexSet(t4, property, J.$mul$ns(t5.$index(t4, property), 1));
        }
        J.$indexSet$ax(this._valuesStartRepeat, property, J.$index$asx(this._valuesStart, property));
      }
      total = J.floor$0$n(J.$mul$ns(frameRate, J.$div$n(this._Phaser$_duration, 1000)));
      tick = J.$div$n(this._Phaser$_duration, total);
      output = [];
      time = 0;
      while (true) {
        if (typeof total !== "number")
          return total.$sub();
        total0 = total - 1;
        if (!(total >= 0))
          break;
        t1 = this._startTime;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = this._Phaser$_duration;
        if (typeof t2 !== "number")
          return H.iae(t2);
        elapsed = (time - t1) / t2;
        value = this._easingFunction$1(elapsed > 1 ? 1 : elapsed);
        blob = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        for (t1 = J.get$iterator$ax(J.get$keys$x(this._valuesEnd)); t1.moveNext$0();) {
          property = t1.get$current();
          start = J.$index$asx(this._valuesStart, property);
          end = J.$index$asx(this._valuesEnd, property);
          if (!!J.getInterceptor(end).$isList)
            blob.$indexSet(0, property, this._interpolationFunction$2(end, value));
          else {
            if (typeof end === "string")
              end = J.$add$ns(start, H.Primitives_parseDouble(end, null));
            if (typeof end === "number") {
              if (typeof start !== "number")
                return H.iae(start);
              if (typeof value !== "number")
                return H.iae(value);
              blob.$indexSet(0, property, start + (end - start) * value);
            }
          }
        }
        output.push(blob);
        if (typeof tick !== "number")
          return H.iae(tick);
        time += tick;
        total = total0;
      }
      blob = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._valuesEnd)); t1.moveNext$0();) {
        property = t1.get$current();
        blob.$indexSet(0, property, J.$index$asx(this._valuesEnd, property));
      }
      output.push(blob);
      if (this._yoyo === true)
        C.JSArray_methods.addAll$1(output, H.setRuntimeTypeInfo(new H.ReversedListIterable(output), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(output, 0)]), 0)]));
      if (data != null) {
        J.addAll$1$ax(data, output);
        return data;
      } else
        return output;
    }, function(frameRate) {
      return this.generateData$2(frameRate, null);
    }, "generateData$1", function() {
      return this.generateData$2(60, null);
    }, "generateData$0", "call$2", "call$1", "call$0", "get$generateData", 0, 4, 1641, 251, 12, 256, [], 87, [], "generateData"],
    stop$0: [function(_) {
      this.isRunning = false;
      this._onUpdateCallback = null;
      J.remove$1$ax(this._manager, this);
      return this;
    }, "call$0", "get$stop", 0, 0, 54, "stop"],
    delay$1: [function(amount) {
      this._delayTime = amount;
      return this;
    }, "call$1", "get$delay", 2, 0, 102, 411, [], "delay"],
    repeat$1: [function(_, times) {
      this._repeat = times;
      return this;
    }, "call$1", "get$repeat", 2, 0, 102, 1642, [], "repeat"],
    yoyo$1: [function(yoyo) {
      this._yoyo = yoyo;
      if (yoyo === true && J.$eq(this._repeat, 0))
        this._repeat = 1;
      return this;
    }, "call$1", "get$yoyo", 2, 0, 102, 1491, [], "yoyo"],
    easing$1: [function(easing) {
      this._easingFunction = easing;
      return this;
    }, "call$1", "get$easing", 2, 0, 102, 1643, [], "easing"],
    interpolation$1: [function(interpolation) {
      this._interpolationFunction = interpolation;
      return this;
    }, "call$1", "get$interpolation", 2, 0, 102, 1644, [], "interpolation"],
    chainTweens$1: [function(tweens) {
      this._chainedTweens = tweens;
      return this;
    }, "call$1", "get$chainTweens", 2, 0, 1645, 1646, [], "chainTweens"],
    chain$1: [function(tween) {
      this._chainedTweens = [tween];
      return this;
    }, "call$1", "get$chain", 2, 0, 1647, 1648, [], "chain"],
    loop$0: [function(_) {
      this._lastChild.chain$1(this);
      return this;
    }, "call$0", "get$loop", 0, 0, 54, "loop"],
    onUpdateCallback$2: [function(callback, callbackContext) {
      this._onUpdateCallback = callback;
      this._onUpdateCallbackContext = callbackContext;
      return this;
    }, "call$2", "get$onUpdateCallback", 4, 0, 959, 26, [], 1649, [], "onUpdateCallback"],
    pause$0: [function(_) {
      this._codePaused = true;
      this._paused = true;
      this._pausedTime = J.get$now$x(this.game.get$time());
    }, "call$0", "get$pause", 0, 0, 54, "pause"],
    _pause$0: [function() {
      if (this._codePaused !== true) {
        this._paused = true;
        this._pausedTime = J.get$now$x(this.game.get$time());
      }
    }, "call$0", "get$_pause", 0, 0, 54, "_pause"],
    resume$0: [function() {
      if (this._paused === true) {
        this._paused = false;
        this._codePaused = false;
        this._startTime = J.$add$ns(this._startTime, J.$sub$n(J.get$now$x(this.game.get$time()), this._pausedTime));
      }
    }, "call$0", "get$resume", 0, 0, 54, "resume"],
    _resume$0: [function() {
      if (this._codePaused === true)
        return;
      else {
        this._startTime = J.$add$ns(this._startTime, this.game.get$time().get$pauseDuration());
        this._paused = false;
      }
    }, "call$0", "get$_resume", 0, 0, 54, "_resume"],
    update$1: [function(time) {
      var t1, elapsed, value, t2, t3, t4, property, start, end, instance, t5, t6, tmp, numChainedTweens, i;
      if (this.pendingDelete === true)
        return false;
      if (this._paused === true || J.$lt$n(time, this._startTime))
        return true;
      t1 = J.getInterceptor$n(time);
      if (t1.$lt(time, this._startTime))
        return true;
      if (J.$eq(this._onStartCallbackFired, false)) {
        this.onStart.dispatch$1(this._object);
        this._onStartCallbackFired = true;
      }
      elapsed = J.$div$n(t1.$sub(time, this._startTime), this._Phaser$_duration);
      if (J.$gt$n(elapsed, 1))
        elapsed = 1;
      value = this._easingFunction$1(elapsed);
      for (t2 = J.get$iterator$ax(J.get$keys$x(this._valuesEnd)), t3 = this._object, t4 = J.getInterceptor$ax(t3); t2.moveNext$0();) {
        property = t2.get$current();
        start = J.$index$asx(this._valuesStart, property);
        end = J.$index$asx(this._valuesEnd, property);
        if (!!J.getInterceptor(end).$isList)
          t4.$indexSet(t3, property, this._interpolationFunction$2(end, value));
        else {
          if (typeof end === "string")
            end = J.$add$ns(start, H.Primitives_parseDouble(end, null));
          if (typeof end === "number") {
            instance = H.reflect(t3);
            t5 = H.Symbol_validatePublicSymbol(property);
            if (typeof start !== "number")
              return H.iae(start);
            if (typeof value !== "number")
              return H.iae(value);
            t6 = start + (end - start) * value;
            instance._invoke$4(new H.Symbol(t5), 2, [t6], C.Map_empty);
            H.reflect(t6);
          }
        }
      }
      t2 = this._onUpdateCallback;
      if (t2 != null) {
        t2.call$3(this._onUpdateCallbackContext, this, value);
        if (this.isRunning !== true)
          return false;
      }
      if (J.$eq(elapsed, 1))
        if (J.$gt$n(this._repeat, 0)) {
          this._repeat = J.$sub$n(this._repeat, 1);
          for (t2 = J.get$iterator$ax(J.get$keys$x(this._valuesStartRepeat)); t2.moveNext$0();) {
            property = t2.get$current();
            t4 = J.$index$asx(this._valuesEnd, property);
            if (typeof t4 === "string") {
              t4 = this._valuesStartRepeat;
              t5 = J.getInterceptor$asx(t4);
              t5.$indexSet(t4, property, J.$add$ns(t5.$index(t4, property), H.Primitives_parseDouble(J.$index$asx(this._valuesEnd, property), null)));
            }
            if (this._yoyo === true) {
              tmp = J.$index$asx(this._valuesStartRepeat, property);
              J.$indexSet$ax(this._valuesStartRepeat, property, J.$index$asx(this._valuesEnd, property));
              J.$indexSet$ax(this._valuesEnd, property, tmp);
            }
            J.$indexSet$ax(this._valuesStart, property, J.$index$asx(this._valuesStartRepeat, property));
          }
          if (this._yoyo === true)
            this._reversed = this._reversed !== true;
          this._startTime = t1.$add(time, this._delayTime);
          this.onLoop.dispatch$1(t3);
          return true;
        } else {
          this.isRunning = false;
          this.onComplete.dispatch$1(t3);
          numChainedTweens = J.get$length$asx(this._chainedTweens);
          if (typeof numChainedTweens !== "number")
            return H.iae(numChainedTweens);
          i = 0;
          for (; i < numChainedTweens; ++i)
            J.start$0$x(J.$index$asx(this._chainedTweens, i));
          return false;
        }
      return true;
    }, "call$1", "get$update", 2, 0, 1620, 727, [], "update"],
    $isTween: true,
    static: {Tween$: [function(_object, game, _manager) {
        return new R.Tween(_object, game, _manager, P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), 1000, 0, false, false, 0, null, $.get$Easing_Default(), R.Math_linearInterpolation$closure(), [], false, null, null, false, 0, false, false, H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), false, null, null);
      }, null, null, 4, 2, 531, 12, 532, [], 252, [], 533, [], "new Tween"]}
  },
  "+Tween": [674],
  TweenManager: {
    "^": "Object;game<-613,_tweens<-1635,_Phaser$_add<-1635",
    getAll$0: [function() {
      return this._tweens;
    }, "call$0", "get$getAll", 0, 0, 54, "getAll"],
    removeAll$0: [function() {
      var t1, t2, i, t3;
      t1 = this._tweens;
      t2 = J.getInterceptor$asx(t1);
      i = 0;
      while (true) {
        t3 = t2.get$length(t1);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        t2.$index(t1, i).set$pendingDelete(true);
        ++i;
      }
      J.clear$0$ax(this._Phaser$_add);
    }, "call$0", "get$removeAll", 0, 0, 54, "removeAll"],
    add$1: [function(_, tween) {
      tween.set$_manager(this);
      J.add$1$ax(this._Phaser$_add, tween);
      return tween;
    }, "call$1", "get$add", 2, 0, 1647, 1648, [], "add"],
    create$1: [function(object) {
      return new R.Tween(object, this.game, this, P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), 1000, 0, false, false, 0, null, $.get$Easing_Default(), R.Math_linearInterpolation$closure(), [], false, null, null, false, 0, false, false, H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), false, null, null);
    }, "call$1", "get$create", 2, 0, 1172, 584, [], "create"],
    remove$1: [function(_, tween) {
      var t1, t2, i;
      t1 = this._tweens;
      t2 = J.getInterceptor$asx(t1);
      i = t2.indexOf$1(t1, tween);
      if (!J.$eq(i, -1))
        t2.$index(t1, i).set$pendingDelete(true);
    }, "call$1", "get$remove", 2, 0, 1650, 1648, [], "remove"],
    update$0: [function() {
      var t1, t2, numTweens, t3, i, t4;
      t1 = this._tweens;
      t2 = J.getInterceptor$asx(t1);
      if (J.$eq(t2.get$length(t1), 0) && J.$eq(J.get$length$asx(this._Phaser$_add), 0))
        return false;
      numTweens = t2.get$length(t1);
      t3 = this.game;
      i = 0;
      while (true) {
        if (typeof numTweens !== "number")
          return H.iae(numTweens);
        if (!(i < numTweens))
          break;
        if (t2.$index(t1, i).update$1(J.get$now$x(t3.get$time())) === true)
          ++i;
        else {
          t2.removeAt$1(t1, i);
          --numTweens;
        }
      }
      t3 = this._Phaser$_add;
      t4 = J.getInterceptor$asx(t3);
      if (J.$gt$n(t4.get$length(t3), 0)) {
        t2.addAll$1(t1, t3);
        t4.set$length(t3, 0);
      }
      return true;
    }, "call$0", "get$update", 0, 0, 247, "update"],
    isTweening$1: [function(object) {
      return J.any$1$ax(this._tweens, new R.TweenManager_isTweening_closure(object));
    }, "call$1", "get$isTweening", 2, 0, 1004, 584, [], "isTweening"],
    _pauseAll$0: [function() {
      var t1, t2, i, t3;
      for (t1 = this._tweens, t2 = J.getInterceptor$asx(t1), i = J.$sub$n(t2.get$length(t1), 1); t3 = J.getInterceptor$n(i), t3.$ge(i, 0); i = t3.$sub(i, 1))
        t2.$index(t1, i)._pause$0();
    }, "call$0", "get$_pauseAll", 0, 0, 54, "_pauseAll"],
    _resumeAll$0: [function() {
      var t1, t2, i, t3;
      for (t1 = this._tweens, t2 = J.getInterceptor$asx(t1), i = J.$sub$n(t2.get$length(t1), 1); t3 = J.getInterceptor$n(i), t3.$ge(i, 0); i = t3.$sub(i, 1))
        t2.$index(t1, i)._resume$0();
    }, "call$0", "get$_resumeAll", 0, 0, 54, "_resumeAll"],
    pauseAll$0: [function() {
      var t1, t2, i, t3;
      for (t1 = this._tweens, t2 = J.getInterceptor$asx(t1), i = J.$sub$n(t2.get$length(t1), 1); t3 = J.getInterceptor$n(i), t3.$ge(i, 0); i = t3.$sub(i, 1))
        J.pause$0$x(t2.$index(t1, i));
    }, "call$0", "get$pauseAll", 0, 0, 54, "pauseAll"],
    resumeAll$0: [function() {
      var t1, t2, i, t3;
      for (t1 = this._tweens, t2 = J.getInterceptor$asx(t1), i = J.$sub$n(t2.get$length(t1), 1); t3 = J.getInterceptor$n(i), t3.$ge(i, 0); i = t3.$sub(i, 1))
        t2.$index(t1, i).resume$0();
    }, "call$0", "get$resumeAll", 0, 0, 54, "resumeAll"],
    TweenManager$1: function(game) {
      var t1 = this.game;
      J.add$1$ax(J.get$onPause$x(t1), this.get$_pauseAll());
      J.add$1$ax(t1.get$onResume(), this.get$_resumeAll());
    },
    static: {TweenManager$: [function(game) {
        var t1 = new R.TweenManager(game, [], []);
        t1.TweenManager$1(game);
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new TweenManager"]}
  },
  "+TweenManager": [674],
  TweenManager_isTweening_closure: {
    "^": "Closure:1650;object_0",
    call$1: [function(tween) {
      return J.$eq(tween.get$_object(), this.object_0);
    }, "call$1", null, 2, 0, 1650, 1648, [], "call"]
  },
  Color: {
    "^": "Object;r*-614,g@-614,b@-614,a*-614,red@-614,green@-614,blue@-614,alpha*-614,color*-614,rgba@-644,h@-671,s@-671,l@-671,v@-671",
    $isColor: true,
    static: {Color$: [function() {
        return new R.Color(null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 534, "new Color"], Color_packPixel: [function(r, g, b, a) {
        var t1, t2, t3;
        t1 = J.getInterceptor$n(g);
        t2 = J.getInterceptor$n(b);
        if ($.Device_LITTLE_ENDIAN === true) {
          t3 = J.$shl$n(a, 24);
          t2 = t2.$shl(b, 16);
          t1 = t1.$shl(g, 8);
          if (typeof r !== "number")
            return H.iae(r);
          return (t3 | t2 | t1 | r) >>> 0;
        } else {
          t3 = J.$shl$n(r, 24);
          t1 = t1.$shl(g, 16);
          t2 = t2.$shl(b, 8);
          if (typeof a !== "number")
            return H.iae(a);
          return (t3 | t1 | t2 | a) >>> 0;
        }
      }, "call$4", "Color_packPixel$closure", 8, 0, 535, 346, [], 536, [], 349, [], 348, [], "packPixel"], Color_unpackPixel: [function(rgba, out, hsl, hsv) {
        var t1, t2, t3, t4, out0, dr, dg, db, min, max, d, r, g, b;
        if (out == null)
          out = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
        t1 = J.getInterceptor$n(rgba);
        t2 = J.getInterceptor$x(out);
        if ($.Device_LITTLE_ENDIAN === true) {
          t2.set$a(out, t1.$and(rgba, 4278190080) >>> 24);
          out.set$b(t1.$and(rgba, 16711680) >>> 16);
          out.set$g(t1.$and(rgba, 65280) >>> 8);
          t2.set$r(out, t1.$and(rgba, 255));
        } else {
          t2.set$r(out, t1.$and(rgba, 4278190080) >>> 24);
          out.set$g(t1.$and(rgba, 16711680) >>> 16);
          out.set$b(t1.$and(rgba, 65280) >>> 8);
          t2.set$a(out, t1.$and(rgba, 255));
        }
        t1 = J.getInterceptor$x(out);
        t1.set$color(out, rgba);
        out.set$rgba(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("rgba(", J.toString$0(t1.get$r(out))) + ",", J.toString$0(out.get$g())) + ",", J.toString$0(out.get$b())) + "," + J.toString$0(J.$div$n(t1.get$a(out), 255)) + ")");
        if (hsl === true) {
          t2 = t1.get$r(out);
          t3 = out.get$g();
          t4 = out.get$b();
          out0 = out == null ? R.Color_createColor(t2, t3, t4, 255, 0, 0, 0, 0) : out;
          dr = J.$div$n(t2, 255);
          dg = J.$div$n(t3, 255);
          db = J.$div$n(t4, 255);
          min = R.Math_minList([dr, dg, db]);
          max = R.Math_maxList([dr, dg, db]);
          out0.set$h(0);
          out0.set$s(0);
          t2 = J.getInterceptor$ns(max);
          out0.set$l(J.$div$n(t2.$add(max, min), 2));
          if (!t2.$eq(max, min)) {
            d = t2.$sub(max, min);
            t3 = J.getInterceptor$n(d);
            if (J.$gt$n(out0.get$l(), 0.5)) {
              if (typeof max !== "number")
                return H.iae(max);
              if (typeof min !== "number")
                return H.iae(min);
              t3 = t3.$div(d, 2 - max - min);
            } else
              t3 = t3.$div(d, t2.$add(max, min));
            out0.set$s(t3);
            if (t2.$eq(max, dr)) {
              t2 = J.getInterceptor$n(dg);
              t3 = J.$div$n(t2.$sub(dg, db), d);
              out0.set$h(J.$add$ns(t3, t2.$lt(dg, db) ? 6 : 0));
            } else if (t2.$eq(max, dg))
              out0.set$h(J.$add$ns(J.$div$n(J.$sub$n(db, dr), d), 2));
            else if (t2.$eq(max, db))
              out0.set$h(J.$add$ns(J.$div$n(J.$sub$n(dr, dg), d), 4));
            out0.set$h(J.$div$n(out0.get$h(), 6));
          }
        }
        if (hsv === true) {
          t1 = t1.get$r(out);
          t2 = out.get$g();
          t3 = out.get$b();
          out0 = out == null ? R.Color_createColor(t1, t2, t3, 255, 0, 0, 0, 0) : out;
          r = J.$tdiv$n(t1, 255);
          g = J.$tdiv$n(t2, 255);
          b = J.$tdiv$n(t3, 255);
          min = R.Math_minList([r, g, b]);
          max = R.Math_maxList([r, g, b]);
          t1 = J.getInterceptor$n(max);
          d = t1.$sub(max, min);
          out0.set$h(0);
          out0.set$s(t1.$eq(max, 0) ? 0 : J.$div$n(d, max));
          out0.set$v(max);
          if (!t1.$eq(max, min)) {
            if (t1.$eq(max, r)) {
              t1 = J.getInterceptor$n(g);
              t2 = J.$div$n(t1.$sub(g, b), d);
              out0.set$h(t2 + (t1.$lt(g, b) ? 6 : 0));
            } else if (t1.$eq(max, g))
              out0.set$h(J.$div$n(J.$sub$n(b, r), d) + 2);
            else if (t1.$eq(max, b))
              out0.set$h(J.$div$n(J.$sub$n(r, g), d) + 4);
            out0.set$h(J.$div$n(out0.get$h(), 6));
          }
        }
        return out;
      }, function(rgba) {
        return R.Color_unpackPixel(rgba, null, false, false);
      }, null, function(rgba, out) {
        return R.Color_unpackPixel(rgba, out, false, false);
      }, null, function(rgba, out, hsl) {
        return R.Color_unpackPixel(rgba, out, hsl, false);
      }, null, "call$4", "call$1", "call$2", "call$3", "Color_unpackPixel$closure", 2, 6, 537, 12, 19, 19, 538, [], 361, [], 539, [], 540, [], "unpackPixel"], Color_fromRGBA: [function(rgba, out) {
        var t1, t2;
        if (out == null)
          out = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
        t1 = J.getInterceptor$n(rgba);
        t2 = J.getInterceptor$x(out);
        t2.set$r(out, t1.$and(rgba, 4278190080) >>> 24);
        out.set$g(t1.$and(rgba, 16711680) >>> 16);
        out.set$b(t1.$and(rgba, 65280) >>> 8);
        t2.set$a(out, t1.$and(rgba, 255));
        out.set$rgba(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("rgba(", J.toString$0(t2.get$r(out))) + ",", J.toString$0(out.get$g())) + ",", J.toString$0(out.get$b())) + ",", J.toString$0(t2.get$a(out))) + ")");
        return out;
      }, "call$2", "Color_fromRGBA$closure", 4, 0, 541, 538, [], 361, [], "fromRGBA"], Color_toRGBA: [function(r, g, b, a) {
        var t1, t2, t3;
        t1 = J.$shl$n(r, 24);
        t2 = J.$shl$n(g, 16);
        t3 = J.$shl$n(b, 8);
        if (typeof a !== "number")
          return H.iae(a);
        return (t1 | t2 | t3 | a) >>> 0;
      }, "call$4", "Color_toRGBA$closure", 8, 0, 535, 346, [], 536, [], 349, [], 348, [], "toRGBA"], Color_RGBtoHSL: [function(r, g, b, out) {
        var dr, dg, db, min, max, t1, d, t2;
        if (out == null)
          out = R.Color_createColor(r, g, b, 255, 0, 0, 0, 0);
        dr = J.$div$n(r, 255);
        dg = J.$div$n(g, 255);
        db = J.$div$n(b, 255);
        min = R.Math_minList([dr, dg, db]);
        max = R.Math_maxList([dr, dg, db]);
        out.set$h(0);
        out.set$s(0);
        t1 = J.getInterceptor$ns(max);
        out.set$l(J.$div$n(t1.$add(max, min), 2));
        if (!t1.$eq(max, min)) {
          d = t1.$sub(max, min);
          t2 = J.getInterceptor$n(d);
          if (J.$gt$n(out.get$l(), 0.5)) {
            if (typeof max !== "number")
              return H.iae(max);
            if (typeof min !== "number")
              return H.iae(min);
            t2 = t2.$div(d, 2 - max - min);
          } else
            t2 = t2.$div(d, t1.$add(max, min));
          out.set$s(t2);
          if (t1.$eq(max, dr)) {
            t1 = J.getInterceptor$n(dg);
            t2 = J.$div$n(t1.$sub(dg, db), d);
            out.set$h(J.$add$ns(t2, t1.$lt(dg, db) ? 6 : 0));
          } else if (t1.$eq(max, dg))
            out.set$h(J.$add$ns(J.$div$n(J.$sub$n(db, dr), d), 2));
          else if (t1.$eq(max, db))
            out.set$h(J.$add$ns(J.$div$n(J.$sub$n(dr, dg), d), 4));
          out.set$h(J.$div$n(out.get$h(), 6));
        }
        return out;
      }, function(r, g, b) {
        return R.Color_RGBtoHSL(r, g, b, null);
      }, null, "call$4", "call$3", "Color_RGBtoHSL$closure", 6, 2, 542, 12, 346, [], 536, [], 349, [], 361, [], "RGBtoHSL"], Color_HSLtoRGB: [function(h, s, l, out) {
        var t1, q, p, dr, dg, db;
        if (out == null)
          out = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
        if (!J.$eq(s, 0)) {
          t1 = J.getInterceptor$n(l);
          if (t1.$lt(l, 0.5)) {
            if (typeof s !== "number")
              return H.iae(s);
            q = t1.$mul(l, 1 + s);
          } else
            q = J.$sub$n(t1.$add(l, s), t1.$mul(l, s));
          if (typeof l !== "number")
            return H.iae(l);
          if (typeof q !== "number")
            return H.iae(q);
          p = 2 * l - q;
          t1 = J.getInterceptor$ns(h);
          dr = R.Color_hueToColor(p, q, t1.$add(h, 0.3333333333333333));
          dg = R.Color_hueToColor(p, q, h);
          db = R.Color_hueToColor(p, q, t1.$sub(h, 0.3333333333333333));
        } else {
          db = l;
          dg = db;
          dr = dg;
        }
        J.set$r$x(out, J.floor$0$n(J.$mul$ns(dr, 255)));
        out.set$g(J.floor$0$n(J.$mul$ns(dg, 255)));
        out.set$b(J.floor$0$n(J.$mul$ns(db, 255)));
        R.Color_updateColor(out);
        return out;
      }, function(h, s, l) {
        return R.Color_HSLtoRGB(h, s, l, null);
      }, null, "call$4", "call$3", "Color_HSLtoRGB$closure", 6, 2, 543, 12, 544, [], 545, [], 546, [], 361, [], "HSLtoRGB"], Color_RGBtoHSV: [function(r, g, b, out) {
        var min, max, t1, d, t2;
        if (out == null)
          out = R.Color_createColor(r, g, b, 255, 0, 0, 0, 0);
        r = J.$tdiv$n(r, 255);
        g = J.$tdiv$n(g, 255);
        b = J.$tdiv$n(b, 255);
        min = R.Math_minList([r, g, b]);
        max = R.Math_maxList([r, g, b]);
        t1 = J.getInterceptor$n(max);
        d = t1.$sub(max, min);
        out.set$h(0);
        out.set$s(t1.$eq(max, 0) ? 0 : J.$div$n(d, max));
        out.set$v(max);
        if (!t1.$eq(max, min)) {
          if (t1.$eq(max, r)) {
            t1 = J.getInterceptor$n(g);
            t2 = J.$div$n(t1.$sub(g, b), d);
            out.set$h(t2 + (t1.$lt(g, b) ? 6 : 0));
          } else if (t1.$eq(max, g))
            out.set$h(J.$div$n(J.$sub$n(b, r), d) + 2);
          else if (t1.$eq(max, b))
            out.set$h(J.$div$n(J.$sub$n(r, g), d) + 4);
          out.set$h(J.$div$n(out.get$h(), 6));
        }
        return out;
      }, "call$4", "Color_RGBtoHSV$closure", 8, 0, 547, 346, [], 536, [], 349, [], 361, [], "RGBtoHSV"], Color_HSVtoRGB: [function(h, s, v, out) {
        var t1, i, f, p, t2, q, t, b, g, r;
        if (out == null)
          out = R.Color_createColor(0, 0, 0, 255, h, s, 0, v);
        t1 = J.getInterceptor$ns(h);
        i = J.floor$0$n(t1.$mul(h, 6));
        f = J.$sub$n(t1.$mul(h, 6), i);
        if (typeof s !== "number")
          return H.iae(s);
        t1 = J.getInterceptor$ns(v);
        p = t1.$mul(v, 1 - s);
        t2 = J.$mul$ns(f, s);
        if (typeof t2 !== "number")
          return H.iae(t2);
        q = t1.$mul(v, 1 - t2);
        if (typeof f !== "number")
          return H.iae(f);
        t = t1.$mul(v, 1 - (1 - f) * s);
        if (typeof i !== "number")
          return i.$mod();
        switch (C.JSInt_methods.$mod(i, 6)) {
          case 0:
            b = p;
            g = t;
            r = v;
            break;
          case 1:
            b = p;
            g = v;
            r = q;
            break;
          case 2:
            b = t;
            g = v;
            r = p;
            break;
          case 3:
            b = v;
            g = q;
            r = p;
            break;
          case 4:
            b = v;
            g = p;
            r = t;
            break;
          case 5:
            b = q;
            g = p;
            r = v;
            break;
          default:
            r = null;
            g = null;
            b = null;
        }
        J.set$r$x(out, J.floor$0$n(J.$mul$ns(r, 255)));
        out.set$g(J.floor$0$n(J.$mul$ns(g, 255)));
        out.set$b(J.floor$0$n(J.$mul$ns(b, 255)));
        R.Color_updateColor(out);
        return out;
      }, function(h, s, v) {
        return R.Color_HSVtoRGB(h, s, v, null);
      }, null, "call$4", "call$3", "Color_HSVtoRGB$closure", 6, 2, 543, 12, 544, [], 545, [], 37, [], 361, [], "HSVtoRGB"], Color_hueToColor: [function(p, q, t) {
        var t1 = J.getInterceptor$n(t);
        if (t1.$lt(t, 0))
          t = t1.$add(t, 1);
        t1 = J.getInterceptor$n(t);
        if (t1.$gt(t, 1))
          t = t1.$sub(t, 1);
        t1 = J.getInterceptor$n(t);
        if (t1.$lt(t, 0.16666666666666666))
          return J.$add$ns(p, J.$mul$ns(J.$mul$ns(J.$sub$n(q, p), 6), t));
        if (t1.$lt(t, 0.5))
          return q;
        if (t1.$lt(t, 0.6666666666666666)) {
          t1 = J.$sub$n(q, p);
          if (typeof t !== "number")
            return H.iae(t);
          return J.$add$ns(p, J.$mul$ns(J.$mul$ns(t1, 0.6666666666666666 - t), 6));
        }
        return p;
      }, "call$3", "Color_hueToColor$closure", 6, 0, 548, 230, [], 549, [], 423, [], "hueToColor"], Color_createColor: [function(r, g, b, a, h, s, l, v) {
        var out = new R.Color(null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        out.r = r;
        out.g = g;
        out.b = b;
        out.a = a;
        out.h = h;
        out.s = s;
        out.l = l;
        out.v = v;
        out.rgba = C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("rgba(", J.toString$0(r)) + ",", J.toString$0(g)) + ",", J.toString$0(b)) + ",", J.toString$0(a)) + ")";
        return out;
      }, function(r) {
        return R.Color_createColor(r, 0, 0, 255, 0, 0, 0, 0);
      }, null, function(r, g) {
        return R.Color_createColor(r, g, 0, 255, 0, 0, 0, 0);
      }, null, function() {
        return R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
      }, null, function(r, g, b) {
        return R.Color_createColor(r, g, b, 255, 0, 0, 0, 0);
      }, null, function(r, g, b, a) {
        return R.Color_createColor(r, g, b, a, 0, 0, 0, 0);
      }, null, function(r, g, b, a, h, s) {
        return R.Color_createColor(r, g, b, a, h, s, 0, 0);
      }, null, function(r, g, b, a, h) {
        return R.Color_createColor(r, g, b, a, h, 0, 0, 0);
      }, null, function(r, g, b, a, h, s, l) {
        return R.Color_createColor(r, g, b, a, h, s, l, 0);
      }, null, "call$8", "call$1", "call$2", "call$0", "call$3", "call$4", "call$6", "call$5", "call$7", "Color_createColor$closure", 0, 16, 550, 49, 49, 49, 551, 49, 49, 49, 49, 346, [], 536, [], 349, [], 348, [], 544, [], 545, [], 546, [], 37, [], "createColor"], Color_updateColor: [function(out) {
        var t1 = J.getInterceptor$x(out);
        out.set$rgba(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("rgba(", J.toString$0(t1.get$r(out))) + ",", J.toString$0(out.get$g())) + ",", J.toString$0(out.get$b())) + ",", J.toString$0(t1.get$a(out))) + ")");
        return out;
      }, "call$1", "Color_updateColor$closure", 2, 0, 552, 361, [], "updateColor"], Color_getColor32: [function(a, r, g, b) {
        var t1, t2, t3;
        t1 = J.$shl$n(a, 24);
        t2 = J.$shl$n(r, 16);
        t3 = J.$shl$n(g, 8);
        if (typeof b !== "number")
          return H.iae(b);
        return (t1 | t2 | t3 | b) >>> 0;
      }, "call$4", "Color_getColor32$closure", 8, 0, 553, 348, [], 346, [], 536, [], 349, [], "getColor32"], Color_getColor: [function(r, g, b) {
        var t1, t2;
        t1 = J.$shl$n(r, 16);
        t2 = J.$shl$n(g, 8);
        if (typeof b !== "number")
          return H.iae(b);
        return (t1 | t2 | b) >>> 0;
      }, "call$3", "Color_getColor$closure", 6, 0, 554, 346, [], 536, [], 349, [], "getColor"], Color_RGBtoString: [function(r, g, b, a, prefix) {
        var t1, t2;
        if (J.$eq(prefix, "#")) {
          t1 = J.$shl$n(r, 16);
          t2 = J.$shl$n(g, 8);
          if (typeof b !== "number")
            return H.iae(b);
          return "#" + C.JSString_methods.substring$1(C.JSInt_methods.toRadixString$1(C.JSNumber_methods.toInt$0(16777216 + t1 + t2 + b), 16), 1);
        } else
          return "0x" + R.Color_componentToHex(a) + R.Color_componentToHex(r) + R.Color_componentToHex(g) + R.Color_componentToHex(b);
      }, function(r, g, b) {
        return R.Color_RGBtoString(r, g, b, 255, "#");
      }, null, function(r, g, b, a) {
        return R.Color_RGBtoString(r, g, b, a, "#");
      }, null, "call$5", "call$3", "call$4", "Color_RGBtoString$closure", 6, 4, 555, 551, 556, 346, [], 536, [], 349, [], 348, [], 260, [], "RGBtoString"], Color_hexToRGB: [function(hex) {
        var rgb, t1;
        rgb = R.Color_hexToColor(hex, null);
        if (rgb != null) {
          t1 = J.getInterceptor$x(rgb);
          return R.Color_getColor32(t1.get$a(rgb), t1.get$r(rgb), rgb.get$g(), rgb.get$b());
        }
        return;
      }, "call$1", "Color_hexToRGB$closure", 2, 0, 557, 243, [], "hexToRGB"], Color_hexToColor: [function(hex, out) {
        if (out == null)
          out = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
        hex = J.replaceFirst$2$s(hex, new H.JSSyntaxRegExp("^#?([a-fd])([a-fd])([a-fd])$", H.JSSyntaxRegExp_makeNative("^#?([a-fd])([a-fd])([a-fd])$", false, true, false), null, null), "$1$1$2$2$3$3");
        new H.JSSyntaxRegExp("^#?([a-fd]{2})([a-fd]{2})([a-fd]{2})$", H.JSSyntaxRegExp_makeNative("^#?([a-fd]{2})([a-fd]{2})([a-fd]{2})$", false, true, false), null, null).firstMatch$1(hex);
        return out;
      }, function(hex) {
        return R.Color_hexToColor(hex, null);
      }, null, "call$2", "call$1", "Color_hexToColor$closure", 2, 2, 558, 12, 243, [], 361, [], "hexToColor"], Color_componentToHex: [function(color) {
        var hex = J.toRadixString$1$n(color, 16);
        return hex.length === 1 ? "0" + hex : hex;
      }, "call$1", "Color_componentToHex$closure", 2, 0, 559, 152, [], "componentToHex"], Color_HSVColorWheel: [function(s, v) {
        var colors, t1, c, t2, out, i, f, p, q, t, b, g, r;
        colors = [];
        for (t1 = J.getInterceptor$ns(v), c = 0; c <= 359; ++c) {
          t2 = c / 359;
          out = R.Color_createColor(0, 0, 0, 255, t2, s, 0, v);
          t2 *= 6;
          i = C.JSInt_methods.floor$0(t2);
          f = t2 - i;
          if (typeof s !== "number")
            return H.iae(s);
          p = t1.$mul(v, 1 - s);
          q = t1.$mul(v, 1 - f * s);
          t = t1.$mul(v, 1 - (1 - f) * s);
          switch (C.JSInt_methods.$mod(i, 6)) {
            case 0:
              b = p;
              g = t;
              r = v;
              break;
            case 1:
              b = p;
              g = v;
              r = q;
              break;
            case 2:
              b = t;
              g = v;
              r = p;
              break;
            case 3:
              b = v;
              g = q;
              r = p;
              break;
            case 4:
              b = v;
              g = p;
              r = t;
              break;
            case 5:
              b = q;
              g = p;
              r = v;
              break;
          }
          out.r = J.floor$0$n(J.$mul$ns(r, 255));
          out.g = J.floor$0$n(J.$mul$ns(g, 255));
          out.b = J.floor$0$n(J.$mul$ns(b, 255));
          R.Color_updateColor(out);
          colors.push(out);
        }
        return colors;
      }, function(s) {
        return R.Color_HSVColorWheel(s, 1);
      }, null, function() {
        return R.Color_HSVColorWheel(1, 1);
      }, null, "call$2", "call$1", "call$0", "Color_HSVColorWheel$closure", 0, 4, 560, 433, 433, 545, [], 37, [], "HSVColorWheel"], Color_HSLColorWheel: [function(s, l) {
        var colors, c;
        colors = [];
        for (c = 0; c <= 359; ++c)
          colors.push(R.Color_HSLtoRGB(c / 359, s, l, null));
        return colors;
      }, function(s) {
        return R.Color_HSLColorWheel(s, 0.5);
      }, null, function() {
        return R.Color_HSLColorWheel(0.5, 0.5);
      }, null, "call$2", "call$1", "call$0", "Color_HSLColorWheel$closure", 0, 4, 560, 561, 561, 545, [], 546, [], "HSLColorWheel"], Color_interpolateColor: [function(color1, color2, steps, currentStep, alpha) {
        var src1, src2;
        src1 = R.Color_getRGB(color1);
        src2 = R.Color_getRGB(color2);
        return R.Color_getColor32(alpha, J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(src2.red, src1.red), currentStep), steps), src1.red), J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(src2.green, src1.green), currentStep), steps), src1.green), J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(src2.blue, src1.blue), currentStep), steps), src1.blue));
      }, function(color1, color2, steps, currentStep) {
        return R.Color_interpolateColor(color1, color2, steps, currentStep, 255);
      }, null, "call$5", "call$4", "Color_interpolateColor$closure", 8, 2, 562, 551, 563, [], 564, [], 565, [], 566, [], 567, [], "interpolateColor"], Color_interpolateColorWithRGB: [function(color, r, g, b, steps, currentStep) {
        var src, or, og, ob, t1, t2;
        src = R.Color_getRGB(color);
        or = J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(r, src.red), currentStep), steps), src.red);
        og = J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(g, src.green), currentStep), steps), src.green);
        ob = J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(b, src.blue), currentStep), steps), src.blue);
        t1 = J.$shl$n(or, 16);
        t2 = J.$shl$n(og, 8);
        if (typeof ob !== "number")
          return H.iae(ob);
        return (t1 | t2 | ob) >>> 0;
      }, "call$6", "Color_interpolateColorWithRGB$closure", 12, 0, 568, 152, [], 346, [], 536, [], 349, [], 565, [], 566, [], "interpolateColorWithRGB"], Color_interpolateRGB: [function(r1, g1, b1, r2, g2, b2, steps, currentStep) {
        var r, g, b, t1, t2;
        r = J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(r2, r1), currentStep), steps), r1);
        g = J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(g2, g1), currentStep), steps), g1);
        b = J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(b2, b1), currentStep), steps), b1);
        t1 = J.$shl$n(r, 16);
        t2 = J.$shl$n(g, 8);
        if (typeof b !== "number")
          return H.iae(b);
        return (t1 | t2 | b) >>> 0;
      }, "call$8", "Color_interpolateRGB$closure", 16, 0, 569, 570, [], 571, [], 447, [], 572, [], 573, [], 448, [], 565, [], 566, [], "interpolateRGB"], Color_getRandomColor: [function(min, max, alpha) {
        var t1, t2, t3;
        t1 = J.getInterceptor$n(max);
        if (t1.$gt(max, 255) || J.$gt$n(min, max))
          return 16777215;
        t2 = $.get$Math_random();
        t3 = J.getInterceptor$ns(min);
        return R.Color_getColor32(alpha, t3.$add(min, J.round$0$n(J.$mul$ns(t2.call$0(), t1.$sub(max, min)))), t3.$add(min, J.round$0$n(J.$mul$ns(t2.call$0(), t1.$sub(max, min)))), t3.$add(min, J.round$0$n(J.$mul$ns(t2.call$0(), t1.$sub(max, min)))));
      }, function(min) {
        return R.Color_getRandomColor(min, 255, 255);
      }, null, function(min, max) {
        return R.Color_getRandomColor(min, max, 255);
      }, null, function() {
        return R.Color_getRandomColor(0, 255, 255);
      }, null, "call$3", "call$1", "call$2", "call$0", "Color_getRandomColor$closure", 0, 6, 574, 49, 551, 551, 409, [], 410, [], 567, [], "getRandomColor"], Color_getRGB: [function(color) {
        var c, t1, t2, t3, t4;
        c = new R.Color(null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1 = J.getInterceptor$n(color);
        if (t1.$gt(color, 16777215)) {
          t2 = t1.$shr(color, 24);
          c.a = t2;
          t3 = t1.$shr(color, 16) & 255;
          c.r = t3;
          t4 = t1.$shr(color, 8) & 255;
          c.g = t4;
          t1 = t1.$and(color, 255);
          c.b = t1;
          c.alpha = t2;
          c.red = t3;
          c.green = t4;
          c.blue = t1;
        } else {
          c.a = 255;
          t2 = t1.$shr(color, 16) & 255;
          c.r = t2;
          t3 = t1.$shr(color, 8) & 255;
          c.g = t3;
          t1 = t1.$and(color, 255);
          c.b = t1;
          c.alpha = 255;
          c.red = t2;
          c.green = t3;
          c.blue = t1;
        }
        return c;
      }, "call$1", "Color_getRGB$closure", 2, 0, 575, 152, [], "getRGB"], Color_getWebRGB: [function(color) {
        var rgb;
        if (!!J.getInterceptor(color).$isColor)
          return C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("rgba(", J.toString$0(color.r)) + ",", J.toString$0(color.g)) + ",", J.toString$0(color.b)) + "," + J.toString$0(J.$div$n(color.a, 255)) + ")";
        else {
          rgb = R.Color_getRGB(color);
          return C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("rgba(", J.toString$0(rgb.r)) + ",", J.toString$0(rgb.g)) + ",", J.toString$0(rgb.b)) + "," + J.toString$0(J.$div$n(rgb.a, 255)) + ")";
        }
      }, "call$1", "Color_getWebRGB$closure", 2, 0, 576, 152, [], "getWebRGB"], Color_getAlpha: [function(color) {
        return J.$shr$n(color, 24);
      }, "call$1", "Color_getAlpha$closure", 2, 0, 248, 152, [], "getAlpha"], Color_getAlphaFloat: [function(color) {
        return J.$shr$n(color, 24) / 255;
      }, "call$1", "Color_getAlphaFloat$closure", 2, 0, 577, 152, [], "getAlphaFloat"], Color_getRed: [function(color) {
        return J.$shr$n(color, 16) & 255;
      }, "call$1", "Color_getRed$closure", 2, 0, 248, 152, [], "getRed"], Color_getGreen: [function(color) {
        return J.$shr$n(color, 8) & 255;
      }, "call$1", "Color_getGreen$closure", 2, 0, 248, 152, [], "getGreen"], Color_getBlue: [function(color) {
        return J.$and$n(color, 255);
      }, "call$1", "Color_getBlue$closure", 2, 0, 248, 152, [], "getBlue"]}
  },
  "+Color": [674],
  Debug: {
    "^": "Object;game@-613,sprite@-661,canvas*-836,baseTexture@-853,texture@-698,textureFrame@-963,context*-876,font*-644,columnWidth*-616,lineHeight*-616,renderShadow@-617,currentX@-616,currentY@-616,currentAlpha@-671,dirty@-617,currentColor@-644",
    sprite$3: function(arg0, arg1, arg2) {
      return this.sprite.call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.sprite.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.sprite.call$4(arg0, arg1, arg2, arg3);
    },
    boot$0: [function() {
      var t1, t2;
      t1 = J.$eq(this.game.get$renderType(), 1);
      t2 = this.game;
      if (t1)
        this.context = J.get$context$x(t2);
      else {
        R.RenderTexture$(t2, J.get$width$x(t2), J.get$height$x(this.game), null, null);
        t1 = R.Canvas_create(J.get$width$x(this.game), J.get$height$x(this.game), "");
        this.canvas = t1;
        this.context = J.getContext$1$x(t1, "2d");
        t1 = M.BaseTexture$(this.canvas, C.scaleModes_0);
        this.baseTexture = t1;
        this.texture = M.Texture$(t1, null);
        this.textureFrame = R.Frame$(0, 0, 0, J.get$width$x(this.game), J.get$height$x(this.game), "debug", this.game.get$rnd().uuid$0());
        this.sprite = this.game.get$make().image$4(0, 0, this.texture, this.textureFrame);
        this.game.get$stage().addChild$1(this.sprite);
      }
    }, "call$0", "get$boot", 0, 0, 54, "boot"],
    preUpdate$0: [function() {
      if (this.dirty === true && this.sprite != null) {
        J.clearRect$4$x(this.context, 0, 0, J.get$width$x(this.game), J.get$height$x(this.game));
        this.dirty = false;
      }
    }, "call$0", "get$preUpdate", 0, 0, 54, "preUpdate"],
    start$4: [function(_, x, y, color, columnWidth) {
      this.currentX = x;
      this.currentY = y;
      this.currentColor = color;
      this.currentAlpha = J.get$globalAlpha$x(this.context);
      this.columnWidth = columnWidth;
      if (this.sprite != null)
        this.dirty = true;
      J.save$0$x(this.context);
      J.setTransform$6$x(this.context, 1, 0, 0, 1, 0, 0);
      J.set$strokeStyle$x(this.context, color);
      J.set$fillStyle$x(this.context, color);
      J.set$font$x(this.context, this.font);
      J.set$globalAlpha$x(this.context, 1);
      J.set$lineWidth$x(this.context, 1);
    }, function($receiver, x) {
      return this.start$4($receiver, x, 0, "rgb(255,255,255)", 0);
    }, "start$1", function($receiver) {
      return this.start$4($receiver, 0, 0, "rgb(255,255,255)", 0);
    }, "start$0", function($receiver, x, y) {
      return this.start$4($receiver, x, y, "rgb(255,255,255)", 0);
    }, "start$2", function($receiver, x, y, color) {
      return this.start$4($receiver, x, y, color, 0);
    }, "start$3", "call$4", "call$1", "call$0", "call$2", "call$3", "get$start", 0, 8, 1248, 49, 49, 1651, 49, 9, [], 10, [], 152, [], 1652, [], "start"],
    reset$0: [function(_) {
      var t1 = this.context;
      if (t1 != null)
        J.clearRect$4$x(t1, 0, 0, J.get$width$x(this.game), J.get$height$x(this.game));
      if (this.sprite != null)
        M.updateWebGLTexture(this.baseTexture, this.game.get$renderer().get$gl());
    }, "call$0", "get$reset", 0, 0, 54, "reset"],
    stop$0: [function(_) {
      J.restore$0$x(this.context);
      J.set$globalAlpha$x(this.context, this.currentAlpha);
      if (this.sprite != null)
        M.updateWebGLTexture(this.baseTexture, this.game.get$renderer().get$gl());
    }, "call$0", "get$stop", 0, 0, 54, "stop"],
    line$1: [function(strs) {
      var $arguments, x, t1, i, t2;
      $arguments = typeof strs === "string" ? [strs] : strs;
      x = this.currentX;
      t1 = J.getInterceptor$asx($arguments);
      i = 0;
      while (true) {
        t2 = t1.get$length($arguments);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        if (this.renderShadow === true) {
          J.set$fillStyle$x(this.context, "rgb(0,0,0)");
          J.fillText$3$x(this.context, t1.$index($arguments, i), J.$add$ns(x, 1), J.$add$ns(this.currentY, 1));
          J.set$fillStyle$x(this.context, this.currentColor);
        }
        J.fillText$3$x(this.context, t1.$index($arguments, i), x, this.currentY);
        x = J.$add$ns(x, this.columnWidth);
        ++i;
      }
      this.currentY = J.$add$ns(this.currentY, this.lineHeight);
    }, "call$1", "get$line", 2, 0, 102, 1653, [], "line"],
    soundInfo$4: [function(sound, x, y, color) {
      var t1;
      this.start$3(0, x, y, color);
      t1 = J.getInterceptor$x(sound);
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Sound: ", t1.get$key(sound)) + " Locked: ", J.toString$0(sound.get$game().get$sound().get$touchLocked())));
      this.line$1(C.JSString_methods.$add("Is Ready?: " + String(this.game.get$cache().isSoundReady$1(t1.get$key(sound))) + " Pending Playback: ", J.toString$0(sound.get$pendingPlayback())));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Decoded: ", J.toString$0(sound.get$isDecoded())) + " Decoding: ", J.toString$0(sound.get$isDecoding())));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Total Duration: ", J.toString$0(sound.get$totalDuration())) + " Playing: ", J.toString$0(sound.get$isPlaying())));
      this.line$1(C.JSString_methods.$add("Time: ", J.toString$0(t1.get$currentTime(sound))));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Volume: ", J.toString$0(t1.get$volume(sound))) + " Muted: ", J.toString$0(sound.get$mute())));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("WebAudio: ", J.toString$0(sound.get$usingWebAudio())) + " Audio: ", J.toString$0(sound.get$usingAudioTag())));
      if (!J.$eq(sound.get$currentMarker(), "")) {
        this.line$1(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("Marker: ", sound.get$currentMarker()) + " Duration: ", J.toString$0(t1.get$duration(sound))) + " (ms: ", J.toString$0(sound.get$durationMS())) + ")");
        this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Start: ", J.toString$0(J.get$start$x(J.$index$asx(sound.get$markers(), sound.get$currentMarker())))) + " Stop: ", J.toString$0(J.get$stop$x(J.$index$asx(sound.get$markers(), sound.get$currentMarker())))));
        this.line$1(C.JSString_methods.$add("Position: ", J.toString$0(t1.get$position(sound))));
      }
      this.stop$0(0);
    }, function(sound, x, y) {
      return this.soundInfo$4(sound, x, y, "rgb(255,255,255)");
    }, "soundInfo$3", "call$4", "call$3", "get$soundInfo", 6, 2, 1654, 1651, 1159, [], 9, [], 10, [], 152, [], "soundInfo"],
    cameraInfo$4: [function(camera, x, y, color) {
      var t1;
      this.start$3(0, x, y, color);
      t1 = J.getInterceptor$x(camera);
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Camera (", J.toString$0(t1.get$width(camera))) + " x ", J.toString$0(t1.get$height(camera))) + ")");
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("X: ", J.toString$0(t1.get$x(camera))) + " Y: ", J.toString$0(t1.get$y(camera))));
      if (camera.get$bounds() != null)
        this.line$1(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("Bounds x: ", J.toString$0(J.get$x$x(camera.get$bounds()))) + " Y: ", J.toString$0(J.get$y$x(camera.get$bounds()))) + " w: ", J.toString$0(J.get$width$x(camera.get$bounds()))) + " h: ", J.toString$0(J.get$height$x(camera.get$bounds()))));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("View x: ", J.toString$0(J.get$x$x(t1.get$view(camera)))) + " Y: ", J.toString$0(J.get$y$x(t1.get$view(camera)))) + " w: ", J.toString$0(J.get$width$x(t1.get$view(camera)))) + " h: ", J.toString$0(J.get$height$x(t1.get$view(camera)))));
      this.stop$0(0);
    }, function(camera, x, y) {
      return this.cameraInfo$4(camera, x, y, "rgb(255,255,255)");
    }, "cameraInfo$3", "call$4", "call$3", "get$cameraInfo", 6, 2, 1655, 1651, 1656, [], 9, [], 10, [], 152, [], "cameraInfo"],
    timer$4: [function(timer, x, y, color) {
      var t1;
      this.start$3(0, x, y, color);
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Timer (running: ", J.toString$0(timer.get$running())) + " expired: ", J.toString$0(timer.get$expired())) + ")");
      t1 = J.getInterceptor$x(timer);
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Next Tick: ", J.toString$0(timer.get$next())) + " Duration: ", J.toString$0(t1.get$duration(timer))));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Paused: ", J.toString$0(t1.get$paused(timer))) + " Length: ", J.toString$0(t1.get$length(timer))));
      this.stop$0(0);
    }, function(timer, x, y) {
      return this.timer$4(timer, x, y, "rgb(255,255,255)");
    }, "timer$3", "call$4", "call$3", "get$timer", 6, 2, 1657, 1651, 515, [], 9, [], 10, [], 152, [], "timer"],
    ropeSegments$3: [function(rope, color, filled) {
      C.JSArray_methods.forEach$1(rope.get$segments(), new R.Debug_ropeSegments_closure(this, color, filled));
    }, function(rope) {
      return this.ropeSegments$3(rope, null, true);
    }, "ropeSegments$1", function(rope, color) {
      return this.ropeSegments$3(rope, color, true);
    }, "ropeSegments$2", "call$3", "call$1", "call$2", "get$ropeSegments", 2, 4, 1658, 12, 78, 1659, [], 152, [], 623, [], "ropeSegments"],
    pointer$5: [function(pointer, hideIfUp, downColor, upColor, color) {
      var t1, t2, t3;
      if (pointer == null)
        return;
      if (J.$eq(hideIfUp, true) && J.$eq(pointer.get$isUp(), true))
        return;
      t1 = J.getInterceptor$x(pointer);
      this.start$3(0, t1.get$x(pointer), J.$sub$n(t1.get$y(pointer), 100), color);
      J.beginPath$0$x(this.context);
      J.arc$5$x(this.context, t1.get$x(pointer), t1.get$y(pointer), pointer.get$circle().get$radius(), 0, 6.283185307179586);
      t2 = pointer.get$active();
      t3 = this.context;
      if (t2 === true)
        J.set$fillStyle$x(t3, downColor);
      else
        J.set$fillStyle$x(t3, upColor);
      J.fill$0$x(this.context);
      J.closePath$0$x(this.context);
      J.beginPath$0$x(this.context);
      J.moveTo$2$x(this.context, J.get$x$x(pointer.get$positionDown()), J.get$y$x(pointer.get$positionDown()));
      J.lineTo$2$x(this.context, J.get$x$x(t1.get$position(pointer)), J.get$y$x(t1.get$position(pointer)));
      J.set$lineWidth$x(this.context, 2);
      J.stroke$0$x(this.context);
      J.closePath$0$x(this.context);
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("ID: ", J.toString$0(t1.get$id(pointer))) + " Active: ", J.toString$0(pointer.get$active())));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("World X: ", J.toString$0(pointer.get$worldX())) + " World Y: ", J.toString$0(pointer.get$worldY())));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Screen X: ", J.toString$0(t1.get$x(pointer))) + " Screen Y: ", J.toString$0(t1.get$y(pointer))));
      this.line$1(C.JSString_methods.$add("Duration: ", J.toString$0(t1.get$duration(pointer))) + " ms");
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("is Down: ", J.toString$0(pointer.get$isDown())) + " is Up: ", J.toString$0(pointer.get$isUp())));
      this.stop$0(0);
    }, function(pointer) {
      return this.pointer$5(pointer, false, "rgba(0,255,0,0.5)", "rgba(255,0,0,0.5)", "rgb(255,255,255)");
    }, "pointer$1", function(pointer, hideIfUp) {
      return this.pointer$5(pointer, hideIfUp, "rgba(0,255,0,0.5)", "rgba(255,0,0,0.5)", "rgb(255,255,255)");
    }, "pointer$2", function(pointer, hideIfUp, downColor) {
      return this.pointer$5(pointer, hideIfUp, downColor, "rgba(255,0,0,0.5)", "rgb(255,255,255)");
    }, "pointer$3", function(pointer, hideIfUp, downColor, upColor) {
      return this.pointer$5(pointer, hideIfUp, downColor, upColor, "rgb(255,255,255)");
    }, "pointer$4", "call$5", "call$1", "call$2", "call$3", "call$4", "get$pointer", 2, 8, 1660, 19, 1661, 1662, 1651, 1021, [], 1663, [], 1664, [], 1665, [], 152, [], "pointer"],
    spriteInputInfo$4: [function(sprite, x, y, color) {
      var t1;
      this.start$3(0, x, y, color);
      t1 = J.getInterceptor$x(sprite);
      this.line$1(["Sprite Input: (" + H.S(t1.get$width(sprite)) + " x " + H.S(t1.get$height(sprite)) + ")"]);
      this.line$1("x: " + J.toStringAsFixed$1$n(sprite.get$input().pointerX$0(), 1) + "  y: " + J.toStringAsFixed$1$n(sprite.get$input().pointerY$0(), 1));
      this.line$1(["over: " + H.S(sprite.get$input().pointerOver$0()) + " duration: " + J.toStringAsFixed$1$n(sprite.get$input().overDuration$0(), 0)]);
      this.line$1(["down: " + H.S(sprite.get$input().pointerDown$0()) + " duration: " + J.toStringAsFixed$1$n(sprite.get$input().downDuration$0(), 0)]);
      this.line$1(["just over: " + sprite.get$input().justOver$0() + " just out: " + sprite.get$input().justOut$0()]);
      this.stop$0(0);
    }, function(sprite, x, y) {
      return this.spriteInputInfo$4(sprite, x, y, "rgb(255,255,255)");
    }, "spriteInputInfo$3", "call$4", "call$3", "get$spriteInputInfo", 6, 2, 1666, 1651, 151, [], 9, [], 10, [], 152, [], "spriteInputInfo"],
    key$4: [function(_, key, x, y, color) {
      var t1;
      this.start$4(0, x, y, color, 150);
      t1 = J.getInterceptor$x(key);
      this.line$1(["Key:", t1.get$keyCode(key), "isDown:", key.get$isDown()]);
      this.line$1(["justPressed:", String(key.justPressed$0()), "justReleased:", String(key.justReleased$0())]);
      this.line$1(["Time Down:", J.toStringAsFixed$1$n(key.get$timeDown(), 0), "duration:", J.toStringAsFixed$1$n(t1.get$duration(key), 0)]);
      this.stop$0(0);
    }, function($receiver, key, x, y) {
      return this.key$4($receiver, key, x, y, "rgb(255,255,255)");
    }, "key$3", "call$4", "call$3", "get$key", 6, 2, 1667, 1651, 269, [], 9, [], 10, [], 152, [], "key"],
    inputInfo$3: [function(x, y, color) {
      this.start$3(0, x, y, color);
      this.line$1("Input");
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("X: ", J.toString$0(J.get$x$x(this.game.get$input()))) + " Y: ", J.toString$0(J.get$y$x(this.game.get$input()))));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("World X: ", J.toString$0(this.game.get$input().get$worldX())) + " World Y: ", J.toString$0(this.game.get$input().get$worldY())));
      this.line$1("Scale X: " + J.toStringAsFixed$1$n(J.get$x$x(J.get$scale$x(this.game.get$input())), 1) + " Scale Y: " + J.toStringAsFixed$1$n(J.get$x$x(J.get$scale$x(this.game.get$input())), 1));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Screen X: ", J.toString$0(J.get$screenX$x(this.game.get$input().get$activePointer()))) + " Screen Y: ", J.toString$0(J.get$screenY$x(this.game.get$input().get$activePointer()))));
      this.stop$0(0);
    }, function(x, y) {
      return this.inputInfo$3(x, y, "rgb(255,255,255)");
    }, "inputInfo$2", "call$3", "call$2", "get$inputInfo", 4, 2, 1668, 1651, 9, [], 10, [], 152, [], "inputInfo"],
    spriteBounds$3: [function(sprite, color, filled) {
      var bounds, t1;
      bounds = sprite.getBounds$0();
      t1 = J.getInterceptor$x(bounds);
      t1.set$x(bounds, J.$add$ns(t1.get$x(bounds), J.get$x$x(this.game.get$camera())));
      t1.set$y(bounds, J.$add$ns(t1.get$y(bounds), J.get$y$x(this.game.get$camera())));
      this.rectangle$3(bounds, color, filled);
    }, function(sprite) {
      return this.spriteBounds$3(sprite, "rgba(255,255,255,0.2)", true);
    }, "spriteBounds$1", function(sprite, color) {
      return this.spriteBounds$3(sprite, color, true);
    }, "spriteBounds$2", "call$3", "call$1", "call$2", "get$spriteBounds", 2, 4, 621, 1669, 78, 151, [], 152, [], 623, [], "spriteBounds"],
    spriteInfo$4: [function(sprite, x, y, color) {
      var t1;
      this.start$3(0, x, y, color);
      t1 = J.getInterceptor$x(sprite);
      this.line$1("Sprite: " + (" (" + H.S(t1.get$width(sprite)) + " x " + H.S(t1.get$height(sprite)) + ") anchor: " + H.S(J.get$x$x(sprite.get$anchor())) + " x " + H.S(J.get$y$x(sprite.get$anchor()))));
      this.line$1("x: " + J.toStringAsFixed$1$n(t1.get$x(sprite), 1) + " y: " + J.toStringAsFixed$1$n(t1.get$y(sprite), 1));
      this.line$1("angle: " + J.toStringAsFixed$1$n(t1.get$angle(sprite), 1) + " rotation: " + J.toStringAsFixed$1$n(sprite.get$rotation(), 1));
      this.line$1("visible: " + H.S(sprite.get$visible()) + " in camera: " + H.S(sprite.get$inCamera()));
      this.stop$0(0);
    }, function(sprite, x, y) {
      return this.spriteInfo$4(sprite, x, y, "rgb(255,255,255)");
    }, "spriteInfo$3", "call$4", "call$3", "get$spriteInfo", 6, 2, 1670, 1651, 151, [], 9, [], 10, [], 152, [], "spriteInfo"],
    spriteCoords$4: [function(sprite, x, y, color) {
      var t1;
      this.start$4(0, x, y, color, 100);
      t1 = J.getInterceptor$x(sprite);
      if (t1.get$name(sprite) != null)
        this.line$1(t1.get$name(sprite));
      this.line$1(["x:", J.toStringAsFixed$1$n(t1.get$x(sprite), 2), "y:", J.toStringAsFixed$1$n(t1.get$y(sprite), 2)]);
      this.line$1(["pos x:", J.toStringAsFixed$1$n(J.get$x$x(t1.get$position(sprite)), 2), "pos y:", J.toStringAsFixed$1$n(J.get$y$x(t1.get$position(sprite)), 2)]);
      this.line$1(["world x:", J.toStringAsFixed$1$n(J.get$x$x(sprite.get$world()), 2), "world y:", J.toStringAsFixed$1$n(J.get$y$x(sprite.get$world()), 2)]);
      this.stop$0(0);
    }, function(sprite, x, y) {
      return this.spriteCoords$4(sprite, x, y, "rgb(255,255,255)");
    }, "spriteCoords$3", "call$4", "call$3", "get$spriteCoords", 6, 2, 1666, 1651, 151, [], 9, [], 10, [], 152, [], "spriteCoords"],
    lineInfo$4: [function(line, x, y, color) {
      var t1;
      this.start$4(0, x, y, color, 80);
      t1 = J.getInterceptor$x(line);
      this.line$1(["start.x:", J.toStringAsFixed$1$n(J.get$x$x(t1.get$start(line)), 2), "start.y:", J.toStringAsFixed$1$n(J.get$y$x(t1.get$start(line)), 2)]);
      this.line$1(["end.x:", J.toStringAsFixed$1$n(J.get$x$x(line.get$end()), 2), "end.y:", J.toStringAsFixed$1$n(J.get$y$x(line.get$end()), 2)]);
      this.line$1(["length:", J.toStringAsFixed$1$n(t1.get$length(line), 2), "angle:", t1.get$angle(line)]);
      this.stop$0(0);
    }, function(line, x, y) {
      return this.lineInfo$4(line, x, y, "rgb(255,255,255)");
    }, "lineInfo$3", "call$4", "call$3", "get$lineInfo", 6, 2, 1671, 1651, 1233, [], 9, [], 10, [], 152, [], "lineInfo"],
    pixel$4: [function(x, y, color, size) {
      this.start$0(0);
      J.set$fillStyle$x(this.context, color);
      J.fillRect$4$x(this.context, x, y, size, size);
      this.stop$0(0);
    }, function(x, y) {
      return this.pixel$4(x, y, "rgba(0,255,0,0.4)", 2);
    }, "pixel$2", function(x, y, color) {
      return this.pixel$4(x, y, color, 2);
    }, "pixel$3", "call$4", "call$2", "call$3", "get$pixel", 4, 4, 1672, 622, 441, 9, [], 10, [], 152, [], 314, [], "pixel"],
    geom$4: [function(object, color, filled, forceType) {
      var t1, t2;
      this.start$0(0);
      J.set$fillStyle$x(this.context, color);
      J.set$strokeStyle$x(this.context, color);
      t1 = J.getInterceptor(object);
      if (!!t1.$isRectangle1 || J.$eq(forceType, 1)) {
        t2 = this.context;
        if (filled === true)
          J.fillRect$4$x(t2, J.$sub$n(t1.get$x(object), J.get$x$x(this.game.get$camera())), J.$sub$n(t1.get$y(object), J.get$y$x(this.game.get$camera())), t1.get$width(object), t1.get$height(object));
        else
          J.strokeRect$4$x(t2, J.$sub$n(t1.get$x(object), J.get$x$x(this.game.get$camera())), J.$sub$n(t1.get$y(object), J.get$y$x(this.game.get$camera())), t1.get$width(object), t1.get$height(object));
      } else if (!!t1.$isCircle0 || J.$eq(forceType, 2)) {
        J.beginPath$0$x(this.context);
        J.arc$6$x(this.context, J.$sub$n(t1.get$x(object), J.get$x$x(this.game.get$camera())), J.$sub$n(t1.get$y(object), J.get$y$x(this.game.get$camera())), object.get$radius(), 0, 6.283185307179586, false);
        J.closePath$0$x(this.context);
        t1 = this.context;
        if (filled === true)
          J.fill$0$x(t1);
        else
          J.stroke$0$x(t1);
      } else if (!!t1.$isPoint || J.$eq(forceType, 3))
        J.fillRect$4$x(this.context, J.$sub$n(t1.get$x(object), J.get$x$x(this.game.get$camera())), J.$sub$n(t1.get$y(object), J.get$y$x(this.game.get$camera())), 4, 4);
      else if (!!t1.$isLine || J.$eq(forceType, 4)) {
        J.set$lineWidth$x(this.context, 1);
        J.beginPath$0$x(this.context);
        J.moveTo$2$x(this.context, J.$sub$n(J.$add$ns(J.get$x$x(t1.get$start(object)), 0.5), J.get$x$x(this.game.get$camera())), J.$sub$n(J.$add$ns(J.get$y$x(t1.get$start(object)), 0.5), J.get$y$x(this.game.get$camera())));
        J.lineTo$2$x(this.context, J.$sub$n(J.$add$ns(J.get$x$x(object.get$end()), 0.5), J.get$x$x(this.game.get$camera())), J.$sub$n(J.$add$ns(J.get$y$x(object.get$end()), 0.5), J.get$y$x(this.game.get$camera())));
        J.closePath$0$x(this.context);
        J.stroke$0$x(this.context);
      }
      this.stop$0(0);
    }, function(object, color, filled) {
      return this.geom$4(object, color, filled, 0);
    }, "geom$3", function(object, color) {
      return this.geom$4(object, color, true, 0);
    }, "geom$2", function(object) {
      return this.geom$4(object, "rgba(0,255,0,0.4)", true, 0);
    }, "geom$1", "call$4", "call$3", "call$2", "call$1", "get$geom", 2, 6, 1673, 622, 78, 49, 584, [], 152, [], 623, [], 1674, [], "geom"],
    rectangle$3: [function(object, color, filled) {
      var t1, t2;
      if (color == null)
        color = "rgba(0, 255, 0, 0.4)";
      this.start$0(0);
      t1 = this.context;
      t2 = J.getInterceptor$x(object);
      if (filled === true) {
        J.set$fillStyle$x(t1, color);
        J.fillRect$4$x(this.context, J.$sub$n(t2.get$x(object), J.get$x$x(this.game.get$camera())), J.$sub$n(t2.get$y(object), J.get$y$x(this.game.get$camera())), t2.get$width(object), t2.get$height(object));
      } else {
        J.set$strokeStyle$x(t1, color);
        J.strokeRect$4$x(this.context, J.$sub$n(t2.get$x(object), J.get$x$x(this.game.get$camera())), J.$sub$n(t2.get$y(object), J.get$y$x(this.game.get$camera())), t2.get$width(object), t2.get$height(object));
      }
      this.stop$0(0);
    }, function(object) {
      return this.rectangle$3(object, "rgba(0, 255, 0, 0.4)", true);
    }, "rectangle$1", function(object, color) {
      return this.rectangle$3(object, color, true);
    }, "rectangle$2", "call$3", "call$1", "call$2", "get$rectangle", 2, 4, 1675, 1676, 78, 584, [], 152, [], 623, [], "rectangle"],
    text$5: [function(_, text, x, y, color, font) {
      this.start$0(0);
      J.set$font$x(this.context, font);
      if (this.renderShadow === true) {
        J.set$fillStyle$x(this.context, "rgb(0,0,0)");
        J.fillText$3$x(this.context, text, J.$add$ns(x, 1), J.$add$ns(y, 1));
      }
      J.set$fillStyle$x(this.context, color);
      J.fillText$3$x(this.context, text, x, y);
      this.stop$0(0);
    }, function($receiver, text, x, y, color) {
      return this.text$5($receiver, text, x, y, color, "16px Courier");
    }, "text$4", function($receiver, text, x, y) {
      return this.text$5($receiver, text, x, y, "rgb(255,255,255)", "16px Courier");
    }, "text$3", "call$5", "call$4", "call$3", "get$text", 6, 4, 1677, 1651, 1678, 124, [], 9, [], 10, [], 152, [], 201, [], "text"],
    quadTree$2: [function(quadtree, color) {
      var bounds, t1, i, t2;
      this.start$0(0);
      bounds = quadtree.get$bounds();
      t1 = J.getInterceptor$x(quadtree);
      if (J.$index$asx(t1.get$nodes(quadtree), 0) == null) {
        J.set$strokeStyle$x(this.context, color);
        t1 = J.getInterceptor$x(bounds);
        J.strokeRect$4$x(this.context, t1.get$x(bounds), t1.get$y(bounds), t1.get$width(bounds), t1.get$height(bounds));
        this.text$5(0, C.JSString_methods.$add("size: ", J.toString$0(J.get$length$asx(quadtree.get$objects()))), J.$add$ns(t1.get$x(bounds), 4), J.$add$ns(t1.get$y(bounds), 16), "rgb(0,200,0)", "12px Courier");
        J.set$strokeStyle$x(this.context, "rgb(0,255,0)");
        i = 0;
        while (true) {
          t1 = J.get$length$asx(quadtree.get$objects());
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          J.strokeRect$4$x(this.context, J.get$x$x(J.$index$asx(quadtree.get$objects(), i)), J.get$y$x(J.$index$asx(quadtree.get$objects(), i)), J.get$width$x(J.$index$asx(quadtree.get$objects(), i)), J.get$height$x(J.$index$asx(quadtree.get$objects(), i)));
          ++i;
        }
      } else {
        i = 0;
        while (true) {
          t2 = J.get$length$asx(t1.get$nodes(quadtree));
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          this.quadTree$1(J.$index$asx(t1.get$nodes(quadtree), i));
          ++i;
        }
      }
      this.stop$0(0);
    }, function(quadtree) {
      return this.quadTree$2(quadtree, "rgba(255,0,0,0.3)");
    }, "quadTree$1", "call$2", "call$1", "get$quadTree", 2, 2, 1679, 1680, 1681, [], 152, [], "quadTree"],
    body$3: [function(_, sprite, color, filled) {
      var t1 = J.getInterceptor$x(sprite);
      if (t1.get$body(sprite) != null) {
        this.start$0(0);
        if (J.$eq(J.get$type$x(t1.get$body(sprite)), 0) || J.$eq(J.get$type$x(t1.get$body(sprite)), 2))
          t1.get$body(sprite).render$3(this.context, color, filled);
        this.stop$0(0);
      }
    }, function($receiver, sprite) {
      return this.body$3($receiver, sprite, "rgba(0,255,0,0.4)", true);
    }, "body$1", function($receiver, sprite, color) {
      return this.body$3($receiver, sprite, color, true);
    }, "body$2", "call$3", "call$1", "call$2", "get$body", 2, 4, 1682, 622, 78, 151, [], 152, [], 623, [], "body"],
    box2dWorld$0: [function() {
      this.start$0(0);
      J.translate$2$x(this.context, J.$negate$n(J.get$x$x(J.get$view$x(this.game.get$camera()))), J.$negate$n(J.get$y$x(J.get$view$x(this.game.get$camera()))));
      this.game.get$physics().get$box2d().renderDebugDraw$1(this.context);
      this.stop$0(0);
    }, "call$0", "get$box2dWorld", 0, 0, 54, "box2dWorld"],
    box2dBody$2: [function(body, color) {
      this.start$0(0);
      this.stop$0(0);
    }, "call$2", "get$box2dBody", 4, 0, 959, 1468, [], 152, [], "box2dBody"],
    bodyInfo$4: [function(sprite, x, y, color) {
      var t1 = J.getInterceptor$x(sprite);
      if (t1.get$body(sprite) != null)
        if (J.$eq(J.get$type$x(t1.get$body(sprite)), 0)) {
          this.start$4(0, x, y, color, 210);
          t1.get$body(sprite).renderBodyInfo$1(this);
          this.stop$0(0);
        }
    }, "call$4", "get$bodyInfo", 8, 0, 1683, 151, [], 9, [], 10, [], 152, [], "bodyInfo"],
    Debug$1: function(game) {
      this.sprite = null;
      this.canvas = null;
      this.baseTexture = null;
      this.texture = null;
      this.textureFrame = null;
      this.context = null;
      this.font = "14px Courier";
      this.columnWidth = 100;
      this.lineHeight = 16;
      this.renderShadow = true;
      this.currentX = 0;
      this.currentY = 0;
      this.currentAlpha = 1;
      this.dirty = false;
    },
    static: {Debug$: [function(game) {
        var t1 = new R.Debug(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Debug$1(game);
        return t1;
      }, null, null, 2, 0, 302, 252, [], "new Debug"]}
  },
  "+Debug": [674],
  Debug_ropeSegments_closure: {
    "^": "Closure:1305;this_0,color_1,filled_2",
    call$1: [function(segment) {
      this.this_0.rectangle$3(segment, this.color_1, this.filled_2);
    }, "call$1", null, 2, 0, 1305, 1684, [], "call"]
  },
  Utils: {
    "^": "Object;",
    static: {Utils$: [function() {
        return new R.Utils();
      }, null, null, 0, 0, 54, "new Utils"], Utils_transposeArray: [function(array) {
        var t1, t2, result, i, t3, j;
        t1 = J.getInterceptor$asx(array);
        t2 = J.get$length$asx(t1.$index(array, 0));
        if (typeof t2 !== "number")
          return H.iae(t2);
        result = Array(t2);
        result.fixed$length = init;
        t2 = result.length;
        i = 0;
        while (true) {
          t3 = J.get$length$asx(t1.$index(array, 0));
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          t3 = J.$sub$n(t1.get$length(array), 1);
          if (typeof t3 !== "number")
            return H.iae(t3);
          t3 = Array(t3);
          t3.fixed$length = init;
          if (i >= t2)
            return H.ioore(result, i);
          result[i] = t3;
          for (j = J.$sub$n(t1.get$length(array), 1); t3 = J.getInterceptor$n(j), t3.$gt(j, -1); j = t3.$sub(j, 1))
            J.$indexSet$ax(result[i], j, J.$index$asx(t1.$index(array, j), i));
          ++i;
        }
        return result;
      }, "call$1", "Utils_transposeArray$closure", 2, 0, 578, 47, [], "transposeArray"], Utils_rotateArray: [function(matrix, direction) {
        var t1, i, t2;
        if (typeof direction !== "string")
          direction = C.JSNumber_methods.$mod(J.$mod$n(direction, 360) + 360, 360);
        t1 = J.getInterceptor(direction);
        if (t1.$eq(direction, 90) || t1.$eq(direction, -270) || t1.$eq(direction, "rotateLeft")) {
          matrix = R.Utils_transposeArray(matrix);
          matrix = H.setRuntimeTypeInfo(new H.ReversedListIterable(matrix), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(matrix, 0)]), 0)]).toList$0(0);
        } else if (t1.$eq(direction, -90) || t1.$eq(direction, 270) || t1.$eq(direction, "rotateRight"))
          matrix = R.Utils_transposeArray(J.toList$0$ax(J.get$reversed$ax(matrix)));
        else if (J.$eq(t1.abs$0(direction), 180) || t1.$eq(direction, "rotate180")) {
          t1 = J.getInterceptor$asx(matrix);
          i = 0;
          while (true) {
            t2 = t1.get$length(matrix);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            J.toList$0$ax(J.get$reversed$ax(t1.$index(matrix, i)));
            ++i;
          }
          matrix = J.toList$0$ax(t1.get$reversed(matrix));
        }
        return matrix;
      }, "call$2", "Utils_rotateArray$closure", 4, 0, 579, 580, [], 581, [], "rotateArray"], Utils_parseDimension: [function(size, dimension) {
        var f, t1, px;
        if (typeof size === "string")
          if (C.JSString_methods.substring$1(size, size.length - 1) === "%") {
            f = J.$div$n(H.Primitives_parseInt(size, null, null), 100);
            if (J.$eq(dimension, 0)) {
              t1 = window.innerWidth;
              if (typeof t1 !== "number")
                return t1.$mul();
              if (typeof f !== "number")
                return H.iae(f);
              px = t1 * f;
            } else {
              t1 = window.innerHeight;
              if (typeof t1 !== "number")
                return t1.$mul();
              if (typeof f !== "number")
                return H.iae(f);
              px = t1 * f;
            }
          } else
            px = H.Primitives_parseInt(size, null, null);
        else
          px = size;
        return px;
      }, "call$2", "Utils_parseDimension$closure", 4, 0, 582, 314, [], 583, [], "parseDimension"], Utils_shuffle: [function(array) {
        var t1 = P.List_List$from(array, true, null);
        H.IterableMixinWorkaround_shuffleList(t1, null);
        return t1;
      }, "call$1", "Utils_shuffle$closure", 2, 0, 439, 47, [], "shuffle"]}
  },
  "+Utils": [674],
  "^": "ROPE<-614,POINTER<-614,RETROFONT<-614,SPRITEBATCH<-614,ELLIPSE<-614,WEBGL_FILTER<-614,CANVAS_FILTER<-614,BITMAPDATA<-614,POLYGON<-614,EMITTER<-614,TILEMAPLAYER<-614,TILEMAP<-614,RENDERTEXTURE<-614,GROUP<-614,BITMAPTEXT<-614,TILESPRITE<-614,TEXT<-614,GRAPHICS<-614,IMAGE<-614,BUTTON<-614,SPRITE<-614,DOWN<-614,UP<-614,RIGHT<-614,LEFT<-614,NONE<-614,HEADLESS<-614,WEBGL<-614,CANVAS<-614,AUTO<-614,GAMES<-1808,VERSION<-644",
  AnimationUpdateFunc: {"^": ":1814;"},
  "+AnimationUpdateFunc": "",
  Creator: {"^": ":324;"},
  "+Creator": "",
  SelectWhere: {"^": ":1004;"},
  "+SelectWhere": "",
  DestroyGroup: {"^": ":719;"},
  "+DestroyGroup": "",
  ScreenFunc: {"^": ":1815;"},
  "+ScreenFunc": "",
  ResizeFunc: {"^": ":8;"},
  "+ResizeFunc": "",
  GameFunc: {"^": ":17;"},
  "+GameFunc": "",
  GameObjectFunc: {"^": ":1816;"},
  "+GameObjectFunc": "",
  InputFunc: {"^": ":1817;"},
  "+InputFunc": "",
  InputUpFunc: {"^": ":1818;"},
  "+InputUpFunc": "",
  GroupFunc: {"^": ":1819;"},
  "+GroupFunc": "",
  AnimationFunc: {"^": ":1820;"},
  "+AnimationFunc": "",
  PointerFunc: {"^": ":1821;"},
  "+PointerFunc": "",
  MoveFunc: {"^": ":1822;"},
  "+MoveFunc": "",
  KeyFunc: {"^": ":1823;"},
  "+KeyFunc": "",
  LoaderStartFunc: {"^": ":712;"},
  "+LoaderStartFunc": "",
  FileStartFunc: {"^": ":1824;"},
  "+FileStartFunc": "",
  FileCompleteFunc: {"^": ":1825;"},
  "+FileCompleteFunc": "",
  FileError0: {"^": ":1826;"},
  "+FileError": "",
  PackCompleteFunc: {"^": ":1827;"},
  "+PackCompleteFunc": "",
  doubleFunc: {"^": ":21;"},
  "+doubleFunc": "",
  CollideFunc: {"^": ":1828;"},
  "+CollideFunc": "",
  ProcessFunc: {"^": ":1829;"},
  "+ProcessFunc": "",
  SoundFunc: {"^": ":1830;"},
  "+SoundFunc": "",
  TimerFunc: {"^": ":1831;"},
  "+TimerFunc": "",
  EasingFunction: {"^": ":1832;"},
  "+EasingFunction": "",
  ObjectFunc: {"^": ":1833;"},
  "+ObjectFunc": ""
}],
["TextFueledCombat", "lib/tfc_dart.dart", , R, {
  "^": "",
  addGameButton: function(game, x, y, key, buttonText, onDown) {
    var sprite, t1, bmp;
    sprite = R.Sprite$(game, 50, 50, key, 0, null);
    t1 = J.getInterceptor$ax(game);
    bmp = t1.get$add(game).bitmapData$2(J.$mul$ns(J.get$x$x(sprite.scale), J.get$width$x(sprite.texture.get$frame())), J.$mul$ns(J.get$y$x(sprite.scale), J.get$height$x(sprite.texture.get$frame())));
    bmp.draw$1(sprite);
    J.fillText$3$x(bmp.ctx, buttonText, J.$div$n(bmp.width, 4), J.$div$n(bmp.height, 2));
    sprite = t1.get$add(game).sprite$3(x, y, bmp);
    sprite.set$inputEnabled(true);
    J.add$1$ax(sprite.get$events().get$onInputDown(), onDown);
    sprite.set$buttonMode(true);
    return sprite;
  },
  getPortraitKey: function(ct) {
    switch (ct) {
      case C.CharType_0:
        return "playerPortrait";
      case C.CharType_1:
        return "devilPortrait";
      default:
        throw H.wrapException(P.Exception_Exception("Invalid CharType supplied for getPortraitKey call"));
    }
  },
  redrawHpBar: function(game, $char) {
    var t1, t2, percent, bmp;
    t1 = $char.get$_hpCurrent();
    t2 = $char.get$_hpMax();
    if (typeof t1 !== "number")
      return t1.$div();
    if (typeof t2 !== "number")
      return H.iae(t2);
    percent = C.JSNumber_methods.toInt$0(t1 / t2 * 100);
    bmp = J.get$add$ax(game).bitmapData$2(J.get$width$x($char.get$hpBar()), J.get$height$x($char.get$hpBar()));
    bmp.draw$1($char.get$hpBar());
    bmp.rect$5(0, 2, 2, percent, 20, "#00FF00");
    bmp.rect$5(0, 2 + percent + 1, 2, 100 - percent, 20, "#000000");
    $char.get$hpBar().loadTexture$1(bmp);
  },
  Array2d: {
    "^": "Object;array@,defaultValue>",
    $index: function(_, x) {
      var t1 = this.array;
      if (x >>> 0 !== x || x >= t1.length)
        return H.ioore(t1, x);
      return t1[x];
    },
    set$width: function(_, v) {
      var t1, t2, newList, y;
      if (typeof v !== "number")
        return H.iae(v);
      for (; t1 = this.array, t2 = t1.length, t2 > v;) {
        if (0 >= t2)
          return H.ioore(t1, 0);
        t1.pop();
      }
      for (t1 = this.defaultValue; this.array.length < v;) {
        newList = [];
        newList.$builtinTypeInfo = [H.getTypeArgumentByIndex(this, 0)];
        if (this.array.length > 0) {
          y = 0;
          while (true) {
            t2 = J.get$length$asx(C.JSArray_methods.get$first(this.array));
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(y < t2))
              break;
            newList.push(t1);
            ++y;
          }
        }
        this.array.push(newList);
      }
    },
    set$height: function(_, v) {
      var x, t1, t2;
      for (; J.$gt$n(J.get$length$asx(C.JSArray_methods.get$first(this.array)), v);)
        for (x = 0; t1 = this.array, x < t1.length; ++x)
          J.removeLast$0$ax(t1[x]);
      for (t1 = this.defaultValue; J.$lt$n(J.get$length$asx(C.JSArray_methods.get$first(this.array)), v);)
        for (x = 0; t2 = this.array, x < t2.length; ++x)
          J.add$1$ax(t2[x], t1);
    },
    toString$0: function(_) {
      var ret, i, t1;
      for (ret = "", i = 0; t1 = this.array, i < t1.length; ++i)
        ret = C.JSString_methods.$add(ret, J.$add$ns(J.toString$0(t1[i]), ",\n"));
      return ret;
    },
    Array2d$3$defaultValue: function(width, height, defaultValue, $T) {
      this.array = H.setRuntimeTypeInfo([], [[P.List, $T]]);
      this.set$width(0, width);
      this.set$height(0, height);
    },
    static: {Array2d$: function(width, height, defaultValue, $T) {
        var t1 = H.setRuntimeTypeInfo(new R.Array2d(null, defaultValue), [$T]);
        t1.Array2d$3$defaultValue(width, height, defaultValue, $T);
        return t1;
      }}
  },
  AStarPathFinder: {
    "^": "Object;_closed,_open,map*,_maxSearchDistance,_nodes,_allowDiagMovement,_heuristic",
    map$1: function($receiver, arg0) {
      return this.map.call$1(arg0);
    },
    findPath$6: function(mover, sx, sy, tx, ty, maxCost) {
      var t1, t2, t3, t4, maxDepth, current, t5, x, t6, y, t7, xp, yp, invalid, t8, t9, nextStepCost, neighbour, dx, dy, path, target;
      P.print("Entered findPath");
      if (this.map.blocked$3(mover, tx, ty) === true) {
        P.print("Destination blocked! :(");
        return;
      }
      t1 = this._nodes.array;
      if (sx >>> 0 !== sx || sx >= t1.length)
        return H.ioore(t1, sx);
      J.$index$asx(t1[sx], sy).set$_cost(0);
      t1 = this._nodes.array;
      if (sx >= t1.length)
        return H.ioore(t1, sx);
      J.$index$asx(t1[sx], sy).set$_depth(0);
      t1 = this._closed;
      C.JSArray_methods.set$length(t1, 0);
      t2 = this._open;
      t2.clear$0(t2);
      t3 = this._nodes.array;
      if (sx >= t3.length)
        return H.ioore(t3, sx);
      t3 = J.$index$asx(t3[sx], sy);
      J.get$length$asx(t2.l);
      P.ListMixin.prototype.add$1.call(t2, t2, t3);
      P.ListMixin.prototype.sort$1.call(t2, t2, null);
      t3 = this._nodes.array;
      if (tx >>> 0 !== tx || tx >= t3.length)
        return H.ioore(t3, tx);
      J.$index$asx(t3[tx], ty).set$_TextFueledCombat$_parent(null);
      t3 = J.getInterceptor(sy);
      t4 = J.getInterceptor$n(ty);
      maxDepth = 0;
      while (true) {
        if (!(maxDepth < this._maxSearchDistance && J.get$length$asx(t2.l) !== 0))
          break;
        current = t2.get$first(t2);
        t5 = this._nodes.array;
        if (tx >= t5.length)
          return H.ioore(t5, tx);
        if (J.$eq(current, J.$index$asx(t5[tx], ty)))
          break;
        t2.remove$1(t2, current);
        t1.push(current);
        for (x = -1; x < 2; ++x)
          for (t5 = x === 0, t6 = !t5, y = -1; y < 2; ++y) {
            if (t5 && y === 0)
              continue;
            if (!this._allowDiagMovement)
              if (t6 && y !== 0)
                continue;
            t7 = current.get$_TextFueledCombat$_x();
            if (typeof t7 !== "number")
              return H.iae(t7);
            xp = x + t7;
            t7 = current.get$_TextFueledCombat$_y();
            if (typeof t7 !== "number")
              return H.iae(t7);
            yp = y + t7;
            if (!(xp < 0))
              if (!(yp < 0)) {
                t7 = this.map._grid.array;
                if (0 >= t7.length)
                  return H.ioore(t7, 0);
                t7 = J.get$length$asx(t7[0]);
                if (typeof t7 !== "number")
                  return H.iae(t7);
                t7 = yp >= t7 || xp >= this.map._grid.array.length;
                invalid = t7;
              } else
                invalid = true;
            else
              invalid = true;
            if (!invalid)
              t7 = sx !== xp || !t3.$eq(sy, yp);
            else
              t7 = false;
            if ((t7 ? this.map.blocked$3(mover, xp, yp) : invalid) !== true) {
              t7 = current.get$_cost();
              t8 = current.get$_TextFueledCombat$_x();
              t9 = current.get$_TextFueledCombat$_y();
              t9 = this.map.getCost$5(mover, t8, t9, xp, yp);
              if (typeof t7 !== "number")
                return t7.$add();
              nextStepCost = t7 + t9;
              if (nextStepCost > maxCost)
                continue;
              t7 = this._nodes.array;
              if (xp >>> 0 !== xp || xp >= t7.length)
                return H.ioore(t7, xp);
              neighbour = J.$index$asx(t7[xp], yp);
              t7 = neighbour.get$_cost();
              if (typeof t7 !== "number")
                return H.iae(t7);
              if (nextStepCost < t7) {
                if (t2.contains$1(t2, neighbour))
                  t2.remove$1(t2, neighbour);
                if (C.JSArray_methods.contains$1(t1, neighbour))
                  C.JSArray_methods.remove$1(t1, neighbour);
              }
              if (!t2.contains$1(t2, neighbour) && !C.JSArray_methods.contains$1(t1, neighbour)) {
                neighbour.set$_cost(nextStepCost);
                this._heuristic.toString;
                dx = tx - xp;
                dy = t4.$sub(ty, yp);
                t7 = J.$mul$ns(dy, dy);
                if (typeof t7 !== "number")
                  return H.iae(t7);
                neighbour.set$_heuristicCost(Math.sqrt(dx * dx + t7));
                maxDepth = P.max(maxDepth, neighbour.setParent$1(current));
                J.get$length$asx(t2.l);
                P.ListMixin.prototype.add$1.call(t2, t2, neighbour);
                P.ListMixin.prototype.sort$1.call(t2, t2, null);
              }
            }
          }
      }
      t1 = this._nodes.array;
      if (tx >= t1.length)
        return H.ioore(t1, tx);
      if (J.$index$asx(t1[tx], ty).get$_TextFueledCombat$_parent() == null) {
        P.print("No path found! D:");
        return;
      }
      path = new R.Path(null);
      path._steps = H.setRuntimeTypeInfo([], [R.Node]);
      t1 = this._nodes.array;
      if (tx >= t1.length)
        return H.ioore(t1, tx);
      target = J.$index$asx(t1[tx], ty);
      P.print("Path cost: " + H.S(target.get$_cost()));
      while (true) {
        t1 = this._nodes.array;
        if (sx >= t1.length)
          return H.ioore(t1, sx);
        if (!!J.$eq(target, J.$index$asx(t1[sx], sy)))
          break;
        C.JSArray_methods.insert$2(path._steps, 0, target);
        target = target.get$_TextFueledCombat$_parent();
      }
      t1 = this._nodes.array;
      if (sx >= t1.length)
        return H.ioore(t1, sx);
      t1 = J.$index$asx(t1[sx], sy);
      C.JSArray_methods.insert$2(path._steps, 0, t1);
      return path;
    },
    findPath$5: function(mover, sx, sy, tx, ty) {
      return this.findPath$6(mover, sx, sy, tx, ty, 1 / 0);
    },
    AStarPathFinder$4: function(map, maxSearchDistance, allowDiagMovement, heuristic) {
      var x, y, t1, mapWidth, mapHeight, t2, exception;
      this._heuristic = new R.ClosestHeuristic();
      this.map = map;
      this._maxSearchDistance = maxSearchDistance;
      this._allowDiagMovement = allowDiagMovement;
      t1 = map.get$_grid().array;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      mapWidth = J.get$length$asx(t1[0]);
      mapHeight = map.get$_grid().array.length;
      P.print("mapheight " + mapHeight + " .. mapwidth " + H.S(mapWidth));
      this._nodes = R.Array2d$(mapHeight, mapWidth, null, null);
      for (x = 0; J.$lt$n(x, mapHeight); x = J.$add$ns(x, 1))
        for (y = 0; J.$lt$n(y, mapWidth); y = J.$add$ns(y, 1)) {
          t1 = x;
          t2 = this._nodes.array;
          if (t1 >>> 0 !== t1 || t1 >= t2.length)
            return H.ioore(t2, t1);
          t1 = t2[t1];
          t2 = new R.Node(null, null, null, null, null, null);
          t2._TextFueledCombat$_x = x;
          t2._TextFueledCombat$_y = y;
          J.$indexSet$ax(t1, y, t2);
          try {
            t1 = x;
            t2 = this._nodes.array;
            if (t1 >>> 0 !== t1 || t1 >= t2.length)
              return H.ioore(t2, t1);
            J.$index$asx(t2[t1], y).set$_cost(map.getCost$5(null, J.$sub$n(x, 1), y, x, y));
          } catch (exception) {
            if (!!J.getInterceptor(H.unwrapException(exception)).$isRangeError) {
              t1 = x;
              t2 = this._nodes.array;
              if (t1 >>> 0 !== t1 || t1 >= t2.length)
                return H.ioore(t2, t1);
              J.$index$asx(t2[t1], y).set$_cost(map.getCost$5(null, J.$add$ns(x, 1), y, x, y));
            } else
              throw exception;
          }

        }
    },
    static: {AStarPathFinder$: function(map, maxSearchDistance, allowDiagMovement, heuristic) {
        var t1 = new R.AStarPathFinder(H.setRuntimeTypeInfo([], [R.Node]), H.setRuntimeTypeInfo(new R.SortedList(H.setRuntimeTypeInfo([], [null])), [null]), null, null, null, null, null);
        t1.AStarPathFinder$4(map, maxSearchDistance, allowDiagMovement, heuristic);
        return t1;
      }}
  },
  Node: {
    "^": "Object;_TextFueledCombat$_x<,_TextFueledCombat$_y<,_cost@,_TextFueledCombat$_parent@,_heuristicCost@,_depth@",
    get$x: function(_) {
      return this._TextFueledCombat$_x;
    },
    get$y: function(_) {
      return this._TextFueledCombat$_y;
    },
    get$cost: function() {
      return this._cost;
    },
    setParent$1: function($parent) {
      var t1 = $parent.get$_depth();
      if (typeof t1 !== "number")
        return t1.$add();
      ++t1;
      this._depth = t1;
      this._TextFueledCombat$_parent = $parent;
      return t1;
    },
    compareTo$1: function(_, other) {
      var t1, t2, f, of;
      t1 = this._heuristicCost;
      t2 = this._cost;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      f = t1 + t2;
      t2 = other.get$_heuristicCost();
      t1 = other.get$_cost();
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof t1 !== "number")
        return H.iae(t1);
      of = t2 + t1;
      if (f < of)
        return -1;
      else if (f > of)
        return 1;
      else
        return 0;
    },
    toString$0: function(_) {
      return "(" + H.S(this._TextFueledCombat$_x) + "," + H.S(this._TextFueledCombat$_y) + ")";
    },
    $isNode: true
  },
  SortedList: {
    "^": "ListBase;l@",
    get$length: function(_) {
      return J.get$length$asx(this.l);
    },
    set$length: function(_, len) {
      J.set$length$asx(this.l, len);
    },
    $index: function(_, i) {
      return J.$index$asx(this.l, i);
    },
    $indexSet: function(_, index, t) {
      J.$indexSet$ax(this.l, index, t);
    },
    add$1: [function(_, o) {
      J.get$length$asx(this.l);
      P.ListMixin.prototype.add$1.call(this, this, o);
      P.ListMixin.prototype.sort$1.call(this, this, null);
    }, "call$1", "get$add", 2, 0, 940, 608, []]
  },
  Character: {
    "^": "Object;_hpMax<,_hpCurrent@,_attackPower,_mobility,_TextFueledCombat$_name<,_pos<,_sprite<,hpBar@,_type<,_tired,_hasMoved,_attackCharges,_weaknesses<",
    get$name: function(_) {
      return this._TextFueledCombat$_name;
    },
    get$sprite: function() {
      return this._sprite;
    },
    sprite$3: function(arg0, arg1, arg2) {
      return this.get$sprite().call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.get$sprite().call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.get$sprite().call$4(arg0, arg1, arg2, arg3);
    },
    get$tired: function() {
      return this._tired;
    },
    get$hasMoved: function() {
      return this._hasMoved;
    },
    get$hpMax: function() {
      return this._hpMax;
    },
    get$hpCurrent: function() {
      return this._hpCurrent;
    },
    get$mobility: function() {
      return this._mobility;
    },
    get$type: function(_) {
      return this._type;
    },
    get$attackCharges: function() {
      return this._attackCharges;
    },
    get$pos: function() {
      return this._pos;
    },
    set$tired: function(isTired) {
      this._tired = isTired;
    },
    set$hasMoved: function(moved) {
      this._hasMoved = moved;
    },
    attack$2: function(atkType, other) {
      var diffX, diffY, t1, t2, damage;
      diffX = J.abs$0$n(J.$sub$n(this._pos.x, other.get$_pos().x));
      diffY = J.abs$0$n(J.$sub$n(this._pos.y, other.get$_pos().y));
      t1 = J.getInterceptor(diffX);
      if (t1.$eq(diffX, 1) || J.$eq(diffY, 1))
        if (!(t1.$eq(diffX, 1) && J.$eq(diffY, 1))) {
          t2 = !(t1.$gt(diffX, 1) || J.$gt$n(diffY, 1));
          t1 = t2;
        } else
          t1 = false;
      else
        t1 = false;
      if (t1) {
        damage = this._attackPower;
        if (J.contains$1$asx(other.get$_weaknesses(), J.get$value$x(atkType))) {
          if (typeof damage !== "number")
            return damage.$mul();
          damage *= 1.1;
        }
        t1 = other.get$_hpCurrent();
        if (typeof t1 !== "number")
          return t1.$sub();
        if (typeof damage !== "number")
          return H.iae(damage);
        other.set$_hpCurrent(t1 - damage);
        t1 = other.get$_hpCurrent();
        if (typeof t1 !== "number")
          return t1.$le();
        if (t1 <= 0)
          other.get$_sprite().kill$0();
        t1 = this._attackCharges;
        t1.$indexSet(0, atkType, J.$sub$n(t1.$index(0, atkType), 1));
        this._tired = true;
      } else
        throw H.wrapException(R.AttackRangeException$("Target out of range!"));
    },
    addCharge$1: function(type) {
      var attType, t1;
      attType = H.IterableMixinWorkaround_firstWhere($.get$Character_ALL_TYPES(), new R.Character_addCharge_closure(type), null);
      if (this._attackCharges.containsKey$1(0, attType)) {
        t1 = this._attackCharges;
        t1.$indexSet(0, attType, J.$add$ns(t1.$index(0, attType), 1));
      } else
        throw H.wrapException(P.Exception_Exception("Invalid AttackType"));
    },
    hasCharge$1: function(at) {
      return J.$gt$n(this._attackCharges.$index(0, at), 0);
    },
    isWeakTo$1: function(type) {
      var t1 = this._weaknesses;
      t1.toString;
      return H.IterableMixinWorkaround_any(t1, new R.Character_isWeakTo_closure(type));
    },
    moveTo$6$finder$precomputed: function(_, x, y, map, game, finder, precomputed) {
      var t1, t2, t3, path, tt, i, line, comp, moveTweens, t4, p1, box_0, box_00;
      t1 = map._grid.array;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t2 = J.getInterceptor$n(y);
      if (!t2.$ge(y, J.get$length$asx(t1[0]))) {
        t1 = J.getInterceptor$n(x);
        t1 = t1.$ge(x, map._grid.array.length) || t1.$lt(x, 0) || t2.$lt(y, 0);
      } else
        t1 = true;
      if (t1)
        ;
      else {
        t1 = this._pos;
        t3 = t1.x;
        t1 = t1.y;
        if (J.$gt$n(J.$add$ns(J.abs$0$n(J.$sub$n(x, t3)), J.abs$0$n(t2.$sub(y, t1))), this._mobility))
          ;
        else {
          if (finder != null) {
            t1 = this._pos;
            t2 = t1.x;
            t1 = t1.y;
            t3 = this._mobility;
            t3.toString;
            path = finder.findPath$6(this, t2, t1, x, y, t3);
          } else
            path = precomputed;
          if (path == null) {
            tt = map.whatTile$2(x, y);
            window.alert("Path blocked! At (" + H.S(x) + "," + H.S(y) + ") there is a tile of type " + H.S(J.get$value$x(tt)));
            return;
          }
          P.print("Printing path steps...");
          for (i = 0; t1 = path._steps, i < t1.length; ++i) {
            t1 = "(" + H.S(J.get$x$x(t1[i])) + ",";
            t2 = path._steps;
            if (i >= t2.length)
              return H.ioore(t2, i);
            line = t1 + H.S(J.get$y$x(t2[i])) + ")";
            H.printString(line);
          }
          P.print("Path End");
          comp = H.setRuntimeTypeInfo(new P._AsyncCompleter(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null])), [null]);
          moveTweens = H.setRuntimeTypeInfo([], [R.Tween]);
          for (t1 = J.getInterceptor$ax(game), i = 0; t2 = path._steps, i < t2.length - 1;) {
            ++i;
            t2 = t2[i];
            t3 = J.getInterceptor$x(t2);
            t4 = J.$add$ns(J.$mul$ns(t3.get$y(t2), 32), 128);
            t2 = J.$sub$n(J.$add$ns(J.$mul$ns(t3.get$x(t2), 32), 64), 46);
            p1 = new R.Point(null, null);
            p1.x = t4;
            p1.y = t2;
            moveTweens.push(t1.get$add(game).tween$1(this._sprite).to$3(P.LinkedHashMap_LinkedHashMap$_literal(["x", t4, "y", t2], null, null), 600, $.get$Easing_Quadratic().get$InOut()));
          }
          box_0 = {};
          for (box_0.i_0 = 0; t1 = box_0.i_0, t1 < moveTweens.length - 1; box_00 = {}, t1 = box_0.i_0, box_00.i_0 = t1, box_00.i_0 = t1 + 1, box_0 = box_00)
            moveTweens[t1].onComplete.addOnce$1(new R.Character_moveTo_closure(box_0, moveTweens));
          C.JSArray_methods.get$last(moveTweens).onComplete.addOnce$1(new R.Character_moveTo_closure0(comp));
          if (0 >= moveTweens.length)
            return H.ioore(moveTweens, 0);
          moveTweens[0].start$0(0);
          t1 = map._units;
          t2 = this._pos;
          t3 = t2.x;
          t1 = t1.array;
          if (t3 >>> 0 !== t3 || t3 >= t1.length)
            return H.ioore(t1, t3);
          J.$indexSet$ax(t1[t3], t2.y, "");
          t2 = map._units.array;
          if (x >>> 0 !== x || x >= t2.length)
            return H.ioore(t2, x);
          J.$indexSet$ax(t2[x], y, this._TextFueledCombat$_name);
          t2 = this._pos;
          t2.x = x;
          t2.y = y;
          this._hasMoved = true;
          return comp.future;
        }
      }
    },
    moveTo$5$precomputed: function($receiver, x, y, map, game, precomputed) {
      return this.moveTo$6$finder$precomputed($receiver, x, y, map, game, null, precomputed);
    },
    moveTo$5$finder: function($receiver, x, y, map, game, finder) {
      return this.moveTo$6$finder$precomputed($receiver, x, y, map, game, finder, null);
    },
    initSprite$1: function(game) {
      switch (this._type) {
        case C.CharType_0:
          this._sprite = J.get$add$ax(game).sprite$3(J.$add$ns(J.$mul$ns(this._pos.y, 32), 128), J.$sub$n(J.$add$ns(J.$mul$ns(this._pos.x, 32), 64), 46), "roshan");
          break;
        case C.CharType_1:
          this._sprite = J.get$add$ax(game).sprite$3(J.$add$ns(J.$mul$ns(this._pos.y, 32), 128), J.$sub$n(J.$add$ns(J.$mul$ns(this._pos.x, 32), 64), 46), "devil");
          break;
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return this._TextFueledCombat$_name === other.get$_TextFueledCombat$_name();
    },
    Character$3: function($name, type, pos) {
      this._TextFueledCombat$_name = $name;
      this._pos = pos;
      this._type = type;
      this._tired = false;
      this._hasMoved = false;
      this._attackCharges = P.LinkedHashMap_LinkedHashMap(null, null, null, R.AttackType, P.$int);
      this._weaknesses = H.setRuntimeTypeInfo([], [R.AttackType]);
      this._attackCharges.$indexSet(0, C.AttackType_0, 0);
      this._attackCharges.$indexSet(0, C.AttackType_1, 0);
      this._attackCharges.$indexSet(0, C.AttackType_2, 0);
      this._attackCharges.$indexSet(0, C.AttackType_3, 0);
      this._attackCharges.$indexSet(0, C.AttackType_4, 0);
      this._attackCharges.$indexSet(0, C.AttackType_5, 0);
      switch (type) {
        case C.CharType_0:
          this._hpMax = 100;
          this._hpCurrent = 100;
          this._attackPower = 10;
          this._mobility = 7;
          this._weaknesses.push(C.AttackType_5);
          break;
        case C.CharType_1:
          this._hpMax = 100;
          this._hpCurrent = 100;
          this._attackPower = 8;
          this._mobility = 7;
          this._weaknesses.push(C.AttackType_1);
          break;
        default:
          throw H.wrapException("Error: Invalid type argument supplied.");
      }
    },
    $isCharacter: true,
    static: {"^": "Character_ALL_TYPES", Character$: function($name, type, pos) {
        var t1 = new R.Character(null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Character$3($name, type, pos);
        return t1;
      }}
  },
  Character_addCharge_closure: {
    "^": "Closure:1685;type_0",
    call$1: function(att) {
      return J.$eq(J.get$value$x(att), this.type_0);
    }
  },
  Character_isWeakTo_closure: {
    "^": "Closure:1685;type_0",
    call$1: function(atkType) {
      return J.$eq(atkType, this.type_0);
    }
  },
  Character_moveTo_closure: {
    "^": "Closure:102;box_0,moveTweens_1",
    call$1: [function(_) {
      var t1, t2;
      t1 = this.moveTweens_1;
      t2 = this.box_0.i_0 + 1;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2].start$0(0);
    }, "call$1", null, 2, 0, null, 1686, [], "call"]
  },
  Character_moveTo_closure0: {
    "^": "Closure:102;comp_2",
    call$1: [function(_) {
      return this.comp_2.complete$1(0, true);
    }, "call$1", null, 2, 0, null, 1686, [], "call"]
  },
  CharType: {
    "^": "Enum;value",
    static: {"^": "CharType_PLAYER,CharType_ENEMY"}
  },
  AttackType: {
    "^": "Enum;value",
    $isAttackType: true,
    static: {"^": "AttackType_TYPE_COUNT,AttackType_FIRE,AttackType_WATER,AttackType_EARTH,AttackType_AIR,AttackType_SWORD,AttackType_MACE"}
  },
  ClosestHeuristic: {
    "^": "Object;"
  },
  Enum: {
    "^": "Object;value>"
  },
  FileProcessor: {
    "^": "Object;_charCountsTile,_charCountsAttack,_charTileMappings,_charAttackMappings,_exhaustedChars,rng",
    analyseTxtFile$1: function(txtFile) {
      var t1, reader, fileIsRead, t2;
      t1 = {};
      reader = new FileReader();
      t1.fileText_0 = "";
      fileIsRead = H.setRuntimeTypeInfo(new P._AsyncCompleter(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null])), [null]);
      t2 = C.EventStreamProvider_loadend.forTarget$1(reader);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t2._target, t2._eventType, W._wrapZone(new R.FileProcessor_analyseTxtFile_closure(t1, this, fileIsRead)), t2._useCapture), [H.getTypeArgumentByIndex(t2, 0)])._tryResume$0();
      reader.readAsText(txtFile);
      return fileIsRead.future;
    },
    takeRandAtkType$1: function(chargee) {
      var t1, keys, rand, randKey, ret;
      t1 = this._charAttackMappings;
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
      t1 = H.setRuntimeTypeInfo(new H.WhereIterable(t1, new R.FileProcessor_takeRandAtkType_closure(this, chargee)), [H.getRuntimeTypeArgument(t1, "IterableBase", 0)]);
      keys = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
      rand = this.rng.nextInt$1(keys.length);
      if (rand >>> 0 !== rand || rand >= keys.length)
        return H.ioore(keys, rand);
      randKey = keys[rand];
      ret = this._charAttackMappings.$index(0, randKey);
      t1 = this._charCountsAttack;
      t1.$indexSet(0, randKey, J.$sub$n(t1.$index(0, randKey), 1));
      if (J.$eq(this._charCountsAttack.$index(0, randKey), 0)) {
        this._charAttackMappings.remove$1(0, randKey);
        this._charCountsAttack.remove$1(0, randKey);
      }
      return ret;
    },
    _takeChar$1: function(chosenChar) {
      var t1 = this._charCountsTile;
      t1.$indexSet(0, chosenChar, J.$sub$n(t1.$index(0, chosenChar), 1));
      if (J.$eq(this._charCountsTile.$index(0, chosenChar), 0)) {
        P.print(H.S(chosenChar) + " exhausted!");
        this._exhaustedChars.$indexSet(0, chosenChar, this._charTileMappings.remove$1(0, chosenChar));
        this._charAttackMappings.remove$1(0, chosenChar);
        this._charCountsTile.remove$1(0, chosenChar);
      }
    },
    _setupCharCountMap$0: function() {
      for (var i = 33; i <= 122; ++i)
        this._charCountsTile.$indexSet(0, H.Primitives_stringFromCharCode(i), 0);
    },
    _setupCharTileMapping$0: function() {
      var t1, i, t2;
      t1 = {};
      t1.x_0 = 0;
      for (i = 33; i <= 122; ++i)
        this._charTileMappings.$indexSet(0, H.Primitives_stringFromCharCode(i), 0);
      t2 = this._charTileMappings;
      H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t2), [H.getTypeArgumentByIndex(t2, 0)]).forEach$1(0, new R.FileProcessor__setupCharTileMapping_closure(t1, this));
    },
    _setupCharAttackMapping$0: function() {
      var t1, i, t2;
      t1 = {};
      t1.x_0 = 0;
      for (i = 33; i <= 122; ++i)
        this._charAttackMappings.$indexSet(0, H.Primitives_stringFromCharCode(i), 0);
      t2 = this._charAttackMappings;
      H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t2), [H.getTypeArgumentByIndex(t2, 0)]).forEach$1(0, new R.FileProcessor__setupCharAttackMapping_closure(t1, this));
    },
    FileProcessor$0: function() {
      this._charCountsTile = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.$int);
      this._charCountsAttack = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.$int);
      this._charTileMappings = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.$int);
      this._charAttackMappings = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.$int);
      this._exhaustedChars = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.$int);
      this._setupCharCountMap$0();
      this._setupCharTileMapping$0();
      this._setupCharAttackMapping$0();
    }
  },
  FileProcessor_analyseTxtFile_closure: {
    "^": "Closure:102;box_0,this_1,fileIsRead_2",
    call$1: [function(e) {
      var t1, t2, i, t3, t4, zeroedKeys;
      t1 = this.box_0;
      t1.fileText_0 = J.get$result$x(J.get$target$x(e));
      t2 = this.this_1;
      i = 0;
      while (true) {
        t3 = J.get$length$asx(t1.fileText_0);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        if (t2._charCountsTile.containsKey$1(0, J.$index$asx(t1.fileText_0, i))) {
          t3 = t2._charCountsTile;
          t4 = J.$index$asx(t1.fileText_0, i);
          t3.$indexSet(0, t4, J.$add$ns(t3.$index(0, t4), 1));
        }
        ++i;
      }
      t1 = t2._charCountsTile;
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
      t1 = H.setRuntimeTypeInfo(new H.WhereIterable(t1, new R.FileProcessor_analyseTxtFile__closure(t2)), [H.getRuntimeTypeArgument(t1, "IterableBase", 0)]);
      zeroedKeys = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
      for (i = 0; i < zeroedKeys.length; ++i) {
        t2._charCountsTile.remove$1(0, zeroedKeys[i]);
        t1 = t2._charTileMappings;
        if (i >= zeroedKeys.length)
          return H.ioore(zeroedKeys, i);
        t1.remove$1(0, zeroedKeys[i]);
        t1 = t2._charAttackMappings;
        if (i >= zeroedKeys.length)
          return H.ioore(zeroedKeys, i);
        t1.remove$1(0, zeroedKeys[i]);
      }
      this.fileIsRead_2.complete$1(0, true);
    }, "call$1", null, 2, 0, null, 356, [], "call"]
  },
  FileProcessor_analyseTxtFile__closure: {
    "^": "Closure:91;this_3",
    call$1: function(k) {
      return J.$eq(this.this_3._charCountsTile.$index(0, k), 0);
    }
  },
  FileProcessor_takeRandAtkType_closure: {
    "^": "Closure:91;this_0,chargee_1",
    call$1: function(str) {
      return !J.contains$1$asx(this.chargee_1.get$_weaknesses(), this.this_0._charAttackMappings.$index(0, str));
    }
  },
  FileProcessor__setupCharTileMapping_closure: {
    "^": "Closure:91;box_0,this_1",
    call$1: function(key) {
      var t1 = this.box_0;
      this.this_1._charTileMappings.$indexSet(0, key, C.JSInt_methods.$mod(t1.x_0, 7));
      ++t1.x_0;
    }
  },
  FileProcessor__setupCharAttackMapping_closure: {
    "^": "Closure:91;box_0,this_1",
    call$1: function(key) {
      var t1 = this.box_0;
      this.this_1._charAttackMappings.$indexSet(0, key, C.JSInt_methods.$mod(t1.x_0, 6));
      ++t1.x_0;
    }
  },
  GameMap: {
    "^": "Object;_tileTypes,_traversableTypes,playerTeam,enemyTeam,_grid<,_units,_spriteGrid,fileProcessor,finder,_rng",
    get$width: function(_) {
      var t1 = this._grid.array;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return J.get$length$asx(t1[0]);
    },
    get$height: function(_) {
      return this._grid.array.length;
    },
    whatTile$2: function(row, col) {
      var t1, tileVal;
      t1 = this._grid.array;
      if (row >>> 0 !== row || row >= t1.length)
        return H.ioore(t1, row);
      tileVal = J.$index$asx(t1[row], col);
      t1 = this._tileTypes;
      return H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]).firstWhere$1(0, new R.GameMap_whatTile_closure(tileVal));
    },
    generateMap$1: function(file) {
      return this.fileProcessor.analyseTxtFile$1(file).then$1(new R.GameMap_generateMap_closure(this));
    },
    _tileFitsWell$3: function(tileTypeInt, row, col) {
      var t1, t2, tileType, temp, strikeCount;
      t1 = this._tileTypes;
      t2 = new P.LinkedHashMapKeyIterable(t1);
      t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
      tileType = t2.firstWhere$1(0, new R.GameMap__tileFitsWell_closure(tileTypeInt));
      if (this._tileTypes.$index(0, tileType).get$_traversable() === true)
        return true;
      else {
        t1 = row > 0;
        if (t1 && col > 0) {
          temp = this.whatTile$2(row - 1, col - 1);
          strikeCount = this._tileTypes.$index(0, temp).get$_traversable() !== true ? 1 : 0;
        } else
          strikeCount = 0;
        if (t1) {
          temp = this.whatTile$2(row - 1, col);
          if (this._tileTypes.$index(0, temp).get$_traversable() !== true)
            ++strikeCount;
        }
        if (t1) {
          t1 = this._grid.array;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1 = J.$sub$n(J.get$length$asx(t1[0]), 1);
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = col < t1;
        } else
          t1 = false;
        if (t1) {
          temp = this.whatTile$2(row - 1, col + 1);
          if (this._tileTypes.$index(0, temp).get$_traversable() !== true)
            ++strikeCount;
        }
        if (col > 0) {
          temp = this.whatTile$2(row, col - 1);
          if (this._tileTypes.$index(0, temp).get$_traversable() !== true)
            ++strikeCount;
        }
      }
      return strikeCount < 1;
    },
    _rollTraversableType$0: function() {
      var t1, t2, t3, traversableChars, rand, chosen, ret;
      t1 = {};
      t1.tileInt_0 = null;
      t2 = this.fileProcessor._charTileMappings;
      t3 = new P.LinkedHashMapKeyIterable(t2);
      t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
      t1 = new H.WhereIterable(t3, new R.GameMap__rollTraversableType_closure(t1, this));
      t1.$builtinTypeInfo = [H.getRuntimeTypeArgument(t3, "IterableBase", 0)];
      traversableChars = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
      rand = this._rng.nextInt$1(traversableChars.length);
      if (rand >>> 0 !== rand || rand >= traversableChars.length)
        return H.ioore(traversableChars, rand);
      chosen = traversableChars[rand];
      ret = this.fileProcessor._charTileMappings.$index(0, chosen);
      this.fileProcessor._takeChar$1(chosen);
      return ret;
    },
    blocked$3: [function(mover, row, col) {
      var t1, t2, enemyIsAtDest;
      if (mover == null) {
        t1 = this._traversableTypes;
        t2 = this._grid.array;
        if (row >>> 0 !== row || row >= t2.length)
          return H.ioore(t2, row);
        return !C.JSArray_methods.contains$1(t1, J.$index$asx(t2[row], col));
      } else {
        t1 = H.interceptedTypeCast(mover, "$isCharacter")._type;
        if (t1 === C.CharType_0) {
          enemyIsAtDest = H.IterableMixinWorkaround_any(this.enemyTeam, new R.GameMap_blocked_closure(this, row, col));
          t1 = this._traversableTypes;
          t2 = this._grid.array;
          if (row >>> 0 !== row || row >= t2.length)
            return H.ioore(t2, row);
          return !C.JSArray_methods.contains$1(t1, J.$index$asx(t2[row], col)) || enemyIsAtDest;
        } else if (t1 === C.CharType_1) {
          enemyIsAtDest = H.IterableMixinWorkaround_any(this.enemyTeam, new R.GameMap_blocked_closure0(this, row, col));
          t1 = this._traversableTypes;
          t2 = this._grid.array;
          if (row >>> 0 !== row || row >= t2.length)
            return H.ioore(t2, row);
          return !C.JSArray_methods.contains$1(t1, J.$index$asx(t2[row], col)) || enemyIsAtDest;
        }
      }
    }, "call$3", "get$blocked", 6, 0, 1687],
    getCost$5: function(mover, startRow, startCol, targetRow, targetCol) {
      var t1, t2, currType, mc;
      if (typeof startRow !== "number")
        return H.iae(startRow);
      t1 = targetRow - startRow;
      if (t1 !== 0) {
        if (typeof startCol !== "number")
          return H.iae(startCol);
        t2 = targetCol - startCol !== 0;
      } else
        t2 = false;
      if (t2)
        throw H.wrapException("Error: Diagonal movement not allowed.");
      else {
        if (!(t1 > 1)) {
          if (typeof startCol !== "number")
            return H.iae(startCol);
          t1 = targetCol - startCol > 1;
        } else
          t1 = true;
        if (t1)
          throw H.wrapException("Error: Trying to assess moving to a tile that is not directly adjacent");
        else {
          t1 = this._grid.array;
          if (targetRow >>> 0 !== targetRow || targetRow >= t1.length)
            return H.ioore(t1, targetRow);
          J.$index$asx(t1[targetRow], targetCol);
          currType = this.whatTile$2(targetRow, targetCol);
          mc = this._tileTypes.$index(0, currType).get$_moveCost();
          mc.toString;
          return mc;
        }
      }
    },
    GameMap$2: function(height, width) {
      var t1, i, j;
      this._grid = R.Array2d$(height, width, null, P.$int);
      this._units = R.Array2d$(height, width, null, P.String);
      this._spriteGrid = R.Array2d$(height, width, null, R.Sprite);
      this._tileTypes = P.LinkedHashMap_LinkedHashMap(null, null, null, R.TileType, R.Tile);
      this._traversableTypes = H.setRuntimeTypeInfo([], [P.$int]);
      this.playerTeam = H.setRuntimeTypeInfo([], [R.Character]);
      this.enemyTeam = H.setRuntimeTypeInfo([], [R.Character]);
      this._rng = C.C__JSRandom;
      this._tileTypes.$indexSet(0, C.TileType_3, R.Tile$(C.TileType_3));
      this._tileTypes.$indexSet(0, C.TileType_5, R.Tile$(C.TileType_5));
      this._tileTypes.$indexSet(0, C.TileType_2, R.Tile$(C.TileType_2));
      this._tileTypes.$indexSet(0, C.TileType_6, R.Tile$(C.TileType_6));
      this._tileTypes.$indexSet(0, C.TileType_1, R.Tile$(C.TileType_1));
      this._tileTypes.$indexSet(0, C.TileType_4, R.Tile$(C.TileType_4));
      this._tileTypes.$indexSet(0, C.TileType_0, R.Tile$(C.TileType_0));
      t1 = new R.FileProcessor(null, null, null, null, null, C.C__JSRandom);
      t1.FileProcessor$0();
      this.fileProcessor = t1;
      this._tileTypes.forEach$1(0, new R.GameMap_closure(this));
      for (i = 0; i < this._units.array.length; ++i) {
        j = 0;
        while (true) {
          t1 = this._units.array;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1 = J.get$length$asx(t1[0]);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(j < t1))
            break;
          t1 = this._units.array;
          if (i >= t1.length)
            return H.ioore(t1, i);
          J.$indexSet$ax(t1[i], j, "");
          ++j;
        }
      }
    },
    static: {GameMap$: function(height, width) {
        var t1 = new R.GameMap(null, null, null, null, null, null, null, null, null, null);
        t1.GameMap$2(height, width);
        return t1;
      }}
  },
  GameMap_closure: {
    "^": "Closure:1688;this_0",
    call$2: function(tt, tile) {
      if (tile.get$_traversable() === true)
        this.this_0._traversableTypes.push(J.get$value$x(tt));
    }
  },
  GameMap_whatTile_closure: {
    "^": "Closure:1689;tileVal_0",
    call$1: function(toTest) {
      return J.$eq(J.get$value$x(toTest), this.tileVal_0);
    }
  },
  GameMap_generateMap_closure: {
    "^": "Closure:102;this_0",
    call$1: [function(_) {
      var t1, t2, countKeys, rand, randKey, i, temp, j, t3, t4;
      t1 = this.this_0;
      t2 = t1.fileProcessor._charCountsTile;
      t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t2), [H.getTypeArgumentByIndex(t2, 0)]);
      countKeys = P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "IterableBase", 0));
      for (rand = null, randKey = null, i = 0; i < t1._grid.array.length; ++i) {
        t2 = i !== 0;
        temp = "";
        j = 0;
        while (true) {
          t3 = t1._grid.array;
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          t3 = J.get$length$asx(t3[0]);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(j < t3))
            break;
          if (t2)
            if (j !== 0) {
              t3 = t1._grid.array;
              t4 = t3.length;
              if (i !== t4 - 1) {
                if (0 >= t4)
                  return H.ioore(t3, 0);
                t3 = j === J.$sub$n(J.get$length$asx(t3[0]), 1);
              } else
                t3 = true;
            } else
              t3 = true;
          else
            t3 = true;
          if (t3) {
            t3 = t1._grid.array;
            if (i >= t3.length)
              return H.ioore(t3, i);
            J.$indexSet$ax(t3[i], j, t1._rollTraversableType$0());
            t3 = t1.fileProcessor._charCountsTile;
            t4 = new P.LinkedHashMapKeyIterable(t3);
            t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(t3, 0)];
            countKeys = P.List_List$from(t4, true, H.getRuntimeTypeArgument(t4, "IterableBase", 0));
          } else {
            t3 = t1.fileProcessor._charCountsTile;
            t4 = new P.LinkedHashMapKeyIterable(t3);
            t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(t3, 0)];
            countKeys = P.List_List$from(t4, true, H.getRuntimeTypeArgument(t4, "IterableBase", 0));
            do {
              rand = t1._rng.nextInt$1(countKeys.length);
              if (rand >>> 0 !== rand || rand >= countKeys.length)
                return H.ioore(countKeys, rand);
              randKey = countKeys[rand];
            } while (!t1._tileFitsWell$3(t1.fileProcessor._charTileMappings.$index(0, randKey), i, j));
            t3 = t1._grid.array;
            if (i >= t3.length)
              return H.ioore(t3, i);
            J.$indexSet$ax(t3[i], j, t1.fileProcessor._charTileMappings.$index(0, randKey));
            t1.fileProcessor._takeChar$1(randKey);
          }
          t3 = t1._grid.array;
          if (i >= t3.length)
            return H.ioore(t3, i);
          temp = C.JSString_methods.$add(temp, J.$add$ns(J.toString$0(J.$index$asx(t3[i], j)), " "));
          if (t1.blocked$3(null, i, j) === true)
            ;
          ++j;
        }
      }
      t1.finder = R.AStarPathFinder$(t1, 10, false, null);
      t1 = t1.fileProcessor;
      t1._charCountsAttack.addAll$1(0, t1._charCountsTile);
    }, "call$1", null, 2, 0, null, 1686, [], "call"]
  },
  GameMap__tileFitsWell_closure: {
    "^": "Closure:1689;tileTypeInt_0",
    call$1: function(t) {
      return J.$eq(J.get$value$x(t), this.tileTypeInt_0);
    }
  },
  GameMap__rollTraversableType_closure: {
    "^": "Closure:91;box_0,this_1",
    call$1: function(mapKey) {
      var t1, tileInt;
      t1 = this.this_1;
      tileInt = t1.fileProcessor._charTileMappings.$index(0, mapKey);
      this.box_0.tileInt_0 = tileInt;
      return C.JSArray_methods.contains$1(t1._traversableTypes, tileInt);
    }
  },
  GameMap_blocked_closure: {
    "^": "Closure:1690;this_0,row_1,col_2",
    call$1: function(c) {
      var t1, t2, t3;
      t1 = J.get$name$x(c);
      t2 = this.row_1;
      t3 = this.this_0._units.array;
      if (t2 >>> 0 !== t2 || t2 >= t3.length)
        return H.ioore(t3, t2);
      return J.$eq(t1, J.$index$asx(t3[t2], this.col_2));
    }
  },
  GameMap_blocked_closure0: {
    "^": "Closure:1690;this_3,row_4,col_5",
    call$1: function(c) {
      var t1, t2, t3;
      t1 = J.get$name$x(c);
      t2 = this.row_4;
      t3 = this.this_3._units.array;
      if (t2 >>> 0 !== t2 || t2 >= t3.length)
        return H.ioore(t3, t2);
      return J.$eq(t1, J.$index$asx(t3[t2], this.col_5));
    }
  },
  Mover: {
    "^": "Object;"
  },
  Path: {
    "^": "Object;_steps",
    get$length: function(_) {
      return this._steps.length;
    },
    contains$2: [function(_, x, y) {
      var t1, t2;
      t1 = this._steps;
      t2 = new R.Node(null, null, null, null, null, null);
      t2._TextFueledCombat$_x = x;
      t2._TextFueledCombat$_y = y;
      return C.JSArray_methods.contains$1(t1, t2);
    }, "call$2", "get$contains", 4, 0, 1691],
    removeLast$0: function(_) {
      var t1 = this._steps;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this._steps, "[", "]");
    }
  },
  UnknownTileException: {
    "^": "Object;_TextFueledCombat$_message",
    toString$0: function(_) {
      return "UnknownTileException: message=" + this._TextFueledCombat$_message;
    },
    static: {UnknownTileException$: function(message) {
        var t1 = new R.UnknownTileException("");
        t1._TextFueledCombat$_message = message;
        return t1;
      }}
  },
  AttackRangeException: {
    "^": "Object;_TextFueledCombat$_message",
    toString$0: function(_) {
      return "AttackRangeException: message=" + this._TextFueledCombat$_message;
    },
    $isAttackRangeException: true,
    static: {AttackRangeException$: function(message) {
        var t1 = new R.AttackRangeException("");
        t1._TextFueledCombat$_message = message;
        return t1;
      }}
  },
  Tile: {
    "^": "Object;_type<,_traversable<,_moveCost<",
    toString$0: function(_) {
      return "_type: " + this._type.value + ", _traversable: " + H.S(this._traversable) + ", _moveCost: " + H.S(this._moveCost);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return this._type === other.get$_type();
    },
    Tile$1: function(type) {
      this._type = type;
      switch (type) {
        case C.TileType_3:
        case C.TileType_2:
        case C.TileType_4:
        case C.TileType_0:
          this._traversable = true;
          this._moveCost = 1;
          break;
        case C.TileType_5:
          this._traversable = true;
          this._moveCost = 2;
          break;
        case C.TileType_6:
        case C.TileType_1:
          this._traversable = false;
          this._moveCost = 1000;
          break;
        default:
          throw H.wrapException(R.UnknownTileException$("Invalid TileType value supplied."));
      }
    },
    $isTile: true,
    static: {Tile$: function(type) {
        var t1 = new R.Tile(null, null, null);
        t1.Tile$1(type);
        return t1;
      }}
  },
  "+Tile": 0,
  TileType: {
    "^": "Enum;value",
    $isTileType: true,
    static: {"^": "TileType_TYPE_COUNT,TileType_WOOD_TILE,TileType_VOID,TileType_GRASS,TileType_DIRT,TileType_WATER,TileType_DRY_LAND,TileType_LAVA"}
  }
}],
["_foreign_helper", "dart:_foreign_helper", , H, {
  "^": "",
  JS_CONST: {
    "^": "Object;code"
  }
}],
["_interceptors", "dart:_interceptors", , J, {
  "^": "",
  getInterceptor: function(object) {
    return void 0;
  },
  makeDispatchRecord: function(interceptor, proto, extension, indexability) {
    return {i: interceptor, p: proto, e: extension, x: indexability};
  },
  getNativeInterceptor: function(object) {
    var record, proto, objectProto, interceptor;
    record = object[init.dispatchPropertyName];
    if (record == null)
      if ($.initNativeDispatchFlag == null) {
        H.initNativeDispatch();
        record = object[init.dispatchPropertyName];
      }
    if (record != null) {
      proto = record.p;
      if (false === proto)
        return record.i;
      if (true === proto)
        return object;
      objectProto = Object.getPrototypeOf(object);
      if (proto === objectProto)
        return record.i;
      if (record.e === objectProto)
        throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
    }
    interceptor = H.lookupAndCacheInterceptor(object);
    if (interceptor == null) {
      proto = Object.getPrototypeOf(object);
      if (proto == null || proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      else
        return C.UnknownJavaScriptObject_methods;
    }
    return interceptor;
  },
  Interceptor: {
    "^": "Object;",
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return H.Primitives_objectToString(receiver);
    },
    noSuchMethod$1: [function(receiver, invocation) {
      throw H.wrapException(P.NoSuchMethodError$(receiver, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments(), null));
    }, "call$1", "get$noSuchMethod", 2, 0, null, 1692, []],
    get$runtimeType: function(receiver) {
      return new H.TypeImpl(H.getRuntimeTypeString(receiver), null);
    },
    "%": "CanvasGradient|CanvasPattern|MediaError|MediaKeyError|PositionError|SQLError|SVGAnimatedEnumeration|SVGAnimatedLength|SVGAnimatedLengthList|SVGAnimatedNumber|SVGAnimatedNumberList|SVGAnimatedString|SVGAnimatedTransformList|WebGLBuffer|WebGLFramebuffer|WebGLProgram|WebGLRenderbuffer|WebGLShader|WebGLTexture"
  },
  JSBool: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    get$runtimeType: function(receiver) {
      return C.Type_EsU;
    },
    $isbool: true
  },
  JSNull: {
    "^": "Interceptor;",
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    },
    get$runtimeType: function(receiver) {
      return C.Type_eZO;
    },
    noSuchMethod$1: [function(receiver, invocation) {
      return J.Interceptor.prototype.noSuchMethod$1.call(this, receiver, invocation);
    }, "call$1", "get$noSuchMethod", 2, 0, null, 1692, []]
  },
  JavaScriptObject: {
    "^": "Interceptor;",
    get$hashCode: function(_) {
      return 0;
    },
    get$runtimeType: function(_) {
      return C.Type_XXD;
    }
  },
  PlainJavaScriptObject: {
    "^": "JavaScriptObject;"
  },
  UnknownJavaScriptObject: {
    "^": "JavaScriptObject;",
    toString$0: function(receiver) {
      return String(receiver);
    }
  },
  JSArray: {
    "^": "Interceptor;",
    checkMutable$1: function(receiver, reason) {
      if (!!receiver.immutable$list)
        throw H.wrapException(P.UnsupportedError$(reason));
    },
    checkGrowable$1: function(receiver, reason) {
      if (!!receiver.fixed$length)
        throw H.wrapException(P.UnsupportedError$(reason));
    },
    add$1: [function(receiver, value) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("add"));
      receiver.push(value);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E", void: true, args: [E]};
      }, this.$receiver, "JSArray");
    }, 138, []],
    removeAt$1: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index < 0 || index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index, null, null));
      this.checkGrowable$1(receiver, "removeAt");
      return receiver.splice(index, 1)[0];
    },
    insert$2: function(receiver, index, value) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index < 0 || index > receiver.length)
        throw H.wrapException(P.RangeError$value(index, null, null));
      this.checkGrowable$1(receiver, "insert");
      receiver.splice(index, 0, value);
    },
    removeLast$0: function(receiver) {
      this.checkGrowable$1(receiver, "removeLast");
      if (receiver.length === 0)
        throw H.wrapException(P.RangeError$value(-1, null, null));
      return receiver.pop();
    },
    remove$1: function(receiver, element) {
      var i;
      this.checkGrowable$1(receiver, "remove");
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    where$1: function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.WhereIterable(receiver, f), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(receiver, 0)]), 0)]);
    },
    addAll$1: function(receiver, collection) {
      var t1;
      for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
        this.add$1(receiver, t1.get$current());
    },
    clear$0: function(receiver) {
      this.set$length(receiver, 0);
    },
    forEach$1: function(receiver, f) {
      var $length, i;
      $length = receiver.length;
      for (i = 0; i < $length; ++i) {
        f.call$1(receiver[i]);
        if ($length !== receiver.length)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    map$1: [function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.MappedListIterable(receiver, f), [null, null]);
    }, "call$1", "get$map", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "Iterable__dynamic__E", ret: P.Iterable, args: [{func: "dynamic__E", args: [E]}]};
      }, this.$receiver, "JSArray");
    }],
    join$1: function(receiver, separator) {
      var t1, list, i, t2;
      t1 = receiver.length;
      list = Array(t1);
      list.fixed$length = init;
      for (i = 0; i < receiver.length; ++i) {
        t2 = H.S(receiver[i]);
        if (i >= t1)
          return H.ioore(list, i);
        list[i] = t2;
      }
      return list.join(separator);
    },
    fold$2: function(receiver, initialValue, combine) {
      return H.IterableMixinWorkaround_fold(receiver, initialValue, combine);
    },
    firstWhere$2$orElse: function(receiver, test, orElse) {
      return H.IterableMixinWorkaround_firstWhere(receiver, test, orElse);
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      if (start == null)
        H.throwExpression(P.ArgumentError$(null));
      if (typeof start !== "number" || Math.floor(start) !== start)
        throw H.wrapException(P.ArgumentError$(start));
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
      if (end == null)
        end = receiver.length;
      else {
        if (typeof end !== "number" || Math.floor(end) !== end)
          throw H.wrapException(P.ArgumentError$(end));
        if (end < start || end > receiver.length)
          throw H.wrapException(P.RangeError$range(end, start, receiver.length, null, null));
      }
      if (start === end)
        return H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
      return H.setRuntimeTypeInfo(receiver.slice(start, end), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    getRange$2: function(receiver, start, end) {
      var t1 = H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(receiver, 0)]);
      H.IterableMixinWorkaround__rangeCheck(receiver, start, end);
      return H.SubListIterable$(receiver, start, end, H.getTypeArgumentByIndex(t1, 0));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return receiver[t1 - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    removeRange$2: function(receiver, start, end) {
      var receiverLength, t1;
      this.checkGrowable$1(receiver, "removeRange");
      receiverLength = receiver.length;
      t1 = J.getInterceptor$n(start);
      if (t1.$lt(start, 0) || t1.$gt(start, receiverLength))
        throw H.wrapException(P.RangeError$range(start, 0, receiverLength, null, null));
      t1 = J.getInterceptor$n(end);
      if (t1.$lt(end, start) || t1.$gt(end, receiverLength))
        throw H.wrapException(P.RangeError$range(end, start, receiverLength, null, null));
      if (typeof end !== "number")
        return H.iae(end);
      H.Lists_copy(receiver, end, receiver, start, receiverLength - end);
      if (typeof start !== "number")
        return H.iae(start);
      this.set$length(receiver, receiverLength - (end - start));
    },
    any$1: [function(receiver, f) {
      return H.IterableMixinWorkaround_any(receiver, f);
    }, "call$1", "get$any", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__bool__E", ret: P.bool, args: [{func: "bool__E", ret: P.bool, args: [E]}]};
      }, this.$receiver, "JSArray");
    }],
    get$reversed: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ReversedListIterable(receiver), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(receiver, 0)]), 0)]);
    },
    sort$1: function(receiver, compare) {
      this.checkMutable$1(receiver, "sort");
      if (compare == null)
        compare = P.Comparable_compare$closure();
      H.Sort__doSort(receiver, 0, receiver.length - 1, compare);
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    indexOf$2: function(receiver, element, start) {
      return H.Lists_indexOf(receiver, element, start, receiver.length);
    },
    indexOf$1: function($receiver, element) {
      return this.indexOf$2($receiver, element, 0);
    },
    contains$1: [function(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], other))
          return true;
      return false;
    }, "call$1", "get$contains", 2, 0, 1693],
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    toList$1$growable: function(receiver, growable) {
      var t1;
      if (growable)
        return H.setRuntimeTypeInfo(receiver.slice(), [H.getTypeArgumentByIndex(receiver, 0)]);
      else {
        t1 = H.setRuntimeTypeInfo(receiver.slice(), [H.getTypeArgumentByIndex(receiver, 0)]);
        t1.fixed$length = Array;
        return t1;
      }
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$iterator: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ListIterator(receiver, receiver.length, 0, null), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    set$length: function(receiver, newLength) {
      if (typeof newLength !== "number" || Math.floor(newLength) !== newLength)
        throw H.wrapException(P.ArgumentError$(newLength));
      if (newLength < 0)
        throw H.wrapException(P.RangeError$value(newLength, null, null));
      this.checkGrowable$1(receiver, "set length");
      receiver.length = newLength;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      this.checkMutable$1(receiver, "indexed set");
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      receiver[index] = value;
    },
    $isJSArray: true,
    $isJSIndexable: true,
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  JSMutableArray: {
    "^": "JSArray;",
    $isJSMutableArray: true,
    $isJSIndexable: true
  },
  JSFixedArray: {
    "^": "JSMutableArray;"
  },
  JSExtendableArray: {
    "^": "JSMutableArray;",
    $isJSExtendableArray: true
  },
  JSNumber: {
    "^": "Interceptor;",
    compareTo$1: function(receiver, b) {
      var bIsNegative;
      if (typeof b !== "number")
        throw H.wrapException(P.ArgumentError$(b));
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (this.get$isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative: function(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    get$isNaN: function(receiver) {
      return isNaN(receiver);
    },
    remainder$1: function(receiver, b) {
      if (b == null)
        H.throwExpression(P.ArgumentError$(null));
      if (typeof b !== "number")
        throw H.wrapException(P.ArgumentError$(b));
      return receiver % b;
    },
    abs$0: function(receiver) {
      return Math.abs(receiver);
    },
    get$sign: function(receiver) {
      var t1;
      if (receiver > 0)
        t1 = 1;
      else
        t1 = receiver < 0 ? -1 : receiver;
      return t1;
    },
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$('' + receiver));
    },
    ceil$0: function(receiver) {
      return this.toInt$0(Math.ceil(receiver));
    },
    floor$0: function(receiver) {
      return this.toInt$0(Math.floor(receiver));
    },
    round$0: function(receiver) {
      return this.toInt$0(this.roundToDouble$0(receiver));
    },
    roundToDouble$0: function(receiver) {
      if (receiver < 0)
        return -Math.round(-receiver);
      else
        return Math.round(receiver);
    },
    clamp$2: function(receiver, lowerLimit, upperLimit) {
      lowerLimit.compareTo$1(0, upperLimit).$gt(0, 0);
      if (this.compareTo$1(receiver, lowerLimit) < 0)
        return lowerLimit;
      if (this.compareTo$1(receiver, upperLimit) > 0)
        return upperLimit;
      return receiver;
    },
    toDouble$0: function(receiver) {
      return receiver;
    },
    toStringAsFixed$1: function(receiver, fractionDigits) {
      var result;
      H.checkNum(fractionDigits);
      if (fractionDigits > 20)
        throw H.wrapException(P.RangeError$(fractionDigits));
      result = receiver.toFixed(fractionDigits);
      if (receiver === 0 && this.get$isNegative(receiver))
        return "-" + result;
      return result;
    },
    toRadixString$1: function(receiver, radix) {
      H.checkNum(radix);
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$(radix));
      return receiver.toString(radix);
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      return receiver & 0x1FFFFFFF;
    },
    $negate: function(receiver) {
      return -receiver;
    },
    $add: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    $sub: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver - other;
    },
    $div: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver / other;
    },
    $mul: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver * other;
    },
    $mod: function(receiver, other) {
      var result;
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      if (other < 0)
        return result - other;
      else
        return result + other;
    },
    $tdiv: function(receiver, other) {
      if ((receiver | 0) === receiver && (other | 0) === other && 0 !== other && -1 !== other)
        return receiver / other | 0;
      else {
        if (typeof other !== "number")
          H.throwExpression(P.ArgumentError$(other));
        return this.toInt$0(receiver / other);
      }
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this.toInt$0(receiver / other);
    },
    $shl: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    _shlPositive$1: function(receiver, other) {
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    $shr: function(receiver, other) {
      var t1;
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrReceiverPositive$1: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      return other > 31 ? 0 : receiver >>> other;
    },
    $and: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver & other) >>> 0;
    },
    $or: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver | other) >>> 0;
    },
    $xor: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver ^ other) >>> 0;
    },
    $lt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver < other;
    },
    $gt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver > other;
    },
    $le: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver <= other;
    },
    $ge: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver >= other;
    },
    get$runtimeType: function(receiver) {
      return C.Type_xM7;
    },
    $isnum: true,
    static: {"^": "JSNumber__MIN_INT32,JSNumber__MAX_INT32"}
  },
  JSInt: {
    "^": "JSNumber;",
    get$runtimeType: function(receiver) {
      return C.Type_SnA;
    },
    $not: function(receiver) {
      return ~receiver >>> 0;
    },
    $is$double: true,
    $isnum: true,
    $is$int: true
  },
  JSDouble: {
    "^": "JSNumber;",
    get$runtimeType: function(receiver) {
      return C.Type_qq1;
    },
    $is$double: true,
    $isnum: true
  },
  JSPositiveInt: {
    "^": "JSInt;"
  },
  JSUInt32: {
    "^": "JSPositiveInt;"
  },
  JSUInt31: {
    "^": "JSUInt32;"
  },
  JSString: {
    "^": "Interceptor;",
    codeUnitAt$1: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      if (index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return receiver.charCodeAt(index);
    },
    allMatches$2: function(receiver, string, start) {
      H.checkString(string);
      H.checkInt(start);
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return H.allMatchesInStringUnchecked(receiver, string, start);
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    matchAsPrefix$2: function(receiver, string, start) {
      var t1, i;
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      t1 = receiver.length;
      if (start + t1 > string.length)
        return;
      for (i = 0; i < t1; ++i)
        if (this.codeUnitAt$1(string, start + i) !== this.codeUnitAt$1(receiver, i))
          return;
      return new H.StringMatch(start, string, receiver);
    },
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    endsWith$1: function(receiver, other) {
      var otherLength, t1;
      H.checkString(other);
      otherLength = other.length;
      t1 = receiver.length;
      if (otherLength > t1)
        return false;
      return other === this.substring$1(receiver, t1 - otherLength);
    },
    replaceAll$2: function(receiver, from, to) {
      H.checkString(to);
      return H.stringReplaceAllUnchecked(receiver, from, to);
    },
    replaceFirst$3: function(receiver, from, to, startIndex) {
      H.checkString(to);
      H.checkInt(startIndex);
      if (startIndex > receiver.length)
        throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length, null, null));
      return H.stringReplaceFirstUnchecked(receiver, from, to, startIndex);
    },
    replaceFirst$2: function($receiver, from, to) {
      return this.replaceFirst$3($receiver, from, to, 0);
    },
    split$1: function(receiver, pattern) {
      if (pattern == null)
        H.throwExpression(P.ArgumentError$(null));
      if (typeof pattern === "string")
        return receiver.split(pattern);
      else if (!!J.getInterceptor(pattern).$isJSSyntaxRegExp && pattern.get$_nativeAnchoredVersion().exec('').length - 2 === 0)
        return receiver.split(pattern.get$_nativeRegExp());
      else
        return this._defaultSplit$1(receiver, pattern);
    },
    _defaultSplit$1: function(receiver, pattern) {
      var result, t1, start, $length, match, matchStart, matchEnd;
      result = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = J.get$iterator$ax(J.allMatches$1$s(pattern, receiver)), start = 0, $length = 1; t1.moveNext$0();) {
        match = t1.get$current();
        matchStart = J.get$start$x(match);
        matchEnd = match.get$end();
        $length = J.$sub$n(matchEnd, matchStart);
        if (J.$eq($length, 0) && J.$eq(start, matchStart))
          continue;
        result.push(this.substring$2(receiver, start, matchStart));
        start = matchEnd;
      }
      if (J.$lt$n(start, receiver.length) || J.$gt$n($length, 0))
        result.push(this.substring$1(receiver, start));
      return result;
    },
    startsWith$2: function(receiver, pattern, index) {
      var endIndex;
      if (index > receiver.length)
        throw H.wrapException(P.RangeError$range(index, 0, receiver.length, null, null));
      endIndex = index + pattern.length;
      if (endIndex > receiver.length)
        return false;
      return pattern === receiver.substring(index, endIndex);
    },
    startsWith$1: function($receiver, pattern) {
      return this.startsWith$2($receiver, pattern, 0);
    },
    substring$2: function(receiver, startIndex, endIndex) {
      var t1;
      if (typeof startIndex !== "number" || Math.floor(startIndex) !== startIndex)
        H.throwExpression(P.ArgumentError$(startIndex));
      if (endIndex == null)
        endIndex = receiver.length;
      if (typeof endIndex !== "number" || Math.floor(endIndex) !== endIndex)
        H.throwExpression(P.ArgumentError$(endIndex));
      t1 = J.getInterceptor$n(startIndex);
      if (t1.$lt(startIndex, 0))
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (t1.$gt(startIndex, endIndex))
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (J.$gt$n(endIndex, receiver.length))
        throw H.wrapException(P.RangeError$value(endIndex, null, null));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    toLowerCase$0: function(receiver) {
      return receiver.toLowerCase();
    },
    toUpperCase$0: function(receiver) {
      return receiver.toUpperCase();
    },
    trim$0: [function(receiver) {
      var result, endIndex, startIndex, t1, endIndex0;
      result = receiver.trim();
      endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (this.codeUnitAt$1(result, 0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    }, "call$0", "get$trim", 0, 0, 810],
    $mul: function(receiver, times) {
      var s, result;
      if (typeof times !== "number")
        return H.iae(times);
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw H.wrapException(C.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    padLeft$2: function(receiver, width, padding) {
      var delta = width - receiver.length;
      if (delta <= 0)
        return receiver;
      return this.$mul(padding, delta) + receiver;
    },
    get$codeUnits: function(receiver) {
      return new J._CodeUnits(receiver);
    },
    indexOf$2: function(receiver, pattern, start) {
      var t1, match, t2, i;
      if (pattern == null)
        H.throwExpression(P.ArgumentError$(null));
      if (typeof start !== "number" || Math.floor(start) !== start)
        throw H.wrapException(P.ArgumentError$(start));
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
      if (typeof pattern === "string")
        return receiver.indexOf(pattern, start);
      t1 = J.getInterceptor(pattern);
      if (!!t1.$isJSSyntaxRegExp) {
        match = pattern._execGlobal$2(receiver, start);
        return match == null ? -1 : match._match.index;
      }
      for (t2 = receiver.length, i = start; i <= t2; ++i)
        if (t1.matchAsPrefix$2(pattern, receiver, i) != null)
          return i;
      return -1;
    },
    indexOf$1: function($receiver, pattern) {
      return this.indexOf$2($receiver, pattern, 0);
    },
    contains$2: [function(receiver, other, startIndex) {
      var t1;
      if (other == null)
        H.throwExpression(P.ArgumentError$(null));
      t1 = J.getInterceptor$n(startIndex);
      if (t1.$lt(startIndex, 0) || t1.$gt(startIndex, receiver.length))
        throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length, null, null));
      return H.stringContainsUnchecked(receiver, other, startIndex);
    }, function($receiver, other) {
      return this.contains$2($receiver, other, 0);
    }, "contains$1", "call$2", "call$1", "get$contains", 2, 2, 1694, 49],
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    compareTo$1: function(receiver, other) {
      var t1;
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    get$runtimeType: function(receiver) {
      return C.Type_Ejg;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return receiver[index];
    },
    $isJSIndexable: true,
    $isString: true,
    static: {JSString__isWhitespace: function(codeUnit) {
        if (codeUnit < 256)
          switch (codeUnit) {
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 32:
            case 133:
            case 160:
              return true;
            default:
              return false;
          }
        switch (codeUnit) {
          case 5760:
          case 6158:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8232:
          case 8233:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }, JSString__skipLeadingWhitespace: function(string, index) {
        var t1, codeUnit;
        for (t1 = string.length; index < t1;) {
          codeUnit = C.JSString_methods.codeUnitAt$1(string, index);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
          ++index;
        }
        return index;
      }, JSString__skipTrailingWhitespace: function(string, index) {
        var index0, codeUnit;
        for (; index > 0; index = index0) {
          index0 = index - 1;
          codeUnit = C.JSString_methods.codeUnitAt$1(string, index0);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
        }
        return index;
      }}
  },
  _CodeUnits: {
    "^": "UnmodifiableListBase;__interceptors$_string",
    get$length: function(_) {
      return this.__interceptors$_string.length;
    },
    $index: function(_, i) {
      return C.JSString_methods.codeUnitAt$1(this.__interceptors$_string, i);
    },
    $asUnmodifiableListBase: function() {
      return [P.$int];
    },
    $asListBase: function() {
      return [P.$int];
    },
    $asObject_ListMixin: function() {
      return [P.$int];
    },
    $asList: function() {
      return [P.$int];
    }
  }
}],
["_isolate_helper", "dart:_isolate_helper", , H, {
  "^": "",
  _callInIsolate: function(isolate, $function) {
    var result = isolate.eval$1($function);
    init.globalState.topEventLoop.run$0();
    return result;
  },
  leaveJsAsync: function() {
    --init.globalState.topEventLoop._activeJsAsyncCount;
  },
  startRootIsolate: function(entry, args) {
    var t1, t2, t3, t4, t5, rootContext;
    t1 = {};
    t1.args_0 = args;
    args = args;
    t1.args_0 = args;
    if (args == null) {
      args = [];
      t1.args_0 = args;
      t2 = args;
    } else
      t2 = args;
    if (!J.getInterceptor(t2).$isList)
      throw H.wrapException(P.ArgumentError$("Arguments to main must be a List: " + H.S(t2)));
    t2 = new H._Manager(0, 0, 1, null, null, null, null, null, null, null, null, null, entry);
    t2._Manager$1(entry);
    init.globalState = t2;
    if (init.globalState.isWorker === true)
      return;
    t2 = init.globalState.nextIsolateId++;
    t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl);
    t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
    t5 = new H.RawReceivePortImpl(0, null, false);
    rootContext = new H._IsolateContext(t2, t3, t4, new Isolate(), t5, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
    t4.add$1(0, 0);
    rootContext._addRegistration$2(0, t5);
    init.globalState.rootContext = rootContext;
    init.globalState.currentContext = rootContext;
    t2 = H.getDynamicRuntimeType();
    t3 = H.buildFunctionType(t2, [t2])._isTest$1(entry);
    if (t3)
      rootContext.eval$1(new H.startRootIsolate_closure(t1, entry));
    else {
      t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(entry);
      if (t2)
        rootContext.eval$1(new H.startRootIsolate_closure0(t1, entry));
      else
        rootContext.eval$1(entry);
    }
    init.globalState.topEventLoop.run$0();
  },
  IsolateNatives_computeThisScript: function() {
    var currentScript = init.currentScript;
    if (currentScript != null)
      return String(currentScript.src);
    if (typeof version == "function" && typeof os == "object" && "system" in os)
      return H.IsolateNatives_computeThisScriptFromTrace();
    if (typeof version == "function" && typeof system == "function")
      return thisFilename();
    if (init.globalState.isWorker === true)
      return H.IsolateNatives_computeThisScriptFromTrace();
    return;
  },
  IsolateNatives_computeThisScriptFromTrace: function() {
    var stack, matches;
    stack = new Error().stack;
    if (stack == null) {
      stack = function() {
        try {
          throw new Error();
        } catch (e) {
          return e.stack;
        }

      }();
      if (stack == null)
        throw H.wrapException(P.UnsupportedError$("No stack trace"));
    }
    matches = stack.match(new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "m"));
    if (matches != null)
      return matches[1];
    matches = stack.match(new RegExp("^[^@]*@(.*):[0-9]*$", "m"));
    if (matches != null)
      return matches[1];
    throw H.wrapException(P.UnsupportedError$("Cannot extract URI from \"" + H.S(stack) + "\""));
  },
  IsolateNatives__processWorkerMessage: [function(sender, e) {
    var msg, t1, functionName, entryPoint, args, message, isSpawnUri, startPaused, replyTo, t2, t3, t4, context;
    msg = H._deserializeMessage(e.data);
    t1 = J.getInterceptor$asx(msg);
    switch (t1.$index(msg, "command")) {
      case "start":
        init.globalState.currentManagerId = t1.$index(msg, "id");
        functionName = t1.$index(msg, "functionName");
        entryPoint = functionName == null ? init.globalState.entry : H.IsolateNatives__getJSFunctionFromName(functionName);
        args = t1.$index(msg, "args");
        message = H._deserializeMessage(t1.$index(msg, "msg"));
        isSpawnUri = t1.$index(msg, "isSpawnUri");
        startPaused = t1.$index(msg, "startPaused");
        replyTo = H._deserializeMessage(t1.$index(msg, "replyTo"));
        t1 = init.globalState.nextIsolateId++;
        t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl);
        t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
        t4 = new H.RawReceivePortImpl(0, null, false);
        context = new H._IsolateContext(t1, t2, t3, new Isolate(), t4, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
        t3.add$1(0, 0);
        context._addRegistration$2(0, t4);
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, new H.IsolateNatives__processWorkerMessage_closure(entryPoint, args, message, isSpawnUri, startPaused, replyTo), "worker-start"));
        init.globalState.currentContext = context;
        init.globalState.topEventLoop.run$0();
        break;
      case "spawn-worker":
        break;
      case "message":
        if (t1.$index(msg, "port") != null)
          J.send$1$x(t1.$index(msg, "port"), t1.$index(msg, "msg"));
        init.globalState.topEventLoop.run$0();
        break;
      case "close":
        init.globalState.managers.remove$1(0, $.get$IsolateNatives_workerIds().$index(0, sender));
        sender.terminate();
        init.globalState.topEventLoop.run$0();
        break;
      case "log":
        H.IsolateNatives__log(t1.$index(msg, "msg"));
        break;
      case "print":
        if (init.globalState.isWorker === true) {
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", msg], null, null));
          t1.toString;
          self.postMessage(t2);
        } else
          P.print(t1.$index(msg, "msg"));
        break;
      case "error":
        throw H.wrapException(t1.$index(msg, "msg"));
    }
  }, "call$2", "IsolateNatives__processWorkerMessage$closure", 4, 0, null, 585, [], 356, []],
  IsolateNatives__log: function(msg) {
    var trace, t1, t2, exception;
    if (init.globalState.isWorker === true) {
      t1 = init.globalState.mainManager;
      t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "log", "msg", msg], null, null));
      t1.toString;
      self.postMessage(t2);
    } else
      try {
        self.console.log(msg);
      } catch (exception) {
        H.unwrapException(exception);
        trace = new H._StackTrace(exception, null);
        throw H.wrapException(P.Exception_Exception(trace));
      }

  },
  IsolateNatives__getJSFunctionFromName: function(functionName) {
    return init.globalFunctions[functionName]();
  },
  IsolateNatives__startIsolate: function(topLevel, args, message, isSpawnUri, startPaused, replyTo) {
    var context, t1, t2, t3;
    context = init.globalState.currentContext;
    t1 = context.id;
    $.Primitives_mirrorFunctionCacheName = $.Primitives_mirrorFunctionCacheName + ("_" + t1);
    $.Primitives_mirrorInvokeCacheName = $.Primitives_mirrorInvokeCacheName + ("_" + t1);
    t1 = context.controlPort;
    t2 = init.globalState.currentContext.id;
    t3 = context.pauseCapability;
    J.send$1$x(replyTo, ["spawned", new H._NativeJsSendPort(t1, t2), t3, context.terminateCapability]);
    t2 = new H.IsolateNatives__startIsolate_runStartFunction(topLevel, args, message, isSpawnUri, context);
    if (startPaused === true) {
      context.addPause$2(t3, t3);
      init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, t2, "start isolate"));
    } else
      t2.call$0();
  },
  _serializeMessage: function(message) {
    var t1;
    if (init.globalState.supportsWorkers === true) {
      t1 = new H._JsSerializer(0, new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    } else {
      t1 = new H._JsCopier(new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    }
  },
  _deserializeMessage: function(message) {
    if (init.globalState.supportsWorkers === true)
      return new H._JsDeserializer(null).deserialize$1(message);
    else
      return message;
  },
  _MessageTraverser_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  _Deserializer_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  startRootIsolate_closure: {
    "^": "Closure:54;box_0,entry_1",
    call$0: function() {
      this.entry_1.call$1(this.box_0.args_0);
    }
  },
  startRootIsolate_closure0: {
    "^": "Closure:54;box_0,entry_2",
    call$0: function() {
      this.entry_2.call$2(this.box_0.args_0, null);
    }
  },
  _Manager: {
    "^": "Object;nextIsolateId,currentManagerId,nextManagerId,currentContext,rootContext,topEventLoop,fromCommandLine,isWorker,supportsWorkers,isolates,mainManager,managers,entry",
    _Manager$1: function(entry) {
      var t1, t2, t3;
      t1 = self.window == null;
      t2 = self.Worker;
      t3 = t1 && !!self.postMessage;
      this.isWorker = t3;
      if (!t3)
        t2 = t2 != null && $.get$IsolateNatives_thisScript() != null;
      else
        t2 = true;
      this.supportsWorkers = t2;
      this.fromCommandLine = t1 && !t3;
      this.topEventLoop = new H._EventLoop(P.ListQueue$(null, H._IsolateEvent), 0);
      this.isolates = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H._IsolateContext);
      this.managers = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, null);
      if (this.isWorker === true) {
        t1 = new H._MainManagerStub();
        this.mainManager = t1;
        self.onmessage = function(f, a) {
          return function(e) {
            f(a, e);
          };
        }(H.IsolateNatives__processWorkerMessage, t1);
        self.dartPrint = self.dartPrint || function(serialize) {
          return function(object) {
            if (self.console && self.console.log) {
              self.console.log(object);
            } else {
              self.postMessage(serialize(object));
            }
          };
        }(H._Manager__serializePrintMessage);
      }
    },
    static: {_Manager__serializePrintMessage: [function(object) {
        return H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", object], null, null));
      }, "call$1", "_Manager__serializePrintMessage$closure", 2, 0, null, 584, []]}
  },
  _IsolateContext: {
    "^": "Object;id>,ports,weakPorts,isolateStatics<,controlPort<,pauseCapability,terminateCapability,initialized?,isPaused<,delayedEvents<,pauseTokens,doneHandlers,_scheduledControlEvents,_isExecutingEvent,errorsAreFatal,errorPorts",
    addPause$2: function(authentification, resume) {
      if (!this.pauseCapability.$eq(0, authentification))
        return;
      if (this.pauseTokens.add$1(0, resume) && !this.isPaused)
        this.isPaused = true;
      this._updateGlobalState$0();
    },
    removePause$1: function(resume) {
      var t1, t2, $event, t3, t4, t5;
      if (!this.isPaused)
        return;
      t1 = this.pauseTokens;
      t1.remove$1(0, resume);
      if (t1._collection$_length === 0) {
        for (t1 = this.delayedEvents; t2 = t1.length, t2 !== 0;) {
          if (0 >= t2)
            return H.ioore(t1, 0);
          $event = t1.pop();
          t2 = init.globalState.topEventLoop.events;
          t3 = t2._head;
          t4 = t2._table;
          t5 = t4.length;
          t3 = (t3 - 1 & t5 - 1) >>> 0;
          t2._head = t3;
          if (t3 < 0 || t3 >= t5)
            return H.ioore(t4, t3);
          t4[t3] = $event;
          if (t3 === t2._tail)
            t2._grow$0();
          ++t2._modificationCount;
        }
        this.isPaused = false;
      }
      this._updateGlobalState$0();
    },
    addDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null) {
        t1 = [];
        this.doneHandlers = t1;
      }
      if (J.contains$1$asx(t1, responsePort))
        return;
      this.doneHandlers.push(responsePort);
    },
    removeDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null)
        return;
      J.remove$1$ax(t1, responsePort);
    },
    setErrorsFatal$2: function(authentification, errorsAreFatal) {
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      this.errorsAreFatal = errorsAreFatal;
    },
    handlePing$2: function(responsePort, pingType) {
      var t1, t2;
      t1 = J.getInterceptor(pingType);
      if (!t1.$eq(pingType, 0))
        t2 = t1.$eq(pingType, 1) && !this._isExecutingEvent;
      else
        t2 = true;
      if (t2) {
        J.send$1$x(responsePort, null);
        return;
      }
      t2 = new H._IsolateContext_handlePing_respond(responsePort);
      if (t1.$eq(pingType, 2)) {
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(this, t2, "ping"));
        return;
      }
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = P.ListQueue$(null, null);
        this._scheduledControlEvents = t1;
      }
      t1._add$1(t2);
    },
    handleKill$2: function(authentification, priority) {
      var t1, t2;
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      t1 = J.getInterceptor(priority);
      if (!t1.$eq(priority, 0))
        t2 = t1.$eq(priority, 1) && !this._isExecutingEvent;
      else
        t2 = true;
      if (t2) {
        this.kill$0();
        return;
      }
      if (t1.$eq(priority, 2)) {
        t1 = init.globalState.topEventLoop;
        t2 = this.get$kill();
        t1.events._add$1(new H._IsolateEvent(this, t2, "kill"));
        return;
      }
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = P.ListQueue$(null, null);
        this._scheduledControlEvents = t1;
      }
      t1._add$1(this.get$kill());
    },
    handleUncaughtError$2: function(error, stackTrace) {
      var t1, message;
      t1 = this.errorPorts;
      if (t1._collection$_length === 0) {
        if (this.errorsAreFatal === true && this === init.globalState.rootContext)
          return;
        if (self.console && self.console.error)
          self.console.error(error, stackTrace);
        else {
          P.print(error);
          if (stackTrace != null)
            P.print(stackTrace);
        }
        return;
      }
      message = Array(2);
      message.fixed$length = init;
      message[0] = J.toString$0(error);
      message[1] = stackTrace == null ? null : J.toString$0(stackTrace);
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();)
        J.send$1$x(t1._collection$_current, message);
    },
    eval$1: function(code) {
      var old, result, e, s, exception, t1;
      old = init.globalState.currentContext;
      init.globalState.currentContext = this;
      $ = this.isolateStatics;
      result = null;
      this._isExecutingEvent = true;
      try {
        result = code.call$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.handleUncaughtError$2(e, s);
        if (this.errorsAreFatal === true) {
          this.kill$0();
          if (this === init.globalState.rootContext)
            throw exception;
        }
      }
 finally {
        this._isExecutingEvent = false;
        init.globalState.currentContext = old;
        if (old != null)
          $ = old.get$isolateStatics();
        if (this._scheduledControlEvents != null)
          for (; t1 = this._scheduledControlEvents, !t1.get$isEmpty(t1);)
            this._scheduledControlEvents.removeFirst$0().call$0();
      }
      return result;
    },
    handleControlMessage$1: function(message) {
      var t1 = J.getInterceptor$asx(message);
      switch (t1.$index(message, 0)) {
        case "pause":
          this.addPause$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "resume":
          this.removePause$1(t1.$index(message, 1));
          break;
        case "add-ondone":
          this.addDoneListener$1(t1.$index(message, 1));
          break;
        case "remove-ondone":
          this.removeDoneListener$1(t1.$index(message, 1));
          break;
        case "set-errors-fatal":
          this.setErrorsFatal$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "ping":
          this.handlePing$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "kill":
          this.handleKill$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "getErrors":
          this.errorPorts.add$1(0, t1.$index(message, 1));
          break;
        case "stopErrors":
          this.errorPorts.remove$1(0, t1.$index(message, 1));
          break;
      }
    },
    lookup$1: function(portId) {
      return this.ports.$index(0, portId);
    },
    _addRegistration$2: function(portId, port) {
      var t1 = this.ports;
      if (t1.containsKey$1(0, portId))
        throw H.wrapException(P.Exception_Exception("Registry: ports must be registered only once."));
      t1.$indexSet(0, portId, port);
    },
    _updateGlobalState$0: function() {
      if (this.ports._collection$_length - this.weakPorts._collection$_length > 0 || this.isPaused || !this.initialized)
        init.globalState.isolates.$indexSet(0, this.id, this);
      else
        this.kill$0();
    },
    kill$0: [function() {
      var t1, t2;
      t1 = this._scheduledControlEvents;
      if (t1 != null)
        t1.clear$0(0);
      for (t1 = this.ports, t2 = t1.get$values(t1), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();)
        t2.__internal$_current.__isolate_helper$_close$0();
      t1.clear$0(0);
      this.weakPorts.clear$0(0);
      init.globalState.isolates.remove$1(0, this.id);
      this.errorPorts.clear$0(0);
      t1 = this.doneHandlers;
      if (t1 != null) {
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          J.send$1$x(t1.__internal$_current, null);
        this.doneHandlers = null;
      }
    }, "call$0", "get$kill", 0, 0, 17],
    $is_IsolateContext: true
  },
  _IsolateContext_handlePing_respond: {
    "^": "Closure:17;responsePort_0",
    call$0: [function() {
      J.send$1$x(this.responsePort_0, null);
    }, "call$0", null, 0, 0, null, "call"]
  },
  _EventLoop: {
    "^": "Object;events<,_activeJsAsyncCount",
    dequeue$0: function() {
      var t1 = this.events;
      if (t1._head === t1._tail)
        return;
      return t1.removeFirst$0();
    },
    runIteration$0: function() {
      var $event, t1, t2;
      $event = this.dequeue$0();
      if ($event == null) {
        if (init.globalState.rootContext != null && init.globalState.isolates.containsKey$1(0, init.globalState.rootContext.id) && init.globalState.fromCommandLine === true && init.globalState.rootContext.ports._collection$_length === 0)
          H.throwExpression(P.Exception_Exception("Program exited with open ReceivePorts."));
        t1 = init.globalState;
        if (t1.isWorker === true && t1.isolates._collection$_length === 0 && t1.topEventLoop._activeJsAsyncCount === 0) {
          t1 = t1.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "close"], null, null));
          t1.toString;
          self.postMessage(t2);
        }
        return false;
      }
      $event.process$0();
      return true;
    },
    _runHelper$0: function() {
      if (self.window != null)
        new H._EventLoop__runHelper_next(this).call$0();
      else
        for (; this.runIteration$0();)
          ;
    },
    run$0: function() {
      var e, trace, exception, t1, t2;
      if (init.globalState.isWorker !== true)
        this._runHelper$0();
      else
        try {
          this._runHelper$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          trace = new H._StackTrace(exception, null);
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "error", "msg", H.S(e) + "\n" + H.S(trace)], null, null));
          t1.toString;
          self.postMessage(t2);
        }

    }
  },
  _EventLoop__runHelper_next: {
    "^": "Closure:17;this_0",
    call$0: function() {
      if (!this.this_0.runIteration$0())
        return;
      P.Timer_Timer(C.Duration_0, this);
    }
  },
  _IsolateEvent: {
    "^": "Object;isolate,fn,message",
    process$0: function() {
      var t1 = this.isolate;
      if (t1.get$isPaused()) {
        t1.get$delayedEvents().push(this);
        return;
      }
      t1.eval$1(this.fn);
    },
    $is_IsolateEvent: true
  },
  _MainManagerStub: {
    "^": "Object;"
  },
  IsolateNatives__processWorkerMessage_closure: {
    "^": "Closure:54;entryPoint_0,args_1,message_2,isSpawnUri_3,startPaused_4,replyTo_5",
    call$0: [function() {
      H.IsolateNatives__startIsolate(this.entryPoint_0, this.args_1, this.message_2, this.isSpawnUri_3, this.startPaused_4, this.replyTo_5);
    }, "call$0", null, 0, 0, null, "call"]
  },
  IsolateNatives__startIsolate_runStartFunction: {
    "^": "Closure:17;topLevel_0,args_1,message_2,isSpawnUri_3,context_4",
    call$0: [function() {
      var t1, t2, t3;
      this.context_4.set$initialized(true);
      if (this.isSpawnUri_3 !== true)
        this.topLevel_0.call$1(this.message_2);
      else {
        t1 = this.topLevel_0;
        t2 = H.getDynamicRuntimeType();
        t3 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
        if (t3)
          t1.call$2(this.args_1, this.message_2);
        else {
          t2 = H.buildFunctionType(t2, [t2])._isTest$1(t1);
          if (t2)
            t1.call$1(this.args_1);
          else
            t1.call$0();
        }
      }
    }, "call$0", null, 0, 0, null, "call"]
  },
  _BaseSendPort: {
    "^": "Object;",
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort: {
    "^": "_BaseSendPort;_receivePort,_isolateId",
    send$1: function(_, message) {
      var t1, t2, isolate, t3, shouldSerialize;
      t1 = {};
      t2 = this._isolateId;
      isolate = init.globalState.isolates.$index(0, t2);
      if (isolate == null)
        return;
      t3 = this._receivePort;
      if (t3.get$_isClosed())
        return;
      shouldSerialize = init.globalState.currentContext != null && init.globalState.currentContext.id !== t2;
      t1.msg_0 = message;
      if (shouldSerialize)
        t1.msg_0 = H._serializeMessage(message);
      if (isolate.get$controlPort() === t3) {
        isolate.handleControlMessage$1(t1.msg_0);
        return;
      }
      t2 = init.globalState.topEventLoop;
      t3 = "receive " + H.S(message);
      t2.events._add$1(new H._IsolateEvent(isolate, new H._NativeJsSendPort_send_closure(t1, this, shouldSerialize), t3));
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$is_NativeJsSendPort && J.$eq(this._receivePort, other._receivePort);
    },
    get$hashCode: function(_) {
      return this._receivePort.get$_id();
    },
    $is_NativeJsSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort_send_closure: {
    "^": "Closure:54;box_0,this_1,shouldSerialize_2",
    call$0: [function() {
      var t1, t2;
      t1 = this.this_1._receivePort;
      if (!t1.get$_isClosed()) {
        if (this.shouldSerialize_2) {
          t2 = this.box_0;
          t2.msg_0 = H._deserializeMessage(t2.msg_0);
        }
        t1.__isolate_helper$_add$1(this.box_0.msg_0);
      }
    }, "call$0", null, 0, 0, null, "call"]
  },
  _WorkerSendPort: {
    "^": "_BaseSendPort;_workerId,_receivePortId,_isolateId",
    send$1: function(_, message) {
      var workerMessage, manager;
      workerMessage = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "message", "port", this, "msg", message], null, null));
      if (init.globalState.isWorker === true) {
        init.globalState.mainManager.toString;
        self.postMessage(workerMessage);
      } else {
        manager = init.globalState.managers.$index(0, this._workerId);
        if (manager != null)
          manager.postMessage(workerMessage);
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$is_WorkerSendPort && J.$eq(this._workerId, other._workerId) && J.$eq(this._isolateId, other._isolateId) && J.$eq(this._receivePortId, other._receivePortId);
    },
    get$hashCode: function(_) {
      var t1, t2, t3;
      t1 = J.$shl$n(this._workerId, 16);
      t2 = J.$shl$n(this._isolateId, 8);
      t3 = this._receivePortId;
      if (typeof t3 !== "number")
        return H.iae(t3);
      return (t1 ^ t2 ^ t3) >>> 0;
    },
    $is_WorkerSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  RawReceivePortImpl: {
    "^": "Object;_id<,_handler,_isClosed<",
    _handler$1: function(arg0) {
      return this._handler.call$1(arg0);
    },
    __isolate_helper$_close$0: function() {
      this._isClosed = true;
      this._handler = null;
    },
    __isolate_helper$_add$1: function(dataEvent) {
      if (this._isClosed)
        return;
      this._handler$1(dataEvent);
    },
    $isRawReceivePortImpl: true,
    static: {"^": "RawReceivePortImpl__nextFreeId"}
  },
  _JsSerializer: {
    "^": "_Serializer;_nextFreeRefId,_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return ["sendport", init.globalState.currentManagerId, x._isolateId, x._receivePort.get$_id()];
      if (!!x.$is_WorkerSendPort)
        return ["sendport", x._workerId, x._isolateId, x._receivePortId];
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return ["capability", x._id];
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    },
    visitFunction$1: function(topLevelFunction) {
      var $name = !!topLevelFunction.$isClosure ? topLevelFunction.$name : null;
      if ($name == null)
        throw H.wrapException(P.UnsupportedError$("only top-level functions can be sent."));
      return ["function", $name];
    }
  },
  _JsCopier: {
    "^": "_Copier;_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return new H._NativeJsSendPort(x._receivePort, x._isolateId);
      if (!!x.$is_WorkerSendPort)
        return new H._WorkerSendPort(x._workerId, x._receivePortId, x._isolateId);
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return new H.CapabilityImpl(x._id);
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    },
    visitFunction$1: function(topLevelFunction) {
      var $name = !!topLevelFunction.$isClosure ? topLevelFunction.$name : null;
      if ($name == null)
        throw H.wrapException(P.UnsupportedError$("only top-level functions can be sent."));
      return H.IsolateNatives__getJSFunctionFromName($name);
    }
  },
  _JsDeserializer: {
    "^": "_Deserializer;_deserialized",
    deserializeSendPort$1: function(list) {
      var t1, managerId, isolateId, receivePortId, isolate, receivePort;
      t1 = J.getInterceptor$asx(list);
      managerId = t1.$index(list, 1);
      isolateId = t1.$index(list, 2);
      receivePortId = t1.$index(list, 3);
      if (J.$eq(managerId, init.globalState.currentManagerId)) {
        isolate = init.globalState.isolates.$index(0, isolateId);
        if (isolate == null)
          return;
        receivePort = isolate.lookup$1(receivePortId);
        if (receivePort == null)
          return;
        return new H._NativeJsSendPort(receivePort, isolateId);
      } else
        return new H._WorkerSendPort(managerId, receivePortId, isolateId);
    },
    deserializeCapability$1: function(list) {
      return new H.CapabilityImpl(J.$index$asx(list, 1));
    },
    deserializeFunction$1: function(list) {
      return H.IsolateNatives__getJSFunctionFromName(J.$index$asx(list, 1));
    }
  },
  _JsVisitedMap: {
    "^": "Object;tagged",
    $index: function(_, object) {
      return object.__MessageTraverser__attached_info__;
    },
    $indexSet: function(_, object, info) {
      this.tagged.push(object);
      object.__MessageTraverser__attached_info__ = info;
    },
    reset$0: function(_) {
      this.tagged = [];
    },
    cleanup$0: function() {
      var $length, i, t1;
      for ($length = this.tagged.length, i = 0; i < $length; ++i) {
        t1 = this.tagged;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].__MessageTraverser__attached_info__ = null;
      }
      this.tagged = null;
    }
  },
  _MessageTraverserVisitedMap: {
    "^": "Object;",
    $index: function(_, object) {
      return;
    },
    $indexSet: function(_, object, info) {
    },
    reset$0: function(_) {
    },
    cleanup$0: function() {
    }
  },
  _MessageTraverser: {
    "^": "Object;",
    traverse$1: function(x) {
      var result;
      if (H._MessageTraverser_isPrimitive(x))
        return this.visitPrimitive$1(x);
      this._visited.reset$0(0);
      result = null;
      try {
        result = this._dispatch$1(x);
      } finally {
        this._visited.cleanup$0();
      }
      return result;
    },
    _dispatch$1: function(x) {
      var t1;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return this.visitPrimitive$1(x);
      t1 = J.getInterceptor(x);
      if (!!t1.$isList)
        return this.visitList$1(x);
      if (!!t1.$isMap)
        return this.visitMap$1(x);
      if (!!t1.$isSendPort)
        return this.visitSendPort$1(x);
      if (!!t1.$isCapability)
        return this.visitCapability$1(x);
      if (!!t1.$isFunction)
        return this.visitFunction$1(x);
      return this.visitObject$1(x);
    },
    visitObject$1: function(x) {
      throw H.wrapException("Message serialization: Illegal value " + H.S(x) + " passed");
    }
  },
  _Copier: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copy, t1, len, t2, i, t3;
      copy = this._visited.$index(0, list);
      if (copy != null)
        return copy;
      t1 = J.getInterceptor$asx(list);
      len = t1.get$length(list);
      if (typeof len !== "number")
        return H.iae(len);
      copy = Array(len);
      copy.fixed$length = init;
      this._visited.$indexSet(0, list, copy);
      for (t2 = copy.length, i = 0; i < len; ++i) {
        t3 = this._dispatch$1(t1.$index(list, i));
        if (i >= t2)
          return H.ioore(copy, i);
        copy[i] = t3;
      }
      return copy;
    },
    visitMap$1: function(map) {
      var t1, copy;
      t1 = {};
      copy = this._visited.$index(0, map);
      t1.copy_0 = copy;
      if (copy != null)
        return copy;
      copy = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1.copy_0 = copy;
      this._visited.$indexSet(0, map, copy);
      J.forEach$1$ax(map, new H._Copier_visitMap_closure(t1, this));
      return t1.copy_0;
    },
    visitFunction$1: function(f) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Copier_visitMap_closure: {
    "^": "Closure:959;box_0,this_1",
    call$2: function(key, val) {
      var t1 = this.this_1;
      J.$indexSet$ax(this.box_0.copy_0, t1._dispatch$1(key), t1._dispatch$1(val));
    }
  },
  _Serializer: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copyId, t1;
      copyId = this._visited.$index(0, list);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, list, t1);
      return ["list", t1, this._serializeList$1(list)];
    },
    visitMap$1: function(map) {
      var copyId, t1, t2;
      copyId = this._visited.$index(0, map);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, map, t1);
      t2 = J.getInterceptor$x(map);
      return ["map", t1, this._serializeList$1(J.toList$0$ax(t2.get$keys(map))), this._serializeList$1(J.toList$0$ax(t2.get$values(map)))];
    },
    _serializeList$1: function(list) {
      var t1, len, result, i, t2;
      t1 = J.getInterceptor$asx(list);
      len = t1.get$length(list);
      result = [];
      C.JSArray_methods.set$length(result, len);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i) {
        t2 = this._dispatch$1(t1.$index(list, i));
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t2;
      }
      return result;
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitFunction$1: function(f) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Deserializer: {
    "^": "Object;",
    deserialize$1: function(x) {
      if (H._Deserializer_isPrimitive(x))
        return x;
      this._deserialized = P.HashMap_HashMap(null, null, null, null, null);
      return this._deserializeHelper$1(x);
    },
    _deserializeHelper$1: function(x) {
      var t1, id;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return x;
      t1 = J.getInterceptor$asx(x);
      switch (t1.$index(x, 0)) {
        case "ref":
          id = t1.$index(x, 1);
          return this._deserialized.$index(0, id);
        case "list":
          return this._deserializeList$1(x);
        case "map":
          return this._deserializeMap$1(x);
        case "sendport":
          return this.deserializeSendPort$1(x);
        case "capability":
          return this.deserializeCapability$1(x);
        case "function":
          return this.deserializeFunction$1(x);
        default:
          return this.deserializeObject$1(x);
      }
    },
    _deserializeList$1: function(x) {
      var t1, id, dartList, len, i;
      t1 = J.getInterceptor$asx(x);
      id = t1.$index(x, 1);
      dartList = t1.$index(x, 2);
      this._deserialized.$indexSet(0, id, dartList);
      t1 = J.getInterceptor$asx(dartList);
      len = t1.get$length(dartList);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        t1.$indexSet(dartList, i, this._deserializeHelper$1(t1.$index(dartList, i)));
      return dartList;
    },
    _deserializeMap$1: function(x) {
      var result, t1, id, keys, values, len, t2, i;
      result = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1 = J.getInterceptor$asx(x);
      id = t1.$index(x, 1);
      this._deserialized.$indexSet(0, id, result);
      keys = t1.$index(x, 2);
      values = t1.$index(x, 3);
      t1 = J.getInterceptor$asx(keys);
      len = t1.get$length(keys);
      if (typeof len !== "number")
        return H.iae(len);
      t2 = J.getInterceptor$asx(values);
      i = 0;
      for (; i < len; ++i)
        result.$indexSet(0, this._deserializeHelper$1(t1.$index(keys, i)), this._deserializeHelper$1(t2.$index(values, i)));
      return result;
    },
    deserializeObject$1: function(x) {
      throw H.wrapException("Unexpected serialized object");
    }
  },
  TimerImpl: {
    "^": "Object;_once,_inEventLoop,_handle",
    cancel$0: function() {
      if (self.setTimeout != null) {
        if (this._inEventLoop)
          throw H.wrapException(P.UnsupportedError$("Timer in event loop cannot be canceled."));
        if (this._handle == null)
          return;
        H.leaveJsAsync();
        var t1 = this._handle;
        if (this._once)
          self.clearTimeout(t1);
        else
          self.clearInterval(t1);
        this._handle = null;
      } else
        throw H.wrapException(P.UnsupportedError$("Canceling a timer."));
    },
    TimerImpl$periodic$2: function(milliseconds, callback) {
      if (self.setTimeout != null) {
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._handle = self.setInterval(H.convertDartClosureToJS(new H.TimerImpl$periodic_closure(this, callback), 0), milliseconds);
      } else
        throw H.wrapException(P.UnsupportedError$("Periodic timer."));
    },
    TimerImpl$2: function(milliseconds, callback) {
      var t1, t2;
      if (milliseconds === 0)
        t1 = self.setTimeout == null || init.globalState.isWorker === true;
      else
        t1 = false;
      if (t1) {
        this._handle = 1;
        t1 = init.globalState.topEventLoop;
        t2 = init.globalState.currentContext;
        t1.events._add$1(new H._IsolateEvent(t2, new H.TimerImpl_internalCallback(this, callback), "timer"));
        this._inEventLoop = true;
      } else if (self.setTimeout != null) {
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._handle = self.setTimeout(H.convertDartClosureToJS(new H.TimerImpl_internalCallback0(this, callback), 0), milliseconds);
      } else
        throw H.wrapException(P.UnsupportedError$("Timer greater than 0."));
    },
    static: {TimerImpl$: function(milliseconds, callback) {
        var t1 = new H.TimerImpl(true, false, null);
        t1.TimerImpl$2(milliseconds, callback);
        return t1;
      }, TimerImpl$periodic: function(milliseconds, callback) {
        var t1 = new H.TimerImpl(false, false, null);
        t1.TimerImpl$periodic$2(milliseconds, callback);
        return t1;
      }}
  },
  TimerImpl_internalCallback: {
    "^": "Closure:17;this_0,callback_1",
    call$0: [function() {
      this.this_0._handle = null;
      this.callback_1.call$0();
    }, "call$0", null, 0, 0, null, "call"]
  },
  TimerImpl_internalCallback0: {
    "^": "Closure:17;this_2,callback_3",
    call$0: [function() {
      this.this_2._handle = null;
      H.leaveJsAsync();
      this.callback_3.call$0();
    }, "call$0", null, 0, 0, null, "call"]
  },
  TimerImpl$periodic_closure: {
    "^": "Closure:54;this_0,callback_1",
    call$0: [function() {
      this.callback_1.call$1(this.this_0);
    }, "call$0", null, 0, 0, null, "call"]
  },
  CapabilityImpl: {
    "^": "Object;_id<",
    get$hashCode: function(_) {
      var hash, t1, t2;
      hash = this._id;
      t1 = J.getInterceptor$n(hash);
      t2 = t1.$shr(hash, 0);
      t1 = t1.$tdiv(hash, 4294967296);
      if (typeof t1 !== "number")
        return H.iae(t1);
      hash = t2 ^ t1;
      hash = (~hash >>> 0) + (hash << 15 >>> 0) & 4294967295;
      hash = ((hash ^ hash >>> 12) >>> 0) * 5 & 4294967295;
      hash = ((hash ^ hash >>> 4) >>> 0) * 2057 & 4294967295;
      return (hash ^ hash >>> 16) >>> 0;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other === this)
        return true;
      if (!!J.getInterceptor(other).$isCapabilityImpl) {
        t1 = this._id;
        t2 = other._id;
        return t1 == null ? t2 == null : t1 === t2;
      }
      return false;
    },
    $isCapabilityImpl: true,
    $isCapability: true
  }
}],
["_js_helper", "dart:_js_helper", , H, {
  "^": "",
  isJsIndexable: function(object, record) {
    var result;
    if (record != null) {
      result = record.x;
      if (result != null)
        return result;
    }
    return !!J.getInterceptor(object).$isJavaScriptIndexingBehavior;
  },
  S: function(value) {
    var res;
    if (typeof value === "string")
      return value;
    if (typeof value === "number") {
      if (value !== 0)
        return "" + value;
    } else if (true === value)
      return "true";
    else if (false === value)
      return "false";
    else if (value == null)
      return "null";
    res = J.toString$0(value);
    if (typeof res !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return res;
  },
  throwInvalidReflectionError: function(memberName) {
    throw H.wrapException(P.UnsupportedError$("Can't use '" + H.S(memberName) + "' in reflection because it is not included in a @MirrorsUsed annotation."));
  },
  getMetadata: function(index) {
    return init.metadata[index];
  },
  Primitives_objectHashCode: function(object) {
    var hash = object.$identityHash;
    if (hash == null) {
      hash = Math.random() * 0x3fffffff | 0;
      object.$identityHash = hash;
    }
    return hash;
  },
  Primitives__throwFormatException: [function(string) {
    throw H.wrapException(P.FormatException$(string, null, null));
  }, "call$1", "Primitives__throwFormatException$closure", 2, 0, 91],
  Primitives_parseInt: function(source, radix, handleError) {
    var match, t1, maxCharCode, digitsPart, i, t2;
    if (handleError == null)
      handleError = H.Primitives__throwFormatException$closure();
    H.checkString(source);
    match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
    if (radix == null) {
      if (match != null) {
        t1 = match.length;
        if (2 >= t1)
          return H.ioore(match, 2);
        if (match[2] != null)
          return parseInt(source, 16);
        if (3 >= t1)
          return H.ioore(match, 3);
        if (match[3] != null)
          return parseInt(source, 10);
        return handleError.call$1(source);
      }
      radix = 10;
    } else {
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$("Radix " + H.S(radix) + " not in range 2..36"));
      if (match != null) {
        if (radix === 10) {
          if (3 >= match.length)
            return H.ioore(match, 3);
          t1 = match[3] != null;
        } else
          t1 = false;
        if (t1)
          return parseInt(source, 10);
        if (!(radix < 10)) {
          if (3 >= match.length)
            return H.ioore(match, 3);
          t1 = match[3] == null;
        } else
          t1 = true;
        if (t1) {
          maxCharCode = radix <= 10 ? 48 + radix - 1 : 97 + radix - 10 - 1;
          if (1 >= match.length)
            return H.ioore(match, 1);
          digitsPart = match[1];
          t1 = J.getInterceptor$asx(digitsPart);
          i = 0;
          while (true) {
            t2 = t1.get$length(digitsPart);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            t1.codeUnitAt$1(digitsPart, 0);
            if (t1.codeUnitAt$1(digitsPart, i) > maxCharCode)
              return handleError.call$1(source);
            ++i;
          }
        }
      }
    }
    if (match == null)
      return handleError.call$1(source);
    return parseInt(source, radix);
  },
  Primitives_parseDouble: function(source, handleError) {
    var result, trimmed, t1;
    H.checkString(source);
    handleError = H.Primitives__throwFormatException$closure();
    if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source))
      return handleError.call$1(source);
    result = parseFloat(source);
    if (isNaN(result)) {
      trimmed = J.trim$0$s(source);
      t1 = J.getInterceptor(trimmed);
      if (t1.$eq(trimmed, "NaN") || t1.$eq(trimmed, "+NaN") || t1.$eq(trimmed, "-NaN"))
        return result;
      return handleError.call$1(source);
    }
    return result;
  },
  Primitives_objectTypeName: function(object) {
    var $name, decompiled;
    $name = C.JS_CONST_8ZY(J.getInterceptor(object));
    if ($name === "Object") {
      decompiled = String(object.constructor).match(/^\s*function\s*(\S*)\s*\(/)[1];
      if (typeof decompiled === "string")
        $name = /^\w+$/.test(decompiled) ? decompiled : $name;
    }
    if ($name.length > 1 && C.JSString_methods.codeUnitAt$1($name, 0) === 36)
      $name = C.JSString_methods.substring$1($name, 1);
    return ($name + H.joinArguments(H.getRuntimeTypeInfo(object), 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  Primitives_objectToString: function(object) {
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Primitives__fromCharCodeApply: function(array) {
    var end, t1, result, i, subarray, t2;
    end = array.length;
    for (t1 = end <= 500, result = "", i = 0; i < end; i += 500) {
      if (t1)
        subarray = array;
      else {
        t2 = i + 500;
        t2 = t2 < end ? t2 : end;
        subarray = array.slice(i, t2);
      }
      result += String.fromCharCode.apply(null, subarray);
    }
    return result;
  },
  Primitives_stringFromCodePoints: function(codePoints) {
    var a, t1, i;
    a = [];
    a.$builtinTypeInfo = [P.$int];
    t1 = new H.ListIterator(codePoints, codePoints.length, 0, null);
    t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(codePoints, 0)];
    for (; t1.moveNext$0();) {
      i = t1.__internal$_current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i <= 65535)
        a.push(i);
      else if (i <= 1114111) {
        a.push(55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
        a.push(56320 + (i & 1023));
      } else
        throw H.wrapException(P.ArgumentError$(i));
    }
    return H.Primitives__fromCharCodeApply(a);
  },
  Primitives_stringFromCharCodes: function(charCodes) {
    var t1, i;
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(charCodes, charCodes.length, 0, null), [H.getTypeArgumentByIndex(charCodes, 0)]); t1.moveNext$0();) {
      i = t1.__internal$_current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i < 0)
        throw H.wrapException(P.ArgumentError$(i));
      if (i > 65535)
        return H.Primitives_stringFromCodePoints(charCodes);
    }
    return H.Primitives__fromCharCodeApply(charCodes);
  },
  Primitives_stringFromCharCode: function(charCode) {
    var bits;
    if (typeof charCode !== "number")
      return H.iae(charCode);
    if (0 <= charCode) {
      if (charCode <= 65535)
        return String.fromCharCode(charCode);
      if (charCode <= 1114111) {
        bits = charCode - 65536;
        return String.fromCharCode((55296 | C.JSNumber_methods._shrOtherPositive$1(bits, 10)) >>> 0, (56320 | bits & 1023) >>> 0);
      }
    }
    throw H.wrapException(P.RangeError$range(charCode, 0, 1114111, null, null));
  },
  Primitives_lazyAsJsDate: function(receiver) {
    if (receiver.date === void 0)
      receiver.date = new Date(receiver.millisecondsSinceEpoch);
    return receiver.date;
  },
  Primitives_getProperty: function(object, key) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    return object[key];
  },
  Primitives_setProperty: function(object, key, value) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    object[key] = value;
  },
  Primitives_functionNoSuchMethod: function($function, positionalArguments, namedArguments) {
    var t1, $arguments, namedArgumentList, t2;
    t1 = {};
    t1.argumentCount_0 = 0;
    $arguments = [];
    namedArgumentList = [];
    if (positionalArguments != null) {
      t2 = J.get$length$asx(positionalArguments);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t1.argumentCount_0 = 0 + t2;
      C.JSArray_methods.addAll$1($arguments, positionalArguments);
    }
    t1.names_1 = "";
    if (namedArguments != null && !namedArguments.get$isEmpty(namedArguments))
      namedArguments.forEach$1(0, new H.Primitives_functionNoSuchMethod_closure(t1, $arguments, namedArgumentList));
    return J.noSuchMethod$1($function, new H.JSInvocationMirror(C.Symbol_call, "call$" + H.S(t1.argumentCount_0) + t1.names_1, 0, $arguments, namedArgumentList, null));
  },
  Primitives_applyFunction: function($function, positionalArguments, namedArguments) {
    var t1, jsFunction, info, t2, defaultArguments, t3, i, index, $arguments, argumentCount;
    t1 = {};
    if (namedArguments != null && !namedArguments.get$isEmpty(namedArguments)) {
      jsFunction = J.getInterceptor($function)["call*"];
      if (jsFunction == null)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      info = H.ReflectionInfo_ReflectionInfo(jsFunction);
      if (info == null || !info.areOptionalParametersNamed)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      positionalArguments = positionalArguments != null ? P.List_List$from(positionalArguments, true, null) : [];
      t2 = info.requiredParameterCount;
      if (t2 !== positionalArguments.length)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      defaultArguments = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      for (t3 = info.optionalParameterCount, i = 0; i < t3; ++i) {
        index = i + t2;
        defaultArguments.$indexSet(0, info.parameterNameInOrder$1(index), init.metadata[info.defaultValueInOrder$1(index)]);
      }
      t1.bad_0 = false;
      namedArguments.forEach$1(0, new H.Primitives_applyFunction_closure(t1, defaultArguments));
      if (t1.bad_0)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      C.JSArray_methods.addAll$1(positionalArguments, defaultArguments.get$values(defaultArguments));
      return jsFunction.apply($function, positionalArguments);
    }
    $arguments = [];
    if (positionalArguments != null) {
      t1 = J.get$length$asx(positionalArguments);
      if (typeof t1 !== "number")
        return H.iae(t1);
      argumentCount = 0 + t1;
      C.JSArray_methods.addAll$1($arguments, positionalArguments);
    } else
      argumentCount = 0;
    jsFunction = $function["call$" + H.S(argumentCount)];
    if (jsFunction == null)
      return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
    return jsFunction.apply($function, $arguments);
  },
  JsCache_allocate: function() {
    var result = Object.create(null);
    result.x = 0;
    delete result.x;
    return result;
  },
  iae: function(argument) {
    throw H.wrapException(P.ArgumentError$(argument));
  },
  ioore: function(receiver, index) {
    if (receiver == null)
      J.get$length$asx(receiver);
    if (typeof index !== "number" || Math.floor(index) !== index)
      H.iae(index);
    throw H.wrapException(P.RangeError$value(index, null, null));
  },
  checkNum: function(value) {
    if (typeof value !== "number")
      throw H.wrapException(P.ArgumentError$(value));
    return value;
  },
  checkInt: function(value) {
    if (typeof value !== "number" || Math.floor(value) !== value)
      throw H.wrapException(P.ArgumentError$(value));
    return value;
  },
  checkString: function(value) {
    if (typeof value !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return value;
  },
  wrapException: function(ex) {
    var wrapper;
    if (ex == null)
      ex = new P.NullThrownError();
    wrapper = new Error();
    wrapper.dartException = ex;
    if ("defineProperty" in Object) {
      Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
      wrapper.name = "";
    } else
      wrapper.toString = H.toStringWrapper;
    return wrapper;
  },
  toStringWrapper: [function() {
    return J.toString$0(this.dartException);
  }, "call$0", "toStringWrapper$closure", 0, 0, null],
  throwExpression: function(ex) {
    throw H.wrapException(ex);
  },
  unwrapException: function(ex) {
    var t1, message, number, ieErrorCode, t2, t3, t4, nullLiteralCall, t5, t6, t7, t8, t9, match;
    t1 = new H.unwrapException_saveStackTrace(ex);
    if (ex == null)
      return;
    if (typeof ex !== "object")
      return ex;
    if ("dartException" in ex)
      return t1.call$1(ex.dartException);
    else if (!("message" in ex))
      return ex;
    message = ex.message;
    if ("number" in ex && typeof ex.number == "number") {
      number = ex.number;
      ieErrorCode = number & 65535;
      if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
        switch (ieErrorCode) {
          case 438:
            return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
          case 445:
          case 5007:
            t2 = H.S(message) + " (Error " + ieErrorCode + ")";
            return t1.call$1(new H.NullError(t2, null));
        }
    }
    if (ex instanceof TypeError) {
      t2 = $.get$TypeErrorDecoder_noSuchMethodPattern();
      t3 = $.get$TypeErrorDecoder_notClosurePattern();
      t4 = $.get$TypeErrorDecoder_nullCallPattern();
      nullLiteralCall = $.get$TypeErrorDecoder_nullLiteralCallPattern();
      t5 = $.get$TypeErrorDecoder_undefinedCallPattern();
      t6 = $.get$TypeErrorDecoder_undefinedLiteralCallPattern();
      t7 = $.get$TypeErrorDecoder_nullPropertyPattern();
      $.get$TypeErrorDecoder_nullLiteralPropertyPattern();
      t8 = $.get$TypeErrorDecoder_undefinedPropertyPattern();
      t9 = $.get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
      match = t2.matchTypeError$1(message);
      if (match != null)
        return t1.call$1(H.JsNoSuchMethodError$(message, match));
      else {
        match = t3.matchTypeError$1(message);
        if (match != null) {
          match.method = "call";
          return t1.call$1(H.JsNoSuchMethodError$(message, match));
        } else {
          match = t4.matchTypeError$1(message);
          if (match == null) {
            match = nullLiteralCall.matchTypeError$1(message);
            if (match == null) {
              match = t5.matchTypeError$1(message);
              if (match == null) {
                match = t6.matchTypeError$1(message);
                if (match == null) {
                  match = t7.matchTypeError$1(message);
                  if (match == null) {
                    match = nullLiteralCall.matchTypeError$1(message);
                    if (match == null) {
                      match = t8.matchTypeError$1(message);
                      if (match == null) {
                        match = t9.matchTypeError$1(message);
                        t2 = match != null;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
          } else
            t2 = true;
          if (t2) {
            t2 = match == null ? null : match.method;
            return t1.call$1(new H.NullError(message, t2));
          }
        }
      }
      t2 = typeof message === "string" ? message : "";
      return t1.call$1(new H.UnknownJsTypeError(t2));
    }
    if (ex instanceof RangeError) {
      if (typeof message === "string" && message.indexOf("call stack") !== -1)
        return new P.StackOverflowError();
      return t1.call$1(new P.ArgumentError(false, null, null, null));
    }
    if (typeof InternalError == "function" && ex instanceof InternalError)
      if (typeof message === "string" && message === "too much recursion")
        return new P.StackOverflowError();
    return ex;
  },
  objectHashCode: function(object) {
    if (object == null || typeof object != 'object')
      return J.get$hashCode$(object);
    else
      return H.Primitives_objectHashCode(object);
  },
  fillLiteralMap: function(keyValuePairs, result) {
    var $length, index, index0, index1;
    $length = keyValuePairs.length;
    for (index = 0; index < $length; index = index1) {
      index0 = index + 1;
      index1 = index0 + 1;
      result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
    }
    return result;
  },
  invokeClosure: [function(closure, isolate, numberOfArguments, arg1, arg2, arg3, arg4) {
    var t1 = J.getInterceptor(numberOfArguments);
    if (t1.$eq(numberOfArguments, 0))
      return H._callInIsolate(isolate, new H.invokeClosure_closure(closure));
    else if (t1.$eq(numberOfArguments, 1))
      return H._callInIsolate(isolate, new H.invokeClosure_closure0(closure, arg1));
    else if (t1.$eq(numberOfArguments, 2))
      return H._callInIsolate(isolate, new H.invokeClosure_closure1(closure, arg1, arg2));
    else if (t1.$eq(numberOfArguments, 3))
      return H._callInIsolate(isolate, new H.invokeClosure_closure2(closure, arg1, arg2, arg3));
    else if (t1.$eq(numberOfArguments, 4))
      return H._callInIsolate(isolate, new H.invokeClosure_closure3(closure, arg1, arg2, arg3, arg4));
    else
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
  }, "call$7", "invokeClosure$closure", 14, 0, null, 586, [], 587, [], 588, [], 589, [], 590, [], 591, [], 592, []],
  convertDartClosureToJS: function(closure, arity) {
    var $function;
    if (closure == null)
      return;
    $function = closure.$identity;
    if (!!$function)
      return $function;
    $function = function(closure, arity, context, invoke) {
      return function(a1, a2, a3, a4) {
        return invoke(closure, context, arity, a1, a2, a3, a4);
      };
    }(closure, arity, init.globalState.currentContext, H.invokeClosure);
    closure.$identity = $function;
    return $function;
  },
  Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
    var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
    $function = functions[0];
    $function.$stubName;
    callName = $function.$callName;
    $function.$reflectionInfo = reflectionInfo;
    functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
    $prototype = isStatic ? Object.create(new H.TearOffClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
    $prototype.$initialize = $prototype.constructor;
    if (isStatic)
      $constructor = function() {
        this.$initialize();
      };
    else if (typeof dart_precompiled == "function") {
      t1 = function(a, b, c, d) {
        this.$initialize(a, b, c, d);
      };
      $constructor = t1;
    } else {
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t1, 1);
      t1 = new Function("a", "b", "c", "d", "this.$initialize(a,b,c,d);" + t1);
      $constructor = t1;
    }
    $prototype.constructor = $constructor;
    $constructor.prototype = $prototype;
    t1 = !isStatic;
    if (t1) {
      isIntercepted = jsArguments.length == 1 && true;
      trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
      trampoline.$reflectionInfo = reflectionInfo;
    } else {
      $prototype.$name = propertyName;
      trampoline = $function;
      isIntercepted = false;
    }
    if (typeof functionType == "number")
      signatureFunction = function(s) {
        return function() {
          return init.metadata[s];
        };
      }(functionType);
    else if (t1 && typeof functionType == "function") {
      getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
      signatureFunction = function(f, r) {
        return function() {
          return f.apply({$receiver: r(this)}, arguments);
        };
      }(functionType, getReceiver);
    } else
      throw H.wrapException("Error in reflectionInfo.");
    $prototype.$signature = signatureFunction;
    $prototype[callName] = trampoline;
    for (t1 = functions.length, i = 1; i < t1; ++i) {
      stub = functions[i];
      stubCallName = stub.$callName;
      if (stubCallName != null) {
        t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
        $prototype[stubCallName] = t2;
      }
    }
    $prototype["call*"] = trampoline;
    return $constructor;
  },
  Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
    var getSelf = H.BoundClosure_selfOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        return function(n, S) {
          return function() {
            return S(this)[n]();
          };
        }(stubName, getSelf);
      case 1:
        return function(n, S) {
          return function(a) {
            return S(this)[n](a);
          };
        }(stubName, getSelf);
      case 2:
        return function(n, S) {
          return function(a, b) {
            return S(this)[n](a, b);
          };
        }(stubName, getSelf);
      case 3:
        return function(n, S) {
          return function(a, b, c) {
            return S(this)[n](a, b, c);
          };
        }(stubName, getSelf);
      case 4:
        return function(n, S) {
          return function(a, b, c, d) {
            return S(this)[n](a, b, c, d);
          };
        }(stubName, getSelf);
      case 5:
        return function(n, S) {
          return function(a, b, c, d, e) {
            return S(this)[n](a, b, c, d, e);
          };
        }(stubName, getSelf);
      default:
        return function(f, s) {
          return function() {
            return f.apply(s(this), arguments);
          };
        }($function, getSelf);
    }
  },
  Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
    var stubName, arity, lookedUpFunction, t1, t2, $arguments;
    if (isIntercepted)
      return H.Closure_forwardInterceptedCallTo(receiver, $function);
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (typeof dart_precompiled == "function" || !t1 || arity >= 27)
      return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
    if (arity === 0) {
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "();";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
    t1 = "return function(" + $arguments + "){return this.";
    t2 = $.BoundClosure_selfFieldNameCache;
    if (t2 == null) {
      t2 = H.BoundClosure_computeFieldNamed("self");
      $.BoundClosure_selfFieldNameCache = t2;
    }
    t2 = t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");";
    t1 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t1, 1);
    return new Function(t2 + H.S(t1) + "}")();
  },
  Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
    var getSelf, getReceiver;
    getSelf = H.BoundClosure_selfOf;
    getReceiver = H.BoundClosure_receiverOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
      case 1:
        return function(n, s, r) {
          return function() {
            return s(this)[n](r(this));
          };
        }($name, getSelf, getReceiver);
      case 2:
        return function(n, s, r) {
          return function(a) {
            return s(this)[n](r(this), a);
          };
        }($name, getSelf, getReceiver);
      case 3:
        return function(n, s, r) {
          return function(a, b) {
            return s(this)[n](r(this), a, b);
          };
        }($name, getSelf, getReceiver);
      case 4:
        return function(n, s, r) {
          return function(a, b, c) {
            return s(this)[n](r(this), a, b, c);
          };
        }($name, getSelf, getReceiver);
      case 5:
        return function(n, s, r) {
          return function(a, b, c, d) {
            return s(this)[n](r(this), a, b, c, d);
          };
        }($name, getSelf, getReceiver);
      case 6:
        return function(n, s, r) {
          return function(a, b, c, d, e) {
            return s(this)[n](r(this), a, b, c, d, e);
          };
        }($name, getSelf, getReceiver);
      default:
        return function(f, s, r, a) {
          return function() {
            a = [r(this)];
            Array.prototype.push.apply(a, arguments);
            return f.apply(s(this), a);
          };
        }($function, getSelf, getReceiver);
    }
  },
  Closure_forwardInterceptedCallTo: function(receiver, $function) {
    var selfField, t1, stubName, arity, isCsp, lookedUpFunction, t2, $arguments;
    selfField = H.BoundClosure_selfFieldName();
    t1 = $.BoundClosure_receiverFieldNameCache;
    if (t1 == null) {
      t1 = H.BoundClosure_computeFieldNamed("receiver");
      $.BoundClosure_receiverFieldNameCache = t1;
    }
    stubName = $function.$stubName;
    arity = $function.length;
    isCsp = typeof dart_precompiled == "function";
    lookedUpFunction = receiver[stubName];
    t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (isCsp || !t2 || arity >= 28)
      return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
    if (arity === 1) {
      t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
    t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
    t2 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t2, 1);
    return new Function(t1 + H.S(t2) + "}")();
  },
  closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
    functions.fixed$length = Array;
    reflectionInfo.fixed$length = Array;
    return H.Closure_fromTearOff(receiver, functions, reflectionInfo, !!isStatic, jsArguments, $name);
  },
  propertyTypeCastError: function(value, property) {
    var t1 = J.getInterceptor$asx(property);
    throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), t1.substring$2(property, 3, t1.get$length(property))));
  },
  interceptedTypeCast: function(value, property) {
    var t1;
    if (value != null)
      t1 = typeof value === "object" && J.getInterceptor(value)[property];
    else
      t1 = true;
    if (t1)
      return value;
    H.propertyTypeCastError(value, property);
  },
  throwCyclicInit: function(staticName) {
    throw H.wrapException(P.CyclicInitializationError$("Cyclic initialization for static " + H.S(staticName)));
  },
  buildFunctionType: function(returnType, parameterTypes, optionalParameterTypes) {
    return new H.RuntimeFunctionType(returnType, parameterTypes, optionalParameterTypes, null);
  },
  getDynamicRuntimeType: function() {
    return C.C_DynamicRuntimeType;
  },
  random64: function() {
    return (Math.random() * 0x100000000 >>> 0) + (Math.random() * 0x100000000 >>> 0) * 4294967296;
  },
  getIsolateAffinityTag: function($name) {
    return init.getIsolateTag($name);
  },
  createRuntimeType: function($name) {
    return new H.TypeImpl($name, null);
  },
  setRuntimeTypeInfo: function(target, typeInfo) {
    if (target != null)
      target.$builtinTypeInfo = typeInfo;
    return target;
  },
  getRuntimeTypeInfo: function(target) {
    if (target == null)
      return;
    return target.$builtinTypeInfo;
  },
  getRuntimeTypeArguments: function(target, substitutionName) {
    return H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
  },
  getRuntimeTypeArgument: function(target, substitutionName, index) {
    var $arguments = H.getRuntimeTypeArguments(target, substitutionName);
    return $arguments == null ? null : $arguments[index];
  },
  getTypeArgumentByIndex: function(target, index) {
    var rti = H.getRuntimeTypeInfo(target);
    return rti == null ? null : rti[index];
  },
  runtimeTypeToString: function(type, onTypeVariable) {
    if (type == null)
      return "dynamic";
    else if (typeof type === "object" && type !== null && type.constructor === Array)
      return type[0].builtin$cls + H.joinArguments(type, 1, onTypeVariable);
    else if (typeof type == "function")
      return type.builtin$cls;
    else if (typeof type === "number" && Math.floor(type) === type)
      if (onTypeVariable == null)
        return C.JSInt_methods.toString$0(type);
      else
        return onTypeVariable.call$1(type);
    else
      return;
  },
  joinArguments: function(types, startIndex, onTypeVariable) {
    var buffer, index, firstArgument, allDynamic, argument, str;
    if (types == null)
      return "";
    buffer = P.StringBuffer$("");
    for (index = startIndex, firstArgument = true, allDynamic = true; index < types.length; ++index) {
      if (firstArgument)
        firstArgument = false;
      else
        buffer._contents += ", ";
      argument = types[index];
      if (argument != null)
        allDynamic = false;
      str = H.runtimeTypeToString(argument, onTypeVariable);
      buffer._contents += typeof str === "string" ? str : H.S(str);
    }
    return allDynamic ? "" : "<" + H.S(buffer) + ">";
  },
  getRuntimeTypeString: function(object) {
    var className = J.getInterceptor(object).constructor.builtin$cls;
    if (object == null)
      return className;
    return className + H.joinArguments(object.$builtinTypeInfo, 0, null);
  },
  substitute: function(substitution, $arguments) {
    if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
      $arguments = substitution;
    else if (typeof substitution == "function") {
      substitution = H.invokeOn(substitution, null, $arguments);
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        $arguments = substitution;
      else if (typeof substitution == "function")
        $arguments = H.invokeOn(substitution, null, $arguments);
    }
    return $arguments;
  },
  checkSubtype: function(object, isField, checks, asField) {
    var $arguments, interceptor;
    if (object == null)
      return false;
    $arguments = H.getRuntimeTypeInfo(object);
    interceptor = J.getInterceptor(object);
    if (interceptor[isField] == null)
      return false;
    return H.areSubtypes(H.substitute(interceptor[asField], $arguments), checks);
  },
  areSubtypes: function(s, t) {
    var len, i;
    if (s == null || t == null)
      return true;
    len = s.length;
    for (i = 0; i < len; ++i)
      if (!H.isSubtype(s[i], t[i]))
        return false;
    return true;
  },
  computeSignature: function(signature, context, contextName) {
    return H.invokeOn(signature, context, H.getRuntimeTypeArguments(context, contextName));
  },
  checkSubtypeOfRuntimeType: function(o, t) {
    var rti, type;
    if (o == null)
      return t == null || t.builtin$cls === "Object" || t.builtin$cls === "Null";
    if (t == null)
      return true;
    rti = H.getRuntimeTypeInfo(o);
    o = J.getInterceptor(o);
    if (rti != null) {
      type = rti.slice();
      type.splice(0, 0, o);
    } else
      type = o;
    return H.isSubtype(type, t);
  },
  subtypeOfRuntimeTypeCast: function(object, type) {
    if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(object), H.runtimeTypeToString(type, null)));
    return object;
  },
  isSubtype: function(s, t) {
    var targetSignatureFunction, t1, typeOfS, t2, typeOfT, $name, substitution;
    if (s === t)
      return true;
    if (s == null || t == null)
      return true;
    if ("func" in t) {
      if (!("func" in s)) {
        if ("$is_" + H.S(t.func) in s)
          return true;
        targetSignatureFunction = s.$signature;
        if (targetSignatureFunction == null)
          return false;
        s = targetSignatureFunction.apply(s, null);
      }
      return H.isFunctionSubtype(s, t);
    }
    if (t.builtin$cls === "Function" && "func" in s)
      return true;
    t1 = typeof s === "object" && s !== null && s.constructor === Array;
    typeOfS = t1 ? s[0] : s;
    t2 = typeof t === "object" && t !== null && t.constructor === Array;
    typeOfT = t2 ? t[0] : t;
    $name = H.runtimeTypeToString(typeOfT, null);
    if (typeOfT !== typeOfS) {
      if (!("$is" + H.S($name) in typeOfS))
        return false;
      substitution = typeOfS["$as" + H.S(H.runtimeTypeToString(typeOfT, null))];
    } else
      substitution = null;
    if (!t1 && substitution == null || !t2)
      return true;
    t1 = t1 ? s.slice(1) : null;
    t2 = t2 ? t.slice(1) : null;
    return H.areSubtypes(H.substitute(substitution, t1), t2);
  },
  areAssignable: function(s, t, allowShorter) {
    var sLength, tLength, i, t1, t2;
    if (t == null && s == null)
      return true;
    if (t == null)
      return allowShorter;
    if (s == null)
      return false;
    sLength = s.length;
    tLength = t.length;
    if (allowShorter) {
      if (sLength < tLength)
        return false;
    } else if (sLength !== tLength)
      return false;
    for (i = 0; i < tLength; ++i) {
      t1 = s[i];
      t2 = t[i];
      if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
        return false;
    }
    return true;
  },
  areAssignableMaps: function(s, t) {
    var t1, names, i, $name, tType, sType;
    if (t == null)
      return true;
    if (s == null)
      return false;
    t1 = Object.getOwnPropertyNames(t);
    t1.fixed$length = Array;
    names = t1;
    for (t1 = names.length, i = 0; i < t1; ++i) {
      $name = names[i];
      if (!Object.hasOwnProperty.call(s, $name))
        return false;
      tType = t[$name];
      sType = s[$name];
      if (!(H.isSubtype(tType, sType) || H.isSubtype(sType, tType)))
        return false;
    }
    return true;
  },
  isFunctionSubtype: function(s, t) {
    var sReturnType, tReturnType, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, t1, t2, tPos, sPos;
    if (!("func" in s))
      return false;
    if ("void" in s) {
      if (!("void" in t) && "ret" in t)
        return false;
    } else if (!("void" in t)) {
      sReturnType = s.ret;
      tReturnType = t.ret;
      if (!(H.isSubtype(sReturnType, tReturnType) || H.isSubtype(tReturnType, sReturnType)))
        return false;
    }
    sParameterTypes = s.args;
    tParameterTypes = t.args;
    sOptionalParameterTypes = s.opt;
    tOptionalParameterTypes = t.opt;
    sParametersLen = sParameterTypes != null ? sParameterTypes.length : 0;
    tParametersLen = tParameterTypes != null ? tParameterTypes.length : 0;
    sOptionalParametersLen = sOptionalParameterTypes != null ? sOptionalParameterTypes.length : 0;
    tOptionalParametersLen = tOptionalParameterTypes != null ? tOptionalParameterTypes.length : 0;
    if (sParametersLen > tParametersLen)
      return false;
    if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
      return false;
    if (sParametersLen === tParametersLen) {
      if (!H.areAssignable(sParameterTypes, tParameterTypes, false))
        return false;
      if (!H.areAssignable(sOptionalParameterTypes, tOptionalParameterTypes, true))
        return false;
    } else {
      for (pos = 0; pos < sParametersLen; ++pos) {
        t1 = sParameterTypes[pos];
        t2 = tParameterTypes[pos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tOptionalParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
    }
    return H.areAssignableMaps(s.named, t.named);
  },
  invokeOn: function($function, receiver, $arguments) {
    return $function.apply(receiver, $arguments);
  },
  toStringForNativeObject: function(obj) {
    var t1 = $.getTagFunction;
    return "Instance of " + (t1 == null ? "<Unknown>" : t1.call$1(obj));
  },
  hashCodeForNativeObject: function(object) {
    return H.Primitives_objectHashCode(object);
  },
  defineProperty: function(obj, property, value) {
    Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
  },
  lookupAndCacheInterceptor: function(obj) {
    var tag, record, interceptor, interceptorClass, mark, t1;
    tag = $.getTagFunction.call$1(obj);
    record = $.dispatchRecordsForInstanceTags[tag];
    if (record != null) {
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    interceptor = $.interceptorsForUncacheableTags[tag];
    if (interceptor != null)
      return interceptor;
    interceptorClass = init.interceptorsByTag[tag];
    if (interceptorClass == null) {
      tag = $.alternateTagFunction.call$2(obj, tag);
      if (tag != null) {
        record = $.dispatchRecordsForInstanceTags[tag];
        if (record != null) {
          Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
          return record.i;
        }
        interceptor = $.interceptorsForUncacheableTags[tag];
        if (interceptor != null)
          return interceptor;
        interceptorClass = init.interceptorsByTag[tag];
      }
    }
    if (interceptorClass == null)
      return;
    interceptor = interceptorClass.prototype;
    mark = tag[0];
    if (mark === "!") {
      record = H.makeLeafDispatchRecord(interceptor);
      $.dispatchRecordsForInstanceTags[tag] = record;
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    if (mark === "~") {
      $.interceptorsForUncacheableTags[tag] = interceptor;
      return interceptor;
    }
    if (mark === "-") {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    }
    if (mark === "+")
      return H.patchInteriorProto(obj, interceptor);
    if (mark === "*")
      throw H.wrapException(P.UnimplementedError$(tag));
    if (init.leafTags[tag] === true) {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    } else
      return H.patchInteriorProto(obj, interceptor);
  },
  patchInteriorProto: function(obj, interceptor) {
    var proto = Object.getPrototypeOf(obj);
    Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
    return interceptor;
  },
  makeLeafDispatchRecord: function(interceptor) {
    return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
  },
  makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
    var interceptor = interceptorClass.prototype;
    if (init.leafTags[tag] === true)
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    else
      return J.makeDispatchRecord(interceptor, proto, null, null);
  },
  initNativeDispatch: function() {
    if (true === $.initNativeDispatchFlag)
      return;
    $.initNativeDispatchFlag = true;
    H.initNativeDispatchContinue();
  },
  initNativeDispatchContinue: function() {
    var map, tags, fun, i, tag, proto, record, interceptorClass;
    $.dispatchRecordsForInstanceTags = Object.create(null);
    $.interceptorsForUncacheableTags = Object.create(null);
    H.initHooks();
    map = init.interceptorsByTag;
    tags = Object.getOwnPropertyNames(map);
    if (typeof window != "undefined") {
      window;
      fun = function() {
      };
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        proto = $.prototypeForTagFunction.call$1(tag);
        if (proto != null) {
          record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
          if (record != null) {
            Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            fun.prototype = proto;
          }
        }
      }
    }
    for (i = 0; i < tags.length; ++i) {
      tag = tags[i];
      if (/^[A-Za-z_]/.test(tag)) {
        interceptorClass = map[tag];
        map["!" + tag] = interceptorClass;
        map["~" + tag] = interceptorClass;
        map["-" + tag] = interceptorClass;
        map["+" + tag] = interceptorClass;
        map["*" + tag] = interceptorClass;
      }
    }
  },
  initHooks: function() {
    var hooks, transformers, i, transformer, getTag, getUnknownTag, prototypeForTag;
    hooks = C.JS_CONST_oRe();
    hooks = H.applyHooksTransformer(C.JS_CONST_0, H.applyHooksTransformer(C.JS_CONST_rr7, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_gkc, H.applyHooksTransformer(C.JS_CONST_4hp, H.applyHooksTransformer(C.JS_CONST_QJm(C.JS_CONST_8ZY), hooks)))))));
    if (typeof dartNativeDispatchHooksTransformer != "undefined") {
      transformers = dartNativeDispatchHooksTransformer;
      if (typeof transformers == "function")
        transformers = [transformers];
      if (transformers.constructor == Array)
        for (i = 0; i < transformers.length; ++i) {
          transformer = transformers[i];
          if (typeof transformer == "function")
            hooks = transformer(hooks) || hooks;
        }
    }
    getTag = hooks.getTag;
    getUnknownTag = hooks.getUnknownTag;
    prototypeForTag = hooks.prototypeForTag;
    $.getTagFunction = new H.initHooks_closure(getTag);
    $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
    $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
  },
  applyHooksTransformer: function(transformer, hooks) {
    return transformer(hooks) || hooks;
  },
  allMatchesInStringUnchecked: function(needle, haystack, startIndex) {
    var result, $length, patternLength, position, endIndex;
    result = H.setRuntimeTypeInfo([], [P.Match]);
    $length = haystack.length;
    patternLength = needle.length;
    for (; true;) {
      position = C.JSString_methods.indexOf$2(haystack, needle, startIndex);
      if (position === -1)
        break;
      result.push(new H.StringMatch(position, haystack, needle));
      endIndex = position + patternLength;
      if (endIndex === $length)
        break;
      else
        startIndex = position === endIndex ? startIndex + 1 : endIndex;
    }
    return result;
  },
  stringContainsUnchecked: function(receiver, other, startIndex) {
    var t1;
    if (typeof other === "string")
      return C.JSString_methods.indexOf$2(receiver, other, startIndex) !== -1;
    else {
      t1 = J.getInterceptor(other);
      if (!!t1.$isJSSyntaxRegExp) {
        t1 = C.JSString_methods.substring$1(receiver, startIndex);
        return other._nativeRegExp.test(H.checkString(t1));
      } else
        return J.get$isNotEmpty$asx(t1.allMatches$1(other, C.JSString_methods.substring$1(receiver, startIndex)));
    }
  },
  stringReplaceFirstRE: function(receiver, regexp, to, startIndex) {
    var match, t1, start, t2;
    match = regexp._execGlobal$2(receiver, startIndex);
    if (match == null)
      return receiver;
    t1 = match._match;
    start = t1.index;
    t2 = t1.index;
    if (0 >= t1.length)
      return H.ioore(t1, 0);
    t1 = J.get$length$asx(t1[0]);
    if (typeof t1 !== "number")
      return H.iae(t1);
    return C.JSString_methods.substring$2(receiver, 0, start) + H.S(to) + C.JSString_methods.substring$1(receiver, t2 + t1);
  },
  stringReplaceAllUnchecked: function(receiver, from, to) {
    var result, $length, i, t1, nativeRegexp;
    H.checkString(to);
    if (typeof from === "string")
      if (from === "")
        if (receiver === "")
          return to;
        else {
          result = P.StringBuffer$("");
          $length = receiver.length;
          result.write$1(to);
          for (i = 0; i < $length; ++i) {
            t1 = receiver[i];
            t1 = result._contents += t1;
            result._contents = t1 + to;
          }
          t1 = result._contents;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        }
      else
        return receiver.replace(new RegExp(from.replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), "\\$&"), 'g'), to.replace(/\$/g, "$$$$"));
    else if (!!J.getInterceptor(from).$isJSSyntaxRegExp) {
      nativeRegexp = from.get$_nativeGlobalVersion();
      nativeRegexp.lastIndex = 0;
      return receiver.replace(nativeRegexp, to.replace(/\$/g, "$$$$"));
    } else {
      if (from == null)
        H.throwExpression(P.ArgumentError$(null));
      throw H.wrapException("String.replaceAll(Pattern) UNIMPLEMENTED");
    }
  },
  stringReplaceFirstUnchecked: function(receiver, from, to, startIndex) {
    var index;
    if (typeof from === "string") {
      index = C.JSString_methods.indexOf$2(receiver, from, startIndex);
      if (index < 0)
        return receiver;
      return C.JSString_methods.substring$2(receiver, 0, index) + H.S(to) + C.JSString_methods.substring$1(receiver, index + from.length);
    } else if (!!J.getInterceptor(from).$isJSSyntaxRegExp)
      return startIndex === 0 ? receiver.replace(from._nativeRegExp, to.replace(/\$/g, "$$$$")) : H.stringReplaceFirstRE(receiver, from, to, startIndex);
    else {
      if (from == null)
        H.throwExpression(P.ArgumentError$(null));
      throw H.wrapException("String.replace(Pattern) UNIMPLEMENTED");
    }
  },
  NoSideEffects: {
    "^": "Object;"
  },
  NoThrows: {
    "^": "Object;"
  },
  NoInline: {
    "^": "Object;"
  },
  Native: {
    "^": "Object;name>"
  },
  ConstantMap: {
    "^": "Object;",
    get$isEmpty: function(_) {
      return J.$eq(this.get$length(this), 0);
    },
    get$isNotEmpty: function(_) {
      return !J.$eq(this.get$length(this), 0);
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    _throwUnmodifiable$0: function() {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable Map"));
    },
    $indexSet: function(_, key, val) {
      return this._throwUnmodifiable$0();
    },
    remove$1: function(_, key) {
      return this._throwUnmodifiable$0();
    },
    clear$0: function(_) {
      return this._throwUnmodifiable$0();
    },
    addAll$1: function(_, other) {
      return this._throwUnmodifiable$0();
    },
    $isMap: true,
    $asMap: null
  },
  ConstantStringMap: {
    "^": "ConstantMap;length>,_jsObject,_keys",
    containsKey$1: function(_, key) {
      if (typeof key !== "string")
        return false;
      if ("__proto__" === key)
        return false;
      return this._jsObject.hasOwnProperty(key);
    },
    $index: function(_, key) {
      if (!this.containsKey$1(0, key))
        return;
      return this._fetch$1(key);
    },
    _fetch$1: function(key) {
      return this._jsObject[key];
    },
    forEach$1: function(_, f) {
      var keys, i, key;
      keys = this._keys;
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        f.call$2(key, this._fetch$1(key));
      }
    },
    get$keys: function(_) {
      return H.setRuntimeTypeInfo(new H._ConstantMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(this._keys, new H.ConstantStringMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    $isEfficientLength: true
  },
  ConstantStringMap_values_closure: {
    "^": "Closure:102;this_0",
    call$1: [function(key) {
      return this.this_0._fetch$1(key);
    }, "call$1", null, 2, 0, null, 269, [], "call"]
  },
  _ConstantMapKeyIterable: {
    "^": "IterableBase;__js_helper$_map",
    get$iterator: function(_) {
      return J.get$iterator$ax(this.__js_helper$_map._keys);
    }
  },
  _Patch: {
    "^": "Object;"
  },
  JSInvocationMirror: {
    "^": "Object;__js_helper$_memberName,_internalName,_kind,_arguments,_namedArgumentNames,_namedIndices",
    get$memberName: function() {
      var $name, t1, t2, unmangledName;
      $name = this.__js_helper$_memberName;
      t1 = J.getInterceptor($name);
      if (!!t1.$isSymbol0)
        return $name;
      t2 = $.get$mangledNames();
      unmangledName = t2.$index(0, $name);
      if (unmangledName != null) {
        t1 = unmangledName.split(":");
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        $name = t1[0];
      } else if (t2.$index(0, this._internalName) == null)
        P.print("Warning: '" + t1.toString$0($name) + "' is used reflectively but not in MirrorsUsed. This will break minified code.");
      t1 = new H.Symbol($name);
      this.__js_helper$_memberName = t1;
      return t1;
    },
    get$positionalArguments: function() {
      var t1, argumentCount, list, index;
      if (this._kind === 1)
        return C.List_empty;
      t1 = this._arguments;
      argumentCount = t1.length - this._namedArgumentNames.length;
      if (argumentCount === 0)
        return C.List_empty;
      list = [];
      for (index = 0; index < argumentCount; ++index) {
        if (index >= t1.length)
          return H.ioore(t1, index);
        list.push(t1[index]);
      }
      list.immutable$list = true;
      list.fixed$length = true;
      return list;
    },
    get$namedArguments: function() {
      var t1, namedArgumentCount, t2, namedArgumentsStartIndex, map, i, t3, t4;
      if (this._kind !== 0)
        return P.LinkedHashMap_LinkedHashMap$_empty(P.Symbol0, null);
      t1 = this._namedArgumentNames;
      namedArgumentCount = t1.length;
      t2 = this._arguments;
      namedArgumentsStartIndex = t2.length - namedArgumentCount;
      if (namedArgumentCount === 0)
        return P.LinkedHashMap_LinkedHashMap$_empty(P.Symbol0, null);
      map = P.LinkedHashMap_LinkedHashMap(null, null, null, P.Symbol0, null);
      for (i = 0; i < namedArgumentCount; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t3 = t1[i];
        t4 = namedArgumentsStartIndex + i;
        if (t4 < 0 || t4 >= t2.length)
          return H.ioore(t2, t4);
        map.$indexSet(0, new H.Symbol(t3), t2[t4]);
      }
      return map;
    },
    __js_helper$_getCachedInvocation$1: function(object) {
      var interceptor, $name, isIntercepted, interceptor0, receiver, method, baseName, isCatchAll;
      interceptor = J.getInterceptor(object);
      $name = this._internalName;
      isIntercepted = Object.prototype.hasOwnProperty.call(init.interceptedNames, $name) || $.interceptedNames.indexOf($name) !== -1;
      if (isIntercepted) {
        interceptor0 = object === interceptor ? null : interceptor;
        receiver = interceptor;
        interceptor = interceptor0;
      } else {
        receiver = object;
        interceptor = null;
      }
      method = receiver[$name];
      if (typeof method != "function") {
        baseName = this.get$memberName().get$_name();
        method = receiver[baseName + "*"];
        if (method == null) {
          interceptor = J.getInterceptor(object);
          method = interceptor[baseName + "*"];
          if (method != null)
            isIntercepted = true;
          else
            interceptor = null;
        }
        isCatchAll = true;
      } else
        isCatchAll = false;
      if (typeof method == "function")
        if (isCatchAll)
          return new H.CachedCatchAllInvocation(H.ReflectionInfo_ReflectionInfo(method), $name, method, isIntercepted, interceptor);
        else
          return new H.CachedInvocation($name, method, isIntercepted, interceptor);
      else
        return new H.CachedNoSuchMethodInvocation(interceptor);
    },
    static: {"^": "JSInvocationMirror_METHOD,JSInvocationMirror_GETTER,JSInvocationMirror_SETTER"}
  },
  CachedInvocation: {
    "^": "Object;mangledName<,jsFunction<,isIntercepted<,cachedInterceptor",
    get$isNoSuchMethod: function() {
      return false;
    },
    get$isGetterStub: function() {
      return !!this.jsFunction.$getterStub;
    },
    invokeOn$2: function(victim, $arguments) {
      var receiver, arguments0;
      if (!this.isIntercepted) {
        if ($arguments.constructor !== Array)
          $arguments = P.List_List$from($arguments, true, null);
        receiver = victim;
      } else {
        arguments0 = [victim];
        C.JSArray_methods.addAll$1(arguments0, $arguments);
        receiver = this.cachedInterceptor;
        receiver = receiver != null ? receiver : victim;
        $arguments = arguments0;
      }
      return this.jsFunction.apply(receiver, $arguments);
    }
  },
  CachedCatchAllInvocation: {
    "^": "CachedInvocation;info,mangledName,jsFunction,isIntercepted,cachedInterceptor",
    get$isGetterStub: function() {
      return false;
    },
    invokeOn$2: function(victim, $arguments) {
      var t1, t2, fullParameterCount, providedArgumentCount, receiver, arguments0, i;
      t1 = this.info;
      t2 = t1.requiredParameterCount;
      fullParameterCount = t2 + t1.optionalParameterCount;
      if (!this.isIntercepted) {
        if ($arguments.constructor === Array) {
          providedArgumentCount = $arguments.length;
          if (providedArgumentCount < fullParameterCount)
            $arguments = P.List_List$from($arguments, true, null);
        } else {
          $arguments = P.List_List$from($arguments, true, null);
          providedArgumentCount = $arguments.length;
        }
        receiver = victim;
      } else {
        arguments0 = [victim];
        C.JSArray_methods.addAll$1(arguments0, $arguments);
        receiver = this.cachedInterceptor;
        receiver = receiver != null ? receiver : victim;
        providedArgumentCount = arguments0.length - 1;
        $arguments = arguments0;
      }
      if (t1.areOptionalParametersNamed && providedArgumentCount > t2)
        throw H.wrapException(H.UnimplementedNoSuchMethodError$("Invocation of unstubbed method '" + t1.get$reflectionName() + "' with " + $arguments.length + " arguments."));
      else if (providedArgumentCount < t2)
        throw H.wrapException(H.UnimplementedNoSuchMethodError$("Invocation of unstubbed method '" + t1.get$reflectionName() + "' with " + providedArgumentCount + " arguments (too few)."));
      else if (providedArgumentCount > fullParameterCount)
        throw H.wrapException(H.UnimplementedNoSuchMethodError$("Invocation of unstubbed method '" + t1.get$reflectionName() + "' with " + providedArgumentCount + " arguments (too many)."));
      for (i = providedArgumentCount; i < fullParameterCount; ++i)
        C.JSArray_methods.add$1($arguments, init.metadata[t1.defaultValue$1(0, i)]);
      return this.jsFunction.apply(receiver, $arguments);
    }
  },
  CachedNoSuchMethodInvocation: {
    "^": "Object;interceptor",
    get$isNoSuchMethod: function() {
      return true;
    },
    get$isGetterStub: function() {
      return false;
    },
    invokeOn$2: function(victim, invocation) {
      var receiver = this.interceptor;
      return J.noSuchMethod$1(receiver == null ? victim : receiver, invocation);
    }
  },
  ReflectionInfo: {
    "^": "Object;jsFunction<,data>,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
    parameterName$1: function(parameter) {
      var metadataIndex = this.data[2 * parameter + this.optionalParameterCount + 3];
      return init.metadata[metadataIndex];
    },
    defaultValue$1: [function(_, parameter) {
      var t1 = this.requiredParameterCount;
      if (typeof parameter !== "number")
        return parameter.$lt();
      if (parameter < t1)
        return;
      return this.data[3 + parameter - t1];
    }, "call$1", "get$defaultValue", 2, 0, 248],
    defaultValueInOrder$1: function(parameter) {
      var t1 = this.requiredParameterCount;
      if (parameter < t1)
        return;
      if (!this.areOptionalParametersNamed || this.optionalParameterCount === 1)
        return this.defaultValue$1(0, parameter);
      return this.defaultValue$1(0, this.sortedIndex$1(parameter - t1));
    },
    parameterNameInOrder$1: function(parameter) {
      var t1 = this.requiredParameterCount;
      if (parameter < t1)
        return;
      if (!this.areOptionalParametersNamed || this.optionalParameterCount === 1)
        return this.parameterName$1(parameter);
      return this.parameterName$1(this.sortedIndex$1(parameter - t1));
    },
    sortedIndex$1: function(unsortedIndex) {
      var t1, t2, positions, t3, i, index, compare;
      t1 = {};
      if (this.cachedSortedIndices == null) {
        t2 = this.optionalParameterCount;
        this.cachedSortedIndices = Array(t2);
        positions = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.$int);
        for (t3 = this.requiredParameterCount, i = 0; i < t2; ++i) {
          index = t3 + i;
          positions.$indexSet(0, this.parameterName$1(index), index);
        }
        t1.index_0 = 0;
        t2 = positions.get$keys(positions).toList$0(0);
        C.JSArray_methods.checkMutable$1(t2, "sort");
        compare = P.Comparable_compare$closure();
        H.Sort__doSort(t2, 0, t2.length - 1, compare);
        C.JSArray_methods.forEach$1(t2, new H.ReflectionInfo_sortedIndex_closure(t1, this, positions));
      }
      t1 = this.cachedSortedIndices;
      if (unsortedIndex < 0 || unsortedIndex >= t1.length)
        return H.ioore(t1, unsortedIndex);
      return t1[unsortedIndex];
    },
    computeFunctionRti$1: function(jsConstructor) {
      var t1, fakeInstance;
      t1 = this.functionType;
      if (typeof t1 == "number")
        return H.getMetadata(t1);
      else if (typeof t1 == "function") {
        fakeInstance = new jsConstructor();
        H.setRuntimeTypeInfo(fakeInstance, fakeInstance["<>"]);
        return t1.apply({$receiver: fakeInstance});
      } else
        throw H.wrapException(H.RuntimeError$("Unexpected function type"));
    },
    get$reflectionName: function() {
      return this.jsFunction.$reflectionName;
    },
    static: {"^": "ReflectionInfo_REQUIRED_PARAMETERS_INFO,ReflectionInfo_OPTIONAL_PARAMETERS_INFO,ReflectionInfo_FUNCTION_TYPE_INDEX,ReflectionInfo_FIRST_DEFAULT_ARGUMENT", ReflectionInfo_ReflectionInfo: function(jsFunction) {
        var data, requiredParametersInfo, optionalParametersInfo;
        data = jsFunction.$reflectionInfo;
        if (data == null)
          return;
        data.fixed$length = Array;
        data = data;
        requiredParametersInfo = data[0];
        optionalParametersInfo = data[1];
        return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
      }}
  },
  ReflectionInfo_sortedIndex_closure: {
    "^": "Closure:91;box_0,this_1,positions_2",
    call$1: function($name) {
      var t1, t2, t3;
      t1 = this.this_1.cachedSortedIndices;
      t2 = this.box_0.index_0++;
      t3 = this.positions_2.$index(0, $name);
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2] = t3;
    }
  },
  Primitives_functionNoSuchMethod_closure: {
    "^": "Closure:119;box_0,arguments_1,namedArgumentList_2",
    call$2: function($name, argument) {
      var t1 = this.box_0;
      t1.names_1 = t1.names_1 + "$" + H.S($name);
      this.namedArgumentList_2.push($name);
      this.arguments_1.push(argument);
      ++t1.argumentCount_0;
    }
  },
  Primitives_applyFunction_closure: {
    "^": "Closure:119;box_0,defaultArguments_1",
    call$2: function(parameter, value) {
      var t1 = this.defaultArguments_1;
      if (t1.containsKey$1(0, parameter))
        t1.$indexSet(0, parameter, value);
      else
        this.box_0.bad_0 = true;
    }
  },
  TypeErrorDecoder: {
    "^": "Object;_pattern,_arguments,_argumentsExpr,_expr,_method,_receiver",
    matchTypeError$1: function(message) {
      var match, result, t1;
      match = new RegExp(this._pattern).exec(message);
      if (match == null)
        return;
      result = Object.create(null);
      t1 = this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    },
    static: {"^": "TypeErrorDecoder_noSuchMethodPattern,TypeErrorDecoder_notClosurePattern,TypeErrorDecoder_nullCallPattern,TypeErrorDecoder_nullLiteralCallPattern,TypeErrorDecoder_undefinedCallPattern,TypeErrorDecoder_undefinedLiteralCallPattern,TypeErrorDecoder_nullPropertyPattern,TypeErrorDecoder_nullLiteralPropertyPattern,TypeErrorDecoder_undefinedPropertyPattern,TypeErrorDecoder_undefinedLiteralPropertyPattern", TypeErrorDecoder_extractPattern: function(message) {
        var match, $arguments, argumentsExpr, expr, method, receiver;
        message = message.replace(String({}), '$receiver$').replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), '\\$&');
        match = message.match(/\\\$[a-zA-Z]+\\\$/g);
        if (match == null)
          match = [];
        $arguments = match.indexOf("\\$arguments\\$");
        argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
        expr = match.indexOf("\\$expr\\$");
        method = match.indexOf("\\$method\\$");
        receiver = match.indexOf("\\$receiver\\$");
        return new H.TypeErrorDecoder(message.replace('\\$arguments\\$', '((?:x|[^x])*)').replace('\\$argumentsExpr\\$', '((?:x|[^x])*)').replace('\\$expr\\$', '((?:x|[^x])*)').replace('\\$method\\$', '((?:x|[^x])*)').replace('\\$receiver\\$', '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
      }, TypeErrorDecoder_provokeCallErrorOn: function(expression) {
        return function($expr$) {
          var $argumentsExpr$ = '$arguments$';
          try {
            $expr$.$method$($argumentsExpr$);
          } catch (e) {
            return e.message;
          }

        }(expression);
      }, TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
        return function($expr$) {
          try {
            $expr$.$method$;
          } catch (e) {
            return e.message;
          }

        }(expression);
      }}
  },
  NullError: {
    "^": "Error;_message,_method",
    toString$0: function(_) {
      var t1 = this._method;
      if (t1 == null)
        return "NullError: " + H.S(this._message);
      return "NullError: Cannot call \"" + H.S(t1) + "\" on null";
    },
    $isError: true
  },
  JsNoSuchMethodError: {
    "^": "Error;_message,_method,_receiver",
    toString$0: function(_) {
      var t1, t2;
      t1 = this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(this._message);
      t2 = this._receiver;
      if (t2 == null)
        return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" (" + H.S(this._message) + ")";
      return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" on \"" + H.S(t2) + "\" (" + H.S(this._message) + ")";
    },
    $isError: true,
    static: {JsNoSuchMethodError$: function(_message, match) {
        var t1, t2;
        t1 = match == null;
        t2 = t1 ? null : match.method;
        t1 = t1 ? null : match.receiver;
        return new H.JsNoSuchMethodError(_message, t2, t1);
      }}
  },
  UnknownJsTypeError: {
    "^": "Error;_message",
    toString$0: function(_) {
      var t1 = this._message;
      return C.JSString_methods.get$isEmpty(t1) ? "Error" : "Error: " + t1;
    }
  },
  unwrapException_saveStackTrace: {
    "^": "Closure:102;ex_0",
    call$1: function(error) {
      if (!!J.getInterceptor(error).$isError)
        if (error.$thrownJsError == null)
          error.$thrownJsError = this.ex_0;
      return error;
    }
  },
  _StackTrace: {
    "^": "Object;_exception,_trace",
    toString$0: function(_) {
      var t1, trace;
      t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = typeof t1 === "object" ? t1.stack : null;
      t1 = trace == null ? "" : trace;
      this._trace = t1;
      return t1;
    }
  },
  invokeClosure_closure: {
    "^": "Closure:54;closure_0",
    call$0: function() {
      return this.closure_0.call$0();
    }
  },
  invokeClosure_closure0: {
    "^": "Closure:54;closure_1,arg1_2",
    call$0: function() {
      return this.closure_1.call$1(this.arg1_2);
    }
  },
  invokeClosure_closure1: {
    "^": "Closure:54;closure_3,arg1_4,arg2_5",
    call$0: function() {
      return this.closure_3.call$2(this.arg1_4, this.arg2_5);
    }
  },
  invokeClosure_closure2: {
    "^": "Closure:54;closure_6,arg1_7,arg2_8,arg3_9",
    call$0: function() {
      return this.closure_6.call$3(this.arg1_7, this.arg2_8, this.arg3_9);
    }
  },
  invokeClosure_closure3: {
    "^": "Closure:54;closure_10,arg1_11,arg2_12,arg3_13,arg4_14",
    call$0: function() {
      return this.closure_10.call$4(this.arg1_11, this.arg2_12, this.arg3_13, this.arg4_14);
    }
  },
  Closure: {
    "^": "Object;",
    toString$0: function(_) {
      return "Closure";
    },
    $isClosure: true,
    $isFunction: true,
    get$$call: function() {
      return this;
    }
  },
  "+Closure": [674, 0],
  TearOffClosure: {
    "^": "Closure;",
    $isTearOffClosure: true
  },
  BoundClosure: {
    "^": "TearOffClosure;_self,__js_helper$_target,_receiver,__js_helper$_name",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$isBoundClosure)
        return false;
      return this._self === other._self && this.__js_helper$_target === other.__js_helper$_target && this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var t1, receiverHashCode;
      t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      return J.$xor$n(receiverHashCode, H.Primitives_objectHashCode(this.__js_helper$_target));
    },
    $isBoundClosure: true,
    static: {"^": "BoundClosure_selfFieldNameCache,BoundClosure_receiverFieldNameCache", BoundClosure_selfOf: function(closure) {
        return closure._self;
      }, BoundClosure_receiverOf: function(closure) {
        return closure._receiver;
      }, BoundClosure_selfFieldName: function() {
        var t1 = $.BoundClosure_selfFieldNameCache;
        if (t1 == null) {
          t1 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t1;
        }
        return t1;
      }, BoundClosure_computeFieldNamed: function(fieldName) {
        var template, t1, names, i, $name;
        template = new H.BoundClosure("self", "target", "receiver", "name");
        t1 = Object.getOwnPropertyNames(template);
        t1.fixed$length = Array;
        names = t1;
        for (t1 = names.length, i = 0; i < t1; ++i) {
          $name = names[i];
          if (template[$name] === fieldName)
            return $name;
        }
      }}
  },
  "+BoundClosure": [1695],
  Creates: {
    "^": "Object;types"
  },
  Returns: {
    "^": "Object;types"
  },
  JSName: {
    "^": "Object;name>"
  },
  CastErrorImplementation: {
    "^": "Error;message",
    toString$0: function(_) {
      return this.message;
    },
    $isError: true,
    static: {CastErrorImplementation$: function(actualType, expectedType) {
        return new H.CastErrorImplementation("CastError: Casting value of type " + H.S(actualType) + " to incompatible type " + H.S(expectedType));
      }}
  },
  RuntimeError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    },
    static: {RuntimeError$: function(message) {
        return new H.RuntimeError(message);
      }}
  },
  RuntimeType: {
    "^": "Object;"
  },
  RuntimeFunctionType: {
    "^": "RuntimeType;returnType,parameterTypes,optionalParameterTypes,namedParameters",
    _isTest$1: function(expression) {
      var functionTypeObject = this._extractFunctionTypeObjectFrom$1(expression);
      return functionTypeObject == null ? false : H.isFunctionSubtype(functionTypeObject, this.toRti$0());
    },
    _extractFunctionTypeObjectFrom$1: function(o) {
      var interceptor = J.getInterceptor(o);
      return "$signature" in interceptor ? interceptor.$signature() : null;
    },
    toRti$0: function() {
      var result, t1, t2, namedRti, keys, i, $name;
      result = {func: "dynafunc"};
      t1 = this.returnType;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isVoidRuntimeType)
        result.void = true;
      else if (!t2.$isDynamicRuntimeType)
        result.ret = t1.toRti$0();
      t1 = this.parameterTypes;
      if (t1 != null && t1.length !== 0)
        result.args = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0)
        result.opt = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.namedParameters;
      if (t1 != null) {
        namedRti = Object.create(null);
        keys = H.extractKeys(t1);
        for (t2 = keys.length, i = 0; i < t2; ++i) {
          $name = keys[i];
          namedRti[$name] = t1[$name].toRti$0();
        }
        result.named = namedRti;
      }
      return result;
    },
    toString$0: function(_) {
      var t1, t2, result, needsComma, i, type, keys, $name;
      t1 = this.parameterTypes;
      if (t1 != null)
        for (t2 = t1.length, result = "(", needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
      else {
        result = "(";
        needsComma = false;
      }
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0) {
        result = (needsComma ? result + ", " : result) + "[";
        for (t2 = t1.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
        result += "]";
      } else {
        t1 = this.namedParameters;
        if (t1 != null) {
          result = (needsComma ? result + ", " : result) + "{";
          keys = H.extractKeys(t1);
          for (t2 = keys.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
            $name = keys[i];
            if (needsComma)
              result += ", ";
            result += H.S(t1[$name].toRti$0()) + " " + $name;
          }
          result += "}";
        }
      }
      return result + (") -> " + H.S(this.returnType));
    },
    static: {"^": "RuntimeFunctionType_inAssert", RuntimeFunctionType_listToRti: function(list) {
        var result, t1, i;
        list = list;
        result = [];
        for (t1 = list.length, i = 0; i < t1; ++i)
          result.push(list[i].toRti$0());
        return result;
      }}
  },
  DynamicRuntimeType: {
    "^": "RuntimeType;",
    toString$0: function(_) {
      return "dynamic";
    },
    toRti$0: function() {
      return;
    },
    $isDynamicRuntimeType: true
  },
  UnimplementedNoSuchMethodError: {
    "^": "Error;_message",
    toString$0: function(_) {
      return "Unsupported operation: " + this._message;
    },
    $isError: true,
    static: {UnimplementedNoSuchMethodError$: function(_message) {
        return new H.UnimplementedNoSuchMethodError(_message);
      }}
  },
  TypeImpl: {
    "^": "Object;_typeName<,_unmangledName",
    toString$0: function(_) {
      var t1, unmangledName;
      t1 = this._unmangledName;
      if (t1 != null)
        return t1;
      unmangledName = this._typeName.replace(/[^<,> ]+/g, function(m) {
        return init.mangledGlobalNames[m] || m;
      });
      this._unmangledName = unmangledName;
      return unmangledName;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this._typeName);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isTypeImpl && J.$eq(this._typeName, other._typeName);
    },
    $isTypeImpl: true,
    $isType: true
  },
  TypeVariable: {
    "^": "Object;owner<,name>,bound>"
  },
  initHooks_closure: {
    "^": "Closure:102;getTag_0",
    call$1: function(o) {
      return this.getTag_0(o);
    }
  },
  initHooks_closure0: {
    "^": "Closure:1696;getUnknownTag_1",
    call$2: function(o, tag) {
      return this.getUnknownTag_1(o, tag);
    }
  },
  initHooks_closure1: {
    "^": "Closure:91;prototypeForTag_2",
    call$1: function(tag) {
      return this.prototypeForTag_2(tag);
    }
  },
  JSSyntaxRegExp: {
    "^": "Object;pattern,_nativeRegExp<,_nativeGlobalRegExp,_nativeAnchoredRegExp",
    toString$0: function(_) {
      return "RegExp/" + this.pattern + "/";
    },
    get$_nativeGlobalVersion: function() {
      var t1 = this._nativeGlobalRegExp;
      if (t1 != null)
        return t1;
      t1 = this._nativeRegExp;
      t1 = H.JSSyntaxRegExp_makeNative(this.pattern, t1.multiline, !t1.ignoreCase, true);
      this._nativeGlobalRegExp = t1;
      return t1;
    },
    get$_nativeAnchoredVersion: function() {
      var t1 = this._nativeAnchoredRegExp;
      if (t1 != null)
        return t1;
      t1 = this._nativeRegExp;
      t1 = H.JSSyntaxRegExp_makeNative(this.pattern + "|()", t1.multiline, !t1.ignoreCase, true);
      this._nativeAnchoredRegExp = t1;
      return t1;
    },
    firstMatch$1: function(string) {
      var m = this._nativeRegExp.exec(H.checkString(string));
      if (m == null)
        return;
      return H._MatchImplementation$(this, m);
    },
    allMatches$2: function(_, string, start) {
      H.checkString(string);
      H.checkInt(start);
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return new H._AllMatchesIterable(this, string, start);
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    _execGlobal$2: function(string, start) {
      var regexp, match;
      regexp = this.get$_nativeGlobalVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      return H._MatchImplementation$(this, match);
    },
    _execAnchored$2: function(string, start) {
      var regexp, match, t1, t2;
      regexp = this.get$_nativeAnchoredVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      t1 = match.length;
      t2 = t1 - 1;
      if (t2 < 0)
        return H.ioore(match, t2);
      if (match[t2] != null)
        return;
      C.JSArray_methods.set$length(match, t2);
      return H._MatchImplementation$(this, match);
    },
    matchAsPrefix$2: function(_, string, start) {
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return this._execAnchored$2(string, start);
    },
    $isJSSyntaxRegExp: true,
    $isRegExp: true,
    static: {JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, global) {
        var m, i, g, regexp, errorMessage;
        H.checkString(source);
        m = multiLine ? "m" : "";
        i = caseSensitive ? "" : "i";
        g = global ? "g" : "";
        regexp = function() {
          try {
            return new RegExp(source, m + i + g);
          } catch (e) {
            return e;
          }

        }();
        if (regexp instanceof RegExp)
          return regexp;
        errorMessage = String(regexp);
        throw H.wrapException(P.FormatException$("Illegal RegExp pattern: " + source + ", " + errorMessage, null, null));
      }}
  },
  _MatchImplementation: {
    "^": "Object;pattern,_match",
    get$input: function() {
      return this._match.input;
    },
    get$start: function(_) {
      return this._match.index;
    },
    start$1: function($receiver, arg0) {
      return this.get$start(this).call$1(arg0);
    },
    start$0: function($receiver) {
      return this.get$start(this).call$0();
    },
    start$2: function($receiver, arg0, arg1) {
      return this.get$start(this).call$2(arg0, arg1);
    },
    start$3: function($receiver, arg0, arg1, arg2) {
      return this.get$start(this).call$3(arg0, arg1, arg2);
    },
    start$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$start(this).call$4(arg0, arg1, arg2, arg3);
    },
    start$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.get$start(this).call$5(arg0, arg1, arg2, arg3, arg4);
    },
    get$end: function() {
      var t1, t2;
      t1 = this._match;
      t2 = t1.index;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1 = J.get$length$asx(t1[0]);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return t2 + t1;
    },
    end$0: function() {
      return this.get$end().call$0();
    },
    $index: function(_, index) {
      var t1 = this._match;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    _MatchImplementation$2: function(pattern, _match) {
    },
    $isMatch: true,
    static: {_MatchImplementation$: function(pattern, _match) {
        var t1 = new H._MatchImplementation(pattern, _match);
        t1._MatchImplementation$2(pattern, _match);
        return t1;
      }}
  },
  _AllMatchesIterable: {
    "^": "IterableBase;_re,_string,_start",
    get$iterator: function(_) {
      return new H._AllMatchesIterator(this._re, this._string, this._start, null);
    },
    $asIterableBase: function() {
      return [P.Match];
    }
  },
  _AllMatchesIterator: {
    "^": "Object;_regExp,_string,_nextIndex,__js_helper$_current",
    get$current: function() {
      return this.__js_helper$_current;
    },
    moveNext$0: function() {
      var t1, t2, match, t3, nextIndex;
      t1 = this._string;
      if (t1 == null)
        return false;
      t2 = this._nextIndex;
      if (t2 <= t1.length) {
        match = this._regExp._execGlobal$2(t1, t2);
        if (match != null) {
          this.__js_helper$_current = match;
          t1 = match._match;
          t2 = t1.index;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t3 = J.get$length$asx(t1[0]);
          if (typeof t3 !== "number")
            return H.iae(t3);
          nextIndex = t2 + t3;
          this._nextIndex = t1.index === nextIndex ? nextIndex + 1 : nextIndex;
          return true;
        }
      }
      this.__js_helper$_current = null;
      this._string = null;
      return false;
    }
  },
  StringMatch: {
    "^": "Object;start>,input<,pattern",
    get$end: function() {
      return this.start + this.pattern.length;
    },
    end$0: function() {
      return this.get$end().call$0();
    },
    $index: function(_, g) {
      if (!J.$eq(g, 0))
        H.throwExpression(P.RangeError$value(g, null, null));
      return this.pattern;
    },
    start$1: function($receiver, arg0) {
      return this.start.call$1(arg0);
    },
    start$0: function($receiver) {
      return this.start.call$0();
    },
    start$2: function($receiver, arg0, arg1) {
      return this.start.call$2(arg0, arg1);
    },
    start$3: function($receiver, arg0, arg1, arg2) {
      return this.start.call$3(arg0, arg1, arg2);
    },
    start$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.start.call$4(arg0, arg1, arg2, arg3);
    },
    start$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.start.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    $isMatch: true
  }
}],
["dart._internal", "dart:_internal", , H, {
  "^": "",
  IterableElementError_noElement: function() {
    return new P.StateError("No element");
  },
  IterableElementError_tooFew: function() {
    return new P.StateError("Too few elements");
  },
  Lists_copy: function(src, srcStart, dst, dstStart, count) {
    var t1, i, j, t2, t3;
    t1 = J.getInterceptor$n(srcStart);
    if (t1.$lt(srcStart, dstStart))
      for (i = J.$sub$n(t1.$add(srcStart, count), 1), j = J.$sub$n(J.$add$ns(dstStart, count), 1), t1 = J.getInterceptor$asx(src); t2 = J.getInterceptor$n(i), t2.$ge(i, srcStart); i = t2.$sub(i, 1), j = J.$sub$n(j, 1))
        C.JSArray_methods.$indexSet(dst, j, t1.$index(src, i));
    else
      for (t2 = J.getInterceptor$asx(src), j = dstStart, i = srcStart; t3 = J.getInterceptor$n(i), t3.$lt(i, t1.$add(srcStart, count)); i = t3.$add(i, 1), j = J.$add$ns(j, 1))
        C.JSArray_methods.$indexSet(dst, j, t2.$index(src, i));
  },
  Lists_indexOf: function(a, element, startIndex, endIndex) {
    var t1, i;
    t1 = J.getInterceptor$n(startIndex);
    if (t1.$ge(startIndex, a.length))
      return -1;
    if (t1.$lt(startIndex, 0))
      startIndex = 0;
    for (i = startIndex; J.$lt$n(i, endIndex); ++i) {
      if (i >>> 0 !== i || i >= a.length)
        return H.ioore(a, i);
      if (J.$eq(a[i], element))
        return i;
    }
    return -1;
  },
  Sort__doSort: function(a, left, right, compare) {
    if (J.$le$n(J.$sub$n(right, left), 32))
      H.Sort__insertionSort(a, left, right, compare);
    else
      H.Sort__dualPivotQuicksort(a, left, right, compare);
  },
  Sort__insertionSort: function(a, left, right, compare) {
    var i, t1, t2, el, j, t3;
    for (i = J.$add$ns(left, 1), t1 = J.getInterceptor$asx(a); t2 = J.getInterceptor$n(i), t2.$le(i, right); i = t2.$add(i, 1)) {
      el = t1.$index(a, i);
      j = i;
      while (true) {
        t3 = J.getInterceptor$n(j);
        if (!(t3.$gt(j, left) && J.$gt$n(compare.call$2(t1.$index(a, t3.$sub(j, 1)), el), 0)))
          break;
        t1.$indexSet(a, j, t1.$index(a, t3.$sub(j, 1)));
        j = t3.$sub(j, 1);
      }
      t1.$indexSet(a, j, el);
    }
  },
  Sort__dualPivotQuicksort: function(a, left, right, compare) {
    var t1, sixth, t2, index1, index5, index3, t3, index2, index4, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, t4, less0, great0, pivots_are_equal;
    t1 = J.getInterceptor$n(right);
    sixth = J.$tdiv$n(J.$add$ns(t1.$sub(right, left), 1), 6);
    t2 = J.getInterceptor$ns(left);
    index1 = t2.$add(left, sixth);
    index5 = t1.$sub(right, sixth);
    index3 = J.$tdiv$n(t2.$add(left, right), 2);
    t3 = J.getInterceptor$n(index3);
    index2 = t3.$sub(index3, sixth);
    index4 = t3.$add(index3, sixth);
    t3 = J.getInterceptor$asx(a);
    el1 = t3.$index(a, index1);
    el2 = t3.$index(a, index2);
    el3 = t3.$index(a, index3);
    el4 = t3.$index(a, index4);
    el5 = t3.$index(a, index5);
    if (J.$gt$n(compare.call$2(el1, el2), 0)) {
      t0 = el2;
      el2 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    if (J.$gt$n(compare.call$2(el1, el3), 0)) {
      t0 = el3;
      el3 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el1, el4), 0)) {
      t0 = el4;
      el4 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el3, el4), 0)) {
      t0 = el4;
      el4 = el3;
      el3 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el5), 0)) {
      t0 = el5;
      el5 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    t3.$indexSet(a, index1, el1);
    t3.$indexSet(a, index3, el3);
    t3.$indexSet(a, index5, el5);
    t3.$indexSet(a, index2, t3.$index(a, left));
    t3.$indexSet(a, index4, t3.$index(a, right));
    less = t2.$add(left, 1);
    great = t1.$sub(right, 1);
    if (J.$eq(compare.call$2(el2, el4), 0)) {
      for (k = less; t1 = J.getInterceptor$n(k), t1.$le(k, great); k = t1.$add(k, 1)) {
        ak = t3.$index(a, k);
        comp = compare.call$2(ak, el2);
        t2 = J.getInterceptor(comp);
        if (t2.$eq(comp, 0))
          continue;
        if (t2.$lt(comp, 0)) {
          if (!t1.$eq(k, less)) {
            t3.$indexSet(a, k, t3.$index(a, less));
            t3.$indexSet(a, less, ak);
          }
          less = J.$add$ns(less, 1);
        } else
          for (; true;) {
            comp = compare.call$2(t3.$index(a, great), el2);
            t2 = J.getInterceptor$n(comp);
            if (t2.$gt(comp, 0)) {
              great = J.$sub$n(great, 1);
              continue;
            } else {
              t4 = J.getInterceptor$n(great);
              if (t2.$lt(comp, 0)) {
                t3.$indexSet(a, k, t3.$index(a, less));
                less0 = J.$add$ns(less, 1);
                t3.$indexSet(a, less, t3.$index(a, great));
                great0 = t4.$sub(great, 1);
                t3.$indexSet(a, great, ak);
                great = great0;
                less = less0;
                break;
              } else {
                t3.$indexSet(a, k, t3.$index(a, great));
                great0 = t4.$sub(great, 1);
                t3.$indexSet(a, great, ak);
                great = great0;
                break;
              }
            }
          }
      }
      pivots_are_equal = true;
    } else {
      for (k = less; t1 = J.getInterceptor$n(k), t1.$le(k, great); k = t1.$add(k, 1)) {
        ak = t3.$index(a, k);
        if (J.$lt$n(compare.call$2(ak, el2), 0)) {
          if (!t1.$eq(k, less)) {
            t3.$indexSet(a, k, t3.$index(a, less));
            t3.$indexSet(a, less, ak);
          }
          less = J.$add$ns(less, 1);
        } else if (J.$gt$n(compare.call$2(ak, el4), 0))
          for (; true;)
            if (J.$gt$n(compare.call$2(t3.$index(a, great), el4), 0)) {
              great = J.$sub$n(great, 1);
              if (J.$lt$n(great, k))
                break;
              continue;
            } else {
              t2 = J.getInterceptor$n(great);
              if (J.$lt$n(compare.call$2(t3.$index(a, great), el2), 0)) {
                t3.$indexSet(a, k, t3.$index(a, less));
                less0 = J.$add$ns(less, 1);
                t3.$indexSet(a, less, t3.$index(a, great));
                great0 = t2.$sub(great, 1);
                t3.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t3.$indexSet(a, k, t3.$index(a, great));
                great0 = t2.$sub(great, 1);
                t3.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      pivots_are_equal = false;
    }
    t1 = J.getInterceptor$n(less);
    t3.$indexSet(a, left, t3.$index(a, t1.$sub(less, 1)));
    t3.$indexSet(a, t1.$sub(less, 1), el2);
    t2 = J.getInterceptor$ns(great);
    t3.$indexSet(a, right, t3.$index(a, t2.$add(great, 1)));
    t3.$indexSet(a, t2.$add(great, 1), el4);
    H.Sort__doSort(a, left, t1.$sub(less, 2), compare);
    H.Sort__doSort(a, t2.$add(great, 2), right, compare);
    if (pivots_are_equal)
      return;
    if (t1.$lt(less, index1) && t2.$gt(great, index5)) {
      for (; J.$eq(compare.call$2(t3.$index(a, less), el2), 0);)
        less = J.$add$ns(less, 1);
      for (; J.$eq(compare.call$2(t3.$index(a, great), el4), 0);)
        great = J.$sub$n(great, 1);
      for (k = less; t1 = J.getInterceptor$n(k), t1.$le(k, great); k = t1.$add(k, 1)) {
        ak = t3.$index(a, k);
        if (J.$eq(compare.call$2(ak, el2), 0)) {
          if (!t1.$eq(k, less)) {
            t3.$indexSet(a, k, t3.$index(a, less));
            t3.$indexSet(a, less, ak);
          }
          less = J.$add$ns(less, 1);
        } else if (J.$eq(compare.call$2(ak, el4), 0))
          for (; true;)
            if (J.$eq(compare.call$2(t3.$index(a, great), el4), 0)) {
              great = J.$sub$n(great, 1);
              if (J.$lt$n(great, k))
                break;
              continue;
            } else {
              t2 = J.getInterceptor$n(great);
              if (J.$lt$n(compare.call$2(t3.$index(a, great), el2), 0)) {
                t3.$indexSet(a, k, t3.$index(a, less));
                less0 = J.$add$ns(less, 1);
                t3.$indexSet(a, less, t3.$index(a, great));
                great0 = t2.$sub(great, 1);
                t3.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t3.$indexSet(a, k, t3.$index(a, great));
                great0 = t2.$sub(great, 1);
                t3.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      H.Sort__doSort(a, less, great, compare);
    } else
      H.Sort__doSort(a, less, great, compare);
  },
  ListIterable: {
    "^": "IterableBase;",
    get$iterator: function(_) {
      return H.setRuntimeTypeInfo(new H.ListIterator(this, this.get$length(this), 0, null), [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
    },
    forEach$1: function(_, action) {
      var $length, i;
      $length = this.get$length(this);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        action.call$1(this.elementAt$1(0, i));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return J.$eq(this.get$length(this), 0);
    },
    get$first: function(_) {
      if (J.$eq(this.get$length(this), 0))
        throw H.wrapException(H.IterableElementError_noElement());
      return this.elementAt$1(0, 0);
    },
    get$last: function(_) {
      if (J.$eq(this.get$length(this), 0))
        throw H.wrapException(H.IterableElementError_noElement());
      return this.elementAt$1(0, J.$sub$n(this.get$length(this), 1));
    },
    contains$1: [function(_, element) {
      var $length, i;
      $length = this.get$length(this);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        if (J.$eq(this.elementAt$1(0, i), element))
          return true;
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return false;
    }, "call$1", "get$contains", 2, 0, 1693],
    any$1: [function(_, test) {
      var $length, i;
      $length = this.get$length(this);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        if (test.call$1(this.elementAt$1(0, i)) === true)
          return true;
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return false;
    }, "call$1", "get$any", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__bool__E0", ret: P.bool, args: [{func: "bool__E0", ret: P.bool, args: [E]}]};
      }, this.$receiver, "ListIterable");
    }],
    firstWhere$2$orElse: function(_, test, orElse) {
      var $length, i, element;
      $length = this.get$length(this);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        element = this.elementAt$1(0, i);
        if (test.call$1(element) === true)
          return element;
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return orElse.call$0();
    },
    join$1: function(_, separator) {
      var $length, t1, first, buffer, i, str;
      $length = this.get$length(this);
      if (separator.length !== 0) {
        t1 = J.getInterceptor($length);
        if (t1.$eq($length, 0))
          return "";
        first = H.S(this.elementAt$1(0, 0));
        if (!t1.$eq($length, this.get$length(this)))
          throw H.wrapException(P.ConcurrentModificationError$(this));
        buffer = P.StringBuffer$(first);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 1;
        for (; i < $length; ++i) {
          buffer._contents += separator;
          str = this.elementAt$1(0, i);
          buffer._contents += typeof str === "string" ? str : H.S(str);
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      } else {
        buffer = P.StringBuffer$("");
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          str = this.elementAt$1(0, i);
          buffer._contents += typeof str === "string" ? str : H.S(str);
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
    },
    where$1: function(_, test) {
      return P.IterableBase.prototype.where$1.call(this, this, test);
    },
    map$1: [function(_, f) {
      return H.setRuntimeTypeInfo(new H.MappedListIterable(this, f), [null, null]);
    }, "call$1", "get$map", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "Iterable__dynamic__E0", ret: P.Iterable, args: [{func: "dynamic__E0", args: [E]}]};
      }, this.$receiver, "ListIterable");
    }],
    fold$2: function(_, initialValue, combine) {
      var $length, value, i;
      $length = this.get$length(this);
      if (typeof $length !== "number")
        return H.iae($length);
      value = initialValue;
      i = 0;
      for (; i < $length; ++i) {
        value = combine.call$2(value, this.elementAt$1(0, i));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return value;
    },
    toList$1$growable: function(_, growable) {
      var result, t1, i;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
      } else {
        t1 = this.get$length(this);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = Array(t1);
        t1.fixed$length = init;
        result = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
      }
      i = 0;
      while (true) {
        t1 = this.get$length(this);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        t1 = this.elementAt$1(0, i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
        ++i;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    $isEfficientLength: true
  },
  SubListIterable: {
    "^": "ListIterable;_iterable,__internal$_start,_endOrLength",
    get$_endIndex: function() {
      var $length, t1;
      $length = J.get$length$asx(this._iterable);
      t1 = this._endOrLength;
      if (t1 == null || J.$gt$n(t1, $length))
        return $length;
      return t1;
    },
    get$_startIndex: function() {
      var $length, t1;
      $length = J.get$length$asx(this._iterable);
      t1 = this.__internal$_start;
      if (J.$gt$n(t1, $length))
        return $length;
      return t1;
    },
    get$length: function(_) {
      var $length, t1, t2;
      $length = J.get$length$asx(this._iterable);
      t1 = this.__internal$_start;
      if (J.$ge$n(t1, $length))
        return 0;
      t2 = this._endOrLength;
      if (t2 == null || J.$ge$n(t2, $length))
        return J.$sub$n($length, t1);
      return J.$sub$n(t2, t1);
    },
    elementAt$1: function(_, index) {
      var realIndex = J.$add$ns(this.get$_startIndex(), index);
      if (J.$lt$n(index, 0) || J.$ge$n(realIndex, this.get$_endIndex()))
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this), null, null));
      return J.elementAt$1$ax(this._iterable, realIndex);
    },
    take$1: function(_, count) {
      var t1, t2, newEnd;
      if (J.$lt$n(count, 0))
        throw H.wrapException(P.RangeError$value(count, null, null));
      t1 = this._endOrLength;
      t2 = this.__internal$_start;
      if (t1 == null)
        return H.SubListIterable$(this._iterable, t2, J.$add$ns(t2, count), H.getTypeArgumentByIndex(this, 0));
      else {
        newEnd = J.$add$ns(t2, count);
        if (J.$lt$n(t1, newEnd))
          return this;
        return H.SubListIterable$(this._iterable, t2, newEnd, H.getTypeArgumentByIndex(this, 0));
      }
    },
    toList$1$growable: function(_, growable) {
      var start, t1, t2, end, end0, $length, result, t3, i, t4;
      start = this.__internal$_start;
      t1 = this._iterable;
      t2 = J.getInterceptor$asx(t1);
      end = t2.get$length(t1);
      end0 = this._endOrLength;
      if (end0 != null && J.$lt$n(end0, end))
        end = end0;
      $length = J.$sub$n(end, start);
      if (J.$lt$n($length, 0))
        $length = 0;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
        C.JSArray_methods.set$length(result, $length);
      } else {
        if (typeof $length !== "number")
          return H.iae($length);
        t3 = Array($length);
        t3.fixed$length = init;
        result = H.setRuntimeTypeInfo(t3, [H.getTypeArgumentByIndex(this, 0)]);
      }
      if (typeof $length !== "number")
        return H.iae($length);
      t3 = J.getInterceptor$ns(start);
      i = 0;
      for (; i < $length; ++i) {
        t4 = t2.elementAt$1(t1, t3.$add(start, i));
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t4;
        if (J.$lt$n(t2.get$length(t1), end))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    SubListIterable$3: function(_iterable, _start, _endOrLength, $E) {
      var t1, t2, t3;
      t1 = this.__internal$_start;
      t2 = J.getInterceptor$n(t1);
      if (t2.$lt(t1, 0))
        throw H.wrapException(P.RangeError$value(t1, null, null));
      t3 = this._endOrLength;
      if (t3 != null) {
        if (J.$lt$n(t3, 0))
          throw H.wrapException(P.RangeError$value(t3, null, null));
        if (t2.$gt(t1, t3))
          throw H.wrapException(P.RangeError$range(t1, 0, t3, null, null));
      }
    },
    static: {SubListIterable$: function(_iterable, _start, _endOrLength, $E) {
        var t1 = H.setRuntimeTypeInfo(new H.SubListIterable(_iterable, _start, _endOrLength), [$E]);
        t1.SubListIterable$3(_iterable, _start, _endOrLength, $E);
        return t1;
      }}
  },
  ListIterator: {
    "^": "Object;_iterable,__internal$_length,_index,__internal$_current",
    get$current: function() {
      return this.__internal$_current;
    },
    moveNext$0: function() {
      var t1, t2, $length, t3;
      t1 = this._iterable;
      t2 = J.getInterceptor$asx(t1);
      $length = t2.get$length(t1);
      if (!J.$eq(this.__internal$_length, $length))
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t3 = this._index;
      if (typeof $length !== "number")
        return H.iae($length);
      if (t3 >= $length) {
        this.__internal$_current = null;
        return false;
      }
      this.__internal$_current = t2.elementAt$1(t1, t3);
      ++this._index;
      return true;
    }
  },
  MappedIterable: {
    "^": "IterableBase;_iterable,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    get$iterator: function(_) {
      var t1 = new H.MappedIterator(null, J.get$iterator$ax(this._iterable), this._f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$length: function(_) {
      return J.get$length$asx(this._iterable);
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this._iterable);
    },
    get$last: function(_) {
      return this._f$1(J.get$last$ax(this._iterable));
    },
    elementAt$1: function(_, index) {
      return this._f$1(J.elementAt$1$ax(this._iterable, index));
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    static: {MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
        if (!!J.getInterceptor(iterable).$isEfficientLength)
          return H.setRuntimeTypeInfo(new H.EfficientLengthMappedIterable(iterable, $function), [$S, $T]);
        return H.setRuntimeTypeInfo(new H.MappedIterable(iterable, $function), [$S, $T]);
      }}
  },
  EfficientLengthMappedIterable: {
    "^": "MappedIterable;_iterable,_f",
    $isEfficientLength: true
  },
  MappedIterator: {
    "^": "Iterator;__internal$_current,_iterator,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      var t1 = this._iterator;
      if (t1.moveNext$0()) {
        this.__internal$_current = this._f$1(t1.get$current());
        return true;
      }
      this.__internal$_current = null;
      return false;
    },
    get$current: function() {
      return this.__internal$_current;
    },
    $asIterator: function($S, $T) {
      return [$T];
    }
  },
  MappedListIterable: {
    "^": "ListIterable;_source,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      return this._f$1(J.elementAt$1$ax(this._source, index));
    },
    $asListIterable: function($S, $T) {
      return [$T];
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $isEfficientLength: true
  },
  WhereIterable: {
    "^": "IterableBase;_iterable,_f",
    get$iterator: function(_) {
      var t1 = new H.WhereIterator(J.get$iterator$ax(this._iterable), this._f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    }
  },
  WhereIterator: {
    "^": "Iterator;_iterator,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      for (var t1 = this._iterator; t1.moveNext$0();)
        if (this._f$1(t1.get$current()) === true)
          return true;
      return false;
    },
    get$current: function() {
      return this._iterator.get$current();
    }
  },
  IterableMixinWorkaround: {
    "^": "Object;",
    static: {IterableMixinWorkaround_any: function(iterable, f) {
        var t1;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();)
          if (f.call$1(t1.__internal$_current) === true)
            return true;
        return false;
      }, IterableMixinWorkaround_every: function(iterable, f) {
        var t1;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();)
          if (f.call$1(t1.__internal$_current) !== true)
            return false;
        return true;
      }, IterableMixinWorkaround_fold: function(iterable, initialValue, combine) {
        var t1;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();)
          initialValue = combine.call$2(initialValue, t1.__internal$_current);
        return initialValue;
      }, IterableMixinWorkaround_firstWhere: function(iterable, test, orElse) {
        var t1, element;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();) {
          element = t1.__internal$_current;
          if (test.call$1(element) === true)
            return element;
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, IterableMixinWorkaround_shuffleList: function(list, random) {
        var $length, pos, t1, tmp;
        $length = list.length;
        for (; $length > 1;) {
          pos = C.C__JSRandom.nextInt$1($length);
          --$length;
          t1 = list.length;
          if ($length >= t1)
            return H.ioore(list, $length);
          tmp = list[$length];
          if (pos < 0 || pos >= t1)
            return H.ioore(list, pos);
          C.JSArray_methods.$indexSet(list, $length, list[pos]);
          C.JSArray_methods.$indexSet(list, pos, tmp);
        }
      }, IterableMixinWorkaround__rangeCheck: function(list, start, end) {
        var t1 = J.getInterceptor$n(start);
        if (t1.$lt(start, 0) || t1.$gt(start, list.length))
          throw H.wrapException(P.RangeError$range(start, 0, list.length, null, null));
        t1 = J.getInterceptor$n(end);
        if (t1.$lt(end, start) || t1.$gt(end, list.length))
          throw H.wrapException(P.RangeError$range(end, start, list.length, null, null));
      }, IterableMixinWorkaround_setRangeList: function(list, start, end, from, skipCount) {
        var $length, t1;
        H.IterableMixinWorkaround__rangeCheck(list, start, end);
        $length = J.$sub$n(end, start);
        if (J.$eq($length, 0))
          return;
        if (skipCount < 0)
          throw H.wrapException(P.ArgumentError$(skipCount));
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = J.get$length$asx(from);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (skipCount + $length > t1)
          throw H.wrapException(H.IterableElementError_tooFew());
        H.Lists_copy(from, skipCount, list, start, $length);
      }, IterableMixinWorkaround_insertAllList: function(list, index, iterable) {
        var t1, index0;
        if (index > list.length)
          throw H.wrapException(P.RangeError$range(index, 0, list.length, null, null));
        C.JSArray_methods.set$length(list, list.length + 2);
        t1 = list.length;
        C.JSArray_methods.checkMutable$1(list, "set range");
        H.IterableMixinWorkaround_setRangeList(list, index + 2, t1, list, index);
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, 2, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0(); index = index0) {
          index0 = index + 1;
          C.JSArray_methods.$indexSet(list, index, t1.__internal$_current);
        }
      }}
  },
  FixedLengthListMixin: {
    "^": "Object;",
    set$length: function(receiver, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of a fixed-length list"));
    },
    add$1: [function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E0", void: true, args: [E]};
      }, this.$receiver, "FixedLengthListMixin");
    }, 138, []],
    insert$2: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    },
    addAll$1: function(receiver, iterable) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    },
    remove$1: function(receiver, element) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    },
    clear$0: function(receiver) {
      throw H.wrapException(P.UnsupportedError$("Cannot clear a fixed-length list"));
    },
    removeAt$1: function(receiver, index) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    },
    removeLast$0: function(receiver) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    },
    removeRange$2: function(receiver, start, end) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    }
  },
  UnmodifiableListMixin: {
    "^": "Object;",
    $indexSet: function(_, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of an unmodifiable list"));
    },
    add$1: [function(_, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E1", void: true, args: [E]};
      }, this.$receiver, "UnmodifiableListMixin");
    }, 138, []],
    insert$2: function(_, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
    },
    addAll$1: function(_, iterable) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
    },
    remove$1: function(_, element) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    clear$0: function(_) {
      throw H.wrapException(P.UnsupportedError$("Cannot clear an unmodifiable list"));
    },
    removeAt$1: function(_, index) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    removeLast$0: function(_) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    removeRange$2: function(_, start, end) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  UnmodifiableListBase: {
    "^": "ListBase+UnmodifiableListMixin;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  ReversedListIterable: {
    "^": "ListIterable;_source",
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      var t1, t2;
      t1 = this._source;
      t2 = J.getInterceptor$asx(t1);
      return t2.elementAt$1(t1, J.$sub$n(J.$sub$n(t2.get$length(t1), 1), index));
    }
  },
  Symbol: {
    "^": "Object;_name<",
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isSymbol && J.$eq(this._name, other._name);
    },
    get$hashCode: function(_) {
      var t1 = J.get$hashCode$(this._name);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 536870911 & 664597 * t1;
    },
    toString$0: function(_) {
      return "Symbol(\"" + H.S(this._name) + "\")";
    },
    $isSymbol: true,
    $isSymbol0: true,
    static: {"^": "Symbol_reservedWordRE,Symbol_publicIdentifierRE,Symbol_identifierRE,Symbol_operatorRE,Symbol_publicSymbolPattern,Symbol_symbolPattern", Symbol_validatePublicSymbol: function($name) {
        var t1 = J.getInterceptor$asx($name);
        if (t1.get$isEmpty($name) === true || $.get$Symbol_publicSymbolPattern()._nativeRegExp.test(H.checkString($name)))
          return $name;
        if (t1.startsWith$1($name, "_"))
          throw H.wrapException(P.ArgumentError$("\"" + H.S($name) + "\" is a private identifier"));
        throw H.wrapException(P.ArgumentError$("\"" + H.S($name) + "\" is not a valid (qualified) symbol name"));
      }}
  }
}],
["dart._js_mirrors", "dart:_js_mirrors", , H, {
  "^": "",
  n: function(symbol) {
    return symbol.get$_name();
  },
  s: function($name) {
    if ($name == null)
      return;
    return new H.Symbol($name);
  },
  reflect: [function(reflectee) {
    if (!!J.getInterceptor(reflectee).$isClosure)
      return new H.JsClosureMirror(reflectee, 4);
    else
      return new H.JsInstanceMirror(reflectee, 4);
  }, "call$1", "reflect$closure", 2, 0, 593, 594, []],
  reflectClassByMangledName: function(mangledName) {
    var unmangledName, t1;
    unmangledName = $.get$mangledGlobalNames().$index(0, mangledName);
    t1 = J.getInterceptor(mangledName);
    if (t1.$eq(mangledName, "dynamic"))
      return $.get$JsMirrorSystem__dynamicType();
    if (t1.$eq(mangledName, "void"))
      return $.get$JsMirrorSystem__voidType();
    return H.reflectClassByName(H.s(unmangledName == null ? mangledName : unmangledName), mangledName);
  },
  reflectClassByName: function(symbol, mangledName) {
    var t1, mirror, typeArgIndex, t2, originalDeclaration, $constructor, descriptor, fields, fieldsMetadata, mixins, classMirror, typeVariables, typeArguments, i;
    t1 = $.classMirrors;
    if (t1 == null) {
      t1 = H.JsCache_allocate();
      $.classMirrors = t1;
    }
    mirror = t1[mangledName];
    if (mirror != null)
      return mirror;
    t1 = J.getInterceptor$asx(mangledName);
    typeArgIndex = t1.indexOf$1(mangledName, "<");
    t2 = J.getInterceptor(typeArgIndex);
    if (!t2.$eq(typeArgIndex, -1)) {
      originalDeclaration = H.reflectClassByMangledName(t1.substring$2(mangledName, 0, typeArgIndex)).get$originalDeclaration();
      if (!!originalDeclaration.$isJsTypedefMirror)
        throw H.wrapException(P.UnimplementedError$(null));
      mirror = new H.JsTypeBoundClassMirror(originalDeclaration, t1.substring$2(mangledName, t2.$add(typeArgIndex, 1), J.$sub$n(t1.get$length(mangledName), 1)), null, null, null, null, null, null, null, null, null, null, null, null, null, originalDeclaration.get$simpleName());
      $.classMirrors[mangledName] = mirror;
      return mirror;
    }
    $constructor = init.allClasses[mangledName];
    if ($constructor == null)
      throw H.wrapException(P.UnsupportedError$("Cannot find class for: " + H.S(H.n(symbol))));
    descriptor = $constructor["@"];
    if (descriptor == null) {
      fields = null;
      fieldsMetadata = null;
    } else {
      fields = descriptor["^"];
      t1 = J.getInterceptor(fields);
      if (!!t1.$isList) {
        fieldsMetadata = t1.getRange$2(fields, 1, t1.get$length(fields)).toList$0(0);
        fields = t1.$index(fields, 0);
      } else
        fieldsMetadata = null;
      if (typeof fields !== "string")
        fields = "";
    }
    t1 = J.getInterceptor$s(fields);
    if (t1.startsWith$1(fields, ":")) {
      mirror = new H.JsTypedefMirror(mangledName, null, symbol);
      mirror.referent = new H.JsFunctionTypeMirror(H.getMetadata(H.Primitives_parseInt(t1.substring$2(fields, 1, t1.get$length(fields) - 1), null, null)), null, null, null, mirror);
    } else {
      t1 = t1.split$1(fields, ";");
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      mixins = J.split$1$s(t1[0], "+");
      if (mixins.length > 1 && $.get$mangledGlobalNames().$index(0, mangledName) == null)
        mirror = H.reflectMixinApplication(mixins, mangledName);
      else {
        classMirror = new H.JsClassMirror(mangledName, $constructor, fields, fieldsMetadata, H.JsCache_allocate(), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, symbol);
        typeVariables = $constructor.prototype["<>"];
        if (typeVariables == null || typeVariables.length === 0)
          mirror = classMirror;
        else {
          for (t1 = typeVariables.length, typeArguments = "dynamic", i = 1; i < t1; ++i)
            typeArguments += ",dynamic";
          mirror = new H.JsTypeBoundClassMirror(classMirror, typeArguments, null, null, null, null, null, null, null, null, null, null, null, null, null, classMirror.simpleName);
        }
      }
    }
    $.classMirrors[mangledName] = mirror;
    return mirror;
  },
  filterConstructors: function(methods) {
    var result, t1, method;
    result = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(methods, methods.length, 0, null), [H.getTypeArgumentByIndex(methods, 0)]); t1.moveNext$0();) {
      method = t1.__internal$_current;
      if (method.get$isConstructor())
        result.$indexSet(0, method.get$simpleName(), method);
    }
    return result;
  },
  reflectMixinApplication: function(mixinNames, mangledName) {
    var mixins, t1, it, superclass;
    mixins = [];
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(mixinNames, mixinNames.length, 0, null), [H.getTypeArgumentByIndex(mixinNames, 0)]); t1.moveNext$0();)
      mixins.push(H.reflectClassByMangledName(t1.__internal$_current));
    it = H.setRuntimeTypeInfo(new H.ListIterator(mixins, mixins.length, 0, null), [H.getTypeArgumentByIndex(mixins, 0)]);
    it.moveNext$0();
    superclass = it.__internal$_current;
    for (; it.moveNext$0();)
      superclass = new H.JsMixinApplication(superclass, it.__internal$_current, null, null, H.s(mangledName));
    return superclass;
  },
  findTypeVariableIndex: function(typeVariables, $name) {
    var t1, i, t2;
    t1 = J.getInterceptor$asx(typeVariables);
    i = 0;
    while (true) {
      t2 = t1.get$length(typeVariables);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (!(i < t2))
        break;
      if (J.$eq(t1.$index(typeVariables, i).get$simpleName(), H.s($name)))
        return i;
      ++i;
    }
    throw H.wrapException(P.ArgumentError$("Type variable not present in list."));
  },
  typeMirrorFromRuntimeTypeRepresentation: function(owner, type) {
    var t1, context, t2, representation, typeVariable, typeVariables, typeArgument;
    t1 = {};
    t1.ownerClass_0 = null;
    for (context = owner; context != null;) {
      t2 = J.getInterceptor(context);
      if (!!t2.$isClassMirror) {
        t1.ownerClass_0 = context;
        break;
      }
      if (!!t2.$isTypedefMirror)
        break;
      context = context.get$owner();
    }
    if (type == null)
      return $.get$JsMirrorSystem__dynamicType();
    else if (!!J.getInterceptor(type).$isTypeImpl)
      return H.reflectClassByMangledName(type._typeName);
    else {
      t2 = t1.ownerClass_0;
      if (t2 == null)
        representation = H.runtimeTypeToString(type, null);
      else if (t2.get$isOriginalDeclaration())
        if (typeof type === "number") {
          typeVariable = H.getMetadata(type);
          typeVariables = t1.ownerClass_0.get$typeVariables();
          return J.$index$asx(typeVariables, H.findTypeVariableIndex(typeVariables, J.get$name$x(typeVariable)));
        } else
          representation = H.runtimeTypeToString(type, null);
      else {
        t1 = new H.typeMirrorFromRuntimeTypeRepresentation_getTypeArgument(t1);
        if (typeof type === "number") {
          typeArgument = t1.call$1(type);
          if (!!J.getInterceptor(typeArgument).$isJsTypeVariableMirror)
            return typeArgument;
        }
        representation = H.runtimeTypeToString(type, new H.typeMirrorFromRuntimeTypeRepresentation_substituteTypeVariable(t1));
      }
    }
    if (representation != null)
      return H.reflectClassByMangledName(representation);
    if (type.typedef != null)
      return H.typeMirrorFromRuntimeTypeRepresentation(owner, type.typedef);
    else if (type.func != null)
      return new H.JsFunctionTypeMirror(type, null, null, null, owner);
    return P.reflectClass(C.Type_EjN);
  },
  computeQualifiedName: function(owner, simpleName) {
    if (owner == null)
      return simpleName;
    return H.s(H.S(owner.get$qualifiedName()._name) + "." + H.S(simpleName._name));
  },
  extractMetadata: function(victim) {
    var metadataFunction, t1;
    metadataFunction = Object.prototype.hasOwnProperty.call(victim, "@") ? victim["@"] : null;
    if (metadataFunction != null)
      return metadataFunction();
    if (typeof victim != "function")
      return C.List_empty;
    if ("$metadataIndex" in victim) {
      t1 = victim.$reflectionInfo.splice(victim.$metadataIndex);
      t1.fixed$length = Array;
      return H.setRuntimeTypeInfo(new H.MappedListIterable(t1, new H.extractMetadata_closure()), [null, null]).toList$0(0);
    }
    return C.List_empty;
  },
  isOperatorName: function($name) {
    switch ($name) {
      case "==":
      case "[]":
      case "*":
      case "/":
      case "%":
      case "~/":
      case "+":
      case "<<":
      case ">>":
      case ">=":
      case ">":
      case "<=":
      case "<":
      case "&":
      case "^":
      case "|":
      case "-":
      case "unary-":
      case "[]=":
      case "~":
        return true;
      default:
        return false;
    }
  },
  isReflectiveDataInPrototype: function(key) {
    var t1, firstChar;
    t1 = J.getInterceptor(key);
    if (t1.$eq(key, "^") || t1.$eq(key, "$methodsWithOptionalArguments"))
      return true;
    firstChar = t1.$index(key, 0);
    t1 = J.getInterceptor(firstChar);
    return t1.$eq(firstChar, "*") || t1.$eq(firstChar, "+");
  },
  JsMirrorSystem: {
    "^": "Object;_cachedLibraries,isolate",
    static: {"^": "JsMirrorSystem__dynamicType,JsMirrorSystem__voidType,JsMirrorSystem__librariesByName,JsMirrorSystem__hasInstalledDeferredLoadHook", JsMirrorSystem_librariesByName: function() {
        var t1 = $.JsMirrorSystem__librariesByName;
        if (t1 == null) {
          t1 = H.JsMirrorSystem_computeLibrariesByName();
          $.JsMirrorSystem__librariesByName = t1;
          if (!$.JsMirrorSystem__hasInstalledDeferredLoadHook) {
            $.JsMirrorSystem__hasInstalledDeferredLoadHook = true;
            $.deferredLoadHook = new H.JsMirrorSystem_librariesByName_closure();
          }
        }
        return t1;
      }, JsMirrorSystem_computeLibrariesByName: function() {
        var result, jsLibraries, t1, data, t2, $name, uriString, uri, t3, scheme, userInfo, host, query, fragment, port, isFile, classes, functions, metadataFunction, fields, isRoot, globalObject, metadata;
        result = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.List, P.LibraryMirror]);
        jsLibraries = init.libraries;
        if (jsLibraries == null)
          return result;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(jsLibraries, jsLibraries.length, 0, null), [H.getTypeArgumentByIndex(jsLibraries, 0)]); t1.moveNext$0();) {
          data = t1.__internal$_current;
          t2 = J.getInterceptor$asx(data);
          $name = t2.$index(data, 0);
          uriString = t2.$index(data, 1);
          if (!J.$eq(uriString, ""))
            uri = P.Uri_parse(uriString);
          else {
            t3 = P.LinkedHashMap_LinkedHashMap$_literal(["lib", $name], null, null);
            scheme = P.Uri__makeScheme("https", 5);
            userInfo = P.Uri__makeUserInfo("", 0, 0);
            host = P.Uri__makeHost("dartlang.org", 0, 12, false);
            query = P.Uri__makeQuery(null, 0, 0, t3);
            fragment = P.Uri__makeFragment(null, 0, 0);
            port = P.Uri__makePort(null, scheme);
            isFile = scheme === "file";
            if (host == null)
              t3 = J.get$isNotEmpty$asx(userInfo) || port != null || isFile;
            else
              t3 = false;
            if (t3)
              host = "";
            uri = new P.Uri(host, port, P.Uri__makePath("dart2js-stripped-uri", 0, 20, null, host != null, isFile), scheme, userInfo, query, fragment, null, null);
          }
          classes = t2.$index(data, 2);
          functions = t2.$index(data, 3);
          metadataFunction = t2.$index(data, 4);
          fields = t2.$index(data, 5);
          isRoot = t2.$index(data, 6);
          globalObject = t2.$index(data, 7);
          metadata = metadataFunction == null ? C.List_empty : metadataFunction();
          J.add$1$ax(result.putIfAbsent$2(0, $name, new H.JsMirrorSystem_computeLibrariesByName_closure()), new H.JsLibraryMirror(uri, classes, functions, metadata, fields, isRoot, globalObject, null, null, null, null, null, null, null, null, null, null, H.s($name)));
        }
        return result;
      }}
  },
  JsMirrorSystem_librariesByName_closure: {
    "^": "Closure:54;",
    call$0: function() {
      $.JsMirrorSystem__librariesByName = null;
      return;
    }
  },
  JsMirrorSystem_computeLibrariesByName_closure: {
    "^": "Closure:54;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [P.LibraryMirror]);
    }
  },
  JsMirror: {
    "^": "Object;",
    toString$0: function(_) {
      return this.get$_prettyName();
    }
  },
  JsIsolateMirror: {
    "^": "JsMirror;_isolateContext",
    get$_prettyName: function() {
      return "Isolate";
    }
  },
  JsDeclarationMirror: {
    "^": "JsMirror;simpleName<",
    get$qualifiedName: function() {
      return H.computeQualifiedName(this.get$owner(), this.get$simpleName());
    },
    toString$0: function(_) {
      return this.get$_prettyName() + " on '" + H.S(this.get$simpleName()._name) + "'";
    },
    _invoke$2: function(positionalArguments, namedArguments) {
      throw H.wrapException(H.RuntimeError$("Should not call _invoke"));
    }
  },
  JsTypeVariableMirror: {
    "^": "JsTypeMirror;owner<,_typeVariable,_metadataIndex,_cachedUpperBound,simpleName",
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isJsTypeVariableMirror && J.$eq(this.simpleName, other.simpleName) && this.owner.$eq(0, other.owner);
    },
    get$hashCode: function(_) {
      var t1, t2;
      t1 = J.get$hashCode$(C.Type_AGr._typeName);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = this.owner;
      return (1073741823 & t1 ^ 17 * J.get$hashCode$(this.simpleName) ^ 19 * t2.get$hashCode(t2)) >>> 0;
    },
    get$_prettyName: function() {
      return "TypeVariableMirror";
    },
    get$upperBound: function(_) {
      var t1 = this._cachedUpperBound;
      if (t1 != null)
        return t1;
      t1 = H.typeMirrorFromRuntimeTypeRepresentation(this.owner, H.getMetadata(J.get$bound$x(this._typeVariable)));
      this._cachedUpperBound = t1;
      return t1;
    },
    _asRuntimeType$0: function() {
      return this._metadataIndex;
    },
    $isJsTypeVariableMirror: true,
    $isTypeVariableMirror: true,
    $isTypeMirror: true
  },
  JsTypeMirror: {
    "^": "JsDeclarationMirror;simpleName",
    get$_prettyName: function() {
      return "TypeMirror";
    },
    get$owner: function() {
      return;
    },
    get$typeVariables: function() {
      return C.List_empty0;
    },
    get$typeArguments: function() {
      return C.List_empty1;
    },
    get$isOriginalDeclaration: function() {
      return true;
    },
    get$originalDeclaration: function() {
      return this;
    },
    _asRuntimeType$0: [function() {
      if (this.$eq(0, $.get$JsMirrorSystem__dynamicType()))
        return;
      if (this.$eq(0, $.get$JsMirrorSystem__voidType()))
        return;
      throw H.wrapException(H.RuntimeError$("Should not call _asRuntimeType"));
    }, "call$0", "get$_asRuntimeType", 0, 0, 54],
    $isTypeMirror: true
  },
  JsLibraryMirror: {
    "^": "JsDeclarationMirror_JsObjectMirror;_uri,_classes,_functions,_metadata,_compactFieldSpecification,_isRoot,_globalObject,_cachedFunctionMirrors,_cachedFields,_cachedClasses,_cachedFunctions,_cachedGetters,_cachedSetters,_cachedVariables,_cachedMembers,_cachedDeclarations,_cachedMetadata,simpleName",
    get$_prettyName: function() {
      return "LibraryMirror";
    },
    get$qualifiedName: function() {
      return this.simpleName;
    },
    get$__classes: function() {
      var t1, result, cls, t2;
      t1 = this._cachedClasses;
      if (t1 != null)
        return t1;
      result = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      for (t1 = J.get$iterator$ax(this._classes); t1.moveNext$0();) {
        cls = H.reflectClassByMangledName(t1.get$current());
        if (!!J.getInterceptor(cls).$isClassMirror)
          cls = cls.get$originalDeclaration();
        t2 = J.getInterceptor(cls);
        if (!!t2.$isJsClassMirror) {
          result.$indexSet(0, cls.simpleName, cls);
          cls._owner = this;
        } else if (!!t2.$isJsTypedefMirror)
          result.$indexSet(0, cls.simpleName, cls);
      }
      t1 = H.setRuntimeTypeInfo(new P.UnmodifiableMapView(result), [P.Symbol0, P.ClassMirror]);
      this._cachedClasses = t1;
      return t1;
    },
    get$owner: function() {
      return;
    },
    $isLibraryMirror: true
  },
  JsDeclarationMirror_JsObjectMirror: {
    "^": "JsDeclarationMirror+JsObjectMirror;"
  },
  JsMixinApplication: {
    "^": "JsTypeMirror_JsObjectMirror;superclass,mixin,_cachedSimpleName,_cachedInstanceMembers,simpleName",
    get$_prettyName: function() {
      return "ClassMirror";
    },
    get$simpleName: function() {
      var t1, superName;
      t1 = this._cachedSimpleName;
      if (t1 != null)
        return t1;
      superName = this.superclass.get$qualifiedName()._name;
      t1 = this.mixin;
      t1 = J.contains$1$asx(superName, " with ") === true ? H.s(H.S(superName) + ", " + H.S(t1.get$qualifiedName()._name)) : H.s(H.S(superName) + " with " + H.S(t1.get$qualifiedName()._name));
      this._cachedSimpleName = t1;
      return t1;
    },
    get$qualifiedName: function() {
      return this.get$simpleName();
    },
    _asRuntimeType$0: function() {
      return;
    },
    newInstance$3: function(constructorName, positionalArguments, namedArguments) {
      throw H.wrapException(P.UnsupportedError$("Can't instantiate mixin application '" + H.S(H.n(this.get$qualifiedName())) + "'"));
    },
    newInstance$2: function(constructorName, positionalArguments) {
      return this.newInstance$3(constructorName, positionalArguments, null);
    },
    get$isOriginalDeclaration: function() {
      return true;
    },
    get$originalDeclaration: function() {
      return this;
    },
    get$typeVariables: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    get$typeArguments: function() {
      return C.List_empty1;
    },
    $isClassMirror: true,
    $isTypeMirror: true
  },
  JsTypeMirror_JsObjectMirror: {
    "^": "JsTypeMirror+JsObjectMirror;"
  },
  JsObjectMirror: {
    "^": "Object;"
  },
  JsInstanceMirror: {
    "^": "JsObjectMirror;reflectee<,_getterCache",
    get$type: function(_) {
      var t1 = this.reflectee;
      if (t1 == null)
        return P.reflectClass(C.Type_eZO);
      return H.reflectClassByMangledName(H.getRuntimeTypeString(t1));
    },
    invoke$3: function(memberName, positionalArguments, namedArguments) {
      return this._invoke$4(memberName, 0, positionalArguments, namedArguments);
    },
    _invokeMethodWithNamedArguments$3: function(reflectiveName, positionalArguments, namedArguments) {
      var t1, jsFunction, info, t2, defaultArguments, t3, i, t4;
      t1 = this.reflectee;
      jsFunction = J.getInterceptor(t1)[reflectiveName];
      if (jsFunction == null)
        throw H.wrapException(H.UnimplementedNoSuchMethodError$("Invoking noSuchMethod with named arguments not implemented"));
      info = H.ReflectionInfo_ReflectionInfo(jsFunction);
      positionalArguments = P.List_List$from(positionalArguments, true, null);
      t2 = info.requiredParameterCount;
      if (t2 !== positionalArguments.length)
        throw H.wrapException(H.UnimplementedNoSuchMethodError$("Invoking noSuchMethod with named arguments not implemented"));
      defaultArguments = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      for (t3 = info.optionalParameterCount, i = 0; i < t3; ++i) {
        t4 = i + t2;
        defaultArguments.$indexSet(0, info.parameterName$1(t4), init.metadata[info.defaultValue$1(0, t4)]);
      }
      namedArguments.forEach$1(0, new H.JsInstanceMirror__invokeMethodWithNamedArguments_closure(defaultArguments));
      C.JSArray_methods.addAll$1(positionalArguments, defaultArguments.get$values(defaultArguments));
      return H.reflect(jsFunction.apply(t1, positionalArguments));
    },
    get$_classInvocationCache: function() {
      var cacheName, cacheHolder, cache;
      cacheName = $.Primitives_mirrorInvokeCacheName;
      cacheHolder = this.reflectee;
      if (cacheHolder == null)
        cacheHolder = J.getInterceptor(null);
      cache = cacheHolder.constructor[cacheName];
      if (cache == null) {
        cache = H.JsCache_allocate();
        cacheHolder.constructor[cacheName] = cache;
      }
      return cache;
    },
    _computeReflectiveName$4: function(symbolName, type, positionalArguments, namedArguments) {
      var $name, nbArgs;
      $name = symbolName.get$_name();
      switch (type) {
        case 1:
          return $name;
        case 2:
          return H.S($name) + "=";
        case 0:
          if (!J.$eq(namedArguments.get$length(namedArguments), 0))
            return H.S($name) + "*";
          nbArgs = positionalArguments.length;
          return H.S($name) + ":" + nbArgs + ":0";
      }
      throw H.wrapException(H.RuntimeError$("Could not compute reflective name for " + H.S($name)));
    },
    _getCachedInvocation$5: function($name, type, reflectiveName, positionalArguments, namedArguments) {
      var cache, cacheEntry;
      cache = this.get$_classInvocationCache();
      cacheEntry = cache[reflectiveName];
      if (cacheEntry == null) {
        cacheEntry = new H.JSInvocationMirror($name, $.get$reflectiveNames().$index(0, reflectiveName), type, positionalArguments, C.List_empty, null).__js_helper$_getCachedInvocation$1(this.reflectee);
        cache[reflectiveName] = cacheEntry;
      }
      return cacheEntry;
    },
    _invoke$4: function($name, type, positionalArguments, namedArguments) {
      var reflectiveName, cacheEntry, t1, getterCacheEntry;
      reflectiveName = this._computeReflectiveName$4($name, type, positionalArguments, namedArguments);
      if (!J.$eq(namedArguments.get$length(namedArguments), 0))
        return this._invokeMethodWithNamedArguments$3(reflectiveName, positionalArguments, namedArguments);
      cacheEntry = this._getCachedInvocation$5($name, type, reflectiveName, positionalArguments, namedArguments);
      if (!cacheEntry.get$isNoSuchMethod())
        t1 = !("$reflectable" in cacheEntry.get$jsFunction() || !!J.getInterceptor(this.reflectee).$isTearOffClosure);
      else
        t1 = true;
      if (t1) {
        if (type === 0) {
          getterCacheEntry = this._getCachedInvocation$5($name, 1, this._computeReflectiveName$4($name, 1, C.List_empty, C.Map_empty), C.List_empty, C.Map_empty);
          t1 = !getterCacheEntry.get$isNoSuchMethod() && !getterCacheEntry.get$isGetterStub();
        } else
          t1 = false;
        if (t1)
          return this.getField$1($name).invoke$3(C.Symbol_call, positionalArguments, namedArguments);
        if (type === 2)
          $name = H.s(H.S($name.get$_name()) + "=");
        if (!cacheEntry.get$isNoSuchMethod())
          H.throwInvalidReflectionError(reflectiveName);
        return H.reflect(cacheEntry.invokeOn$2(this.reflectee, new H.JSInvocationMirror($name, $.get$reflectiveNames().$index(0, reflectiveName), type, positionalArguments, [], null)));
      } else
        return H.reflect(cacheEntry.invokeOn$2(this.reflectee, positionalArguments));
    },
    getField$1: function(fieldName) {
      var cache, getter, value, result;
      $FASTPATH$0: {
        cache = this._getterCache;
        if (typeof cache == "number" || typeof fieldName.$p == "undefined")
          break $FASTPATH$0;
        getter = fieldName.$p(cache);
        if (typeof getter == "undefined")
          break $FASTPATH$0;
        value = getter(this.reflectee);
        if (value === getter.v)
          return getter.m;
        else {
          result = H.reflect(value);
          getter.v = value;
          getter.m = result;
          return result;
        }
      }
      return this._getFieldSlow$1(fieldName);
    },
    _getFieldSlow$1: function(fieldName) {
      var result, $name, cacheEntry, cache, useEval, mangledName, getter;
      result = this._invoke$4(fieldName, 1, C.List_empty, C.Map_empty);
      $name = fieldName.get$_name();
      cacheEntry = this.get$_classInvocationCache()[$name];
      if (cacheEntry.get$isNoSuchMethod())
        return result;
      cache = this._getterCache;
      if (typeof cache == "number") {
        cache = J.$sub$n(cache, 1);
        this._getterCache = cache;
        if (!J.$eq(cache, 0))
          return result;
        cache = Object.create(null);
        this._getterCache = cache;
      }
      useEval = typeof dart_precompiled != "function";
      if (typeof fieldName.$p == "undefined")
        fieldName.$p = this._newProbeFn$2($name, useEval);
      mangledName = cacheEntry.get$mangledName();
      getter = cacheEntry.get$isIntercepted() ? this._newInterceptedGetterFn$2(mangledName, useEval) : this._newGetterFn$2(mangledName, useEval);
      cache[$name] = getter;
      getter.v = getter.m = cache;
      return result;
    },
    _newProbeFn$2: function(id, useEval) {
      if (useEval)
        return function(b) {
          return eval(b);
        }("(function probe$" + H.S(id) + "(c){return c." + H.S(id) + "})");
      else
        return function(n) {
          return function(c) {
            return c[n];
          };
        }(id);
    },
    _newGetterFn$2: function($name, useEval) {
      if (!useEval)
        return function(n) {
          return function(o) {
            return o[n]();
          };
        }($name);
      return function(b) {
        return eval(b);
      }("(function " + this.reflectee.constructor.name + "$" + H.S($name) + "(o){return o." + H.S($name) + "()})");
    },
    _newInterceptedGetterFn$2: function($name, useEval) {
      var interceptor, functionName;
      interceptor = J.getInterceptor(this.reflectee);
      if (!useEval)
        return function(n, i) {
          return function(o) {
            return i[n](o);
          };
        }($name, interceptor);
      functionName = interceptor.constructor.name + "$" + H.S($name);
      return function(b) {
        return eval(b);
      }("(function(i) {  function " + functionName + "(o){return i." + H.S($name) + "(o)}  return " + functionName + ";})")(interceptor);
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!!J.getInterceptor(other).$isJsInstanceMirror) {
        t1 = this.reflectee;
        t2 = other.reflectee;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return J.$xor$n(H.objectHashCode(this.reflectee), 909522486);
    },
    toString$0: function(_) {
      return "InstanceMirror on " + H.S(P.Error_safeToString(this.reflectee));
    },
    $isJsInstanceMirror: true
  },
  JsInstanceMirror__invokeMethodWithNamedArguments_closure: {
    "^": "Closure:1697;defaultArguments_0",
    call$2: function(symbol, value) {
      var parameter, t1;
      parameter = symbol.get$_name();
      t1 = this.defaultArguments_0;
      if (t1.containsKey$1(0, parameter))
        t1.$indexSet(0, parameter, value);
      else
        throw H.wrapException(H.UnimplementedNoSuchMethodError$("Invoking noSuchMethod with named arguments not implemented"));
    }
  },
  JsTypeBoundClassMirror: {
    "^": "JsDeclarationMirror;_class,_typeArguments,_cachedTypeArguments,_cachedDeclarations,_cachedMembers,_cachedConstructors,_cachedVariables,_cachedGetters,_cachedSetters,_cachedMethodsMap,_cachedMethods,_superclass,_cachedSuperinterfaces,_cachedInstanceMembers,_cachedStaticMembers,simpleName",
    get$_prettyName: function() {
      return "ClassMirror";
    },
    toString$0: function(_) {
      var result, t1, t2;
      result = "ClassMirror on " + H.S(this._class.get$simpleName()._name);
      if (this.get$typeArguments() != null) {
        t1 = result + "<";
        t2 = this.get$typeArguments();
        result = t1 + H.S(t2.join$1(t2, ", ")) + ">";
      }
      return result;
    },
    get$_mangledName: function() {
      for (var t1 = this.get$typeArguments(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
        if (!J.$eq(t1.__internal$_current, $.get$JsMirrorSystem__dynamicType()))
          return H.S(this._class.get$_mangledName()) + "<" + this._typeArguments + ">";
      return this._class.get$_mangledName();
    },
    get$typeVariables: function() {
      return this._class.get$typeVariables();
    },
    get$typeArguments: function() {
      var t1, result, t2, t3, level, currentTypeArgument, i, character;
      t1 = this._cachedTypeArguments;
      if (t1 != null)
        return t1;
      result = [];
      t1 = new H.JsTypeBoundClassMirror_typeArguments_addTypeArgument(result);
      t2 = this._typeArguments;
      if (C.JSString_methods.indexOf$1(t2, "<") === -1)
        C.JSArray_methods.forEach$1(t2.split(","), new H.JsTypeBoundClassMirror_typeArguments_closure(t1));
      else {
        for (t3 = t2.length, level = 0, currentTypeArgument = "", i = 0; i < t3; ++i) {
          character = t2[i];
          if (character === " ")
            continue;
          else if (character === "<") {
            currentTypeArgument += character;
            ++level;
          } else if (character === ">") {
            currentTypeArgument += character;
            --level;
          } else if (character === ",")
            if (level > 0)
              currentTypeArgument += character;
            else {
              t1.call$1(currentTypeArgument);
              currentTypeArgument = "";
            }
          else
            currentTypeArgument += character;
        }
        t1.call$1(currentTypeArgument);
      }
      t1 = H.setRuntimeTypeInfo(new P.UnmodifiableListView(result), [null]);
      this._cachedTypeArguments = t1;
      return t1;
    },
    newInstance$3: function(constructorName, positionalArguments, namedArguments) {
      var instance, t1;
      instance = this._class._getInvokedInstance$3(constructorName, positionalArguments, namedArguments);
      t1 = this.get$typeArguments();
      return H.reflect(H.setRuntimeTypeInfo(instance, t1.map$1(t1, new H.JsTypeBoundClassMirror_newInstance_closure()).toList$0(0)));
    },
    newInstance$2: function(constructorName, positionalArguments) {
      return this.newInstance$3(constructorName, positionalArguments, null);
    },
    _asRuntimeType$0: function() {
      var t1, t2;
      t1 = this._class.get$_jsConstructor();
      t2 = this.get$typeArguments();
      return C.JSArray_methods.addAll$1([t1], t2.map$1(t2, new H.JsTypeBoundClassMirror__asRuntimeType_closure()));
    },
    get$owner: function() {
      return this._class.get$owner();
    },
    get$isOriginalDeclaration: function() {
      return false;
    },
    get$originalDeclaration: function() {
      return this._class;
    },
    get$qualifiedName: function() {
      return this._class.get$qualifiedName();
    },
    get$simpleName: function() {
      return this._class.get$simpleName();
    },
    $isJsTypeBoundClassMirror: true,
    $isClassMirror: true,
    $isTypeMirror: true
  },
  JsTypeBoundClassMirror_typeArguments_addTypeArgument: {
    "^": "Closure:91;result_0",
    call$1: function(typeArgument) {
      var parsedIndex, t1, typeVariable;
      parsedIndex = H.Primitives_parseInt(typeArgument, null, new H.JsTypeBoundClassMirror_typeArguments_addTypeArgument_closure());
      t1 = this.result_0;
      if (J.$eq(parsedIndex, -1))
        t1.push(H.reflectClassByMangledName(J.trim$0$s(typeArgument)));
      else {
        typeVariable = H.getMetadata(parsedIndex);
        t1.push(new H.JsTypeVariableMirror(P.reflectClass(typeVariable.get$owner()), typeVariable, parsedIndex, null, H.s(J.get$name$x(typeVariable))));
      }
    }
  },
  JsTypeBoundClassMirror_typeArguments_addTypeArgument_closure: {
    "^": "Closure:102;",
    call$1: function(_) {
      return -1;
    }
  },
  JsTypeBoundClassMirror_typeArguments_closure: {
    "^": "Closure:102;addTypeArgument_1",
    call$1: function(t) {
      return this.addTypeArgument_1.call$1(t);
    }
  },
  JsTypeBoundClassMirror_newInstance_closure: {
    "^": "Closure:102;",
    call$1: [function(t) {
      return t._asRuntimeType$0();
    }, "call$1", null, 2, 0, null, 423, [], "call"]
  },
  JsTypeBoundClassMirror__asRuntimeType_closure: {
    "^": "Closure:102;",
    call$1: [function(t) {
      return t._asRuntimeType$0();
    }, "call$1", null, 2, 0, null, 423, [], "call"]
  },
  JsClassMirror: {
    "^": "JsTypeMirror_JsObjectMirror0;_mangledName<,_jsConstructor<,_fieldsDescriptor,_fieldsMetadata,_jsConstructorCache,_metadata,_superclass,_cachedMethods,_cachedFields,_cachedConstructors,_cachedMethodsMap,_cachedGetters,_cachedSetters,_cachedVariables,_cachedMembers,_cachedDeclarations,_cachedMetadata,_cachedSuperinterfaces,_cachedTypeVariables,_cachedInstanceMembers,_cachedStaticMembers,_owner,simpleName",
    get$_prettyName: function() {
      return "ClassMirror";
    },
    get$__constructors: function() {
      var t1 = this._cachedConstructors;
      if (t1 != null)
        return t1;
      t1 = H.setRuntimeTypeInfo(new P.UnmodifiableMapView(H.filterConstructors(this.get$_methods())), [P.Symbol0, P.MethodMirror]);
      this._cachedConstructors = t1;
      return t1;
    },
    _asRuntimeType$0: function() {
      var type, i, t1;
      if (J.get$isEmpty$asx(this.get$typeVariables()))
        return this._jsConstructor;
      type = [this._jsConstructor];
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.get$typeVariables());
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        type.push($.get$JsMirrorSystem__dynamicType().get$_asRuntimeType());
        ++i;
      }
      return type;
    },
    _getMethodsWithOwner$1: function(methodOwner) {
      var $prototype, keys, result, t1, key, simpleName, $function, mirror, mangledName, jsFunction, reflectionName, isConstructor, t2;
      $prototype = this._jsConstructor.prototype;
      keys = H.extractKeys($prototype);
      result = H.setRuntimeTypeInfo([], [H.JsMethodMirror]);
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(keys, keys.length, 0, null), [H.getTypeArgumentByIndex(keys, 0)]); t1.moveNext$0();) {
        key = t1.__internal$_current;
        if (H.isReflectiveDataInPrototype(key))
          continue;
        simpleName = $.get$mangledNames().$index(0, key);
        if (simpleName == null)
          continue;
        $function = $prototype[key];
        if ($function.$reflectable == 2)
          continue;
        mirror = H.JsMethodMirror_JsMethodMirror$fromUnmangledName(simpleName, $function, false, false);
        result.push(mirror);
        mirror._owner = methodOwner;
      }
      keys = H.extractKeys(init.statics[this._mangledName]);
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(keys, keys.length, 0, null), [H.getTypeArgumentByIndex(keys, 0)]); t1.moveNext$0();) {
        mangledName = t1.__internal$_current;
        if (H.isReflectiveDataInPrototype(mangledName))
          continue;
        jsFunction = this.get$owner()._globalObject[mangledName];
        if ("$reflectable" in jsFunction) {
          reflectionName = jsFunction.$reflectionName;
          if (reflectionName == null)
            continue;
          isConstructor = C.JSString_methods.startsWith$1(reflectionName, "new ");
          if (isConstructor) {
            t2 = C.JSString_methods.substring$1(reflectionName, 4);
            reflectionName = H.stringReplaceAllUnchecked(t2, "$", ".");
          }
        } else
          continue;
        mirror = H.JsMethodMirror_JsMethodMirror$fromUnmangledName(reflectionName, jsFunction, !isConstructor, isConstructor);
        result.push(mirror);
        mirror._owner = methodOwner;
      }
      return result;
    },
    get$_methods: function() {
      var t1 = this._cachedMethods;
      if (t1 != null)
        return t1;
      t1 = this._getMethodsWithOwner$1(this);
      this._cachedMethods = t1;
      return t1;
    },
    _getInvokedInstance$3: function(constructorName, positionalArguments, namedArguments) {
      var t1, t2, mirror, t3;
      t1 = this._jsConstructorCache;
      t2 = constructorName._name;
      mirror = t1[t2];
      if (mirror == null) {
        t3 = this.get$__constructors()._map;
        mirror = t3.get$values(t3).firstWhere$2$orElse(0, new H.JsClassMirror__getInvokedInstance_closure(constructorName), new H.JsClassMirror__getInvokedInstance_closure0(constructorName, positionalArguments, namedArguments));
        t1[t2] = mirror;
      }
      return mirror._invoke$2(positionalArguments, namedArguments);
    },
    newInstance$3: function(constructorName, positionalArguments, namedArguments) {
      return H.reflect(this._getInvokedInstance$3(constructorName, positionalArguments, namedArguments));
    },
    newInstance$2: function(constructorName, positionalArguments) {
      return this.newInstance$3(constructorName, positionalArguments, null);
    },
    get$owner: function() {
      var t1, t2;
      t1 = this._owner;
      if (t1 == null) {
        t1 = H.JsMirrorSystem_librariesByName();
        t1 = t1.get$values(t1);
        t2 = new H.MappedIterator(null, J.get$iterator$ax(t1._iterable), t1._f);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)];
        for (; t2.moveNext$0();)
          for (t1 = J.get$iterator$ax(t2.__internal$_current); t1.moveNext$0();)
            t1.get$current().get$__classes();
        t1 = this._owner;
        if (t1 == null)
          throw H.wrapException(P.StateError$("Class \"" + H.S(H.n(this.simpleName)) + "\" has no owner"));
      }
      return t1;
    },
    get$isOriginalDeclaration: function() {
      return true;
    },
    get$originalDeclaration: function() {
      return this;
    },
    get$typeVariables: function() {
      var t1, result, typeVariables, i, typeVariable;
      t1 = this._cachedTypeVariables;
      if (t1 != null)
        return t1;
      result = [];
      typeVariables = this._jsConstructor.prototype["<>"];
      if (typeVariables == null)
        return result;
      for (i = 0; i < typeVariables.length; ++i) {
        t1 = typeVariables[i];
        typeVariable = init.metadata[t1];
        result.push(new H.JsTypeVariableMirror(this, typeVariable, t1, null, H.s(J.get$name$x(typeVariable))));
      }
      t1 = new P.UnmodifiableListView(result);
      t1.$builtinTypeInfo = [null];
      this._cachedTypeVariables = t1;
      return t1;
    },
    get$typeArguments: function() {
      return C.List_empty1;
    },
    $isJsClassMirror: true,
    $isClassMirror: true,
    $isTypeMirror: true
  },
  JsTypeMirror_JsObjectMirror0: {
    "^": "JsTypeMirror+JsObjectMirror;"
  },
  JsClassMirror__getInvokedInstance_closure: {
    "^": "Closure:102;constructorName_0",
    call$1: function(m) {
      return J.$eq(m.get$constructorName(), this.constructorName_0);
    }
  },
  JsClassMirror__getInvokedInstance_closure0: {
    "^": "Closure:54;constructorName_1,positionalArguments_2,namedArguments_3",
    call$0: function() {
      throw H.wrapException(H.NoSuchStaticMethodError$method(null, this.constructorName_1, this.positionalArguments_2, this.namedArguments_3));
    }
  },
  JsClosureMirror: {
    "^": "JsInstanceMirror;reflectee,_getterCache",
    apply$2: function(positionalArguments, namedArguments) {
      return H.reflect(H.Primitives_applyFunction(this.reflectee, positionalArguments, P.Function__toMangledNames(namedArguments)));
    },
    apply$1: function(positionalArguments) {
      return this.apply$2(positionalArguments, null);
    },
    toString$0: function(_) {
      return "ClosureMirror on '" + H.S(P.Error_safeToString(this.reflectee)) + "'";
    },
    get$source: function(_) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  JsMethodMirror: {
    "^": "JsDeclarationMirror;_jsFunction,_requiredParameterCount,_optionalParameterCount,isGetter,isSetter,isStatic,isConstructor<,isOperator,_owner,_metadata,_returnType,_parameters,simpleName",
    get$_prettyName: function() {
      return "MethodMirror";
    },
    get$parameters: function() {
      var t1 = this._parameters;
      if (t1 != null)
        return t1;
      this.get$metadata();
      return this._parameters;
    },
    get$owner: function() {
      return this._owner;
    },
    get$metadata: function() {
      var t1, raw, t2, formals, info, functionType, type, isNamed, t3, t4, t5, i, parameter, $name, result, p, defaultValue, i0;
      t1 = this._metadata;
      if (t1 == null) {
        t1 = this._jsFunction;
        raw = H.extractMetadata(t1);
        t2 = J.$add$ns(this._requiredParameterCount, this._optionalParameterCount);
        if (typeof t2 !== "number")
          return H.iae(t2);
        formals = Array(t2);
        info = H.ReflectionInfo_ReflectionInfo(t1);
        if (info != null) {
          functionType = info.functionType;
          if (typeof functionType === "number" && Math.floor(functionType) === functionType)
            type = new H.JsFunctionTypeMirror(info.computeFunctionRti$1(null), null, null, null, this);
          else
            type = this.get$owner() != null && !!J.getInterceptor(this.get$owner()).$isLibraryMirror ? new H.JsFunctionTypeMirror(info.computeFunctionRti$1(null), null, null, null, this._owner) : new H.JsFunctionTypeMirror(info.computeFunctionRti$1(this._owner.get$originalDeclaration().get$_jsConstructor()), null, null, null, this._owner);
          if (this.isConstructor)
            this._returnType = this._owner;
          else
            this._returnType = type.get$returnType();
          isNamed = info.areOptionalParametersNamed;
          for (t1 = type.get$parameters(), t1 = t1.get$iterator(t1), t2 = formals.length, t3 = info.requiredParameterCount, t4 = info.data, t5 = info.optionalParameterCount, i = 0; t1.moveNext$0(); i = i0) {
            parameter = t1.__internal$_current;
            $name = info.parameterName$1(i);
            result = t4[2 * i + t5 + 3 + 1];
            if (i < t3)
              p = new H.JsParameterMirror(this, parameter.get$__js_mirrors$_type(), false, false, null, result, H.s($name));
            else {
              defaultValue = info.defaultValue$1(0, i);
              p = new H.JsParameterMirror(this, parameter.get$__js_mirrors$_type(), true, isNamed, defaultValue, result, H.s($name));
            }
            i0 = i + 1;
            if (i >= t2)
              return H.ioore(formals, i);
            formals[i] = p;
          }
        }
        this._parameters = H.setRuntimeTypeInfo(new P.UnmodifiableListView(formals), [P.ParameterMirror]);
        t1 = H.setRuntimeTypeInfo(new P.UnmodifiableListView(J.map$1$ax(raw, H.reflect$closure())), [null]);
        this._metadata = t1;
      }
      return t1;
    },
    get$constructorName: function() {
      var $name, t1, index, t2;
      if (!this.isConstructor)
        return C.Symbol_0c4;
      $name = this.simpleName._name;
      t1 = J.getInterceptor$asx($name);
      index = t1.indexOf$1($name, ".");
      t2 = J.getInterceptor(index);
      if (t2.$eq(index, -1))
        return C.Symbol_0c4;
      return H.s(t1.substring$1($name, t2.$add(index, 1)));
    },
    _invoke$2: function(positionalArguments, namedArguments) {
      var t1, positionalLength, t2, t3, i;
      if (namedArguments != null && !J.$eq(namedArguments.get$length(namedArguments), 0))
        throw H.wrapException(P.UnsupportedError$("Named arguments are not implemented."));
      if (!this.isStatic && !this.isConstructor)
        throw H.wrapException(H.RuntimeError$("Cannot invoke instance method without receiver."));
      t1 = J.getInterceptor$asx(positionalArguments);
      positionalLength = t1.get$length(positionalArguments);
      t2 = this._requiredParameterCount;
      t3 = J.getInterceptor$n(positionalLength);
      if (t3.$lt(positionalLength, t2) || t3.$gt(positionalLength, J.$add$ns(t2, this._optionalParameterCount)) || this._jsFunction == null)
        throw H.wrapException(P.NoSuchMethodError$(this.get$owner(), this.simpleName, positionalArguments, namedArguments, null));
      if (t3.$lt(positionalLength, J.$add$ns(t2, this._optionalParameterCount))) {
        positionalArguments = t1.toList$0(positionalArguments);
        for (t1 = J.getInterceptor$ax(positionalArguments), i = positionalLength; t2 = J.getInterceptor$n(i), t2.$lt(i, J.get$length$asx(this.get$parameters()._collection$_source)); i = t2.$add(i, 1))
          t1.add$1(positionalArguments, J.get$defaultValue$x(J.elementAt$1$ax(this.get$parameters()._collection$_source, i)).get$reflectee());
      }
      return this._jsFunction.apply($, P.List_List$from(positionalArguments, true, null));
    },
    get$source: function(_) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    $isJsMethodMirror: true,
    $isMethodMirror: true,
    static: {JsMethodMirror_JsMethodMirror$fromUnmangledName: function($name, jsFunction, isStatic, isConstructor) {
        var info, isOperator, isSetter, t1, requiredParameterCount, isGetter, optionalParameterCount;
        info = J.split$1$s($name, ":");
        if (0 >= info.length)
          return H.ioore(info, 0);
        $name = info[0];
        isOperator = H.isOperatorName($name);
        isSetter = !isOperator && J.endsWith$1$s($name, "=");
        t1 = info.length;
        if (t1 === 1) {
          if (isSetter) {
            requiredParameterCount = 1;
            isGetter = false;
          } else {
            requiredParameterCount = 0;
            isGetter = true;
          }
          optionalParameterCount = 0;
        } else {
          if (1 >= t1)
            return H.ioore(info, 1);
          requiredParameterCount = H.Primitives_parseInt(info[1], null, null);
          if (2 >= info.length)
            return H.ioore(info, 2);
          optionalParameterCount = H.Primitives_parseInt(info[2], null, null);
          isGetter = false;
        }
        return new H.JsMethodMirror(jsFunction, requiredParameterCount, optionalParameterCount, isGetter, isSetter, isStatic, isConstructor, isOperator, null, null, null, null, H.s($name));
      }}
  },
  JsParameterMirror: {
    "^": "JsDeclarationMirror;owner<,__js_mirrors$_type<,isOptional,isNamed,_defaultValue,metadataList,simpleName",
    get$_prettyName: function() {
      return "ParameterMirror";
    },
    get$type: function(_) {
      return H.typeMirrorFromRuntimeTypeRepresentation(this.owner, this.__js_mirrors$_type);
    },
    get$defaultValue: function(_) {
      var t1 = this._defaultValue;
      return t1 != null ? H.reflect(H.getMetadata(t1)) : null;
    },
    $isParameterMirror: true
  },
  JsTypedefMirror: {
    "^": "JsDeclarationMirror;_mangledName<,referent,simpleName",
    get$value: function(_) {
      return this.referent;
    },
    get$_prettyName: function() {
      return "TypedefMirror";
    },
    get$typeVariables: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    get$originalDeclaration: function() {
      return this;
    },
    get$owner: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    $isJsTypedefMirror: true,
    $isTypedefMirror: true,
    $isTypeMirror: true
  },
  BrokenClassMirror: {
    "^": "Object;",
    newInstance$3: function(constructorName, positionalArguments, namedArguments) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    newInstance$2: function(constructorName, positionalArguments) {
      return this.newInstance$3(constructorName, positionalArguments, null);
    },
    get$typeVariables: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    get$typeArguments: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    get$originalDeclaration: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    get$simpleName: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    get$qualifiedName: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  JsFunctionTypeMirror: {
    "^": "BrokenClassMirror;_typeData,_cachedToString,_cachedReturnType,_cachedParameters,owner<",
    get$isOriginalDeclaration: function() {
      return true;
    },
    get$returnType: function() {
      var t1 = this._cachedReturnType;
      if (t1 != null)
        return t1;
      t1 = this._typeData;
      if (!!t1.void) {
        t1 = $.get$JsMirrorSystem__voidType();
        this._cachedReturnType = t1;
        return t1;
      }
      if (!("ret" in t1)) {
        t1 = $.get$JsMirrorSystem__dynamicType();
        this._cachedReturnType = t1;
        return t1;
      }
      t1 = H.typeMirrorFromRuntimeTypeRepresentation(this.owner, t1.ret);
      this._cachedReturnType = t1;
      return t1;
    },
    get$parameters: function() {
      var t1, result, t2, parameterCount, parameterCount0, $name;
      t1 = this._cachedParameters;
      if (t1 != null)
        return t1;
      result = [];
      t1 = this._typeData;
      if ("args" in t1)
        for (t2 = t1.args, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), parameterCount = 0; t2.moveNext$0(); parameterCount = parameterCount0) {
          parameterCount0 = parameterCount + 1;
          result.push(new H.JsParameterMirror(this, t2.__internal$_current, false, false, null, C.List_empty2, H.s("argument" + parameterCount)));
        }
      else
        parameterCount = 0;
      if ("opt" in t1)
        for (t2 = t1.opt, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0(); parameterCount = parameterCount0) {
          parameterCount0 = parameterCount + 1;
          result.push(new H.JsParameterMirror(this, t2.__internal$_current, false, false, null, C.List_empty2, H.s("argument" + parameterCount)));
        }
      if ("named" in t1)
        for (t2 = H.extractKeys(t1.named), t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();) {
          $name = t2.__internal$_current;
          result.push(new H.JsParameterMirror(this, t1.named[$name], false, false, null, C.List_empty2, H.s($name)));
        }
      t1 = H.setRuntimeTypeInfo(new P.UnmodifiableListView(result), [P.ParameterMirror]);
      this._cachedParameters = t1;
      return t1;
    },
    _unmangleIfPreserved$1: function(mangled) {
      var result = init.mangledGlobalNames[mangled];
      if (result != null)
        return result;
      return mangled;
    },
    toString$0: function(_) {
      var t1, t2, s, sep, argument, $name;
      t1 = this._cachedToString;
      if (t1 != null)
        return t1;
      t1 = this._typeData;
      if ("args" in t1)
        for (t2 = t1.args, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), s = "FunctionTypeMirror on '(", sep = ""; t2.moveNext$0(); sep = ", ") {
          argument = t2.__internal$_current;
          s = C.JSString_methods.$add(s + sep, this._unmangleIfPreserved$1(H.runtimeTypeToString(argument, null)));
        }
      else {
        s = "FunctionTypeMirror on '(";
        sep = "";
      }
      if ("opt" in t1) {
        s += sep + "[";
        for (t2 = t1.opt, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), sep = ""; t2.moveNext$0(); sep = ", ") {
          argument = t2.__internal$_current;
          s = C.JSString_methods.$add(s + sep, this._unmangleIfPreserved$1(H.runtimeTypeToString(argument, null)));
        }
        s += "]";
      }
      if ("named" in t1) {
        s += sep + "{";
        for (t2 = H.extractKeys(t1.named), t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), sep = ""; t2.moveNext$0(); sep = ", ") {
          $name = t2.__internal$_current;
          s = C.JSString_methods.$add(s + sep + (H.S($name) + ": "), this._unmangleIfPreserved$1(H.runtimeTypeToString(t1.named[$name], null)));
        }
        s += "}";
      }
      s += ") -> ";
      if (!!t1.void)
        s += "void";
      else
        s = "ret" in t1 ? C.JSString_methods.$add(s, this._unmangleIfPreserved$1(H.runtimeTypeToString(t1.ret, null))) : s + "dynamic";
      t1 = s + "'";
      this._cachedToString = t1;
      return t1;
    },
    $isClassMirror: true,
    $isTypeMirror: true
  },
  typeMirrorFromRuntimeTypeRepresentation_getTypeArgument: {
    "^": "Closure:1698;box_0",
    call$1: function(index) {
      var typeVariable, t1, variableIndex;
      typeVariable = H.getMetadata(index);
      t1 = this.box_0;
      variableIndex = H.findTypeVariableIndex(t1.ownerClass_0.get$typeVariables(), J.get$name$x(typeVariable));
      return J.$index$asx(t1.ownerClass_0.get$typeArguments(), variableIndex);
    }
  },
  typeMirrorFromRuntimeTypeRepresentation_substituteTypeVariable: {
    "^": "Closure:559;getTypeArgument_1",
    call$1: function(index) {
      var typeArgument, t1;
      typeArgument = this.getTypeArgument_1.call$1(index);
      t1 = J.getInterceptor(typeArgument);
      if (!!t1.$isJsTypeVariableMirror)
        return H.S(typeArgument._metadataIndex);
      if (!t1.$isJsClassMirror && !t1.$isJsTypeBoundClassMirror)
        if (t1.$eq(typeArgument, $.get$JsMirrorSystem__dynamicType()))
          return "dynamic";
        else if (t1.$eq(typeArgument, $.get$JsMirrorSystem__voidType()))
          return "void";
        else
          return "dynamic";
      return typeArgument.get$_mangledName();
    }
  },
  extractMetadata_closure: {
    "^": "Closure:99;",
    call$1: [function(i) {
      return H.getMetadata(i);
    }, "call$1", null, 2, 0, null, 424, [], "call"]
  },
  NoSuchStaticMethodError: {
    "^": "Error;_cls,__js_mirrors$_name,_positionalArguments,__js_mirrors$_namedArguments,__js_mirrors$_kind",
    toString$0: function(_) {
      switch (this.__js_mirrors$_kind) {
        case 0:
          return "NoSuchMethodError: No constructor named '" + H.S(this.__js_mirrors$_name._name) + "' in class '" + H.S(this._cls.get$qualifiedName().get$_name()) + "'.";
        case 1:
          return "NoSuchMethodError: No top-level method named '" + H.S(this.__js_mirrors$_name._name) + "'.";
        default:
          return "NoSuchMethodError";
      }
    },
    $isError: true,
    static: {"^": "NoSuchStaticMethodError_MISSING_CONSTRUCTOR,NoSuchStaticMethodError_MISSING_METHOD", NoSuchStaticMethodError$method: function(_cls, _name, _positionalArguments, _namedArguments) {
        return new H.NoSuchStaticMethodError(_cls, _name, _positionalArguments, _namedArguments, 1);
      }}
  }
}],
["dart._js_names", "dart:_js_names", , H, {
  "^": "",
  computeMangledNames: function(jsMangledNames, isGlobal) {
    var keys, result, t1, t2, key, value, t3;
    keys = H.extractKeys(jsMangledNames);
    result = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String);
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(keys, keys.length, 0, null), [H.getTypeArgumentByIndex(keys, 0)]), t2 = !isGlobal; t1.moveNext$0();) {
      key = t1.__internal$_current;
      value = jsMangledNames[key];
      result.$indexSet(0, key, value);
      if (t2) {
        t3 = J.getInterceptor$s(key);
        if (t3.startsWith$1(key, "get$"))
          result.$indexSet(0, "set$" + t3.substring$1(key, 4), value + "=");
      }
    }
    return result;
  },
  computeReflectiveNames: function(map) {
    var result = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String);
    map.forEach$1(0, new H.computeReflectiveNames_closure(result));
    return result;
  },
  extractKeys: function(victim) {
    var t1 = H.setRuntimeTypeInfo(function(victim, hasOwnProperty) {
      var result = [];
      for (var key in victim) {
        if (hasOwnProperty.call(victim, key))
          result.push(key);
      }
      return result;
    }(victim, Object.prototype.hasOwnProperty), [null]);
    t1.fixed$length = Array;
    return t1;
  },
  computeReflectiveNames_closure: {
    "^": "Closure:772;result_0",
    call$2: function(mangledName, reflectiveName) {
      this.result_0.$indexSet(0, reflectiveName, mangledName);
    }
  }
}],
["dart.async", "dart:async", , P, {
  "^": "",
  _AsyncRun__initializeScheduleImmediate: function() {
    var t1, div, span;
    t1 = {};
    if (self.scheduleImmediate != null)
      return P._AsyncRun__scheduleImmediateJsOverride$closure();
    if (self.MutationObserver != null && self.document != null) {
      div = self.document.createElement("div");
      span = self.document.createElement("span");
      t1.storedCallback_0 = null;
      new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
      return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
    } else if (self.setImmediate != null)
      return P._AsyncRun__scheduleImmediateWithSetImmediate$closure();
    return P._AsyncRun__scheduleImmediateWithTimer$closure();
  },
  _AsyncRun__scheduleImmediateJsOverride: [function(callback) {
    ++init.globalState.topEventLoop._activeJsAsyncCount;
    self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(callback), 0));
  }, "call$1", "_AsyncRun__scheduleImmediateJsOverride$closure", 2, 0, 595],
  _AsyncRun__scheduleImmediateWithSetImmediate: [function(callback) {
    ++init.globalState.topEventLoop._activeJsAsyncCount;
    self.setImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(callback), 0));
  }, "call$1", "_AsyncRun__scheduleImmediateWithSetImmediate$closure", 2, 0, 595],
  _AsyncRun__scheduleImmediateWithTimer: [function(callback) {
    P.Timer__createTimer(C.Duration_0, callback);
  }, "call$1", "_AsyncRun__scheduleImmediateWithTimer$closure", 2, 0, 595],
  _registerErrorHandler: function(errorHandler, zone) {
    var t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(t1, [t1, t1])._isTest$1(errorHandler);
    if (t1) {
      zone.toString;
      return errorHandler;
    } else {
      zone.toString;
      return errorHandler;
    }
  },
  Future_Future: function(computation, $T) {
    var result = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [$T]);
    P.Timer_Timer(C.Duration_0, new P.Future_Future_closure(computation, result));
    return result;
  },
  Future_Future$sync: function(computation, $T) {
    var result, T0, error, stackTrace, t1, exception;
    try {
      result = computation.call$0();
      t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [T0]);
      t1._asyncComplete$1(result);
      return t1;
    } catch (exception) {
      t1 = H.unwrapException(exception);
      error = t1;
      stackTrace = new H._StackTrace(exception, null);
      error = error;
      stackTrace = stackTrace;
      error = error != null ? error : new P.NullThrownError();
      t1 = $.Zone__current;
      if (t1 !== C.C__RootZone)
        t1.toString;
      t1 = H.setRuntimeTypeInfo(new P._Future(0, t1, null), [T0]);
      t1._asyncCompleteError$2(error, stackTrace);
      return t1;
    }

  },
  Future_forEach: function(input, f) {
    return P.Future_doWhile(new P.Future_forEach_closure(f, H.setRuntimeTypeInfo(new H.ListIterator(input, input.length, 0, null), [H.getTypeArgumentByIndex(input, 0)])));
  },
  Future_doWhile: function(f) {
    var t1, doneSignal, nextIteration;
    t1 = {};
    doneSignal = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
    t1.nextIteration_0 = null;
    nextIteration = $.Zone__current.bindUnaryCallback$2$runGuarded(new P.Future_doWhile_closure(t1, f, doneSignal), true);
    t1.nextIteration_0 = nextIteration;
    nextIteration.call$1(true);
    return doneSignal;
  },
  _completeWithErrorCallback: function(result, error, stackTrace) {
    $.Zone__current.toString;
    result._completeError$2(error, stackTrace);
  },
  _asyncRunCallbackLoop: function() {
    var t1, t2;
    for (; t1 = $._nextCallback, t1 != null;) {
      $._lastPriorityCallback = null;
      t2 = t1.get$next();
      $._nextCallback = t2;
      if (t2 == null)
        $._lastCallback = null;
      t1.callback$0();
    }
  },
  _asyncRunCallback: [function() {
    $._isInCallbackLoop = true;
    try {
      P._asyncRunCallbackLoop();
    } finally {
      $._lastPriorityCallback = null;
      $._isInCallbackLoop = false;
      if ($._nextCallback != null)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    }
  }, "call$0", "_asyncRunCallback$closure", 0, 0, 17],
  _scheduleAsyncCallback: function(callback) {
    var t1, newEntry;
    if ($._nextCallback == null) {
      t1 = new P._AsyncCallbackEntry(callback, null);
      $._lastCallback = t1;
      $._nextCallback = t1;
      if (!$._isInCallbackLoop)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    } else {
      newEntry = new P._AsyncCallbackEntry(callback, null);
      $._lastCallback.next = newEntry;
      $._lastCallback = newEntry;
    }
  },
  scheduleMicrotask: function(callback) {
    var t1 = $.Zone__current;
    if (C.C__RootZone === t1) {
      P._rootScheduleMicrotask(null, null, C.C__RootZone, callback);
      return;
    }
    P._rootScheduleMicrotask(null, null, t1, t1.bindCallback$2$runGuarded(callback, true));
  },
  _runGuarded: function(notificationHandler) {
    var result, e, s, exception, t1;
    if (notificationHandler == null)
      return;
    try {
      result = notificationHandler.call$0();
      if (!!J.getInterceptor(result).$isFuture)
        return result;
      return;
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = new H._StackTrace(exception, null);
      t1 = $.Zone__current;
      t1.toString;
      P._rootHandleUncaughtError(null, null, t1, e, s);
    }

  },
  _nullDataHandler: [function(value) {
  }, "call$1", "_nullDataHandler$closure", 2, 0, 596, 138, []],
  _nullErrorHandler: [function(error, stackTrace) {
    var t1 = $.Zone__current;
    t1.toString;
    P._rootHandleUncaughtError(null, null, t1, error, stackTrace);
  }, function(error) {
    return P._nullErrorHandler(error, null);
  }, null, "call$2", "call$1", "_nullErrorHandler$closure", 2, 2, 597, 12, 598, [], 599, []],
  _nullDoneHandler: [function() {
  }, "call$0", "_nullDoneHandler$closure", 0, 0, 17],
  _runUserCode: function(userCode, onSuccess, onError) {
    var e, s, replacement, error, stackTrace, exception, t1;
    try {
      onSuccess.call$1(userCode.call$0());
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = new H._StackTrace(exception, null);
      $.Zone__current.toString;
      replacement = null;
      if (replacement == null)
        onError.call$2(e, s);
      else {
        t1 = J.get$error$x(replacement);
        error = t1;
        stackTrace = replacement.get$stackTrace();
        onError.call$2(error, stackTrace);
      }
    }

  },
  _cancelAndError: function(subscription, future, error, stackTrace) {
    var cancelFuture = subscription.cancel$0();
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndError_closure(future, error, stackTrace));
    else
      future._completeError$2(error, stackTrace);
  },
  _cancelAndErrorClosure: function(subscription, future) {
    return new P._cancelAndErrorClosure_closure(subscription, future);
  },
  _cancelAndValue: function(subscription, future, value) {
    var cancelFuture = subscription.cancel$0();
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, value));
    else
      future._complete$1(value);
  },
  _addErrorWithReplacement: function(sink, error, stackTrace) {
    $.Zone__current.toString;
    sink._addError$2(error, stackTrace);
  },
  Timer_Timer: function(duration, callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone) {
      t1.toString;
      return P.Timer__createTimer(duration, callback);
    }
    return P.Timer__createTimer(duration, t1.bindCallback$2$runGuarded(callback, true));
  },
  Timer_Timer$periodic: function(duration, callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone) {
      t1.toString;
      return P.Timer__createPeriodicTimer(duration, callback);
    }
    return P.Timer__createPeriodicTimer(duration, t1.bindUnaryCallback$2$runGuarded(callback, true));
  },
  Timer__createTimer: function(duration, callback) {
    var milliseconds = C.JSNumber_methods._tdivFast$1(duration._duration, 1000);
    return H.TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
  },
  Timer__createPeriodicTimer: function(duration, callback) {
    var milliseconds = C.JSNumber_methods._tdivFast$1(duration._duration, 1000);
    return H.TimerImpl$periodic(milliseconds < 0 ? 0 : milliseconds, callback);
  },
  Zone__enter: function(zone) {
    var previous = $.Zone__current;
    $.Zone__current = zone;
    return previous;
  },
  _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
    var t1, entry, t2;
    t1 = new P._rootHandleUncaughtError_closure(error, stackTrace);
    entry = new P._AsyncCallbackEntry(t1, null);
    t2 = $._nextCallback;
    if (t2 == null) {
      P._scheduleAsyncCallback(t1);
      $._lastPriorityCallback = $._lastCallback;
    } else {
      t1 = $._lastPriorityCallback;
      if (t1 == null) {
        entry.next = t2;
        $._lastPriorityCallback = entry;
        $._nextCallback = entry;
      } else {
        entry.next = t1.next;
        t1.next = entry;
        $._lastPriorityCallback = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    }
  },
  _rootRun: function($self, $parent, zone, f) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$0();
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$0();
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootRunUnary: function($self, $parent, zone, f, arg) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$1(arg);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$1(arg);
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootRunBinary: function($self, $parent, zone, f, arg1, arg2) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$2(arg1, arg2);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$2(arg1, arg2);
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootScheduleMicrotask: function($self, $parent, zone, f) {
    var t1 = C.C__RootZone !== zone;
    if (t1)
      f = zone.bindCallback$2$runGuarded(f, !(!t1 || C.C__RootZone.get$errorZone() === zone));
    P._scheduleAsyncCallback(f);
  },
  _AsyncRun__initializeScheduleImmediate_internalCallback: {
    "^": "Closure:102;box_0",
    call$1: [function(_) {
      var t1, f;
      H.leaveJsAsync();
      t1 = this.box_0;
      f = t1.storedCallback_0;
      t1.storedCallback_0 = null;
      f.call$0();
    }, "call$1", null, 2, 0, null, 1686, [], "call"]
  },
  _AsyncRun__initializeScheduleImmediate_closure: {
    "^": "Closure:1699;box_0,div_1,span_2",
    call$1: function(callback) {
      var t1, t2;
      ++init.globalState.topEventLoop._activeJsAsyncCount;
      this.box_0.storedCallback_0 = callback;
      t1 = this.div_1;
      t2 = this.span_2;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    }
  },
  _AsyncRun__scheduleImmediateJsOverride_internalCallback: {
    "^": "Closure:54;callback_0",
    call$0: [function() {
      H.leaveJsAsync();
      this.callback_0.call$0();
    }, "call$0", null, 0, 0, null, "call"]
  },
  _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: {
    "^": "Closure:54;callback_0",
    call$0: [function() {
      H.leaveJsAsync();
      this.callback_0.call$0();
    }, "call$0", null, 0, 0, null, "call"]
  },
  _UncaughtAsyncError: {
    "^": "AsyncError;error,stackTrace",
    toString$0: function(_) {
      var result, t1;
      result = "Uncaught Error: " + H.S(this.error);
      t1 = this.stackTrace;
      return t1 != null ? result + ("\nStack Trace:\n" + H.S(t1)) : result;
    },
    static: {_UncaughtAsyncError$: function(error, stackTrace) {
        return new P._UncaughtAsyncError(error, P._UncaughtAsyncError__getBestStackTrace(error, stackTrace));
      }, _UncaughtAsyncError__getBestStackTrace: function(error, stackTrace) {
        if (stackTrace != null)
          return stackTrace;
        if (!!J.getInterceptor(error).$isError)
          return error.get$stackTrace();
        return;
      }}
  },
  _BroadcastStream: {
    "^": "_ControllerStream;_async$_controller"
  },
  _BroadcastSubscription: {
    "^": "_ControllerSubscription;_eventState@,_async$_next@,_async$_previous@,_async$_controller,_async$_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    get$_async$_controller: function() {
      return this._async$_controller;
    },
    _expectsEvent$1: function(eventId) {
      var t1 = this._eventState;
      if (typeof t1 !== "number")
        return t1.$and();
      return (t1 & 1) === eventId;
    },
    _toggleEventId$0: function() {
      var t1 = this._eventState;
      if (typeof t1 !== "number")
        return t1.$xor();
      this._eventState = t1 ^ 1;
    },
    get$_isFiring: function() {
      var t1 = this._eventState;
      if (typeof t1 !== "number")
        return t1.$and();
      return (t1 & 2) !== 0;
    },
    _setRemoveAfterFiring$0: function() {
      var t1 = this._eventState;
      if (typeof t1 !== "number")
        return t1.$or();
      this._eventState = t1 | 4;
    },
    get$_removeAfterFiring: function() {
      var t1 = this._eventState;
      if (typeof t1 !== "number")
        return t1.$and();
      return (t1 & 4) !== 0;
    },
    _async$_onPause$0: [function() {
    }, "call$0", "get$_async$_onPause", 0, 0, 17],
    _async$_onResume$0: [function() {
    }, "call$0", "get$_async$_onResume", 0, 0, 17],
    static: {"^": "_BroadcastSubscription__STATE_EVENT_ID,_BroadcastSubscription__STATE_FIRING,_BroadcastSubscription__STATE_REMOVE_AFTER_FIRING"}
  },
  _BroadcastStreamController: {
    "^": "Object;_async$_next@,_async$_previous@",
    get$isPaused: function() {
      return false;
    },
    get$_isFiring: function() {
      return (this._state & 2) !== 0;
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 != null)
        return t1;
      t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      this._doneFuture = t1;
      return t1;
    },
    _removeListener$1: function(subscription) {
      var previous, next;
      previous = subscription.get$_async$_previous();
      next = subscription.get$_async$_next();
      previous.set$_async$_next(next);
      next.set$_async$_previous(previous);
      subscription.set$_async$_previous(subscription);
      subscription.set$_async$_next(subscription);
    },
    _subscribe$4: function(onData, onError, onDone, cancelOnError) {
      var t1, t2, subscription;
      if ((this._state & 4) !== 0) {
        if (onDone == null)
          onDone = P._nullDoneHandler$closure();
        t1 = new P._DoneStreamSubscription($.Zone__current, 0, onDone);
        t1.$builtinTypeInfo = this.$builtinTypeInfo;
        t1._schedule$0();
        return t1;
      }
      t1 = $.Zone__current;
      t2 = cancelOnError ? 1 : 0;
      subscription = new P._BroadcastSubscription(null, null, null, this, null, null, null, t1, t2, null, null);
      subscription.$builtinTypeInfo = this.$builtinTypeInfo;
      subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
      subscription._async$_previous = subscription;
      subscription._async$_next = subscription;
      t2 = this._async$_previous;
      subscription._async$_previous = t2;
      subscription._async$_next = this;
      t2.set$_async$_next(subscription);
      this._async$_previous = subscription;
      subscription._eventState = this._state & 1;
      if (this._async$_next === subscription)
        P._runGuarded(this._onListen);
      return subscription;
    },
    _recordCancel$1: function(subscription) {
      if (subscription.get$_async$_next() === subscription)
        return;
      if (subscription.get$_isFiring())
        subscription._setRemoveAfterFiring$0();
      else {
        this._removeListener$1(subscription);
        if ((this._state & 2) === 0 && this._async$_next === this)
          this._callOnCancel$0();
      }
      return;
    },
    _recordPause$1: function(subscription) {
    },
    _recordResume$1: function(subscription) {
    },
    _addEventError$0: function() {
      if ((this._state & 4) !== 0)
        return new P.StateError("Cannot add new events after calling close");
      return new P.StateError("Cannot add new events while doing an addStream");
    },
    add$1: [function(_, data) {
      if (this._state >= 4)
        throw H.wrapException(this._addEventError$0());
      this._sendData$1(data);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "void__T", void: true, args: [T]};
      }, this.$receiver, "_BroadcastStreamController");
    }, 87, []],
    addError$2: [function(error, stackTrace) {
      error = error != null ? error : new P.NullThrownError();
      if (this._state >= 4)
        throw H.wrapException(this._addEventError$0());
      $.Zone__current.toString;
      this._sendError$2(error, stackTrace);
    }, function(error) {
      return this.addError$2(error, null);
    }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 1700, 12, 598, [], 599, []],
    close$0: function(_) {
      var t1, doneFuture;
      t1 = this._state;
      if ((t1 & 4) !== 0)
        return this._doneFuture;
      if (t1 >= 4)
        throw H.wrapException(this._addEventError$0());
      this._state = t1 | 4;
      doneFuture = this._ensureDoneFuture$0();
      this._sendDone$0();
      return doneFuture;
    },
    _async$_add$1: function(data) {
      this._sendData$1(data);
    },
    _addError$2: function(error, stackTrace) {
      this._sendError$2(error, stackTrace);
    },
    _close$0: function() {
      var addState = this._addStreamState;
      this._addStreamState = null;
      this._state &= 4294967287;
      C.JSNull_methods.complete$0(addState);
    },
    _forEachListener$1: function(action) {
      var t1, link, id, link0;
      t1 = this._state;
      if ((t1 & 2) !== 0)
        throw H.wrapException(P.StateError$("Cannot fire new event. Controller is already firing an event"));
      link = this._async$_next;
      if (link === this)
        return;
      id = t1 & 1;
      this._state = t1 ^ 3;
      for (; link !== this;)
        if (link._expectsEvent$1(id)) {
          t1 = link.get$_eventState();
          if (typeof t1 !== "number")
            return t1.$or();
          link.set$_eventState(t1 | 2);
          action.call$1(link);
          link._toggleEventId$0();
          link0 = link.get$_async$_next();
          if (link.get$_removeAfterFiring())
            this._removeListener$1(link);
          t1 = link.get$_eventState();
          if (typeof t1 !== "number")
            return t1.$and();
          link.set$_eventState(t1 & 4294967293);
          link = link0;
        } else
          link = link.get$_async$_next();
      this._state &= 4294967293;
      if (this._async$_next === this)
        this._callOnCancel$0();
    },
    _callOnCancel$0: function() {
      if ((this._state & 4) !== 0 && this._doneFuture._state === 0)
        this._doneFuture._asyncComplete$1(null);
      P._runGuarded(this._onCancel);
    }
  },
  _SyncBroadcastStreamController: {
    "^": "_BroadcastStreamController;_onListen,_onCancel,_state,_async$_next,_async$_previous,_addStreamState,_doneFuture",
    _sendData$1: function(data) {
      var t1 = this._async$_next;
      if (t1 === this)
        return;
      if (t1.get$_async$_next() === this) {
        this._state |= 2;
        this._async$_next._async$_add$1(data);
        this._state &= 4294967293;
        if (this._async$_next === this)
          this._callOnCancel$0();
        return;
      }
      this._forEachListener$1(new P._SyncBroadcastStreamController__sendData_closure(this, data));
    },
    _sendError$2: function(error, stackTrace) {
      if (this._async$_next === this)
        return;
      this._forEachListener$1(new P._SyncBroadcastStreamController__sendError_closure(this, error, stackTrace));
    },
    _sendDone$0: function() {
      if (this._async$_next !== this)
        this._forEachListener$1(new P._SyncBroadcastStreamController__sendDone_closure(this));
      else
        this._doneFuture._asyncComplete$1(null);
    }
  },
  _SyncBroadcastStreamController__sendData_closure: {
    "^": "Closure;this_0,data_1",
    call$1: function(subscription) {
      subscription._async$_add$1(this.data_1);
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic___BufferingStreamSubscription", args: [[P._BufferingStreamSubscription, T]]};
      }, this.this_0, "_SyncBroadcastStreamController");
    }
  },
  _SyncBroadcastStreamController__sendError_closure: {
    "^": "Closure;this_0,error_1,stackTrace_2",
    call$1: function(subscription) {
      subscription._addError$2(this.error_1, this.stackTrace_2);
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic___BufferingStreamSubscription", args: [[P._BufferingStreamSubscription, T]]};
      }, this.this_0, "_SyncBroadcastStreamController");
    }
  },
  _SyncBroadcastStreamController__sendDone_closure: {
    "^": "Closure;this_0",
    call$1: function(subscription) {
      subscription._close$0();
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic___BroadcastSubscription", args: [[P._BroadcastSubscription, T]]};
      }, this.this_0, "_SyncBroadcastStreamController");
    }
  },
  Future: {
    "^": "Object;",
    $isFuture: true
  },
  Future_Future_closure: {
    "^": "Closure:54;computation_0,result_1",
    call$0: function() {
      var e, s, exception, t1;
      try {
        this.result_1._complete$1(this.computation_0.call$0());
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        P._completeWithErrorCallback(this.result_1, e, s);
      }

    }
  },
  Future_forEach_closure: {
    "^": "Closure:54;f_0,iterator_1",
    call$0: function() {
      var t1 = this.iterator_1;
      if (!t1.moveNext$0())
        return false;
      return P.Future_Future$sync(new P.Future_forEach__closure(this.f_0, t1), null).then$1(new P.Future_forEach__closure0());
    }
  },
  Future_forEach__closure: {
    "^": "Closure:54;f_2,iterator_3",
    call$0: function() {
      return this.f_2.call$1(this.iterator_3.__internal$_current);
    }
  },
  Future_forEach__closure0: {
    "^": "Closure:102;",
    call$1: [function(_) {
      return true;
    }, "call$1", null, 2, 0, null, 1686, [], "call"]
  },
  Future_doWhile_closure: {
    "^": "Closure:639;box_0,f_1,doneSignal_2",
    call$1: function(keepGoing) {
      var t1 = this.doneSignal_2;
      if (keepGoing === true)
        P.Future_Future$sync(this.f_1, null).then$2$onError(this.box_0.nextIteration_0, t1.get$_completeError());
      else
        t1._complete$1(null);
    }
  },
  _Completer: {
    "^": "Object;",
    completeError$2: function(error, stackTrace) {
      error = error != null ? error : new P.NullThrownError();
      if (this.future._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      $.Zone__current.toString;
      this._completeError$2(error, stackTrace);
    },
    completeError$1: function(error) {
      return this.completeError$2(error, null);
    }
  },
  _AsyncCompleter: {
    "^": "_Completer;future",
    complete$1: [function(_, value) {
      var t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncComplete$1(value);
    }, function($receiver) {
      return this.complete$1($receiver, null);
    }, "complete$0", "call$1", "call$0", "get$complete", 0, 2, 1701, 12],
    _completeError$2: function(error, stackTrace) {
      this.future._asyncCompleteError$2(error, stackTrace);
    }
  },
  _FutureListener: {
    "^": "Object;_nextListener@,result>,state>,callback<,errorCallback",
    callback$0: function() {
      return this.callback.call$0();
    },
    callback$1: function(arg0) {
      return this.callback.call$1(arg0);
    },
    get$_zone: function() {
      return this.result.get$_zone();
    },
    get$handlesValue: function() {
      return (this.state & 1) !== 0;
    },
    get$hasErrorTest: function() {
      return this.state === 6;
    },
    get$handlesComplete: function() {
      return this.state === 8;
    },
    get$_onValue: function() {
      return this.callback;
    },
    get$_onError: function() {
      return this.errorCallback;
    },
    get$_errorTest: function() {
      return this.callback;
    },
    get$_whenCompleteAction: function() {
      return this.callback;
    },
    static: {"^": "_FutureListener_MASK_VALUE,_FutureListener_MASK_ERROR,_FutureListener_MASK_TEST_ERROR,_FutureListener_MASK_WHENCOMPLETE,_FutureListener_STATE_CHAIN,_FutureListener_STATE_THEN,_FutureListener_STATE_THEN_ONERROR,_FutureListener_STATE_CATCHERROR,_FutureListener_STATE_CATCHERROR_TEST,_FutureListener_STATE_WHENCOMPLETE"}
  },
  _Future: {
    "^": "Object;_state,_zone<,_resultOrListeners",
    get$_hasError: function() {
      return this._state === 8;
    },
    set$_isChained: function(value) {
      if (value)
        this._state = 2;
      else
        this._state = 0;
    },
    then$2$onError: function(f, onError) {
      var result, t1;
      result = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t1 = result._zone;
      if (t1 !== C.C__RootZone) {
        t1.toString;
        if (onError != null)
          onError = P._registerErrorHandler(onError, t1);
      }
      t1 = onError == null ? 1 : 3;
      this._addListener$1(new P._FutureListener(null, result, t1, f, onError));
      return result;
    },
    then$1: function(f) {
      return this.then$2$onError(f, null);
    },
    whenComplete$1: function(action) {
      var t1, result;
      t1 = $.Zone__current;
      result = new P._Future(0, t1, null);
      result.$builtinTypeInfo = this.$builtinTypeInfo;
      if (t1 !== C.C__RootZone)
        t1.toString;
      this._addListener$1(new P._FutureListener(null, result, 8, action, null));
      return result;
    },
    _markPendingCompletion$0: function() {
      if (this._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      this._state = 1;
    },
    get$_async$_value: function() {
      return this._resultOrListeners;
    },
    get$_error: function() {
      return this._resultOrListeners;
    },
    _setValue$1: function(value) {
      this._state = 4;
      this._resultOrListeners = value;
    },
    _setErrorObject$1: function(error) {
      this._state = 8;
      this._resultOrListeners = error;
    },
    _setError$2: function(error, stackTrace) {
      this._setErrorObject$1(new P.AsyncError(error, stackTrace));
    },
    _addListener$1: function(listener) {
      var t1;
      if (this._state >= 4) {
        t1 = this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, new P._Future__addListener_closure(this, listener));
      } else {
        listener._nextListener = this._resultOrListeners;
        this._resultOrListeners = listener;
      }
    },
    _removeListeners$0: function() {
      var current, prev, next;
      current = this._resultOrListeners;
      this._resultOrListeners = null;
      for (prev = null; current != null; prev = current, current = next) {
        next = current.get$_nextListener();
        current.set$_nextListener(prev);
      }
      return prev;
    },
    _complete$1: function(value) {
      var t1, listeners;
      t1 = J.getInterceptor(value);
      if (!!t1.$isFuture)
        if (!!t1.$is_Future)
          P._Future__chainCoreFuture(value, this);
        else
          P._Future__chainForeignFuture(value, this);
      else {
        listeners = this._removeListeners$0();
        this._setValue$1(value);
        P._Future__propagateToListeners(this, listeners);
      }
    },
    _completeWithValue$1: function(value) {
      var listeners = this._removeListeners$0();
      this._setValue$1(value);
      P._Future__propagateToListeners(this, listeners);
    },
    _completeError$2: [function(error, stackTrace) {
      var listeners = this._removeListeners$0();
      this._setErrorObject$1(new P.AsyncError(error, stackTrace));
      P._Future__propagateToListeners(this, listeners);
    }, function(error) {
      return this._completeError$2(error, null);
    }, "_completeError$1", "call$2", "call$1", "get$_completeError", 2, 2, 597, 12, 598, [], 599, []],
    _asyncComplete$1: function(value) {
      var t1;
      if (value == null)
        ;
      else {
        t1 = J.getInterceptor(value);
        if (!!t1.$isFuture) {
          if (!!t1.$is_Future) {
            t1 = value._state;
            if (t1 >= 4 && t1 === 8) {
              this._markPendingCompletion$0();
              t1 = this._zone;
              t1.toString;
              P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncComplete_closure(this, value));
            } else
              P._Future__chainCoreFuture(value, this);
          } else
            P._Future__chainForeignFuture(value, this);
          return;
        }
      }
      this._markPendingCompletion$0();
      t1 = this._zone;
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncComplete_closure0(this, value));
    },
    _asyncCompleteError$2: function(error, stackTrace) {
      var t1;
      this._markPendingCompletion$0();
      t1 = this._zone;
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncCompleteError_closure(this, error, stackTrace));
    },
    $is_Future: true,
    $isFuture: true,
    static: {"^": "_Future__INCOMPLETE,_Future__PENDING_COMPLETE,_Future__CHAINED,_Future__VALUE,_Future__ERROR", _Future__chainForeignFuture: function(source, target) {
        target.set$_isChained(true);
        source.then$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target));
      }, _Future__chainCoreFuture: function(source, target) {
        var listener;
        target.set$_isChained(true);
        listener = new P._FutureListener(null, target, 0, null, null);
        if (source._state >= 4)
          P._Future__propagateToListeners(source, listener);
        else
          source._addListener$1(listener);
      }, _Future__propagateToListeners: function(source, listeners) {
        var t1, t2, t3, hasError, asyncError, t4, listeners0, sourceValue, zone, oldZone, chainSource, result;
        t1 = {};
        t1.source_4 = source;
        for (t2 = source; true;) {
          t3 = {};
          hasError = t2.get$_hasError();
          if (listeners == null) {
            if (hasError) {
              asyncError = t1.source_4.get$_error();
              t2 = t1.source_4.get$_zone();
              t3 = J.get$error$x(asyncError);
              t4 = asyncError.get$stackTrace();
              t2.toString;
              P._rootHandleUncaughtError(null, null, t2, t3, t4);
            }
            return;
          }
          for (; listeners.get$_nextListener() != null; listeners = listeners0) {
            listeners0 = listeners.get$_nextListener();
            listeners.set$_nextListener(null);
            P._Future__propagateToListeners(t1.source_4, listeners);
          }
          t3.listenerHasValue_1 = true;
          sourceValue = hasError ? null : t1.source_4.get$_async$_value();
          t3.listenerValueOrError_2 = sourceValue;
          t3.isPropagationAborted_3 = false;
          t2 = !hasError;
          if (!t2 || listeners.get$handlesValue() || listeners.get$handlesComplete()) {
            zone = listeners.get$_zone();
            if (hasError) {
              t4 = t1.source_4.get$_zone();
              t4.toString;
              if (t4 == null ? zone != null : t4 !== zone) {
                t4 = t4.get$errorZone();
                zone.toString;
                t4 = t4 === zone;
              } else
                t4 = true;
              t4 = !t4;
            } else
              t4 = false;
            if (t4) {
              asyncError = t1.source_4.get$_error();
              t2 = t1.source_4.get$_zone();
              t3 = J.get$error$x(asyncError);
              t4 = asyncError.get$stackTrace();
              t2.toString;
              P._rootHandleUncaughtError(null, null, t2, t3, t4);
              return;
            }
            oldZone = $.Zone__current;
            if (oldZone == null ? zone != null : oldZone !== zone)
              $.Zone__current = zone;
            else
              oldZone = null;
            if (t2) {
              if (listeners.get$handlesValue())
                t3.listenerHasValue_1 = new P._Future__propagateToListeners_handleValueCallback(t3, listeners, sourceValue, zone).call$0();
            } else
              new P._Future__propagateToListeners_handleError(t1, t3, listeners, zone).call$0();
            if (listeners.get$handlesComplete())
              new P._Future__propagateToListeners_handleWhenCompleteCallback(t1, t3, hasError, listeners, zone).call$0();
            if (oldZone != null)
              $.Zone__current = oldZone;
            if (t3.isPropagationAborted_3)
              return;
            if (t3.listenerHasValue_1 === true) {
              t2 = t3.listenerValueOrError_2;
              t2 = (sourceValue == null ? t2 != null : sourceValue !== t2) && !!J.getInterceptor(t2).$isFuture;
            } else
              t2 = false;
            if (t2) {
              chainSource = t3.listenerValueOrError_2;
              result = J.get$result$x(listeners);
              if (!!J.getInterceptor(chainSource).$is_Future)
                if (chainSource._state >= 4) {
                  result.set$_isChained(true);
                  t1.source_4 = chainSource;
                  listeners = new P._FutureListener(null, result, 0, null, null);
                  t2 = chainSource;
                  continue;
                } else
                  P._Future__chainCoreFuture(chainSource, result);
              else
                P._Future__chainForeignFuture(chainSource, result);
              return;
            }
          }
          result = J.get$result$x(listeners);
          listeners = result._removeListeners$0();
          t2 = t3.listenerHasValue_1;
          t3 = t3.listenerValueOrError_2;
          if (t2 === true)
            result._setValue$1(t3);
          else
            result._setErrorObject$1(t3);
          t1.source_4 = result;
          t2 = result;
        }
      }}
  },
  _Future__addListener_closure: {
    "^": "Closure:54;this_0,listener_1",
    call$0: function() {
      P._Future__propagateToListeners(this.this_0, this.listener_1);
    }
  },
  _Future__chainForeignFuture_closure: {
    "^": "Closure:102;target_0",
    call$1: [function(value) {
      this.target_0._completeWithValue$1(value);
    }, "call$1", null, 2, 0, null, 138, [], "call"]
  },
  _Future__chainForeignFuture_closure0: {
    "^": "Closure:888;target_1",
    call$2: [function(error, stackTrace) {
      this.target_1._completeError$2(error, stackTrace);
    }, function(error) {
      return this.call$2(error, null);
    }, "call$1", "call$2", null, null, 2, 2, null, 12, 598, [], 599, [], "call"]
  },
  _Future__asyncComplete_closure: {
    "^": "Closure:54;this_0,coreFuture_1",
    call$0: function() {
      P._Future__chainCoreFuture(this.coreFuture_1, this.this_0);
    }
  },
  _Future__asyncComplete_closure0: {
    "^": "Closure:54;this_2,value_3",
    call$0: function() {
      this.this_2._completeWithValue$1(this.value_3);
    }
  },
  _Future__asyncCompleteError_closure: {
    "^": "Closure:54;this_0,error_1,stackTrace_2",
    call$0: function() {
      this.this_0._completeError$2(this.error_1, this.stackTrace_2);
    }
  },
  _Future__propagateToListeners_handleValueCallback: {
    "^": "Closure:247;box_1,listener_3,sourceValue_4,zone_5",
    call$0: function() {
      var e, s, exception, t1;
      try {
        this.box_1.listenerValueOrError_2 = this.zone_5.runUnary$2(this.listener_3.get$_onValue(), this.sourceValue_4);
        return true;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.box_1.listenerValueOrError_2 = new P.AsyncError(e, s);
        return false;
      }

    }
  },
  _Future__propagateToListeners_handleError: {
    "^": "Closure:17;box_2,box_1,listener_6,zone_7",
    call$0: function() {
      var asyncError, matchesTest, test, e, s, errorCallback, e0, s0, t1, exception, t2, listenerValueOrError, t3, t4;
      asyncError = this.box_2.source_4.get$_error();
      matchesTest = true;
      t1 = this.listener_6;
      if (t1.get$hasErrorTest()) {
        test = t1.get$_errorTest();
        try {
          matchesTest = this.zone_7.runUnary$2(test, J.get$error$x(asyncError));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = new H._StackTrace(exception, null);
          t1 = J.get$error$x(asyncError);
          t2 = e;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P.AsyncError(e, s);
          t1 = this.box_1;
          t1.listenerValueOrError_2 = listenerValueOrError;
          t1.listenerHasValue_1 = false;
          return;
        }

      }
      errorCallback = t1.get$_onError();
      if (matchesTest === true && errorCallback != null) {
        try {
          t1 = errorCallback;
          t2 = H.getDynamicRuntimeType();
          t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
          t3 = this.zone_7;
          t4 = this.box_1;
          if (t2)
            t4.listenerValueOrError_2 = t3.runBinary$3(errorCallback, J.get$error$x(asyncError), asyncError.get$stackTrace());
          else
            t4.listenerValueOrError_2 = t3.runUnary$2(errorCallback, J.get$error$x(asyncError));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e0 = t1;
          s0 = new H._StackTrace(exception, null);
          t1 = J.get$error$x(asyncError);
          t2 = e0;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P.AsyncError(e0, s0);
          t1 = this.box_1;
          t1.listenerValueOrError_2 = listenerValueOrError;
          t1.listenerHasValue_1 = false;
          return;
        }

        this.box_1.listenerHasValue_1 = true;
      } else {
        t1 = this.box_1;
        t1.listenerValueOrError_2 = asyncError;
        t1.listenerHasValue_1 = false;
      }
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback: {
    "^": "Closure:17;box_2,box_1,hasError_8,listener_9,zone_10",
    call$0: function() {
      var t1, e, s, completeResult, t2, exception, result;
      t1 = {};
      t1.completeResult_0 = null;
      try {
        completeResult = this.zone_10.run$1(this.listener_9.get$_whenCompleteAction());
        t1.completeResult_0 = completeResult;
        t2 = completeResult;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        if (this.hasError_8) {
          t1 = J.get$error$x(this.box_2.source_4.get$_error());
          t2 = e;
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        t2 = this.box_1;
        if (t1)
          t2.listenerValueOrError_2 = this.box_2.source_4.get$_error();
        else
          t2.listenerValueOrError_2 = new P.AsyncError(e, s);
        t2.listenerHasValue_1 = false;
        return;
      }

      if (!!J.getInterceptor(t2).$isFuture) {
        result = J.get$result$x(this.listener_9);
        result.set$_isChained(true);
        this.box_1.isPropagationAborted_3 = true;
        t1.completeResult_0.then$2$onError(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(this.box_2, result), new P._Future__propagateToListeners_handleWhenCompleteCallback_closure0(t1, result));
      }
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure: {
    "^": "Closure:102;box_2,result_11",
    call$1: [function(ignored) {
      P._Future__propagateToListeners(this.box_2.source_4, new P._FutureListener(null, this.result_11, 0, null, null));
    }, "call$1", null, 2, 0, null, 1702, [], "call"]
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure0: {
    "^": "Closure:888;box_0,result_12",
    call$2: [function(error, stackTrace) {
      var t1, completeResult;
      t1 = this.box_0;
      if (!J.getInterceptor(t1.completeResult_0).$is_Future) {
        completeResult = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
        t1.completeResult_0 = completeResult;
        completeResult._setError$2(error, stackTrace);
      }
      P._Future__propagateToListeners(t1.completeResult_0, new P._FutureListener(null, this.result_12, 0, null, null));
    }, function(error) {
      return this.call$2(error, null);
    }, "call$1", "call$2", null, null, 2, 2, null, 12, 598, [], 599, [], "call"]
  },
  _AsyncCallbackEntry: {
    "^": "Object;callback<,next@",
    callback$0: function() {
      return this.callback.call$0();
    },
    callback$1: function(arg0) {
      return this.callback.call$1(arg0);
    },
    next$1: function(arg0) {
      return this.next.call$1(arg0);
    },
    next$0: function() {
      return this.next.call$0();
    }
  },
  Stream: {
    "^": "Object;",
    where$1: function(_, test) {
      return H.setRuntimeTypeInfo(new P._WhereStream(test, this), [H.getRuntimeTypeArgument(this, "Stream", 0)]);
    },
    map$1: [function(_, convert) {
      return H.setRuntimeTypeInfo(new P._MapStream(convert, this), [H.getRuntimeTypeArgument(this, "Stream", 0), null]);
    }, "call$1", "get$map", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "Stream__dynamic__T", ret: P.Stream, args: [{func: "dynamic__T0", args: [T]}]};
      }, this.$receiver, "Stream");
    }],
    fold$2: function(_, initialValue, combine) {
      var t1, result;
      t1 = {};
      result = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t1.value_0 = initialValue;
      t1.subscription_1 = null;
      t1.subscription_1 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_fold_closure(t1, this, combine, result), true, new P.Stream_fold_closure0(t1, result), new P.Stream_fold_closure1(result));
      return result;
    },
    join$1: function(_, separator) {
      var t1, result, buffer;
      t1 = {};
      result = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [P.String]);
      buffer = P.StringBuffer$("");
      t1.subscription_0 = null;
      t1.first_1 = true;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_join_closure(t1, this, separator, result, buffer), true, new P.Stream_join_closure0(result, buffer), new P.Stream_join_closure1(result));
      return result;
    },
    contains$1: [function(_, needle) {
      var t1, future;
      t1 = {};
      future = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [P.bool]);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_contains_closure(t1, this, needle, future), true, new P.Stream_contains_closure0(future), future.get$_completeError());
      return future;
    }, "call$1", "get$contains", 2, 0, 1703],
    forEach$1: function(_, action) {
      var t1, future;
      t1 = {};
      future = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_forEach_closure(t1, this, action, future), true, new P.Stream_forEach_closure0(future), future.get$_completeError());
      return future;
    },
    any$1: [function(_, test) {
      var t1, future;
      t1 = {};
      future = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [P.bool]);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_any_closure(t1, this, test, future), true, new P.Stream_any_closure0(future), future.get$_completeError());
      return future;
    }, "call$1", "get$any", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "Future__bool__T", ret: [P.Future, P.bool], args: [{func: "bool__T0", ret: P.bool, args: [T]}]};
      }, this.$receiver, "Stream");
    }],
    get$length: function(_) {
      var t1, future;
      t1 = {};
      future = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [P.$int]);
      t1.count_0 = 0;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    },
    get$isEmpty: function(_) {
      var t1, future;
      t1 = {};
      future = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [P.bool]);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_isEmpty_closure(t1, future), true, new P.Stream_isEmpty_closure0(future), future.get$_completeError());
      return future;
    },
    toList$0: function(_) {
      var result, future;
      result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      future = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [[P.List, H.getRuntimeTypeArgument(this, "Stream", 0)]]);
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_toList_closure(this, result), true, new P.Stream_toList_closure0(result, future), future.get$_completeError());
      return future;
    },
    get$last: function(_) {
      var t1, future;
      t1 = {};
      future = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      t1.result_0 = null;
      t1.foundResult_1 = false;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_last_closure(t1, this), true, new P.Stream_last_closure0(t1, future), future.get$_completeError());
      return future;
    },
    elementAt$1: function(_, index) {
      var t1, future;
      t1 = {};
      t1.index_0 = index;
      if (typeof index !== "number" || Math.floor(index) !== index || J.$lt$n(index, 0))
        throw H.wrapException(P.ArgumentError$(t1.index_0));
      future = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      t1.subscription_1 = null;
      t1.subscription_1 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_elementAt_closure(t1, this, future), true, new P.Stream_elementAt_closure0(t1, future), future.get$_completeError());
      return future;
    },
    $isStream: true
  },
  Stream_fold_closure: {
    "^": "Closure;box_0,this_1,combine_2,result_3",
    call$1: [function(element) {
      var t1 = this.box_0;
      P._runUserCode(new P.Stream_fold__closure(t1, this.combine_2, element), new P.Stream_fold__closure0(t1), P._cancelAndErrorClosure(t1.subscription_1, this.result_3));
    }, "call$1", null, 2, 0, null, 23, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_fold__closure: {
    "^": "Closure:54;box_0,combine_4,element_5",
    call$0: function() {
      return this.combine_4.call$2(this.box_0.value_0, this.element_5);
    }
  },
  Stream_fold__closure0: {
    "^": "Closure:102;box_0",
    call$1: function(newValue) {
      this.box_0.value_0 = newValue;
    }
  },
  Stream_fold_closure1: {
    "^": "Closure:959;result_6",
    call$2: [function(e, st) {
      this.result_6._completeError$2(e, st);
    }, "call$2", null, 4, 0, null, 356, [], 1704, [], "call"]
  },
  Stream_fold_closure0: {
    "^": "Closure:54;box_0,result_7",
    call$0: [function() {
      this.result_7._complete$1(this.box_0.value_0);
    }, "call$0", null, 0, 0, null, "call"]
  },
  Stream_join_closure: {
    "^": "Closure;box_0,this_1,separator_2,result_3,buffer_4",
    call$1: [function(element) {
      var e, s, t1, exception, t2;
      t1 = this.box_0;
      if (!t1.first_1)
        this.buffer_4.write$1(this.separator_2);
      t1.first_1 = false;
      try {
        this.buffer_4.write$1(element);
      } catch (exception) {
        t2 = H.unwrapException(exception);
        e = t2;
        s = new H._StackTrace(exception, null);
        t1 = t1.subscription_0;
        $.Zone__current.toString;
        P._cancelAndError(t1, this.result_3, e, s);
      }

    }, "call$1", null, 2, 0, null, 23, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_join_closure1: {
    "^": "Closure:102;result_5",
    call$1: [function(e) {
      this.result_5._completeError$1(e);
    }, "call$1", null, 2, 0, null, 356, [], "call"]
  },
  Stream_join_closure0: {
    "^": "Closure:54;result_6,buffer_7",
    call$0: [function() {
      var t1 = this.buffer_7._contents;
      this.result_6._complete$1(t1.charCodeAt(0) == 0 ? t1 : t1);
    }, "call$0", null, 0, 0, null, "call"]
  },
  Stream_contains_closure: {
    "^": "Closure;box_0,this_1,needle_2,future_3",
    call$1: [function(element) {
      var t1, t2;
      t1 = this.box_0;
      t2 = this.future_3;
      P._runUserCode(new P.Stream_contains__closure(this.needle_2, element), new P.Stream_contains__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription_0, t2));
    }, "call$1", null, 2, 0, null, 23, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_contains__closure: {
    "^": "Closure:54;needle_4,element_5",
    call$0: function() {
      return J.$eq(this.element_5, this.needle_4);
    }
  },
  Stream_contains__closure0: {
    "^": "Closure:639;box_0,future_6",
    call$1: function(isMatch) {
      if (isMatch === true)
        P._cancelAndValue(this.box_0.subscription_0, this.future_6, true);
    }
  },
  Stream_contains_closure0: {
    "^": "Closure:54;future_7",
    call$0: [function() {
      this.future_7._complete$1(false);
    }, "call$0", null, 0, 0, null, "call"]
  },
  Stream_forEach_closure: {
    "^": "Closure;box_0,this_1,action_2,future_3",
    call$1: [function(element) {
      P._runUserCode(new P.Stream_forEach__closure(this.action_2, element), new P.Stream_forEach__closure0(), P._cancelAndErrorClosure(this.box_0.subscription_0, this.future_3));
    }, "call$1", null, 2, 0, null, 23, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_forEach__closure: {
    "^": "Closure:54;action_4,element_5",
    call$0: function() {
      return this.action_4.call$1(this.element_5);
    }
  },
  Stream_forEach__closure0: {
    "^": "Closure:102;",
    call$1: function(_) {
    }
  },
  Stream_forEach_closure0: {
    "^": "Closure:54;future_6",
    call$0: [function() {
      this.future_6._complete$1(null);
    }, "call$0", null, 0, 0, null, "call"]
  },
  Stream_any_closure: {
    "^": "Closure;box_0,this_1,test_2,future_3",
    call$1: [function(element) {
      var t1, t2;
      t1 = this.box_0;
      t2 = this.future_3;
      P._runUserCode(new P.Stream_any__closure(this.test_2, element), new P.Stream_any__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription_0, t2));
    }, "call$1", null, 2, 0, null, 23, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_any__closure: {
    "^": "Closure:54;test_4,element_5",
    call$0: function() {
      return this.test_4.call$1(this.element_5);
    }
  },
  Stream_any__closure0: {
    "^": "Closure:639;box_0,future_6",
    call$1: function(isMatch) {
      if (isMatch === true)
        P._cancelAndValue(this.box_0.subscription_0, this.future_6, true);
    }
  },
  Stream_any_closure0: {
    "^": "Closure:54;future_7",
    call$0: [function() {
      this.future_7._complete$1(false);
    }, "call$0", null, 0, 0, null, "call"]
  },
  Stream_length_closure: {
    "^": "Closure:102;box_0",
    call$1: [function(_) {
      ++this.box_0.count_0;
    }, "call$1", null, 2, 0, null, 1686, [], "call"]
  },
  Stream_length_closure0: {
    "^": "Closure:54;box_0,future_1",
    call$0: [function() {
      this.future_1._complete$1(this.box_0.count_0);
    }, "call$0", null, 0, 0, null, "call"]
  },
  Stream_isEmpty_closure: {
    "^": "Closure:102;box_0,future_1",
    call$1: [function(_) {
      P._cancelAndValue(this.box_0.subscription_0, this.future_1, false);
    }, "call$1", null, 2, 0, null, 1686, [], "call"]
  },
  Stream_isEmpty_closure0: {
    "^": "Closure:54;future_2",
    call$0: [function() {
      this.future_2._complete$1(true);
    }, "call$0", null, 0, 0, null, "call"]
  },
  Stream_toList_closure: {
    "^": "Closure;this_0,result_1",
    call$1: [function(data) {
      this.result_1.push(data);
    }, "call$1", null, 2, 0, null, 87, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_0, "Stream");
    }
  },
  Stream_toList_closure0: {
    "^": "Closure:54;result_2,future_3",
    call$0: [function() {
      this.future_3._complete$1(this.result_2);
    }, "call$0", null, 0, 0, null, "call"]
  },
  Stream_last_closure: {
    "^": "Closure;box_0,this_1",
    call$1: [function(value) {
      var t1 = this.box_0;
      t1.foundResult_1 = true;
      t1.result_0 = value;
    }, "call$1", null, 2, 0, null, 138, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_last_closure0: {
    "^": "Closure:54;box_0,future_2",
    call$0: [function() {
      var e, s, t1, exception;
      t1 = this.box_0;
      if (t1.foundResult_1) {
        this.future_2._complete$1(t1.result_0);
        return;
      }
      try {
        t1 = H.IterableElementError_noElement();
        throw H.wrapException(t1);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        P._completeWithErrorCallback(this.future_2, e, s);
      }

    }, "call$0", null, 0, 0, null, "call"]
  },
  Stream_elementAt_closure: {
    "^": "Closure;box_0,this_1,future_2",
    call$1: [function(value) {
      var t1 = this.box_0;
      if (J.$eq(t1.index_0, 0)) {
        P._cancelAndValue(t1.subscription_1, this.future_2, value);
        return;
      }
      t1.index_0 = J.$sub$n(t1.index_0, 1);
    }, "call$1", null, 2, 0, null, 138, [], "call"],
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_elementAt_closure0: {
    "^": "Closure:54;box_0,future_3",
    call$0: [function() {
      this.future_3._completeError$1(P.RangeError$value(this.box_0.index_0, null, null));
    }, "call$0", null, 0, 0, null, "call"]
  },
  StreamSubscription: {
    "^": "Object;",
    $isStreamSubscription: true
  },
  _ControllerStream: {
    "^": "_StreamImpl;",
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      return this._async$_controller._subscribe$4(onData, onError, onDone, cancelOnError);
    },
    get$hashCode: function(_) {
      return (H.Primitives_objectHashCode(this._async$_controller) ^ 892482866) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$is_ControllerStream)
        return false;
      return other._async$_controller === this._async$_controller;
    },
    $is_ControllerStream: true
  },
  _ControllerSubscription: {
    "^": "_BufferingStreamSubscription;_async$_controller<",
    _onCancel$0: function() {
      return this.get$_async$_controller()._recordCancel$1(this);
    },
    _async$_onPause$0: [function() {
      this.get$_async$_controller()._recordPause$1(this);
    }, "call$0", "get$_async$_onPause", 0, 0, 17],
    _async$_onResume$0: [function() {
      this.get$_async$_controller()._recordResume$1(this);
    }, "call$0", "get$_async$_onResume", 0, 0, 17]
  },
  _EventSink: {
    "^": "Object;"
  },
  _BufferingStreamSubscription: {
    "^": "Object;_async$_onData,_onError<,_onDone,_zone<,_state,_cancelFuture,_pending",
    onError$1: [function(_, handleError) {
      if (handleError == null)
        handleError = P._nullErrorHandler$closure();
      this._onError = P._registerErrorHandler(handleError, this._zone);
    }, "call$1", "get$onError", 2, 0, 1705],
    pause$1: function(_, resumeSignal) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      this._state = (t1 + 128 | 4) >>> 0;
      if (t1 < 128 && this._pending != null)
        this._pending.cancelSchedule$0();
      if ((t1 & 4) === 0 && (this._state & 32) === 0)
        this._guardCallback$1(this.get$_async$_onPause());
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function() {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 >= 128) {
        t1 -= 128;
        this._state = t1;
        if (t1 < 128) {
          if ((t1 & 64) !== 0) {
            t1 = this._pending;
            t1 = !t1.get$isEmpty(t1);
          } else
            t1 = false;
          if (t1)
            this._pending.schedule$1(this);
          else {
            t1 = (this._state & 4294967291) >>> 0;
            this._state = t1;
            if ((t1 & 32) === 0)
              this._guardCallback$1(this.get$_async$_onResume());
          }
        }
      }
    },
    cancel$0: function() {
      var t1 = (this._state & 4294967279) >>> 0;
      this._state = t1;
      if ((t1 & 8) !== 0)
        return this._cancelFuture;
      this._cancel$0();
      return this._cancelFuture;
    },
    get$isPaused: function() {
      return this._state >= 128;
    },
    _cancel$0: function() {
      var t1 = (this._state | 8) >>> 0;
      this._state = t1;
      if ((t1 & 64) !== 0)
        this._pending.cancelSchedule$0();
      if ((this._state & 32) === 0)
        this._pending = null;
      this._cancelFuture = this._onCancel$0();
    },
    _async$_add$1: function(data) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendData$1(data);
      else
        this._addPending$1(H.setRuntimeTypeInfo(new P._DelayedData(data, null), [null]));
    },
    _addError$2: function(error, stackTrace) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendError$2(error, stackTrace);
      else
        this._addPending$1(new P._DelayedError(error, stackTrace, null));
    },
    _close$0: function() {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      t1 = (t1 | 2) >>> 0;
      this._state = t1;
      if (t1 < 32)
        this._sendDone$0();
      else
        this._addPending$1(C.C__DelayedDone);
    },
    _async$_onPause$0: [function() {
    }, "call$0", "get$_async$_onPause", 0, 0, 17],
    _async$_onResume$0: [function() {
    }, "call$0", "get$_async$_onResume", 0, 0, 17],
    _onCancel$0: function() {
      return;
    },
    _addPending$1: function($event) {
      var pending, t1;
      pending = this._pending;
      if (pending == null) {
        pending = new P._StreamImplEvents(null, null, 0);
        this._pending = pending;
      }
      pending.add$1(0, $event);
      t1 = this._state;
      if ((t1 & 64) === 0) {
        t1 = (t1 | 64) >>> 0;
        this._state = t1;
        if (t1 < 128)
          this._pending.schedule$1(this);
      }
    },
    _sendData$1: function(data) {
      var t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      this._zone.runUnaryGuarded$2(this._async$_onData, data);
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _sendError$2: function(error, stackTrace) {
      var t1, t2;
      t1 = this._state;
      t2 = new P._BufferingStreamSubscription__sendError_sendError(this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        this._state = (t1 | 16) >>> 0;
        this._cancel$0();
        t1 = this._cancelFuture;
        if (!!J.getInterceptor(t1).$isFuture)
          t1.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0: function() {
      var t1, t2;
      t1 = new P._BufferingStreamSubscription__sendDone_sendDone(this);
      this._cancel$0();
      this._state = (this._state | 16) >>> 0;
      t2 = this._cancelFuture;
      if (!!J.getInterceptor(t2).$isFuture)
        t2.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1: function(callback) {
      var t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      callback.call$0();
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1: function(wasInputPaused) {
      var t1, isInputPaused;
      if ((this._state & 64) !== 0) {
        t1 = this._pending;
        t1 = t1.get$isEmpty(t1);
      } else
        t1 = false;
      if (t1) {
        t1 = (this._state & 4294967231) >>> 0;
        this._state = t1;
        if ((t1 & 4) !== 0)
          if (t1 < 128) {
            t1 = this._pending;
            t1 = t1 == null || t1.get$isEmpty(t1);
          } else
            t1 = false;
        else
          t1 = false;
        if (t1)
          this._state = (this._state & 4294967291) >>> 0;
      }
      for (; true; wasInputPaused = isInputPaused) {
        t1 = this._state;
        if ((t1 & 8) !== 0) {
          this._pending = null;
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        this._state = (t1 ^ 32) >>> 0;
        if (isInputPaused)
          this._async$_onPause$0();
        else
          this._async$_onResume$0();
        this._state = (this._state & 4294967263) >>> 0;
      }
      t1 = this._state;
      if ((t1 & 64) !== 0 && t1 < 128)
        this._pending.schedule$1(this);
    },
    _BufferingStreamSubscription$4: function(onData, onError, onDone, cancelOnError, $T) {
      this._zone.toString;
      this._async$_onData = onData;
      this.onError$1(0, onError);
      this._onDone = onDone == null ? P._nullDoneHandler$closure() : onDone;
    },
    $isStreamSubscription: true,
    static: {"^": "_BufferingStreamSubscription__STATE_CANCEL_ON_ERROR,_BufferingStreamSubscription__STATE_CLOSED,_BufferingStreamSubscription__STATE_INPUT_PAUSED,_BufferingStreamSubscription__STATE_CANCELED,_BufferingStreamSubscription__STATE_WAIT_FOR_CANCEL,_BufferingStreamSubscription__STATE_IN_CALLBACK,_BufferingStreamSubscription__STATE_HAS_PENDING,_BufferingStreamSubscription__STATE_PAUSE_COUNT,_BufferingStreamSubscription__STATE_PAUSE_COUNT_SHIFT", _BufferingStreamSubscription$: function(onData, onError, onDone, cancelOnError, $T) {
        var t1, t2;
        t1 = $.Zone__current;
        t2 = cancelOnError ? 1 : 0;
        t2 = H.setRuntimeTypeInfo(new P._BufferingStreamSubscription(null, null, null, t1, t2, null, null), [$T]);
        t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
        return t2;
      }}
  },
  _BufferingStreamSubscription__sendError_sendError: {
    "^": "Closure:17;this_0,error_1,stackTrace_2",
    call$0: [function() {
      var t1, t2, t3, t4, t5, t6;
      t1 = this.this_0;
      t2 = t1._state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._state = (t2 | 32) >>> 0;
      t2 = t1._onError;
      t3 = H.getDynamicRuntimeType();
      t3 = H.buildFunctionType(t3, [t3, t3])._isTest$1(t2);
      t4 = t1._zone;
      t5 = this.error_1;
      t6 = t1._onError;
      if (t3)
        t4.runBinaryGuarded$3(t6, t5, this.stackTrace_2);
      else
        t4.runUnaryGuarded$2(t6, t5);
      t1._state = (t1._state & 4294967263) >>> 0;
    }, "call$0", null, 0, 0, null, "call"]
  },
  _BufferingStreamSubscription__sendDone_sendDone: {
    "^": "Closure:17;this_0",
    call$0: [function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 42) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967263) >>> 0;
    }, "call$0", null, 0, 0, null, "call"]
  },
  _StreamImpl: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      return this._createSubscription$4(onData, onError, onDone, true === cancelOnError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      return P._BufferingStreamSubscription$(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
    }
  },
  _DelayedEvent: {
    "^": "Object;next@",
    next$1: function(arg0) {
      return this.next.call$1(arg0);
    },
    next$0: function() {
      return this.next.call$0();
    }
  },
  _DelayedData: {
    "^": "_DelayedEvent;value>,next",
    perform$1: function(dispatch) {
      dispatch._sendData$1(this.value);
    }
  },
  _DelayedError: {
    "^": "_DelayedEvent;error>,stackTrace<,next",
    perform$1: function(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    }
  },
  _DelayedDone: {
    "^": "Object;",
    perform$1: function(dispatch) {
      dispatch._sendDone$0();
    },
    get$next: function() {
      return;
    },
    next$1: function(arg0) {
      return this.get$next().call$1(arg0);
    },
    next$0: function() {
      return this.get$next().call$0();
    },
    set$next: function(_) {
      throw H.wrapException(P.StateError$("No events after a done."));
    }
  },
  _PendingEvents: {
    "^": "Object;",
    schedule$1: function(dispatch) {
      var t1 = this._state;
      if (t1 === 1)
        return;
      if (t1 >= 1) {
        this._state = 1;
        return;
      }
      P.scheduleMicrotask(new P._PendingEvents_schedule_closure(this, dispatch));
      this._state = 1;
    },
    cancelSchedule$0: function() {
      if (this._state === 1)
        this._state = 3;
    }
  },
  _PendingEvents_schedule_closure: {
    "^": "Closure:54;this_0,dispatch_1",
    call$0: function() {
      var t1, oldState;
      t1 = this.this_0;
      oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t1.handleNext$1(this.dispatch_1);
    }
  },
  _StreamImplEvents: {
    "^": "_PendingEvents;firstPendingEvent,lastPendingEvent,_state",
    get$isEmpty: function(_) {
      return this.lastPendingEvent == null;
    },
    add$1: [function(_, $event) {
      var t1 = this.lastPendingEvent;
      if (t1 == null) {
        this.lastPendingEvent = $event;
        this.firstPendingEvent = $event;
      } else {
        t1.set$next($event);
        this.lastPendingEvent = $event;
      }
    }, "call$1", "get$add", 2, 0, 1706, 666, []],
    handleNext$1: function(dispatch) {
      var $event, t1;
      $event = this.firstPendingEvent;
      t1 = $event.get$next();
      this.firstPendingEvent = t1;
      if (t1 == null)
        this.lastPendingEvent = null;
      $event.perform$1(dispatch);
    },
    clear$0: function(_) {
      if (this._state === 1)
        this._state = 3;
      this.lastPendingEvent = null;
      this.firstPendingEvent = null;
    }
  },
  _DoneStreamSubscription: {
    "^": "Object;_zone<,_state,_onDone",
    get$isPaused: function() {
      return this._state >= 4;
    },
    _schedule$0: function() {
      var t1, t2;
      if ((this._state & 2) !== 0)
        return;
      t1 = this._zone;
      t2 = this.get$_sendDone();
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, t2);
      this._state = (this._state | 2) >>> 0;
    },
    onError$1: [function(_, handleError) {
    }, "call$1", "get$onError", 2, 0, 1705],
    pause$1: function(_, resumeSignal) {
      this._state += 4;
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function() {
      var t1 = this._state;
      if (t1 >= 4) {
        t1 -= 4;
        this._state = t1;
        if (t1 < 4 && (t1 & 1) === 0)
          this._schedule$0();
      }
    },
    cancel$0: function() {
      return;
    },
    _sendDone$0: [function() {
      var t1 = (this._state & 4294967293) >>> 0;
      this._state = t1;
      if (t1 >= 4)
        return;
      this._state = (t1 | 1) >>> 0;
      this._zone.runGuarded$1(this._onDone);
    }, "call$0", "get$_sendDone", 0, 0, 17],
    $isStreamSubscription: true,
    static: {"^": "_DoneStreamSubscription__DONE_SENT,_DoneStreamSubscription__SCHEDULED,_DoneStreamSubscription__PAUSED"}
  },
  _cancelAndError_closure: {
    "^": "Closure:54;future_0,error_1,stackTrace_2",
    call$0: [function() {
      return this.future_0._completeError$2(this.error_1, this.stackTrace_2);
    }, "call$0", null, 0, 0, null, "call"]
  },
  _cancelAndErrorClosure_closure: {
    "^": "Closure:1707;subscription_0,future_1",
    call$2: function(error, stackTrace) {
      return P._cancelAndError(this.subscription_0, this.future_1, error, stackTrace);
    }
  },
  _cancelAndValue_closure: {
    "^": "Closure:54;future_0,value_1",
    call$0: [function() {
      return this.future_0._complete$1(this.value_1);
    }, "call$0", null, 0, 0, null, "call"]
  },
  _ForwardingStream: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1, t2, t3, t4;
      cancelOnError = true === cancelOnError;
      t1 = H.getRuntimeTypeArgument(this, "_ForwardingStream", 0);
      t2 = H.getRuntimeTypeArgument(this, "_ForwardingStream", 1);
      t3 = $.Zone__current;
      t4 = cancelOnError ? 1 : 0;
      t4 = H.setRuntimeTypeInfo(new P._ForwardingStreamSubscription(this, null, null, null, null, t3, t4, null, null), [t1, t2]);
      t4._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t2);
      t4._ForwardingStreamSubscription$5(this, onData, onError, onDone, cancelOnError, t1, t2);
      return t4;
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    _handleData$2: function(data, sink) {
      sink._async$_add$1(data);
    },
    $asStream: function($S, $T) {
      return [$T];
    }
  },
  _ForwardingStreamSubscription: {
    "^": "_BufferingStreamSubscription;_stream,_subscription,_async$_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    _async$_add$1: function(data) {
      if ((this._state & 2) !== 0)
        return;
      P._BufferingStreamSubscription.prototype._async$_add$1.call(this, data);
    },
    _addError$2: function(error, stackTrace) {
      if ((this._state & 2) !== 0)
        return;
      P._BufferingStreamSubscription.prototype._addError$2.call(this, error, stackTrace);
    },
    _async$_onPause$0: [function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.pause$0(0);
    }, "call$0", "get$_async$_onPause", 0, 0, 17],
    _async$_onResume$0: [function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.resume$0();
    }, "call$0", "get$_async$_onResume", 0, 0, 17],
    _onCancel$0: function() {
      var t1 = this._subscription;
      if (t1 != null) {
        this._subscription = null;
        t1.cancel$0();
      }
      return;
    },
    _handleData$1: [function(data) {
      this._stream._handleData$2(data, this);
    }, "call$1", "get$_handleData", 2, 0, function() {
      return H.computeSignature(function(S, T) {
        return {func: "void__S", void: true, args: [S]};
      }, this.$receiver, "_ForwardingStreamSubscription");
    }, 87, []],
    _handleError$2: [function(error, stackTrace) {
      this._addError$2(error, stackTrace);
    }, "call$2", "get$_handleError", 4, 0, 1708, 598, [], 599, []],
    _handleDone$0: [function() {
      this._close$0();
    }, "call$0", "get$_handleDone", 0, 0, 17],
    _ForwardingStreamSubscription$5: function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
      var t1, t2;
      t1 = this.get$_handleData();
      t2 = this.get$_handleError();
      this._subscription = this._stream._async$_source.listen$3$onDone$onError(t1, this.get$_handleDone(), t2);
    },
    $as_BufferingStreamSubscription: function($S, $T) {
      return [$T];
    },
    $asStreamSubscription: function($S, $T) {
      return [$T];
    }
  },
  _WhereStream: {
    "^": "_ForwardingStream;_test,_async$_source",
    _test$1: function(arg0) {
      return this._test.call$1(arg0);
    },
    _handleData$2: function(inputEvent, sink) {
      var satisfies, e, s, exception, t1;
      satisfies = null;
      try {
        satisfies = this._test$1(inputEvent);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        P._addErrorWithReplacement(sink, e, s);
        return;
      }

      if (satisfies === true)
        sink._async$_add$1(inputEvent);
    },
    $as_ForwardingStream: function($T) {
      return [$T, $T];
    },
    $asStream: null
  },
  _MapStream: {
    "^": "_ForwardingStream;_transform,_async$_source",
    _transform$1: function(arg0) {
      return this._transform.call$1(arg0);
    },
    _handleData$2: function(inputEvent, sink) {
      var outputEvent, e, s, exception, t1;
      outputEvent = null;
      try {
        outputEvent = this._transform$1(inputEvent);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        P._addErrorWithReplacement(sink, e, s);
        return;
      }

      sink._async$_add$1(outputEvent);
    }
  },
  AsyncError: {
    "^": "Object;error>,stackTrace<",
    toString$0: function(_) {
      return J.toString$0(this.error);
    },
    $isError: true
  },
  _Zone: {
    "^": "Object;"
  },
  _rootHandleUncaughtError_closure: {
    "^": "Closure:54;error_0,stackTrace_1",
    call$0: function() {
      throw H.wrapException(P._UncaughtAsyncError$(this.error_0, this.stackTrace_1));
    }
  },
  _RootZone: {
    "^": "_Zone;",
    get$parent: function(_) {
      return;
    },
    get$errorZone: function() {
      return this;
    },
    runGuarded$1: function(f) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$0();
          return t1;
        }
        t1 = P._rootRun(null, null, this, f);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    runUnaryGuarded$2: function(f, arg) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$1(arg);
          return t1;
        }
        t1 = P._rootRunUnary(null, null, this, f, arg);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    runBinaryGuarded$3: function(f, arg1, arg2) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$2(arg1, arg2);
          return t1;
        }
        t1 = P._rootRunBinary(null, null, this, f, arg1, arg2);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    bindCallback$2$runGuarded: function(f, runGuarded) {
      if (runGuarded)
        return new P._RootZone_bindCallback_closure(this, f);
      else
        return new P._RootZone_bindCallback_closure0(this, f);
    },
    bindUnaryCallback$2$runGuarded: function(f, runGuarded) {
      if (runGuarded)
        return new P._RootZone_bindUnaryCallback_closure(this, f);
      else
        return new P._RootZone_bindUnaryCallback_closure0(this, f);
    },
    $index: function(_, key) {
      return;
    },
    run$1: function(f) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$0();
      return P._rootRun(null, null, this, f);
    },
    runUnary$2: function(f, arg) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$1(arg);
      return P._rootRunUnary(null, null, this, f, arg);
    },
    runBinary$3: function(f, arg1, arg2) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$2(arg1, arg2);
      return P._rootRunBinary(null, null, this, f, arg1, arg2);
    },
    static: {"^": "_RootZone__rootMap,_RootZone__rootDelegate"}
  },
  _RootZone_bindCallback_closure: {
    "^": "Closure:54;this_0,f_1",
    call$0: [function() {
      return this.this_0.runGuarded$1(this.f_1);
    }, "call$0", null, 0, 0, null, "call"]
  },
  _RootZone_bindCallback_closure0: {
    "^": "Closure:54;this_2,f_3",
    call$0: [function() {
      return this.this_2.run$1(this.f_3);
    }, "call$0", null, 0, 0, null, "call"]
  },
  _RootZone_bindUnaryCallback_closure: {
    "^": "Closure:102;this_0,f_1",
    call$1: [function(arg) {
      return this.this_0.runUnaryGuarded$2(this.f_1, arg);
    }, "call$1", null, 2, 0, null, 1709, [], "call"]
  },
  _RootZone_bindUnaryCallback_closure0: {
    "^": "Closure:102;this_2,f_3",
    call$1: [function(arg) {
      return this.this_2.runUnary$2(this.f_3, arg);
    }, "call$1", null, 2, 0, null, 1709, [], "call"]
  }
}],
["dart.collection", "dart:collection", , P, {
  "^": "",
  LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
    return H.fillLiteralMap(keyValuePairs, H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]));
  },
  LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  _defaultEquals: [function(a, b) {
    return J.$eq(a, b);
  }, "call$2", "_defaultEquals$closure", 4, 0, 600],
  _defaultHashCode: [function(a) {
    return J.get$hashCode$(a);
  }, "call$1", "_defaultHashCode$closure", 2, 0, 156, 348, []],
  HashMap_HashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._HashMap(0, null, null, null, null), [$K, $V]);
  },
  IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
    var parts, t1;
    if (P.IterableBase__isToStringVisiting(iterable)) {
      if (leftDelimiter === "(" && rightDelimiter === ")")
        return "(...)";
      return leftDelimiter + "..." + rightDelimiter;
    }
    parts = [];
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      P.IterableBase__iterablePartsToStrings(iterable, parts);
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = P.StringBuffer$(leftDelimiter);
    t1.writeAll$2(parts, ", ");
    t1.write$1(rightDelimiter);
    t1 = t1._contents;
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
    var buffer, t1;
    if (P.IterableBase__isToStringVisiting(iterable))
      return leftDelimiter + "..." + rightDelimiter;
    buffer = P.StringBuffer$(leftDelimiter);
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      buffer.writeAll$2(iterable, ", ");
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    buffer.write$1(rightDelimiter);
    t1 = buffer.get$_contents();
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  IterableBase__isToStringVisiting: function(o) {
    var i, t1;
    for (i = 0; t1 = $.get$IterableBase__toStringVisiting(), i < t1.length; ++i) {
      t1 = t1[i];
      if (o == null ? t1 == null : o === t1)
        return true;
    }
    return false;
  },
  IterableBase__iterablePartsToStrings: function(iterable, parts) {
    var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision;
    it = iterable.get$iterator(iterable);
    $length = 0;
    count = 0;
    while (true) {
      if (!($length < 80 || count < 3))
        break;
      if (!it.moveNext$0())
        return;
      next = H.S(it.get$current());
      parts.push(next);
      $length += next.length + 2;
      ++count;
    }
    if (!it.moveNext$0()) {
      if (count <= 5)
        return;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      ultimateString = parts.pop();
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      penultimateString = parts.pop();
    } else {
      penultimate = it.get$current();
      ++count;
      if (!it.moveNext$0()) {
        if (count <= 4) {
          parts.push(H.S(penultimate));
          return;
        }
        ultimateString = H.S(penultimate);
        if (0 >= parts.length)
          return H.ioore(parts, 0);
        penultimateString = parts.pop();
        $length += ultimateString.length + 2;
      } else {
        ultimate = it.get$current();
        ++count;
        for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
          ultimate0 = it.get$current();
          ++count;
          if (count > 100) {
            while (true) {
              if (!($length > 75 && count > 3))
                break;
              if (0 >= parts.length)
                return H.ioore(parts, 0);
              $length -= parts.pop().length + 2;
              --count;
            }
            parts.push("...");
            return;
          }
        }
        penultimateString = H.S(penultimate);
        ultimateString = H.S(ultimate);
        $length += ultimateString.length + penultimateString.length + 4;
      }
    }
    if (count > parts.length + 2) {
      $length += 5;
      elision = "...";
    } else
      elision = null;
    while (true) {
      if (!($length > 80 && parts.length > 3))
        break;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      $length -= parts.pop().length + 2;
      if (elision == null) {
        $length += 5;
        elision = "...";
      }
    }
    if (elision != null)
      parts.push(elision);
    parts.push(penultimateString);
    parts.push(ultimateString);
  },
  LinkedHashMap_LinkedHashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  LinkedHashSet_LinkedHashSet: function(equals, hashCode, isValidKey, $E) {
    return H.setRuntimeTypeInfo(new P._LinkedHashSet(0, null, null, null, null, null, 0), [$E]);
  },
  Maps_mapToString: function(m) {
    var t1, result;
    t1 = {};
    if (P.IterableBase__isToStringVisiting(m))
      return "{...}";
    result = P.StringBuffer$("");
    try {
      $.get$IterableBase__toStringVisiting().push(m);
      result.write$1("{");
      t1.first_0 = true;
      J.forEach$1$ax(m, new P.Maps_mapToString_closure(t1, result));
      result.write$1("}");
    } finally {
      t1 = $.get$IterableBase__toStringVisiting();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = result.get$_contents();
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  _HashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_collection$_keys",
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    get$keys: function(_) {
      return H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._HashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    containsKey$1: function(_, key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        return strings == null ? false : strings[key] != null;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        return nums == null ? false : nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
    },
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new P._HashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, t1, entry, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          t1 = null;
        else {
          entry = strings[key];
          t1 = entry === strings ? null : entry;
        }
        return t1;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          t1 = null;
        else {
          entry = nums[key];
          t1 = entry === nums ? null : entry;
        }
        return t1;
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._HashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._HashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._HashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        P._HashMap__setTableEntry(rest, hash, [key, value]);
        ++this._collection$_length;
        this._collection$_keys = null;
      } else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index + 1] = value;
        else {
          bucket.push(key, value);
          ++this._collection$_length;
          this._collection$_keys = null;
        }
      }
    },
    remove$1: function(_, key) {
      if (typeof key === "string" && key !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return this._removeHashTableEntry$2(this._nums, key);
      else
        return this._remove$1(key);
    },
    _remove$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      --this._collection$_length;
      this._collection$_keys = null;
      return bucket.splice(index, 2)[1];
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._collection$_keys = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
      }
    },
    forEach$1: function(_, action) {
      var keys, $length, i, key;
      keys = this._collection$_computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        key = keys[i];
        action.call$2(key, this.$index(0, key));
        if (keys !== this._collection$_keys)
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    _collection$_computeKeys$0: function() {
      var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
      t1 = this._collection$_keys;
      if (t1 != null)
        return t1;
      result = Array(this._collection$_length);
      result.fixed$length = init;
      strings = this._strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = this._nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = this._rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; i0 += 2) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      this._collection$_keys = result;
      return result;
    },
    _addHashTableEntry$3: function(table, key, value) {
      if (table[key] == null) {
        ++this._collection$_length;
        this._collection$_keys = null;
      }
      P._HashMap__setTableEntry(table, key, value);
    },
    _removeHashTableEntry$2: function(table, key) {
      var value;
      if (table != null && table[key] != null) {
        value = P._HashMap__getTableEntry(table, key);
        delete table[key];
        --this._collection$_length;
        this._collection$_keys = null;
        return value;
      } else
        return;
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2)
        if (J.$eq(bucket[i], key))
          return i;
      return -1;
    },
    $isMap: true,
    $asMap: null,
    static: {_HashMap__getTableEntry: function(table, key) {
        var entry = table[key];
        return entry === table ? null : entry;
      }, _HashMap__setTableEntry: function(table, key, value) {
        if (value == null)
          table[key] = table;
        else
          table[key] = value;
      }, _HashMap__newHashTable: function() {
        var table = Object.create(null);
        P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _HashMap_values_closure: {
    "^": "Closure:102;this_0",
    call$1: [function(each) {
      return this.this_0.$index(0, each);
    }, "call$1", null, 2, 0, null, 1710, [], "call"]
  },
  _HashMap_addAll_closure: {
    "^": "Closure;this_0",
    call$2: [function(key, value) {
      this.this_0.$indexSet(0, key, value);
    }, "call$2", null, 4, 0, null, 269, [], 138, [], "call"],
    $signature: function() {
      return H.computeSignature(function(K, V) {
        return {func: "dynamic__K_V", args: [K, V]};
      }, this.this_0, "_HashMap");
    }
  },
  HashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._map._collection$_length === 0;
    },
    get$iterator: function(_) {
      var t1 = this._map;
      t1 = new P.HashMapKeyIterator(t1, t1._collection$_computeKeys$0(), 0, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    contains$1: [function(_, element) {
      return this._map.containsKey$1(0, element);
    }, "call$1", "get$contains", 2, 0, 1693],
    forEach$1: function(_, f) {
      var t1, keys, $length, i;
      t1 = this._map;
      keys = t1._collection$_computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        f.call$1(keys[i]);
        if (keys !== t1._collection$_keys)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
      }
    },
    $isEfficientLength: true
  },
  HashMapKeyIterator: {
    "^": "Object;_map,_collection$_keys,_offset,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var keys, offset, t1;
      keys = this._collection$_keys;
      offset = this._offset;
      t1 = this._map;
      if (keys !== t1._collection$_keys)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= keys.length) {
        this._collection$_current = null;
        return false;
      } else {
        this._collection$_current = keys[offset];
        this._offset = offset + 1;
        return true;
      }
    }
  },
  _LinkedHashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    get$keys: function(_) {
      return H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._LinkedHashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    containsKey$1: function(_, key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[key] != null;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
    },
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new P._LinkedHashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, cell, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return;
        cell = strings[key];
        return cell == null ? null : cell.get$_value();
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return;
        cell = nums[key];
        return cell == null ? null : cell.get$_value();
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      return bucket[index].get$_value();
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._LinkedHashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._LinkedHashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$2(key, value)];
      else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index].set$_value(value);
        else
          bucket.push(this._newLinkedCell$2(key, value));
      }
    },
    putIfAbsent$2: function(_, key, ifAbsent) {
      var value;
      if (this.containsKey$1(0, key))
        return this.$index(0, key);
      value = ifAbsent.call$0();
      this.$indexSet(0, key, value);
      return value;
    },
    remove$1: function(_, key) {
      if (typeof key === "string" && key !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return this._removeHashTableEntry$2(this._nums, key);
      else
        return this._remove$1(key);
    },
    _remove$1: function(key) {
      var rest, bucket, index, cell;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      cell = bucket.splice(index, 1)[0];
      this._unlinkCell$1(cell);
      return cell.get$_value();
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$2(cell.get$_key(cell), cell.get$_value());
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell.get$_next();
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      var cell = table[key];
      if (cell == null)
        table[key] = this._newLinkedCell$2(key, value);
      else
        cell.set$_value(value);
    },
    _removeHashTableEntry$2: function(table, key) {
      var cell;
      if (table == null)
        return;
      cell = table[key];
      if (cell == null)
        return;
      this._unlinkCell$1(cell);
      delete table[key];
      return cell.get$_value();
    },
    _newLinkedCell$2: function(key, value) {
      var cell, last;
      cell = new P.LinkedHashMapCell(key, value, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last.set$_next(cell);
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell.get$_previous();
      next = cell.get$_next();
      if (previous == null)
        this._first = next;
      else
        previous.set$_next(next);
      if (next == null)
        this._last = previous;
      else
        next.set$_previous(previous);
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(J.get$_key$x(bucket[i]), key))
          return i;
      return -1;
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    $isMap: true,
    $asMap: null,
    static: {_LinkedHashMap__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _LinkedHashMap_values_closure: {
    "^": "Closure:102;this_0",
    call$1: [function(each) {
      return this.this_0.$index(0, each);
    }, "call$1", null, 2, 0, null, 1710, [], "call"]
  },
  _LinkedHashMap_addAll_closure: {
    "^": "Closure;this_0",
    call$2: [function(key, value) {
      this.this_0.$indexSet(0, key, value);
    }, "call$2", null, 4, 0, null, 269, [], 138, [], "call"],
    $signature: function() {
      return H.computeSignature(function(K, V) {
        return {func: "dynamic__K_V0", args: [K, V]};
      }, this.this_0, "_LinkedHashMap");
    }
  },
  LinkedHashMapCell: {
    "^": "Object;_key>,_value@,_next@,_previous@"
  },
  LinkedHashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._map._collection$_length === 0;
    },
    get$iterator: function(_) {
      var t1, t2;
      t1 = this._map;
      t2 = new P.LinkedHashMapKeyIterator(t1, t1._modifications, null, null);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      t2._cell = t1._first;
      return t2;
    },
    contains$1: [function(_, element) {
      return this._map.containsKey$1(0, element);
    }, "call$1", "get$contains", 2, 0, 1693],
    forEach$1: function(_, f) {
      var t1, cell, modifications;
      t1 = this._map;
      cell = t1._first;
      modifications = t1._modifications;
      for (; cell != null;) {
        f.call$1(cell.get$_key(cell));
        if (modifications !== t1._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        cell = cell.get$_next();
      }
    },
    $isEfficientLength: true
  },
  LinkedHashMapKeyIterator: {
    "^": "Object;_map,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._map;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1.get$_key(t1);
          this._cell = this._cell.get$_next();
          return true;
        }
      }
    }
  },
  _LinkedHashSet: {
    "^": "_HashSetBase;_collection$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$iterator: function(_) {
      var t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(this, this._modifications, null, null), [null]);
      t1._cell = t1._set._first;
      return t1;
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    contains$1: [function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[object] != null;
      } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[object] != null;
      } else
        return this._contains$1(object);
    }, "call$1", "get$contains", 2, 0, 1693],
    _contains$1: function(object) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
    },
    lookup$1: function(object) {
      var t1;
      if (!(typeof object === "string" && object !== "__proto__"))
        t1 = typeof object === "number" && (object & 0x3ffffff) === object;
      else
        t1 = true;
      if (t1)
        return this.contains$1(0, object) ? object : null;
      else
        return this._lookup$1(object);
    },
    _lookup$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return;
      return J.$index$asx(bucket, index).get$_collection$_element();
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$1(cell.get$_collection$_element());
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell.get$_next();
      }
    },
    get$last: function(_) {
      var t1 = this._last;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No elements"));
      return t1.get$_collection$_element();
    },
    add$1: [function(_, element) {
      var strings, table, nums;
      if (typeof element === "string" && element !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._strings = table;
          strings = table;
        }
        return this._addHashTableEntry$2(strings, element);
      } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
        nums = this._nums;
        if (nums == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._nums = table;
          nums = table;
        }
        return this._addHashTableEntry$2(nums, element);
      } else
        return this._add$1(element);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__E1", ret: P.bool, args: [E]};
      }, this.$receiver, "_LinkedHashSet");
    }, 23, []],
    _add$1: function(element) {
      var rest, hash, bucket;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashSet__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$1(element)];
      else {
        if (this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(this._newLinkedCell$1(element));
      }
      return true;
    },
    remove$1: function(_, object) {
      if (typeof object === "string" && object !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, object);
      else if (typeof object === "number" && (object & 0x3ffffff) === object)
        return this._removeHashTableEntry$2(this._nums, object);
      else
        return this._remove$1(object);
    },
    _remove$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return false;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      this._unlinkCell$1(bucket.splice(index, 1)[0]);
      return true;
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    _addHashTableEntry$2: function(table, element) {
      if (table[element] != null)
        return false;
      table[element] = this._newLinkedCell$1(element);
      return true;
    },
    _removeHashTableEntry$2: function(table, element) {
      var cell;
      if (table == null)
        return false;
      cell = table[element];
      if (cell == null)
        return false;
      this._unlinkCell$1(cell);
      delete table[element];
      return true;
    },
    _newLinkedCell$1: function(element) {
      var cell, last;
      cell = new P.LinkedHashSetCell(element, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last.set$_next(cell);
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell.get$_previous();
      next = cell.get$_next();
      if (previous == null)
        this._first = next;
      else
        previous.set$_next(next);
      if (next == null)
        this._last = previous;
      else
        next.set$_previous(previous);
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i].get$_collection$_element(), element))
          return i;
      return -1;
    },
    $isEfficientLength: true,
    static: {_LinkedHashSet__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  LinkedHashSetCell: {
    "^": "Object;_collection$_element<,_next@,_previous@"
  },
  LinkedHashSetIterator: {
    "^": "Object;_set,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._set;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1.get$_collection$_element();
          this._cell = this._cell.get$_next();
          return true;
        }
      }
    }
  },
  UnmodifiableListView: {
    "^": "UnmodifiableListBase;_collection$_source",
    get$length: function(_) {
      return J.get$length$asx(this._collection$_source);
    },
    $index: function(_, index) {
      return J.elementAt$1$ax(this._collection$_source, index);
    }
  },
  _HashSetBase: {
    "^": "SetBase;"
  },
  IterableBase: {
    "^": "Object;",
    map$1: [function(_, f) {
      return H.MappedIterable_MappedIterable(this, f, H.getRuntimeTypeArgument(this, "IterableBase", 0), null);
    }, "call$1", "get$map", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "Iterable__dynamic__E1", ret: P.Iterable, args: [{func: "dynamic__E1", args: [E]}]};
      }, this.$receiver, "IterableBase");
    }],
    where$1: function(_, f) {
      return H.setRuntimeTypeInfo(new H.WhereIterable(this, f), [H.getRuntimeTypeArgument(this, "IterableBase", 0)]);
    },
    contains$1: [function(_, element) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (J.$eq(t1.get$current(), element))
          return true;
      return false;
    }, "call$1", "get$contains", 2, 0, 1693],
    forEach$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current());
    },
    reduce$1: function(_, combine) {
      var iterator, value;
      iterator = this.get$iterator(this);
      if (!iterator.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      value = iterator.get$current();
      for (; iterator.moveNext$0();)
        value = combine.call$2(value, iterator.get$current());
      return value;
    },
    fold$2: function(_, initialValue, combine) {
      var t1, value;
      for (t1 = this.get$iterator(this), value = initialValue; t1.moveNext$0();)
        value = combine.call$2(value, t1.get$current());
      return value;
    },
    join$1: function(_, separator) {
      var iterator, buffer, t1;
      iterator = this.get$iterator(this);
      if (!iterator.moveNext$0())
        return "";
      buffer = P.StringBuffer$("");
      if (separator === "") {
        do {
          t1 = H.S(iterator.get$current());
          buffer._contents += t1;
        } while (iterator.moveNext$0());
      } else {
        buffer.write$1(H.S(iterator.get$current()));
        for (; iterator.moveNext$0();) {
          buffer._contents += separator;
          t1 = H.S(iterator.get$current());
          buffer._contents += t1;
        }
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    any$1: [function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (f.call$1(t1.get$current()) === true)
          return true;
      return false;
    }, "call$1", "get$any", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__bool__E1", ret: P.bool, args: [{func: "bool__E2", ret: P.bool, args: [E]}]};
      }, this.$receiver, "IterableBase");
    }],
    toList$1$growable: function(_, growable) {
      return P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "IterableBase", 0));
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$length: function(_) {
      var it, count;
      it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    get$isEmpty: function(_) {
      return !this.get$iterator(this).moveNext$0();
    },
    get$isNotEmpty: function(_) {
      return this.get$isEmpty(this) !== true;
    },
    get$last: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = it.get$current();
      while (it.moveNext$0());
      return result;
    },
    firstWhere$2$orElse: function(_, test, orElse) {
      var t1, element;
      for (t1 = this.get$iterator(this); t1.moveNext$0();) {
        element = t1.get$current();
        if (test.call$1(element) === true)
          return element;
      }
      if (orElse != null)
        return orElse.call$0();
      throw H.wrapException(H.IterableElementError_noElement());
    },
    firstWhere$1: function($receiver, test) {
      return this.firstWhere$2$orElse($receiver, test, null);
    },
    elementAt$1: function(_, index) {
      var t1, remaining, element, t2;
      if (typeof index !== "number" || Math.floor(index) !== index || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      for (t1 = this.get$iterator(this), remaining = index; t1.moveNext$0();) {
        element = t1.get$current();
        t2 = J.getInterceptor(remaining);
        if (t2.$eq(remaining, 0))
          return element;
        remaining = t2.$sub(remaining, 1);
      }
      throw H.wrapException(P.RangeError$value(index, null, null));
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToShortString(this, "(", ")");
    }
  },
  ListBase: {
    "^": "Object_ListMixin;"
  },
  Object_ListMixin: {
    "^": "Object+ListMixin;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  ListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ListIterator(receiver, this.get$length(receiver), 0, null), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    forEach$1: function(receiver, action) {
      var $length, i;
      $length = this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        action.call$1(this.$index(receiver, i));
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    get$isEmpty: function(receiver) {
      return J.$eq(this.get$length(receiver), 0);
    },
    get$isNotEmpty: function(receiver) {
      return !this.get$isEmpty(receiver);
    },
    get$first: function(receiver) {
      if (J.$eq(this.get$length(receiver), 0))
        throw H.wrapException(H.IterableElementError_noElement());
      return this.$index(receiver, 0);
    },
    get$last: function(receiver) {
      if (J.$eq(this.get$length(receiver), 0))
        throw H.wrapException(H.IterableElementError_noElement());
      return this.$index(receiver, J.$sub$n(this.get$length(receiver), 1));
    },
    contains$1: [function(receiver, element) {
      var $length, t1, i, t2;
      $length = this.get$length(receiver);
      t1 = J.getInterceptor($length);
      i = 0;
      while (true) {
        t2 = this.get$length(receiver);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        if (J.$eq(this.$index(receiver, i), element))
          return true;
        if (!t1.$eq($length, this.get$length(receiver)))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
        ++i;
      }
      return false;
    }, "call$1", "get$contains", 2, 0, 1693],
    any$1: [function(receiver, test) {
      var $length, i;
      $length = this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        if (test.call$1(this.$index(receiver, i)) === true)
          return true;
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    }, "call$1", "get$any", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__bool__E2", ret: P.bool, args: [{func: "bool__E3", ret: P.bool, args: [E]}]};
      }, this.$receiver, "ListMixin");
    }],
    firstWhere$2$orElse: function(receiver, test, orElse) {
      var $length, i, element;
      $length = this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        element = this.$index(receiver, i);
        if (test.call$1(element) === true)
          return element;
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return orElse.call$0();
    },
    join$1: function(receiver, separator) {
      var buffer, t1;
      if (J.$eq(this.get$length(receiver), 0))
        return "";
      buffer = P.StringBuffer$("");
      buffer.writeAll$2(receiver, separator);
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    where$1: function(receiver, test) {
      return H.setRuntimeTypeInfo(new H.WhereIterable(receiver, test), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
    },
    map$1: [function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.MappedListIterable(receiver, f), [null, null]);
    }, "call$1", "get$map", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "Iterable__dynamic__E2", ret: P.Iterable, args: [{func: "dynamic__E2", args: [E]}]};
      }, this.$receiver, "ListMixin");
    }],
    fold$2: function(receiver, initialValue, combine) {
      var $length, value, i;
      $length = this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      value = initialValue;
      i = 0;
      for (; i < $length; ++i) {
        value = combine.call$2(value, this.$index(receiver, i));
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return value;
    },
    toList$1$growable: function(receiver, growable) {
      var result, t1, i;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(receiver));
      } else {
        t1 = this.get$length(receiver);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = Array(t1);
        t1.fixed$length = init;
        result = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      }
      i = 0;
      while (true) {
        t1 = this.get$length(receiver);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        t1 = this.$index(receiver, i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
        ++i;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    add$1: [function(receiver, element) {
      var t1 = this.get$length(receiver);
      this.set$length(receiver, J.$add$ns(t1, 1));
      this.$indexSet(receiver, t1, element);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E2", void: true, args: [E]};
      }, this.$receiver, "ListMixin");
    }, 23, []],
    addAll$1: function(receiver, iterable) {
      var t1, element, t2;
      for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0();) {
        element = t1.get$current();
        t2 = this.get$length(receiver);
        this.set$length(receiver, J.$add$ns(t2, 1));
        this.$indexSet(receiver, t2, element);
      }
    },
    remove$1: function(receiver, element) {
      var i, t1;
      i = 0;
      while (true) {
        t1 = this.get$length(receiver);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$eq(this.$index(receiver, i), element)) {
          this.setRange$4(receiver, i, J.$sub$n(this.get$length(receiver), 1), receiver, i + 1);
          this.set$length(receiver, J.$sub$n(this.get$length(receiver), 1));
          return true;
        }
        ++i;
      }
      return false;
    },
    clear$0: function(receiver) {
      this.set$length(receiver, 0);
    },
    removeLast$0: function(receiver) {
      var result;
      if (J.$eq(this.get$length(receiver), 0))
        throw H.wrapException(H.IterableElementError_noElement());
      result = this.$index(receiver, J.$sub$n(this.get$length(receiver), 1));
      this.set$length(receiver, J.$sub$n(this.get$length(receiver), 1));
      return result;
    },
    sort$1: function(receiver, compare) {
      if (compare == null)
        compare = P.Comparable_compare$closure();
      H.Sort__doSort(receiver, 0, J.$sub$n(this.get$length(receiver), 1), compare);
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    _rangeCheck$2: function(receiver, start, end) {
      var t1 = J.getInterceptor$n(start);
      if (t1.$lt(start, 0) || t1.$gt(start, this.get$length(receiver)))
        throw H.wrapException(P.RangeError$range(start, 0, this.get$length(receiver), null, null));
      t1 = J.getInterceptor$n(end);
      if (t1.$lt(end, start) || t1.$gt(end, this.get$length(receiver)))
        throw H.wrapException(P.RangeError$range(end, start, this.get$length(receiver), null, null));
    },
    sublist$2: function(receiver, start, end) {
      var $length, result, i, t1;
      if (end == null)
        end = this.get$length(receiver);
      this._rangeCheck$2(receiver, start, end);
      $length = J.$sub$n(end, start);
      result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      C.JSArray_methods.set$length(result, $length);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        t1 = this.$index(receiver, start + i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    getRange$2: function(receiver, start, end) {
      this._rangeCheck$2(receiver, start, end);
      return H.SubListIterable$(receiver, start, end, H.getRuntimeTypeArgument(receiver, "ListMixin", 0));
    },
    removeRange$2: function(receiver, start, end) {
      var $length;
      this._rangeCheck$2(receiver, start, end);
      $length = J.$sub$n(end, start);
      this.setRange$4(receiver, start, J.$sub$n(this.get$length(receiver), $length), receiver, end);
      this.set$length(receiver, J.$sub$n(this.get$length(receiver), $length));
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var $length, t1, t2, t3, i, t4;
      this._rangeCheck$2(receiver, start, end);
      $length = J.$sub$n(end, start);
      t1 = J.getInterceptor($length);
      if (t1.$eq($length, 0))
        return;
      t2 = J.getInterceptor$n(skipCount);
      if (t2.$lt(skipCount, 0))
        throw H.wrapException(P.ArgumentError$(skipCount));
      t3 = J.getInterceptor$asx(iterable);
      if (J.$gt$n(t2.$add(skipCount, $length), t3.get$length(iterable)))
        throw H.wrapException(H.IterableElementError_tooFew());
      if (t2.$lt(skipCount, start))
        for (i = t1.$sub($length, 1), t1 = J.getInterceptor$ns(start); t4 = J.getInterceptor$n(i), t4.$ge(i, 0); i = t4.$sub(i, 1))
          this.$indexSet(receiver, t1.$add(start, i), t3.$index(iterable, t2.$add(skipCount, i)));
      else {
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = J.getInterceptor$ns(start);
        i = 0;
        for (; i < $length; ++i)
          this.$indexSet(receiver, t1.$add(start, i), t3.$index(iterable, t2.$add(skipCount, i)));
      }
    },
    indexOf$2: function(receiver, element, startIndex) {
      var t1, i;
      t1 = J.getInterceptor$n(startIndex);
      if (t1.$ge(startIndex, this.get$length(receiver)))
        return -1;
      if (t1.$lt(startIndex, 0))
        startIndex = 0;
      for (i = startIndex; t1 = J.getInterceptor$n(i), t1.$lt(i, this.get$length(receiver)); i = t1.$add(i, 1))
        if (J.$eq(this.$index(receiver, i), element))
          return i;
      return -1;
    },
    indexOf$1: function($receiver, element) {
      return this.indexOf$2($receiver, element, 0);
    },
    insert$2: function(receiver, index, element) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$gt(index, this.get$length(receiver)))
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(receiver), null, null));
      if (t1.$eq(index, this.get$length(receiver))) {
        this.add$1(receiver, element);
        return;
      }
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      this.set$length(receiver, J.$add$ns(this.get$length(receiver), 1));
      this.setRange$4(receiver, index + 1, this.get$length(receiver), receiver, index);
      this.$indexSet(receiver, index, element);
    },
    removeAt$1: function(receiver, index) {
      var result = this.$index(receiver, index);
      this.setRange$4(receiver, index, J.$sub$n(this.get$length(receiver), 1), receiver, J.$add$ns(index, 1));
      this.set$length(receiver, J.$sub$n(this.get$length(receiver), 1));
      return result;
    },
    get$reversed: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ReversedListIterable(receiver), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  _UnmodifiableMapMixin: {
    "^": "Object;",
    $indexSet: function(_, key, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    },
    addAll$1: function(_, other) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    },
    clear$0: function(_) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    },
    remove$1: function(_, key) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    },
    $isMap: true,
    $asMap: null
  },
  MapView: {
    "^": "Object;",
    $index: function(_, key) {
      return this._map.$index(0, key);
    },
    $indexSet: function(_, key, value) {
      this._map.$indexSet(0, key, value);
    },
    addAll$1: function(_, other) {
      this._map.addAll$1(0, other);
    },
    clear$0: function(_) {
      this._map.clear$0(0);
    },
    containsKey$1: function(_, key) {
      return this._map.containsKey$1(0, key);
    },
    forEach$1: function(_, action) {
      this._map.forEach$1(0, action);
    },
    get$isEmpty: function(_) {
      return this._map._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._map._collection$_length !== 0;
    },
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$keys: function(_) {
      var t1 = this._map;
      return H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
    },
    remove$1: function(_, key) {
      return this._map.remove$1(0, key);
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this._map);
    },
    get$values: function(_) {
      var t1 = this._map;
      return t1.get$values(t1);
    },
    $isMap: true,
    $asMap: null
  },
  UnmodifiableMapView: {
    "^": "MapView+_UnmodifiableMapMixin;_map",
    $isMap: true,
    $asMap: null
  },
  Maps_mapToString_closure: {
    "^": "Closure:959;box_0,result_1",
    call$2: function(k, v) {
      var t1 = this.box_0;
      if (!t1.first_0)
        this.result_1.write$1(", ");
      t1.first_0 = false;
      t1 = this.result_1;
      t1.write$1(k);
      t1.write$1(": ");
      t1.write$1(v);
    }
  },
  DoubleLinkedQueueEntry: {
    "^": "Object;_previous@,_next@,_collection$_element<",
    _link$2: function(previous, next) {
      this._next = next;
      this._previous = previous;
      previous.set$_next(this);
      next.set$_previous(this);
    },
    append$1: function(_, e) {
      var t1 = new P.DoubleLinkedQueueEntry(null, null, e);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      t1._link$2(this, this._next);
    },
    remove$0: function(_) {
      this._previous.set$_next(this._next);
      this._next.set$_previous(this._previous);
      this._next = null;
      this._previous = null;
      return this._collection$_element;
    },
    get$element: function() {
      return this._collection$_element;
    }
  },
  _DoubleLinkedQueueEntrySentinel: {
    "^": "DoubleLinkedQueueEntry;_previous,_next,_collection$_element",
    remove$0: function(_) {
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$element: function() {
      throw H.wrapException(H.IterableElementError_noElement());
    }
  },
  DoubleLinkedQueue: {
    "^": "IterableBase;_sentinel,_elementCount",
    get$length: function(_) {
      return this._elementCount;
    },
    add$1: [function(_, value) {
      var t1 = this._sentinel;
      H.setRuntimeTypeInfo(new P.DoubleLinkedQueueEntry(null, null, value), [H.getTypeArgumentByIndex(t1, 0)])._link$2(t1._previous, t1);
      ++this._elementCount;
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E3", void: true, args: [E]};
      }, this.$receiver, "DoubleLinkedQueue");
    }, 138, []],
    addAll$1: function(_, iterable) {
      var t1, value, t2, t3, t4;
      for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0();) {
        value = t1.get$current();
        t2 = this._sentinel;
        t3 = new P.DoubleLinkedQueueEntry(null, null, value);
        t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
        t4 = t2._previous;
        t3._next = t2;
        t3._previous = t4;
        t4.set$_next(t3);
        t2._previous = t3;
        ++this._elementCount;
      }
    },
    removeLast$0: function(_) {
      var result = this._sentinel._previous.remove$0(0);
      --this._elementCount;
      return result;
    },
    removeFirst$0: function() {
      var result = this._sentinel._next.remove$0(0);
      --this._elementCount;
      return result;
    },
    remove$1: function(_, o) {
      var entry = this._sentinel._next;
      for (; entry !== this._sentinel;) {
        if (J.$eq(entry.get$element(), o)) {
          entry.remove$0(0);
          --this._elementCount;
          return true;
        }
        entry = entry.get$_next();
      }
      return false;
    },
    get$last: function(_) {
      return this._sentinel._previous.get$element();
    },
    get$isEmpty: function(_) {
      var t1 = this._sentinel;
      return t1._next === t1;
    },
    clear$0: function(_) {
      var t1 = this._sentinel;
      t1._next = t1;
      t1._previous = t1;
      this._elementCount = 0;
    },
    get$iterator: function(_) {
      var t1 = this._sentinel;
      t1 = new P._DoubleLinkedQueueIterator(t1, t1._next, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    $isEfficientLength: true
  },
  _DoubleLinkedQueueIterator: {
    "^": "Object;_sentinel,_nextEntry,_collection$_current",
    moveNext$0: function() {
      var t1, t2;
      t1 = this._nextEntry;
      t2 = this._sentinel;
      if (t1 == null ? t2 != null : t1 !== t2) {
        this._collection$_current = t1.get$_collection$_element();
        this._nextEntry = this._nextEntry.get$_next();
        return true;
      }
      this._collection$_current = null;
      this._sentinel = null;
      this._nextEntry = null;
      return false;
    },
    get$current: function() {
      return this._collection$_current;
    }
  },
  ListQueue: {
    "^": "IterableBase;_table,_head,_tail,_modificationCount",
    get$iterator: function(_) {
      var t1 = new P._ListQueueIterator(this, this._tail, this._modificationCount, this._head, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    forEach$1: function(_, action) {
      var modificationCount, i, t1;
      modificationCount = this._modificationCount;
      for (i = this._head; i !== this._tail; i = (i + 1 & this._table.length - 1) >>> 0) {
        t1 = this._table;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        action.call$1(t1[i]);
        if (modificationCount !== this._modificationCount)
          H.throwExpression(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this._head === this._tail;
    },
    get$length: function(_) {
      return J.$and$n(J.$sub$n(this._tail, this._head), this._table.length - 1);
    },
    get$last: function(_) {
      var t1, t2;
      t1 = this._head;
      t2 = this._tail;
      if (t1 === t2)
        throw H.wrapException(H.IterableElementError_noElement());
      t1 = this._table;
      t2 = J.$and$n(J.$sub$n(t2, 1), this._table.length - 1);
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    elementAt$1: function(_, index) {
      var t1, t2, t3;
      t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$ge(index, this.get$length(this)))
        throw H.wrapException(P.IndexError$(index, this, null, null, null));
      t1 = this._table;
      t2 = this._head;
      if (typeof index !== "number")
        return H.iae(index);
      t3 = t1.length;
      t2 = (t2 + index & t3 - 1) >>> 0;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    toList$1$growable: function(_, growable) {
      var list, t1;
      if (growable) {
        list = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
        C.JSArray_methods.set$length(list, this.get$length(this));
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = init;
        list = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      }
      this._writeToList$1(list);
      return list;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    add$1: [function(_, element) {
      this._add$1(element);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E4", void: true, args: [E]};
      }, this.$receiver, "ListQueue");
    }, 23, []],
    addAll$1: function(_, elements) {
      var t1, addCount, $length, t2, t3, newCapacity, newTable, endSpace, preSpace;
      t1 = J.getInterceptor(elements);
      if (!!t1.$isList) {
        addCount = t1.get$length(elements);
        $length = this.get$length(this);
        if (typeof addCount !== "number")
          return H.iae(addCount);
        t1 = $length + addCount;
        t2 = this._table;
        t3 = t2.length;
        if (t1 >= t3) {
          newCapacity = P.ListQueue__nextPowerOf2(t1 + C.JSNumber_methods._shrOtherPositive$1(t1, 1));
          if (typeof newCapacity !== "number")
            return H.iae(newCapacity);
          t2 = Array(newCapacity);
          t2.fixed$length = init;
          newTable = H.setRuntimeTypeInfo(t2, [H.getTypeArgumentByIndex(this, 0)]);
          this._tail = this._writeToList$1(newTable);
          this._table = newTable;
          this._head = 0;
          C.JSArray_methods.checkMutable$1(newTable, "set range");
          H.IterableMixinWorkaround_setRangeList(newTable, $length, t1, elements, 0);
          this._tail = J.$add$ns(this._tail, addCount);
        } else {
          t1 = this._tail;
          if (typeof t1 !== "number")
            return H.iae(t1);
          endSpace = t3 - t1;
          if (addCount < endSpace) {
            C.JSArray_methods.checkMutable$1(t2, "set range");
            H.IterableMixinWorkaround_setRangeList(t2, t1, t1 + addCount, elements, 0);
            this._tail = J.$add$ns(this._tail, addCount);
          } else {
            preSpace = addCount - endSpace;
            C.JSArray_methods.checkMutable$1(t2, "set range");
            H.IterableMixinWorkaround_setRangeList(t2, t1, t1 + endSpace, elements, 0);
            t1 = this._table;
            C.JSArray_methods.checkMutable$1(t1, "set range");
            H.IterableMixinWorkaround_setRangeList(t1, 0, preSpace, elements, endSpace);
            this._tail = preSpace;
          }
        }
        ++this._modificationCount;
      } else
        for (t1 = t1.get$iterator(elements); t1.moveNext$0();)
          this._add$1(t1.get$current());
    },
    remove$1: function(_, object) {
      var i, t1;
      for (i = this._head; i !== this._tail; i = (i + 1 & this._table.length - 1) >>> 0) {
        t1 = this._table;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        if (J.$eq(t1[i], object)) {
          this._remove$1(i);
          ++this._modificationCount;
          return true;
        }
      }
      return false;
    },
    clear$0: function(_) {
      var i, t1, t2, t3, t4;
      i = this._head;
      t1 = this._tail;
      if (i !== t1) {
        for (t2 = this._table, t3 = t2.length, t4 = t3 - 1; i !== t1; i = (i + 1 & t4) >>> 0) {
          if (i < 0 || i >= t3)
            return H.ioore(t2, i);
          t2[i] = null;
        }
        this._tail = 0;
        this._head = 0;
        ++this._modificationCount;
      }
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    removeFirst$0: function() {
      var t1, t2, t3, result;
      t1 = this._head;
      if (t1 === this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      ++this._modificationCount;
      t2 = this._table;
      t3 = t2.length;
      if (t1 >= t3)
        return H.ioore(t2, t1);
      result = t2[t1];
      t2[t1] = null;
      this._head = (t1 + 1 & t3 - 1) >>> 0;
      return result;
    },
    removeLast$0: function(_) {
      var t1, t2, result;
      t1 = this._head;
      t2 = this._tail;
      if (t1 === t2)
        throw H.wrapException(H.IterableElementError_noElement());
      ++this._modificationCount;
      t1 = J.$and$n(J.$sub$n(t2, 1), this._table.length - 1);
      this._tail = t1;
      t2 = this._table;
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      result = t2[t1];
      t2[t1] = null;
      return result;
    },
    _add$1: function(element) {
      var t1, t2;
      t1 = this._table;
      t2 = this._tail;
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2] = element;
      t2 = (t2 + 1 & this._table.length - 1) >>> 0;
      this._tail = t2;
      if (this._head === t2)
        this._grow$0();
      ++this._modificationCount;
    },
    _remove$1: function(offset) {
      var mask, t1, t2, t3, i, prevOffset, t4, nextOffset;
      mask = this._table.length - 1;
      if ((offset - this._head & mask) >>> 0 < J.$and$n(J.$sub$n(this._tail, offset), mask)) {
        for (t1 = this._head, t2 = this._table, t3 = t2.length, i = offset; i !== t1; i = prevOffset) {
          prevOffset = (i - 1 & mask) >>> 0;
          if (prevOffset < 0 || prevOffset >= t3)
            return H.ioore(t2, prevOffset);
          t4 = t2[prevOffset];
          if (i < 0 || i >= t3)
            return H.ioore(t2, i);
          t2[i] = t4;
        }
        if (t1 >= t3)
          return H.ioore(t2, t1);
        t2[t1] = null;
        this._head = (t1 + 1 & mask) >>> 0;
        return (offset + 1 & mask) >>> 0;
      } else {
        t1 = J.$and$n(J.$sub$n(this._tail, 1), mask);
        this._tail = t1;
        for (t2 = this._table, t3 = t2.length, i = offset; i !== t1; i = nextOffset) {
          nextOffset = (i + 1 & mask) >>> 0;
          if (nextOffset < 0 || nextOffset >= t3)
            return H.ioore(t2, nextOffset);
          t4 = t2[nextOffset];
          if (i < 0 || i >= t3)
            return H.ioore(t2, i);
          t2[i] = t4;
        }
        if (t1 >= t3)
          return H.ioore(t2, t1);
        t2[t1] = null;
        return offset;
      }
    },
    _grow$0: function() {
      var t1, newTable, t2, split;
      t1 = Array(this._table.length * 2);
      t1.fixed$length = init;
      newTable = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      t1 = this._table;
      t2 = this._head;
      split = t1.length - t2;
      C.JSArray_methods.checkMutable$1(newTable, "set range");
      H.IterableMixinWorkaround_setRangeList(newTable, 0, split, t1, t2);
      t2 = this._head;
      t1 = this._table;
      C.JSArray_methods.checkMutable$1(newTable, "set range");
      H.IterableMixinWorkaround_setRangeList(newTable, split, split + t2, t1, 0);
      this._head = 0;
      this._tail = this._table.length;
      this._table = newTable;
    },
    _writeToList$1: function(target) {
      var t1, t2, $length, firstPartSize;
      t1 = this._head;
      t2 = this._tail;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 <= t2) {
        $length = t2 - t1;
        t1 = this._table;
        t2 = this._head;
        C.JSArray_methods.checkMutable$1(target, "set range");
        H.IterableMixinWorkaround_setRangeList(target, 0, $length, t1, t2);
        return $length;
      } else {
        t2 = this._table;
        firstPartSize = t2.length - t1;
        C.JSArray_methods.checkMutable$1(target, "set range");
        H.IterableMixinWorkaround_setRangeList(target, 0, firstPartSize, t2, t1);
        t1 = this._tail;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = this._table;
        C.JSArray_methods.checkMutable$1(target, "set range");
        H.IterableMixinWorkaround_setRangeList(target, firstPartSize, firstPartSize + t1, t2, 0);
        return J.$add$ns(this._tail, firstPartSize);
      }
    },
    ListQueue$1: function(initialCapacity, $E) {
      var t1 = Array(8);
      t1.fixed$length = init;
      this._table = H.setRuntimeTypeInfo(t1, [$E]);
    },
    $isEfficientLength: true,
    static: {"^": "ListQueue__INITIAL_CAPACITY", ListQueue$: function(initialCapacity, $E) {
        var t1 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [$E]);
        t1.ListQueue$1(initialCapacity, $E);
        return t1;
      }, ListQueue__nextPowerOf2: function(number) {
        var nextNumber;
        if (typeof number !== "number")
          return number.$shl();
        number = (number << 1 >>> 0) - 1;
        for (; true; number = nextNumber) {
          nextNumber = (number & number - 1) >>> 0;
          if (nextNumber === 0)
            return number;
        }
      }}
  },
  _ListQueueIterator: {
    "^": "Object;_queue,_end,_modificationCount,_collection$_position,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1, t2, t3;
      t1 = this._queue;
      if (this._modificationCount !== t1._modificationCount)
        H.throwExpression(P.ConcurrentModificationError$(t1));
      t2 = this._collection$_position;
      if (t2 === this._end) {
        this._collection$_current = null;
        return false;
      }
      t1 = t1._table;
      t3 = t1.length;
      if (t2 >= t3)
        return H.ioore(t1, t2);
      this._collection$_current = t1[t2];
      this._collection$_position = (t2 + 1 & t3 - 1) >>> 0;
      return true;
    }
  },
  SetMixin: {
    "^": "Object;",
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$isNotEmpty: function(_) {
      return this.get$length(this) !== 0;
    },
    clear$0: function(_) {
      this.removeAll$1(this.toList$0(0));
    },
    addAll$1: function(_, elements) {
      var t1;
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        this.add$1(0, t1.get$current());
    },
    removeAll$1: function(elements) {
      var t1;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(elements, elements.length, 0, null), [H.getTypeArgumentByIndex(elements, 0)]); t1.moveNext$0();)
        this.remove$1(0, t1.__internal$_current);
    },
    toList$1$growable: function(_, growable) {
      var result, t1, i, element, i0;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = init;
        result = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      }
      for (t1 = this.get$iterator(this), i = 0; t1.moveNext$0(); i = i0) {
        element = t1._collection$_current;
        i0 = i + 1;
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = element;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    map$1: [function(_, f) {
      return H.setRuntimeTypeInfo(new H.EfficientLengthMappedIterable(this, f), [H.getTypeArgumentByIndex(this, 0), null]);
    }, "call$1", "get$map", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "Iterable__dynamic__E3", ret: P.Iterable, args: [{func: "dynamic__E3", args: [E]}]};
      }, this.$receiver, "SetMixin");
    }],
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    where$1: function(_, f) {
      var t1 = new H.WhereIterable(this, f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    forEach$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1._collection$_current);
    },
    fold$2: function(_, initialValue, combine) {
      var t1, value;
      for (t1 = this.get$iterator(this), value = initialValue; t1.moveNext$0();)
        value = combine.call$2(value, t1._collection$_current);
      return value;
    },
    join$1: function(_, separator) {
      var iterator, buffer, t1;
      iterator = this.get$iterator(this);
      if (!iterator.moveNext$0())
        return "";
      buffer = P.StringBuffer$("");
      if (separator === "") {
        do {
          t1 = H.S(iterator._collection$_current);
          buffer._contents += t1;
        } while (iterator.moveNext$0());
      } else {
        buffer.write$1(H.S(iterator._collection$_current));
        for (; iterator.moveNext$0();) {
          buffer._contents += separator;
          t1 = H.S(iterator._collection$_current);
          buffer._contents += t1;
        }
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    any$1: [function(_, test) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (test.call$1(t1._collection$_current) === true)
          return true;
      return false;
    }, "call$1", "get$any", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__bool__E3", ret: P.bool, args: [{func: "bool__E4", ret: P.bool, args: [E]}]};
      }, this.$receiver, "SetMixin");
    }],
    get$last: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = it._collection$_current;
      while (it.moveNext$0());
      return result;
    },
    firstWhere$2$orElse: function(_, test, orElse) {
      var t1, element;
      for (t1 = this.get$iterator(this); t1.moveNext$0();) {
        element = t1._collection$_current;
        if (test.call$1(element) === true)
          return element;
      }
      return orElse.call$0();
    },
    elementAt$1: function(_, index) {
      var t1, remaining, element, t2;
      if (typeof index !== "number" || Math.floor(index) !== index || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      for (t1 = this.get$iterator(this), remaining = index; t1.moveNext$0();) {
        element = t1._collection$_current;
        t2 = J.getInterceptor(remaining);
        if (t2.$eq(remaining, 0))
          return element;
        remaining = t2.$sub(remaining, 1);
      }
      throw H.wrapException(P.RangeError$value(index, null, null));
    },
    $isEfficientLength: true
  },
  SetBase: {
    "^": "SetMixin;"
  }
}],
["dart.convert", "dart:convert", , P, {
  "^": "",
  _convertJsonToDartLazy: function(object) {
    var i;
    if (object == null)
      return;
    if (typeof object != "object")
      return object;
    if (Object.getPrototypeOf(object) !== Array.prototype)
      return new P._JsonMap(object, Object.create(null), null);
    for (i = 0; i < object.length; ++i)
      object[i] = P._convertJsonToDartLazy(object[i]);
    return object;
  },
  _parseJson: function(source, reviver) {
    var parsed, e, t1, exception;
    t1 = source;
    if (typeof t1 !== "string")
      throw H.wrapException(P.ArgumentError$(source));
    parsed = null;
    try {
      parsed = JSON.parse(source);
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      throw H.wrapException(P.FormatException$(String(e), null, null));
    }

    return P._convertJsonToDartLazy(parsed);
  },
  _JsonMap: {
    "^": "Object;_original,_processed,_data",
    $index: function(_, key) {
      var t1, result;
      t1 = this._processed;
      if (t1 == null)
        return this._data.$index(0, key);
      else if (typeof key !== "string")
        return;
      else {
        result = t1[key];
        return typeof result == "undefined" ? this._process$1(key) : result;
      }
    },
    get$length: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        t1 = t1.get$length(t1);
      } else
        t1 = this._computeKeys$0().length;
      return t1;
    },
    get$isEmpty: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        t1 = t1.get$length(t1);
      } else
        t1 = this._computeKeys$0().length;
      return t1 === 0;
    },
    get$isNotEmpty: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        t1 = t1.get$length(t1);
      } else
        t1 = this._computeKeys$0().length;
      return t1 > 0;
    },
    get$keys: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        return t1.get$keys(t1);
      }
      t1 = this._computeKeys$0();
      return H.SubListIterable$(t1, 0, null, H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0));
    },
    get$values: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        return t1.get$values(t1);
      }
      return H.MappedIterable_MappedIterable(this._computeKeys$0(), new P._JsonMap_values_closure(this), null, null);
    },
    $indexSet: function(_, key, value) {
      var processed, original;
      if (this._processed == null)
        this._data.$indexSet(0, key, value);
      else if (this.containsKey$1(0, key)) {
        processed = this._processed;
        processed[key] = value;
        original = this._original;
        if (original == null ? processed != null : original !== processed)
          original[key] = null;
      } else
        this._upgrade$0().$indexSet(0, key, value);
    },
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new P._JsonMap_addAll_closure(this));
    },
    containsKey$1: function(_, key) {
      if (this._processed == null)
        return this._data.containsKey$1(0, key);
      if (typeof key !== "string")
        return false;
      return Object.prototype.hasOwnProperty.call(this._original, key);
    },
    remove$1: function(_, key) {
      if (this._processed != null && !this.containsKey$1(0, key))
        return;
      return this._upgrade$0().remove$1(0, key);
    },
    clear$0: function(_) {
      var t1;
      if (this._processed == null)
        this._data.clear$0(0);
      else {
        t1 = this._data;
        if (t1 != null)
          J.clear$0$ax(t1);
        this._processed = null;
        this._original = null;
        this._data = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      }
    },
    forEach$1: function(_, f) {
      var keys, i, key, value;
      if (this._processed == null)
        return this._data.forEach$1(0, f);
      keys = this._computeKeys$0();
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        value = this._processed[key];
        if (typeof value == "undefined") {
          value = P._convertJsonToDartLazy(this._original[key]);
          this._processed[key] = value;
        }
        f.call$2(key, value);
        if (keys !== this._data)
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    _computeKeys$0: function() {
      var keys = this._data;
      if (keys == null) {
        keys = Object.keys(this._original);
        this._data = keys;
      }
      return keys;
    },
    _upgrade$0: function() {
      var result, keys, i, t1, key;
      if (this._processed == null)
        return this._data;
      result = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      keys = this._computeKeys$0();
      for (i = 0; t1 = keys.length, i < t1; ++i) {
        key = keys[i];
        result.$indexSet(0, key, this.$index(0, key));
      }
      if (t1 === 0)
        keys.push(null);
      else
        C.JSArray_methods.set$length(keys, 0);
      this._processed = null;
      this._original = null;
      this._data = result;
      return result;
    },
    _process$1: function(key) {
      var result;
      if (!Object.prototype.hasOwnProperty.call(this._original, key))
        return;
      result = P._convertJsonToDartLazy(this._original[key]);
      return this._processed[key] = result;
    },
    $isMap: true,
    $asMap: function() {
      return [null, null];
    }
  },
  _JsonMap_values_closure: {
    "^": "Closure:102;this_0",
    call$1: [function(each) {
      return this.this_0.$index(0, each);
    }, "call$1", null, 2, 0, null, 1710, [], "call"]
  },
  _JsonMap_addAll_closure: {
    "^": "Closure:959;this_0",
    call$2: [function(key, value) {
      this.this_0.$indexSet(0, key, value);
    }, "call$2", null, 4, 0, null, 269, [], 138, [], "call"]
  },
  Codec: {
    "^": "Object;"
  },
  Converter: {
    "^": "Object;"
  },
  Encoding: {
    "^": "Codec;",
    $asCodec: function() {
      return [P.String, [P.List, P.$int]];
    }
  },
  JsonCodec: {
    "^": "Codec;_reviver,_toEncodable",
    decode$2$reviver: function(source, reviver) {
      return P._parseJson(source, this.get$decoder()._reviver);
    },
    decode$1: function(source) {
      return this.decode$2$reviver(source, null);
    },
    get$decoder: function() {
      return C.JsonDecoder_null;
    },
    $asCodec: function() {
      return [P.Object, P.String];
    }
  },
  JsonDecoder: {
    "^": "Converter;_reviver",
    $asConverter: function() {
      return [P.String, P.Object];
    }
  },
  Utf8Codec: {
    "^": "Encoding;_allowMalformed",
    get$name: function(_) {
      return "utf-8";
    },
    get$encoder: function() {
      return new P.Utf8Encoder();
    }
  },
  Utf8Encoder: {
    "^": "Converter;",
    convert$1: function(string) {
      var t1, t2, encoder;
      t1 = J.getInterceptor$asx(string);
      t2 = new Uint8Array(H._checkLength(J.$mul$ns(t1.get$length(string), 3)));
      encoder = new P._Utf8Encoder(0, 0, t2);
      if (encoder._fillBuffer$3(string, 0, t1.get$length(string)) !== t1.get$length(string))
        encoder._writeSurrogate$2(t1.codeUnitAt$1(string, J.$sub$n(t1.get$length(string), 1)), 0);
      return C.NativeUint8List_methods.sublist$2(t2, 0, encoder._bufferIndex);
    },
    $asConverter: function() {
      return [P.String, [P.List, P.$int]];
    }
  },
  _Utf8Encoder: {
    "^": "Object;_carry,_bufferIndex,_buffer",
    _writeSurrogate$2: function(leadingSurrogate, nextCodeUnit) {
      var t1, t2, rune, t3, t4;
      t1 = this._buffer;
      t2 = this._bufferIndex;
      if ((nextCodeUnit & 64512) === 56320) {
        rune = 65536 + ((leadingSurrogate & 1023) << 10 >>> 0) | nextCodeUnit & 1023;
        t3 = t2 + 1;
        this._bufferIndex = t3;
        t4 = t1.length;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = (240 | rune >>> 18) >>> 0;
        t2 = t3 + 1;
        this._bufferIndex = t2;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | rune >>> 12 & 63;
        t3 = t2 + 1;
        this._bufferIndex = t3;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 128 | rune >>> 6 & 63;
        this._bufferIndex = t3 + 1;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | rune & 63;
        return true;
      } else {
        t3 = t2 + 1;
        this._bufferIndex = t3;
        t4 = t1.length;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 224 | leadingSurrogate >>> 12;
        t2 = t3 + 1;
        this._bufferIndex = t2;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | leadingSurrogate >>> 6 & 63;
        this._bufferIndex = t2 + 1;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 128 | leadingSurrogate & 63;
        return false;
      }
    },
    _fillBuffer$3: function(str, start, end) {
      var t1, t2, t3, stringIndex, codeUnit, t4, stringIndex0, t5;
      if (start !== end && (J.codeUnitAt$1$s(str, J.$sub$n(end, 1)) & 64512) === 55296)
        end = J.$sub$n(end, 1);
      if (typeof end !== "number")
        return H.iae(end);
      t1 = this._buffer;
      t2 = t1.length;
      t3 = J.getInterceptor$s(str);
      stringIndex = start;
      for (; stringIndex < end; ++stringIndex) {
        codeUnit = t3.codeUnitAt$1(str, stringIndex);
        if (codeUnit <= 127) {
          t4 = this._bufferIndex;
          if (t4 >= t2)
            break;
          this._bufferIndex = t4 + 1;
          t1[t4] = codeUnit;
        } else if ((codeUnit & 64512) === 55296) {
          if (this._bufferIndex + 3 >= t2)
            break;
          stringIndex0 = stringIndex + 1;
          if (this._writeSurrogate$2(codeUnit, t3.codeUnitAt$1(str, stringIndex0)))
            stringIndex = stringIndex0;
        } else if (codeUnit <= 2047) {
          t4 = this._bufferIndex;
          t5 = t4 + 1;
          if (t5 >= t2)
            break;
          this._bufferIndex = t5;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = 192 | codeUnit >>> 6;
          this._bufferIndex = t5 + 1;
          t1[t5] = 128 | codeUnit & 63;
        } else {
          t4 = this._bufferIndex;
          if (t4 + 2 >= t2)
            break;
          t5 = t4 + 1;
          this._bufferIndex = t5;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = 224 | codeUnit >>> 12;
          t4 = t5 + 1;
          this._bufferIndex = t4;
          if (t5 >= t2)
            return H.ioore(t1, t5);
          t1[t5] = 128 | codeUnit >>> 6 & 63;
          this._bufferIndex = t4 + 1;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = 128 | codeUnit & 63;
        }
      }
      return stringIndex;
    },
    static: {"^": "_Utf8Encoder__DEFAULT_BYTE_BUFFER_SIZE"}
  },
  Utf8Decoder: {
    "^": "Converter;_allowMalformed",
    convert$1: function(codeUnits) {
      var buffer, decoder, t1;
      buffer = P.StringBuffer$("");
      decoder = new P._Utf8Decoder(this._allowMalformed, buffer, true, 0, 0, 0);
      decoder.convert$3(codeUnits, 0, J.get$length$asx(codeUnits));
      decoder.flush$0(0);
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $asConverter: function() {
      return [[P.List, P.$int], P.String];
    }
  },
  _Utf8Decoder: {
    "^": "Object;_allowMalformed,_stringSink,_isFirstCharacter,_convert$_value,_expectedUnits,_extraUnits",
    flush$0: function(_) {
      if (this._expectedUnits > 0) {
        if (!this._allowMalformed)
          throw H.wrapException(P.FormatException$("Unfinished UTF-8 octet sequence", null, null));
        this._stringSink.write$1(H.Primitives_stringFromCharCode(65533));
        this._convert$_value = 0;
        this._expectedUnits = 0;
        this._extraUnits = 0;
      }
    },
    convert$3: function(codeUnits, startIndex, endIndex) {
      var value, expectedUnits, extraUnits, t1, t2, t3, t4, t5, i, unit, t6, oneBytes, i0;
      value = this._convert$_value;
      expectedUnits = this._expectedUnits;
      extraUnits = this._extraUnits;
      this._convert$_value = 0;
      this._expectedUnits = 0;
      this._extraUnits = 0;
      t1 = new P._Utf8Decoder_convert_scanOneByteCharacters(endIndex);
      t2 = new P._Utf8Decoder_convert_addSingleBytes(this, codeUnits, startIndex, endIndex);
      $loop$0:
        for (t3 = this._stringSink, t4 = !this._allowMalformed, t5 = J.getInterceptor$asx(codeUnits), i = startIndex; true; i = i0) {
          $multibyte$2: {
            if (expectedUnits > 0) {
              do {
                if (i === endIndex)
                  break $loop$0;
                unit = t5.$index(codeUnits, i);
                t6 = J.getInterceptor$n(unit);
                if (t6.$and(unit, 192) !== 128) {
                  if (t4)
                    throw H.wrapException(P.FormatException$("Bad UTF-8 encoding 0x" + t6.toRadixString$1(unit, 16), null, null));
                  this._isFirstCharacter = false;
                  t6 = H.Primitives_stringFromCharCode(65533);
                  t3._contents += t6;
                  expectedUnits = 0;
                  break $multibyte$2;
                } else {
                  value = (value << 6 | t6.$and(unit, 63)) >>> 0;
                  --expectedUnits;
                  ++i;
                }
              } while (expectedUnits > 0);
              t6 = extraUnits - 1;
              if (t6 < 0 || t6 >= 4)
                return H.ioore(C.List_127_2047_65535_1114111, t6);
              if (value <= C.List_127_2047_65535_1114111[t6]) {
                if (t4)
                  throw H.wrapException(P.FormatException$("Overlong encoding of 0x" + C.JSInt_methods.toRadixString$1(value, 16), null, null));
                value = 65533;
                expectedUnits = 0;
                extraUnits = 0;
              }
              if (value > 1114111) {
                if (t4)
                  throw H.wrapException(P.FormatException$("Character outside valid Unicode range: 0x" + C.JSInt_methods.toRadixString$1(value, 16), null, null));
                value = 65533;
              }
              if (!this._isFirstCharacter || value !== 65279) {
                t6 = H.Primitives_stringFromCharCode(value);
                t3._contents += t6;
              }
              this._isFirstCharacter = false;
            }
          }
          for (; i < endIndex; i = i0) {
            oneBytes = t1.call$2(codeUnits, i);
            if (J.$gt$n(oneBytes, 0)) {
              this._isFirstCharacter = false;
              if (typeof oneBytes !== "number")
                return H.iae(oneBytes);
              i0 = i + oneBytes;
              t2.call$2(i, i0);
              if (i0 === endIndex)
                break;
              i = i0;
            }
            i0 = i + 1;
            unit = t5.$index(codeUnits, i);
            t6 = J.getInterceptor$n(unit);
            if (t6.$lt(unit, 0)) {
              if (t4)
                throw H.wrapException(P.FormatException$("Negative UTF-8 code unit: -0x" + J.toRadixString$1$n(t6.$negate(unit), 16), null, null));
              t6 = H.Primitives_stringFromCharCode(65533);
              t3._contents += t6;
            } else {
              if (t6.$and(unit, 224) === 192) {
                value = t6.$and(unit, 31);
                expectedUnits = 1;
                extraUnits = 1;
                continue $loop$0;
              }
              if (t6.$and(unit, 240) === 224) {
                value = t6.$and(unit, 15);
                expectedUnits = 2;
                extraUnits = 2;
                continue $loop$0;
              }
              if (t6.$and(unit, 248) === 240 && t6.$lt(unit, 245)) {
                value = t6.$and(unit, 7);
                expectedUnits = 3;
                extraUnits = 3;
                continue $loop$0;
              }
              if (t4)
                throw H.wrapException(P.FormatException$("Bad UTF-8 encoding 0x" + t6.toRadixString$1(unit, 16), null, null));
              this._isFirstCharacter = false;
              t6 = H.Primitives_stringFromCharCode(65533);
              t3._contents += t6;
              value = 65533;
              expectedUnits = 0;
              extraUnits = 0;
            }
          }
          break $loop$0;
        }
      if (expectedUnits > 0) {
        this._convert$_value = value;
        this._expectedUnits = expectedUnits;
        this._extraUnits = extraUnits;
      }
    },
    static: {"^": "_Utf8Decoder__LIMITS"}
  },
  _Utf8Decoder_convert_scanOneByteCharacters: {
    "^": "Closure:1711;endIndex_0",
    call$2: function(units, from) {
      var to, t1, i, unit;
      to = this.endIndex_0;
      for (t1 = J.getInterceptor$asx(units), i = from; i < to; ++i) {
        unit = t1.$index(units, i);
        if (J.$and$n(unit, 127) !== unit)
          return i - from;
      }
      return to - from;
    }
  },
  _Utf8Decoder_convert_addSingleBytes: {
    "^": "Closure:1712;this_1,codeUnits_2,startIndex_3,endIndex_4",
    call$2: function(from, to) {
      this.this_1._stringSink.write$1(P.String_String$fromCharCodes(this.codeUnits_2, from, to));
    }
  }
}],
["dart.core", "dart:core", , P, {
  "^": "",
  Function__toMangledNames: function(namedArguments) {
    return;
  },
  String__stringFromIterable: function(charCodes, start, end) {
    var t1, it, i, list;
    if (start < 0)
      throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(charCodes), null, null));
    t1 = end == null;
    if (!t1 && end < start)
      throw H.wrapException(P.RangeError$range(end, start, J.get$length$asx(charCodes), null, null));
    it = J.get$iterator$ax(charCodes);
    for (i = 0; i < start; ++i)
      if (!it.moveNext$0())
        throw H.wrapException(P.RangeError$range(start, 0, i, null, null));
    list = [];
    if (t1)
      for (; it.moveNext$0();)
        list.push(it.__internal$_current);
    else
      for (i = start; i < end; ++i) {
        if (!it.moveNext$0())
          throw H.wrapException(P.RangeError$range(end, start, i, null, null));
        list.push(it.__internal$_current);
      }
    return H.Primitives_stringFromCharCodes(list);
  },
  Comparable_compare: [function(a, b) {
    return J.compareTo$1$ns(a, b);
  }, "call$2", "Comparable_compare$closure", 4, 0, 601],
  Error_safeToString: function(object) {
    if (typeof object === "number" || typeof object === "boolean" || null == object)
      return J.toString$0(object);
    if (typeof object === "string")
      return JSON.stringify(object);
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Exception_Exception: function(message) {
    return new P._ExceptionImplementation(message);
  },
  identical: [function(a, b) {
    return a == null ? b == null : a === b;
  }, "call$2", "identical$closure", 4, 0, 602],
  identityHashCode: [function(object) {
    return H.objectHashCode(object);
  }, "call$1", "identityHashCode$closure", 2, 0, 603],
  List_List$from: function(other, growable, $E) {
    var list, t1;
    list = H.setRuntimeTypeInfo([], [$E]);
    for (t1 = J.get$iterator$ax(other); t1.moveNext$0();)
      list.push(t1.get$current());
    if (growable)
      return list;
    list.fixed$length = Array;
    return list;
  },
  print: function(object) {
    var line = H.S(object);
    H.printString(line);
  },
  String_String$fromCharCodes: function(charCodes, start, end) {
    var len, t1;
    if (charCodes.constructor !== Array)
      return P.String__stringFromIterable(charCodes, start, end);
    len = charCodes.length;
    if (start < 0 || start > len)
      throw H.wrapException(P.RangeError$range(start, 0, len, null, null));
    if (end == null)
      end = len;
    else if (end < start || end > len)
      throw H.wrapException(P.RangeError$range(end, start, len, null, null));
    if (start <= 0) {
      if (typeof end !== "number")
        return end.$lt();
      t1 = end < len;
    } else
      t1 = true;
    return H.Primitives_stringFromCharCodes(t1 ? C.JSArray_methods.sublist$2(charCodes, start, end) : charCodes);
  },
  Function__toMangledNames_closure: {
    "^": "Closure:959;result_0",
    call$2: function(symbol, value) {
      this.result_0.$indexSet(0, symbol.get$_name(), value);
    }
  },
  NoSuchMethodError_toString_closure: {
    "^": "Closure:1697;box_0",
    call$2: function(key, value) {
      var t1 = this.box_0;
      if (t1.i_1 > 0)
        t1.sb_0.write$1(", ");
      t1.sb_0.write$1(key.get$_name());
      t1.sb_0.write$1(": ");
      t1.sb_0.write$1(P.Error_safeToString(value));
      ++t1.i_1;
    }
  },
  Deprecated: {
    "^": "Object;expires",
    toString$0: function(_) {
      return "Deprecated feature. Will be removed " + this.expires;
    }
  },
  bool: {
    "^": "Object;",
    toString$0: function(_) {
      return this ? "true" : "false";
    },
    $isbool: true
  },
  "+bool": 0,
  Comparable: {
    "^": "Object;"
  },
  DateTime: {
    "^": "Object;millisecondsSinceEpoch<,isUtc",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDateTime)
        return false;
      return this.millisecondsSinceEpoch === other.millisecondsSinceEpoch && this.isUtc === other.isUtc;
    },
    compareTo$1: function(_, other) {
      return C.JSNumber_methods.compareTo$1(this.millisecondsSinceEpoch, other.get$millisecondsSinceEpoch());
    },
    get$hashCode: function(_) {
      return this.millisecondsSinceEpoch;
    },
    toString$0: function(_) {
      var t1, y, m, d, h, min, sec, ms;
      t1 = this.isUtc;
      y = P.DateTime__fourDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCFullYear() + 0 : H.Primitives_lazyAsJsDate(this).getFullYear() + 0);
      m = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMonth() + 1 : H.Primitives_lazyAsJsDate(this).getMonth() + 1);
      d = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCDate() + 0 : H.Primitives_lazyAsJsDate(this).getDate() + 0);
      h = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCHours() + 0 : H.Primitives_lazyAsJsDate(this).getHours() + 0);
      min = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMinutes() + 0 : H.Primitives_lazyAsJsDate(this).getMinutes() + 0);
      sec = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCSeconds() + 0 : H.Primitives_lazyAsJsDate(this).getSeconds() + 0);
      ms = P.DateTime__threeDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMilliseconds() + 0 : H.Primitives_lazyAsJsDate(this).getMilliseconds() + 0);
      if (t1)
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "Z";
      else
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms;
    },
    add$1: [function(_, duration) {
      return P.DateTime$fromMillisecondsSinceEpoch(this.millisecondsSinceEpoch + duration.get$inMilliseconds(), this.isUtc);
    }, "call$1", "get$add", 2, 0, 1713, 94, []],
    difference$1: function(other) {
      return P.Duration$(0, 0, 0, this.millisecondsSinceEpoch - other.get$millisecondsSinceEpoch(), 0, 0);
    },
    get$second: function() {
      return this.isUtc ? H.Primitives_lazyAsJsDate(this).getUTCSeconds() + 0 : H.Primitives_lazyAsJsDate(this).getSeconds() + 0;
    },
    DateTime$fromMillisecondsSinceEpoch$2$isUtc: function(millisecondsSinceEpoch, isUtc) {
      if (Math.abs(millisecondsSinceEpoch) > 8640000000000000)
        throw H.wrapException(P.ArgumentError$(millisecondsSinceEpoch));
    },
    $isDateTime: true,
    static: {"^": "DateTime_MONDAY,DateTime_TUESDAY,DateTime_WEDNESDAY,DateTime_THURSDAY,DateTime_FRIDAY,DateTime_SATURDAY,DateTime_SUNDAY,DateTime_DAYS_PER_WEEK,DateTime_JANUARY,DateTime_FEBRUARY,DateTime_MARCH,DateTime_APRIL,DateTime_MAY,DateTime_JUNE,DateTime_JULY,DateTime_AUGUST,DateTime_SEPTEMBER,DateTime_OCTOBER,DateTime_NOVEMBER,DateTime_DECEMBER,DateTime_MONTHS_PER_YEAR,DateTime__MAX_MILLISECONDS_SINCE_EPOCH", DateTime$fromMillisecondsSinceEpoch: function(millisecondsSinceEpoch, isUtc) {
        var t1 = new P.DateTime(millisecondsSinceEpoch, isUtc);
        t1.DateTime$fromMillisecondsSinceEpoch$2$isUtc(millisecondsSinceEpoch, isUtc);
        return t1;
      }, DateTime__fourDigits: function(n) {
        var absN, sign;
        absN = Math.abs(n);
        sign = n < 0 ? "-" : "";
        if (absN >= 1000)
          return "" + n;
        if (absN >= 100)
          return sign + "0" + H.S(absN);
        if (absN >= 10)
          return sign + "00" + H.S(absN);
        return sign + "000" + H.S(absN);
      }, DateTime__threeDigits: function(n) {
        if (n >= 100)
          return "" + n;
        if (n >= 10)
          return "0" + n;
        return "00" + n;
      }, DateTime__twoDigits: function(n) {
        if (n >= 10)
          return "" + n;
        return "0" + n;
      }}
  },
  $double: {
    "^": "num;",
    $is$double: true
  },
  "+double": 0,
  Duration: {
    "^": "Object;_duration<",
    $add: function(_, other) {
      return P.Duration$(0, 0, this._duration + other.get$_duration(), 0, 0, 0);
    },
    $sub: function(_, other) {
      return P.Duration$(0, 0, this._duration - other.get$_duration(), 0, 0, 0);
    },
    $mul: function(_, factor) {
      if (typeof factor !== "number")
        return H.iae(factor);
      return P.Duration$(0, 0, C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(this._duration * factor)), 0, 0, 0);
    },
    $tdiv: function(_, quotient) {
      if (J.$eq(quotient, 0))
        throw H.wrapException(P.IntegerDivisionByZeroException$());
      if (typeof quotient !== "number")
        return H.iae(quotient);
      return P.Duration$(0, 0, C.JSNumber_methods.$tdiv(this._duration, quotient), 0, 0, 0);
    },
    $lt: function(_, other) {
      return this._duration < other.get$_duration();
    },
    $gt: function(_, other) {
      return this._duration > other.get$_duration();
    },
    $le: function(_, other) {
      return this._duration <= other.get$_duration();
    },
    $ge: function(_, other) {
      return this._duration >= other.get$_duration();
    },
    get$inMilliseconds: function() {
      return C.JSNumber_methods._tdivFast$1(this._duration, 1000);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDuration)
        return false;
      return this._duration === other._duration;
    },
    get$hashCode: function(_) {
      return this._duration & 0x1FFFFFFF;
    },
    compareTo$1: function(_, other) {
      return C.JSNumber_methods.compareTo$1(this._duration, other.get$_duration());
    },
    toString$0: function(_) {
      var t1, t2, twoDigitMinutes, twoDigitSeconds, sixDigitUs;
      t1 = new P.Duration_toString_twoDigits();
      t2 = this._duration;
      if (t2 < 0)
        return "-" + P.Duration$(0, 0, -t2, 0, 0, 0).toString$0(0);
      twoDigitMinutes = t1.call$1(C.JSNumber_methods.remainder$1(C.JSNumber_methods._tdivFast$1(t2, 60000000), 60));
      twoDigitSeconds = t1.call$1(C.JSNumber_methods.remainder$1(C.JSNumber_methods._tdivFast$1(t2, 1000000), 60));
      sixDigitUs = new P.Duration_toString_sixDigits().call$1(C.JSNumber_methods.remainder$1(t2, 1000000));
      return H.S(C.JSNumber_methods._tdivFast$1(t2, 3600000000)) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
    },
    abs$0: function(_) {
      return P.Duration$(0, 0, Math.abs(this._duration), 0, 0, 0);
    },
    $negate: function(_) {
      return P.Duration$(0, 0, -this._duration, 0, 0, 0);
    },
    $isDuration: true,
    static: {"^": "Duration_MICROSECONDS_PER_MILLISECOND,Duration_MILLISECONDS_PER_SECOND,Duration_SECONDS_PER_MINUTE,Duration_MINUTES_PER_HOUR,Duration_HOURS_PER_DAY,Duration_MICROSECONDS_PER_SECOND,Duration_MICROSECONDS_PER_MINUTE,Duration_MICROSECONDS_PER_HOUR,Duration_MICROSECONDS_PER_DAY,Duration_MILLISECONDS_PER_MINUTE,Duration_MILLISECONDS_PER_HOUR,Duration_MILLISECONDS_PER_DAY,Duration_SECONDS_PER_HOUR,Duration_SECONDS_PER_DAY,Duration_MINUTES_PER_DAY,Duration_ZERO", Duration$: function(days, hours, microseconds, milliseconds, minutes, seconds) {
        return new P.Duration(days * 86400000000 + hours * 3600000000 + minutes * 60000000 + seconds * 1000000 + milliseconds * 1000 + microseconds);
      }}
  },
  Duration_toString_sixDigits: {
    "^": "Closure:559;",
    call$1: function(n) {
      if (n >= 100000)
        return H.S(n);
      if (n >= 10000)
        return "0" + H.S(n);
      if (n >= 1000)
        return "00" + H.S(n);
      if (n >= 100)
        return "000" + H.S(n);
      if (n >= 10)
        return "0000" + H.S(n);
      return "00000" + H.S(n);
    }
  },
  Duration_toString_twoDigits: {
    "^": "Closure:559;",
    call$1: function(n) {
      if (n >= 10)
        return H.S(n);
      return "0" + H.S(n);
    }
  },
  Error: {
    "^": "Object;",
    get$stackTrace: function() {
      return new H._StackTrace(this.$thrownJsError, null);
    },
    $isError: true
  },
  NullThrownError: {
    "^": "Error;",
    toString$0: function(_) {
      return "Throw of null.";
    }
  },
  ArgumentError: {
    "^": "Error;_hasValue,invalidValue,name>,message",
    toString$0: function(_) {
      var t1;
      if (!this._hasValue) {
        t1 = this.message;
        return t1 != null ? "Invalid arguments(s): " + H.S(t1) : "Invalid arguments(s)";
      }
      return H.S(this.message) + ": " + H.S(P.Error_safeToString(this.invalidValue));
    },
    static: {ArgumentError$: function(message) {
        return new P.ArgumentError(false, null, null, message);
      }}
  },
  RangeError: {
    "^": "ArgumentError;start>,end<,_hasValue,invalidValue,name,message",
    start$1: function($receiver, arg0) {
      return this.start.call$1(arg0);
    },
    start$0: function($receiver) {
      return this.start.call$0();
    },
    start$2: function($receiver, arg0, arg1) {
      return this.start.call$2(arg0, arg1);
    },
    start$3: function($receiver, arg0, arg1, arg2) {
      return this.start.call$3(arg0, arg1, arg2);
    },
    start$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.start.call$4(arg0, arg1, arg2, arg3);
    },
    start$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.start.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    end$0: function() {
      return this.end.call$0();
    },
    toString$0: function(_) {
      var value, t1, explanation, t2, t3;
      if (!this._hasValue)
        return "RangeError: " + H.S(this.message);
      value = P.Error_safeToString(this.invalidValue);
      t1 = this.start;
      if (t1 == null) {
        t1 = this.end;
        explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
      } else {
        t2 = this.end;
        if (t2 == null)
          explanation = ": Not greater than or equal to " + H.S(t1);
        else {
          t3 = J.getInterceptor$n(t2);
          if (t3.$gt(t2, t1))
            explanation = ": Not in range " + H.S(t1) + ".." + H.S(t2) + ", inclusive.";
          else
            explanation = t3.$lt(t2, t1) ? ": Valid value range is empty" : ": Only valid value is " + H.S(t1);
        }
      }
      return "RangeError: " + H.S(this.message) + " (" + H.S(value) + ")" + explanation;
    },
    $isRangeError: true,
    static: {RangeError$: function(message) {
        return new P.RangeError(null, null, false, null, null, message);
      }, RangeError$value: function(value, $name, message) {
        return new P.RangeError(null, null, true, value, $name, "Value not in range");
      }, RangeError$range: function(invalidValue, start, end, $name, message) {
        return new P.RangeError(start, end, true, invalidValue, $name, "Invalid value");
      }}
  },
  IndexError: {
    "^": "ArgumentError;indexable,length>,_hasValue,invalidValue,name,message",
    get$start: function(_) {
      return 0;
    },
    start$1: function($receiver, arg0) {
      return this.get$start(this).call$1(arg0);
    },
    start$0: function($receiver) {
      return this.get$start(this).call$0();
    },
    start$2: function($receiver, arg0, arg1) {
      return this.get$start(this).call$2(arg0, arg1);
    },
    start$3: function($receiver, arg0, arg1, arg2) {
      return this.get$start(this).call$3(arg0, arg1, arg2);
    },
    start$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$start(this).call$4(arg0, arg1, arg2, arg3);
    },
    start$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.get$start(this).call$5(arg0, arg1, arg2, arg3, arg4);
    },
    get$end: function() {
      return this.length - 1;
    },
    end$0: function() {
      return this.get$end().call$0();
    },
    toString$0: function(_) {
      var target, explanation, t1;
      target = P.Error_safeToString(this.indexable);
      explanation = "index should be less than " + this.length;
      t1 = this.invalidValue;
      if (J.$lt$n(t1, 0))
        explanation = "index must not be negative";
      return "RangeError: " + H.S(this.message) + " (" + H.S(target) + "[" + H.S(t1) + "]): " + explanation;
    },
    $isRangeError: true,
    $isError: true,
    static: {IndexError$: function(invalidValue, indexable, $name, message, $length) {
        var t1 = J.get$length$asx(indexable);
        return new P.IndexError(indexable, t1, true, invalidValue, $name, "Index out of range");
      }}
  },
  NoSuchMethodError: {
    "^": "Error;_core$_receiver,_memberName,_core$_arguments,_namedArguments,_existingArgumentNames",
    toString$0: function(_) {
      var t1, t2, t3, t4, t5, str;
      t1 = {};
      t1.sb_0 = P.StringBuffer$("");
      t1.i_1 = 0;
      t2 = this._core$_arguments;
      if (t2 != null) {
        t3 = J.getInterceptor$asx(t2);
        t4 = 0;
        while (true) {
          t5 = t3.get$length(t2);
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (!(t4 < t5))
            break;
          t4 = t1.i_1;
          if (t4 > 0) {
            t5 = t1.sb_0;
            t5._contents += ", ";
          }
          t5 = t1.sb_0;
          str = P.Error_safeToString(t3.$index(t2, t4));
          t5._contents += typeof str === "string" ? str : H.S(str);
          t4 = ++t1.i_1;
        }
      }
      t2 = this._namedArguments;
      if (t2 != null)
        t2.forEach$1(0, new P.NoSuchMethodError_toString_closure(t1));
      return "NoSuchMethodError : method not found: '" + J.toString$0(this._memberName) + "'\nReceiver: " + H.S(P.Error_safeToString(this._core$_receiver)) + "\nArguments: [" + H.S(t1.sb_0) + "]";
    },
    static: {NoSuchMethodError$: function(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames) {
        return new P.NoSuchMethodError(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames);
      }}
  },
  UnsupportedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    static: {UnsupportedError$: function(message) {
        return new P.UnsupportedError(message);
      }}
  },
  UnimplementedError: {
    "^": "Error;message",
    toString$0: function(_) {
      var t1 = this.message;
      return t1 != null ? "UnimplementedError: " + H.S(t1) : "UnimplementedError";
    },
    $isError: true,
    static: {UnimplementedError$: function(message) {
        return new P.UnimplementedError(message);
      }}
  },
  StateError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Bad state: " + this.message;
    },
    static: {StateError$: function(message) {
        return new P.StateError(message);
      }}
  },
  ConcurrentModificationError: {
    "^": "Error;modifiedObject",
    toString$0: function(_) {
      return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(this.modifiedObject)) + ".";
    },
    static: {ConcurrentModificationError$: function(modifiedObject) {
        return new P.ConcurrentModificationError(modifiedObject);
      }}
  },
  OutOfMemoryError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Out of Memory";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: true
  },
  StackOverflowError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Stack Overflow";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: true
  },
  CyclicInitializationError: {
    "^": "Error;variableName",
    toString$0: function(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    },
    static: {CyclicInitializationError$: function(variableName) {
        return new P.CyclicInitializationError(variableName);
      }}
  },
  _ExceptionImplementation: {
    "^": "Object;message",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 == null)
        return "Exception";
      return "Exception: " + H.S(t1);
    }
  },
  FormatException: {
    "^": "Object;message,source>,offset>",
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    toString$0: function(_) {
      var t1, report, offset, source, lineNum, lineStart, lastWasCR, i, $char, lineEnd, t2, end, start, prefix, postfix, slice;
      t1 = this.message;
      report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException";
      offset = this.offset;
      source = this.source;
      if (typeof source !== "string")
        return offset != null ? report + (" (at offset " + H.S(offset) + ")") : report;
      if (offset != null) {
        t1 = J.getInterceptor$n(offset);
        t1 = t1.$lt(offset, 0) || t1.$gt(offset, J.get$length$asx(source));
      } else
        t1 = false;
      if (t1)
        offset = null;
      if (offset == null) {
        t1 = J.getInterceptor$asx(source);
        if (J.$gt$n(t1.get$length(source), 78))
          source = t1.substring$2(source, 0, 75) + "...";
        return report + "\n" + H.S(source);
      }
      if (typeof offset !== "number")
        return H.iae(offset);
      t1 = J.getInterceptor$asx(source);
      lineNum = 1;
      lineStart = 0;
      lastWasCR = null;
      i = 0;
      for (; i < offset; ++i) {
        $char = t1.codeUnitAt$1(source, i);
        if ($char === 10) {
          if (lineStart !== i || lastWasCR !== true)
            ++lineNum;
          lineStart = i + 1;
          lastWasCR = false;
        } else if ($char === 13) {
          ++lineNum;
          lineStart = i + 1;
          lastWasCR = true;
        }
      }
      report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + H.S(offset - lineStart + 1) + ")\n") : report + (" (at character " + H.S(offset + 1) + ")\n");
      lineEnd = t1.get$length(source);
      i = offset;
      while (true) {
        t2 = t1.get$length(source);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        $char = t1.codeUnitAt$1(source, i);
        if ($char === 10 || $char === 13) {
          lineEnd = i;
          break;
        }
        ++i;
      }
      t2 = J.getInterceptor$n(lineEnd);
      if (J.$gt$n(t2.$sub(lineEnd, lineStart), 78))
        if (offset - lineStart < 75) {
          end = lineStart + 75;
          start = lineStart;
          prefix = "";
          postfix = "...";
        } else {
          if (J.$lt$n(t2.$sub(lineEnd, offset), 75)) {
            start = t2.$sub(lineEnd, 75);
            end = lineEnd;
            postfix = "";
          } else {
            start = offset - 36;
            end = offset + 36;
            postfix = "...";
          }
          prefix = "...";
        }
      else {
        end = lineEnd;
        start = lineStart;
        prefix = "";
        postfix = "";
      }
      slice = t1.substring$2(source, start, end);
      if (typeof start !== "number")
        return H.iae(start);
      return report + prefix + slice + postfix + "\n" + C.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
    },
    static: {FormatException$: function(message, source, offset) {
        return new P.FormatException(message, source, offset);
      }}
  },
  IntegerDivisionByZeroException: {
    "^": "Object;",
    toString$0: function(_) {
      return "IntegerDivisionByZeroException";
    },
    static: {IntegerDivisionByZeroException$: function() {
        return new P.IntegerDivisionByZeroException();
      }}
  },
  Expando: {
    "^": "Object;name>",
    toString$0: function(_) {
      return "Expando:" + H.S(this.name);
    },
    $index: function(_, object) {
      var values = H.Primitives_getProperty(object, "expando$values");
      return values == null ? null : H.Primitives_getProperty(values, this._getKey$0());
    },
    $indexSet: function(_, object, value) {
      var values = H.Primitives_getProperty(object, "expando$values");
      if (values == null) {
        values = new P.Object();
        H.Primitives_setProperty(object, "expando$values", values);
      }
      H.Primitives_setProperty(values, this._getKey$0(), value);
    },
    _getKey$0: function() {
      var key, t1;
      key = H.Primitives_getProperty(this, "expando$key");
      if (key == null) {
        t1 = $.Expando__keyCount;
        $.Expando__keyCount = t1 + 1;
        key = "expando$key$" + t1;
        H.Primitives_setProperty(this, "expando$key", key);
      }
      return key;
    },
    static: {"^": "Expando__KEY_PROPERTY_NAME,Expando__EXPANDO_PROPERTY_NAME,Expando__keyCount", Expando$: function($name, $T) {
        return H.setRuntimeTypeInfo(new P.Expando($name), [$T]);
      }}
  },
  Function: {
    "^": "Object;",
    $isFunction: true
  },
  $int: {
    "^": "num;",
    $is$int: true
  },
  "+int": 0,
  Invocation: {
    "^": "Object;"
  },
  Iterable: {
    "^": "Object;"
  },
  Iterator: {
    "^": "Object;"
  },
  List: {
    "^": "Object;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  "+List": 0,
  Map: {
    "^": "Object;",
    $isMap: true,
    $asMap: null
  },
  Null: {
    "^": "Object;",
    toString$0: function(_) {
      return "null";
    }
  },
  "+Null": 0,
  num: {
    "^": "Object;",
    $isnum: true
  },
  "+num": 0,
  Object: {
    "^": ";",
    $eq: [function(_, other) {
      return this === other;
    }, "call$1", "get$==", 2, 0, 1004, 1714, [], "=="],
    get$hashCode: [function(_) {
      return H.Primitives_objectHashCode(this);
    }, null, null, 1, 0, 412, "hashCode"],
    toString$0: [function(_) {
      return H.Primitives_objectToString(this);
    }, "call$0", "get$toString", 0, 0, 810, "toString"],
    noSuchMethod$1: [function(_, invocation) {
      throw H.wrapException(P.NoSuchMethodError$(this, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments(), null));
    }, "call$1", "get$noSuchMethod", 2, 0, 1715, 1692, [], "noSuchMethod"],
    get$runtimeType: [function(_) {
      return new H.TypeImpl(H.getRuntimeTypeString(this), null);
    }, null, null, 1, 0, 53, "runtimeType"],
    $isObject: true
  },
  Pattern: {
    "^": "Object;"
  },
  Match: {
    "^": "Object;",
    $isMatch: true
  },
  StackTrace: {
    "^": "Object;"
  },
  String: {
    "^": "Object;",
    $isString: true
  },
  "+String": 0,
  StringBuffer: {
    "^": "Object;_contents<",
    get$length: function(_) {
      return this._contents.length;
    },
    get$isEmpty: function(_) {
      return this._contents.length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._contents.length !== 0;
    },
    write$1: function(obj) {
      this._contents += typeof obj === "string" ? obj : H.S(obj);
    },
    writeAll$2: function(objects, separator) {
      var iterator, str;
      iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return;
      if (separator.length === 0) {
        do {
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        } while (iterator.moveNext$0());
      } else {
        this.write$1(iterator.get$current());
        for (; iterator.moveNext$0();) {
          this._contents += separator;
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        }
      }
    },
    clear$0: function(_) {
      this._contents = "";
    },
    toString$0: function(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    StringBuffer$1: function($content) {
      this._contents = $content;
    },
    static: {StringBuffer$: function($content) {
        var t1 = new P.StringBuffer("");
        t1.StringBuffer$1($content);
        return t1;
      }}
  },
  Symbol0: {
    "^": "Object;",
    $isSymbol0: true
  },
  Type: {
    "^": "Object;",
    $isType: true
  },
  Uri: {
    "^": "Object;_host,_port,_path,scheme,_userInfo,_query,_fragment,_pathSegments,_queryParameters",
    get$host: function(_) {
      var t1, t2;
      t1 = this._host;
      if (t1 == null)
        return "";
      t2 = J.getInterceptor$s(t1);
      if (t2.startsWith$1(t1, "["))
        return t2.substring$2(t1, 1, J.$sub$n(t2.get$length(t1), 1));
      return t1;
    },
    get$port: function(_) {
      var t1 = this._port;
      if (t1 == null)
        return P.Uri__defaultPort(this.scheme);
      return t1;
    },
    toString$0: function(_) {
      var sb, t1, t2, t3;
      sb = P.StringBuffer$("");
      t1 = this.scheme;
      if ("" !== t1) {
        sb.write$1(t1);
        sb.write$1(":");
      }
      t2 = this._host;
      t3 = t2 == null;
      if (!t3 || J.startsWith$1$s(this._path, "//") || t1 === "file") {
        sb.write$1("//");
        t1 = this._userInfo;
        if (J.get$isNotEmpty$asx(t1)) {
          sb.write$1(t1);
          sb.write$1("@");
        }
        if (!t3)
          sb.write$1(t2);
        t1 = this._port;
        if (t1 != null) {
          sb.write$1(":");
          sb.write$1(t1);
        }
      }
      sb.write$1(this._path);
      t1 = this._query;
      if (t1 != null) {
        sb.write$1("?");
        sb.write$1(t1);
      }
      t1 = this._fragment;
      if (t1 != null) {
        sb.write$1("#");
        sb.write$1(t1);
      }
      t1 = sb._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $eq: function(_, other) {
      var t1, t2, t3, t4;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isUri)
        return false;
      if (this.scheme === other.scheme)
        if (this._host != null === (other._host != null))
          if (J.$eq(this._userInfo, other._userInfo))
            if (J.$eq(this.get$host(this), t1.get$host(other))) {
              t2 = this.get$port(this);
              t1 = t1.get$port(other);
              if (t2 == null ? t1 == null : t2 === t1)
                if (J.$eq(this._path, other._path)) {
                  t1 = this._query;
                  t2 = t1 == null;
                  t3 = other._query;
                  t4 = t3 == null;
                  if (!t2 === !t4) {
                    if (t2)
                      t1 = "";
                    if (J.$eq(t1, t4 ? "" : t3)) {
                      t1 = this._fragment;
                      t2 = t1 == null;
                      t3 = other._fragment;
                      t4 = t3 == null;
                      if (!t2 === !t4) {
                        if (t2)
                          t1 = "";
                        t1 = J.$eq(t1, t4 ? "" : t3);
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  } else
                    t1 = false;
                } else
                  t1 = false;
              else
                t1 = false;
            } else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1, t2, t3, t4, t5;
      t1 = new P.Uri_hashCode_combine();
      t2 = this.get$host(this);
      t3 = this.get$port(this);
      t4 = this._query;
      if (t4 == null)
        t4 = "";
      t5 = this._fragment;
      return t1.call$2(this.scheme, t1.call$2(this._userInfo, t1.call$2(t2, t1.call$2(t3, t1.call$2(this._path, t1.call$2(t4, t1.call$2(t5 == null ? "" : t5, 1)))))));
    },
    $isUri: true,
    static: {"^": "Uri__SPACE,Uri__DOUBLE_QUOTE,Uri__NUMBER_SIGN,Uri__PERCENT,Uri__ASTERISK,Uri__PLUS,Uri__DOT,Uri__SLASH,Uri__ZERO,Uri__NINE,Uri__COLON,Uri__LESS,Uri__GREATER,Uri__QUESTION,Uri__AT_SIGN,Uri__UPPER_CASE_A,Uri__UPPER_CASE_F,Uri__UPPER_CASE_Z,Uri__LEFT_BRACKET,Uri__BACKSLASH,Uri__RIGHT_BRACKET,Uri__LOWER_CASE_A,Uri__LOWER_CASE_F,Uri__LOWER_CASE_Z,Uri__BAR,Uri__unreservedTable,Uri__unreserved2396Table,Uri__encodeFullTable,Uri__schemeTable,Uri__schemeLowerTable,Uri__subDelimitersTable,Uri__genDelimitersTable,Uri__userinfoTable,Uri__regNameTable,Uri__pathCharTable,Uri__pathCharOrSlashTable,Uri__queryCharTable", Uri__defaultPort: function(scheme) {
        if (scheme === "http")
          return 80;
        if (scheme === "https")
          return 443;
        return 0;
      }, Uri_parse: function(uri) {
        var t1, pathStart, state, t2, i, t3, $char, index, t4, path, numberSignIndex, t5, query, fragment;
        t1 = {};
        t1.scheme_0 = "";
        t1.userinfo_1 = "";
        t1.host_2 = null;
        t1.port_3 = null;
        t1.index_4 = 0;
        t1.char_5 = -1;
        t2 = J.getInterceptor$asx(uri);
        i = 0;
        while (true) {
          t3 = t2.get$length(uri);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3)) {
            pathStart = 0;
            state = 0;
            break;
          }
          $char = t2.codeUnitAt$1(uri, i);
          t1.char_5 = $char;
          if ($char === 63 || $char === 35) {
            pathStart = 0;
            state = 0;
            break;
          }
          if ($char === 47) {
            state = i === 0 ? 2 : 1;
            pathStart = 0;
            break;
          }
          if ($char === 58) {
            if (i === 0)
              P.Uri__fail(uri, 0, "Invalid empty scheme");
            t1.scheme_0 = P.Uri__makeScheme(uri, i);
            ++i;
            if (i === t2.get$length(uri)) {
              t1.char_5 = -1;
              state = 0;
            } else {
              $char = t2.codeUnitAt$1(uri, i);
              t1.char_5 = $char;
              if ($char === 63 || $char === 35)
                state = 0;
              else
                state = $char === 47 ? 2 : 1;
            }
            pathStart = i;
            break;
          }
          ++i;
          t1.char_5 = -1;
        }
        t1.index_4 = i;
        if (state === 2) {
          index = i + 1;
          t1.index_4 = index;
          if (index === t2.get$length(uri)) {
            t1.char_5 = -1;
            state = 0;
          } else {
            $char = t2.codeUnitAt$1(uri, t1.index_4);
            t1.char_5 = $char;
            if ($char === 47) {
              t1.index_4 = J.$add$ns(t1.index_4, 1);
              new P.Uri_parse_parseAuth(t1, uri, -1).call$0();
              pathStart = t1.index_4;
            }
            t3 = t1.char_5;
            state = t3 === 63 || t3 === 35 || t3 === -1 ? 0 : 1;
          }
        }
        if (state === 1)
          for (; index = J.$add$ns(t1.index_4, 1), t1.index_4 = index, J.$lt$n(index, t2.get$length(uri));) {
            $char = t2.codeUnitAt$1(uri, t1.index_4);
            t1.char_5 = $char;
            if ($char === 63 || $char === 35)
              break;
            t1.char_5 = -1;
          }
        t3 = t1.scheme_0;
        t4 = t1.host_2;
        path = P.Uri__makePath(uri, pathStart, t1.index_4, null, t4 != null, t3 === "file");
        t3 = t1.char_5;
        if (t3 === 63) {
          numberSignIndex = t2.indexOf$2(uri, "#", J.$add$ns(t1.index_4, 1));
          t3 = J.getInterceptor$n(numberSignIndex);
          t4 = t3.$lt(numberSignIndex, 0);
          t5 = t1.index_4;
          if (t4) {
            query = P.Uri__makeQuery(uri, J.$add$ns(t5, 1), t2.get$length(uri), null);
            fragment = null;
          } else {
            query = P.Uri__makeQuery(uri, J.$add$ns(t5, 1), numberSignIndex, null);
            fragment = P.Uri__makeFragment(uri, t3.$add(numberSignIndex, 1), t2.get$length(uri));
          }
        } else {
          fragment = t3 === 35 ? P.Uri__makeFragment(uri, J.$add$ns(t1.index_4, 1), t2.get$length(uri)) : null;
          query = null;
        }
        t2 = t1.scheme_0;
        t3 = t1.userinfo_1;
        return new P.Uri(t1.host_2, t1.port_3, path, t2, t3, query, fragment, null, null);
      }, Uri__fail: function(uri, index, message) {
        throw H.wrapException(P.FormatException$(message, uri, index));
      }, Uri__makePort: function(port, scheme) {
        if (port != null && port === P.Uri__defaultPort(scheme))
          return;
        return port;
      }, Uri__makeHost: function(host, start, end, strictIPv6) {
        var t1, t2, t3, i;
        if (host == null)
          return;
        t1 = J.getInterceptor(start);
        if (t1.$eq(start, end))
          return "";
        t2 = J.getInterceptor$s(host);
        if (t2.codeUnitAt$1(host, start) === 91) {
          t3 = J.getInterceptor$n(end);
          if (t2.codeUnitAt$1(host, t3.$sub(end, 1)) !== 93)
            P.Uri__fail(host, start, "Missing end `]` to match `[` in host");
          P.Uri_parseIPv6Address(host, t1.$add(start, 1), t3.$sub(end, 1));
          return t2.substring$2(host, start, end).toLowerCase();
        }
        if (!strictIPv6)
          for (i = start; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = t1.$add(i, 1))
            if (t2.codeUnitAt$1(host, i) === 58) {
              P.Uri_parseIPv6Address(host, start, end);
              return "[" + H.S(host) + "]";
            }
        return P.Uri__normalizeRegName(host, start, end);
      }, Uri__normalizeRegName: function(host, start, end) {
        var t1, index, sectionStart, buffer, isNormalized, t2, $char, replacement, t3, slice, sourceLength, tail;
        for (t1 = J.getInterceptor$s(host), index = start, sectionStart = index, buffer = null, isNormalized = true; t2 = J.getInterceptor$n(index), t2.$lt(index, end);) {
          $char = t1.codeUnitAt$1(host, index);
          if ($char === 37) {
            replacement = P.Uri__normalizeEscape(host, index, true);
            t3 = replacement == null;
            if (t3 && isNormalized) {
              index = t2.$add(index, 3);
              continue;
            }
            if (buffer == null) {
              buffer = new P.StringBuffer("");
              buffer._contents = "";
            }
            slice = t1.substring$2(host, sectionStart, index);
            if (!isNormalized)
              slice = slice.toLowerCase();
            buffer._contents = buffer._contents + slice;
            if (t3) {
              replacement = t1.substring$2(host, index, t2.$add(index, 3));
              sourceLength = 3;
            } else if (replacement === "%") {
              replacement = "%25";
              sourceLength = 1;
            } else
              sourceLength = 3;
            buffer._contents += replacement;
            index = t2.$add(index, sourceLength);
            sectionStart = index;
            isNormalized = true;
          } else {
            if ($char < 127) {
              t3 = $char >>> 4;
              if (t3 >= 8)
                return H.ioore(C.List_qNA, t3);
              t3 = (C.List_qNA[t3] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
            } else
              t3 = false;
            if (t3) {
              if (isNormalized && 65 <= $char && 90 >= $char) {
                if (buffer == null) {
                  buffer = new P.StringBuffer("");
                  buffer._contents = "";
                }
                if (J.$lt$n(sectionStart, index)) {
                  t3 = t1.substring$2(host, sectionStart, index);
                  buffer._contents = buffer._contents + t3;
                  sectionStart = index;
                }
                isNormalized = false;
              }
              index = t2.$add(index, 1);
            } else {
              if ($char <= 93) {
                t3 = $char >>> 4;
                if (t3 >= 8)
                  return H.ioore(C.List_2Vk, t3);
                t3 = (C.List_2Vk[t3] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
              } else
                t3 = false;
              if (t3)
                P.Uri__fail(host, index, "Invalid character");
              else {
                if (($char & 64512) === 55296 && J.$lt$n(t2.$add(index, 1), end)) {
                  tail = t1.codeUnitAt$1(host, t2.$add(index, 1));
                  if ((tail & 64512) === 56320) {
                    $char = (65536 | ($char & 1023) << 10 | tail & 1023) >>> 0;
                    sourceLength = 2;
                  } else
                    sourceLength = 1;
                } else
                  sourceLength = 1;
                if (buffer == null) {
                  buffer = new P.StringBuffer("");
                  buffer._contents = "";
                }
                slice = t1.substring$2(host, sectionStart, index);
                if (!isNormalized)
                  slice = slice.toLowerCase();
                buffer._contents = buffer._contents + slice;
                t3 = P.Uri__escapeChar($char);
                buffer._contents += t3;
                index = t2.$add(index, sourceLength);
                sectionStart = index;
              }
            }
          }
        }
        if (buffer == null)
          return t1.substring$2(host, start, end);
        if (J.$lt$n(sectionStart, end)) {
          slice = t1.substring$2(host, sectionStart, end);
          buffer.write$1(!isNormalized ? slice.toLowerCase() : slice);
        }
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, Uri__makeScheme: function(scheme, end) {
        var t1, firstCodeUnit, allLowercase, t2, i, codeUnit;
        if (J.$eq(end, 0))
          return "";
        t1 = J.getInterceptor$s(scheme);
        firstCodeUnit = t1.codeUnitAt$1(scheme, 0);
        allLowercase = firstCodeUnit >= 97;
        if (!(allLowercase && firstCodeUnit <= 122))
          t2 = firstCodeUnit >= 65 && firstCodeUnit <= 90;
        else
          t2 = true;
        if (!t2)
          P.Uri__fail(scheme, 0, "Scheme not starting with alphabetic character");
        if (typeof end !== "number")
          return H.iae(end);
        i = 0;
        for (; i < end; ++i) {
          codeUnit = t1.codeUnitAt$1(scheme, i);
          if (codeUnit < 128) {
            t2 = codeUnit >>> 4;
            if (t2 >= 8)
              return H.ioore(C.List_JYB, t2);
            t2 = (C.List_JYB[t2] & C.JSInt_methods._shlPositive$1(1, codeUnit & 15)) !== 0;
          } else
            t2 = false;
          if (!t2)
            P.Uri__fail(scheme, i, "Illegal scheme character");
          if (codeUnit < 97 || codeUnit > 122)
            allLowercase = false;
        }
        scheme = t1.substring$2(scheme, 0, end);
        return !allLowercase ? scheme.toLowerCase() : scheme;
      }, Uri__makeUserInfo: function(userInfo, start, end) {
        if (userInfo == null)
          return "";
        return P.Uri__normalize(userInfo, start, end, C.List_gRj);
      }, Uri__makePath: function(path, start, end, pathSegments, ensureLeadingSlash, isFile) {
        var t1, result;
        t1 = path == null;
        if (t1 && true)
          return isFile ? "/" : "";
        t1 = !t1;
        if (t1)
          ;
        result = t1 ? P.Uri__normalize(path, start, end, C.List_qg4) : C.JSNull_methods.map$1(pathSegments, new P.Uri__makePath_closure()).join$1(0, "/");
        t1 = J.getInterceptor$asx(result);
        if (t1.get$isEmpty(result) === true) {
          if (isFile)
            return "/";
        } else if ((isFile || ensureLeadingSlash) && t1.codeUnitAt$1(result, 0) !== 47)
          return "/" + H.S(result);
        return result;
      }, Uri__makeQuery: function(query, start, end, queryParameters) {
        var t1, t2, result;
        t1 = {};
        t2 = query == null;
        if (t2 && queryParameters == null)
          return;
        t2 = !t2;
        if (t2 && queryParameters != null)
          throw H.wrapException(P.ArgumentError$("Both query and queryParameters specified"));
        if (t2)
          return P.Uri__normalize(query, start, end, C.List_CVk);
        result = P.StringBuffer$("");
        t1.first_0 = true;
        queryParameters.forEach$1(0, new P.Uri__makeQuery_closure(t1, result));
        t1 = result._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, Uri__makeFragment: function(fragment, start, end) {
        if (fragment == null)
          return;
        return P.Uri__normalize(fragment, start, end, C.List_CVk);
      }, Uri__isHexDigit: function($char) {
        if (57 >= $char)
          return 48 <= $char;
        $char |= 32;
        return 97 <= $char && 102 >= $char;
      }, Uri__hexValue: function($char) {
        if (57 >= $char)
          return $char - 48;
        return ($char | 32) - 87;
      }, Uri__normalizeEscape: function(source, index, lowerCase) {
        var t1, t2, firstDigit, secondDigit, value, t3;
        t1 = J.getInterceptor$ns(index);
        t2 = J.getInterceptor$asx(source);
        if (J.$ge$n(t1.$add(index, 2), t2.get$length(source)))
          return "%";
        firstDigit = t2.codeUnitAt$1(source, t1.$add(index, 1));
        secondDigit = t2.codeUnitAt$1(source, t1.$add(index, 2));
        if (!P.Uri__isHexDigit(firstDigit) || !P.Uri__isHexDigit(secondDigit))
          return "%";
        value = P.Uri__hexValue(firstDigit) * 16 + P.Uri__hexValue(secondDigit);
        if (value < 127) {
          t3 = C.JSInt_methods._shrOtherPositive$1(value, 4);
          if (t3 >= 8)
            return H.ioore(C.List_nxB, t3);
          t3 = (C.List_nxB[t3] & C.JSInt_methods._shlPositive$1(1, value & 15)) !== 0;
        } else
          t3 = false;
        if (t3)
          return H.Primitives_stringFromCharCode(lowerCase && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
        if (firstDigit >= 97 || secondDigit >= 97)
          return t2.substring$2(source, index, t1.$add(index, 3)).toUpperCase();
        return;
      }, Uri__escapeChar: function($char) {
        var codeUnits, flag, encodedBytes, t1, index, $byte, t2, t3;
        if ($char < 128) {
          codeUnits = Array(3);
          codeUnits.fixed$length = init;
          codeUnits[0] = 37;
          codeUnits[1] = C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", $char >>> 4);
          codeUnits[2] = C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", $char & 15);
        } else {
          if ($char > 2047)
            if ($char > 65535) {
              flag = 240;
              encodedBytes = 4;
            } else {
              flag = 224;
              encodedBytes = 3;
            }
          else {
            flag = 192;
            encodedBytes = 2;
          }
          t1 = 3 * encodedBytes;
          codeUnits = Array(t1);
          codeUnits.fixed$length = init;
          for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
            $byte = C.JSInt_methods._shrReceiverPositive$1($char, 6 * encodedBytes) & 63 | flag;
            if (index >= t1)
              return H.ioore(codeUnits, index);
            codeUnits[index] = 37;
            t2 = index + 1;
            t3 = C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", $byte >>> 4);
            if (t2 >= t1)
              return H.ioore(codeUnits, t2);
            codeUnits[t2] = t3;
            t3 = index + 2;
            t2 = C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", $byte & 15);
            if (t3 >= t1)
              return H.ioore(codeUnits, t3);
            codeUnits[t3] = t2;
            index += 3;
          }
        }
        return P.String_String$fromCharCodes(codeUnits, 0, null);
      }, Uri__normalize: function(component, start, end, charTable) {
        var t1, index, sectionStart, buffer, t2, $char, t3, replacement, sourceLength, tail;
        for (t1 = J.getInterceptor$s(component), index = start, sectionStart = index, buffer = null; t2 = J.getInterceptor$n(index), t2.$lt(index, end);) {
          $char = t1.codeUnitAt$1(component, index);
          if ($char < 127) {
            t3 = $char >>> 4;
            if (t3 >= 8)
              return H.ioore(charTable, t3);
            t3 = (charTable[t3] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
          } else
            t3 = false;
          if (t3)
            index = t2.$add(index, 1);
          else {
            if ($char === 37) {
              replacement = P.Uri__normalizeEscape(component, index, false);
              if (replacement == null) {
                index = t2.$add(index, 3);
                continue;
              }
              if ("%" === replacement) {
                replacement = "%25";
                sourceLength = 1;
              } else
                sourceLength = 3;
            } else {
              if ($char <= 93) {
                t3 = $char >>> 4;
                if (t3 >= 8)
                  return H.ioore(C.List_2Vk, t3);
                t3 = (C.List_2Vk[t3] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
              } else
                t3 = false;
              if (t3) {
                P.Uri__fail(component, index, "Invalid character");
                replacement = null;
                sourceLength = null;
              } else {
                if (($char & 64512) === 55296)
                  if (J.$lt$n(t2.$add(index, 1), end)) {
                    tail = t1.codeUnitAt$1(component, t2.$add(index, 1));
                    if ((tail & 64512) === 56320) {
                      $char = (65536 | ($char & 1023) << 10 | tail & 1023) >>> 0;
                      sourceLength = 2;
                    } else
                      sourceLength = 1;
                  } else
                    sourceLength = 1;
                else
                  sourceLength = 1;
                replacement = P.Uri__escapeChar($char);
              }
            }
            if (buffer == null) {
              buffer = new P.StringBuffer("");
              buffer._contents = "";
            }
            t3 = t1.substring$2(component, sectionStart, index);
            buffer._contents = buffer._contents + t3;
            buffer._contents += typeof replacement === "string" ? replacement : H.S(replacement);
            index = t2.$add(index, sourceLength);
            sectionStart = index;
          }
        }
        if (buffer == null)
          return t1.substring$2(component, start, end);
        if (J.$lt$n(sectionStart, end))
          buffer.write$1(t1.substring$2(component, sectionStart, end));
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, Uri_parseIPv4Address: function(host) {
        var t1, bytes;
        t1 = new P.Uri_parseIPv4Address_error();
        bytes = host.split(".");
        if (bytes.length !== 4)
          t1.call$1("IPv4 address should contain exactly 4 parts");
        return H.setRuntimeTypeInfo(new H.MappedListIterable(bytes, new P.Uri_parseIPv4Address_closure(t1)), [null, null]).toList$0(0);
      }, Uri_parseIPv6Address: function(host, start, end) {
        var error, parseHex, parts, partStart, last, i, wildcardSeen, t1, atEnd, isLastWildcard, exception, t2, bytes, index, value, wildCardLength, j;
        if (end == null)
          end = J.get$length$asx(host);
        error = new P.Uri_parseIPv6Address_error(host);
        parseHex = new P.Uri_parseIPv6Address_parseHex(host, error);
        if (J.$lt$n(J.get$length$asx(host), 2))
          error.call$1("address is too short");
        parts = [];
        partStart = start;
        for (i = start, wildcardSeen = false; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = J.$add$ns(i, 1))
          if (J.codeUnitAt$1$s(host, i) === 58) {
            if (t1.$eq(i, start)) {
              i = t1.$add(i, 1);
              if (J.codeUnitAt$1$s(host, i) !== 58)
                error.call$2("invalid start colon.", i);
              partStart = i;
            }
            t1 = J.getInterceptor(i);
            if (t1.$eq(i, partStart)) {
              if (wildcardSeen)
                error.call$2("only one wildcard `::` is allowed", i);
              J.add$1$ax(parts, -1);
              wildcardSeen = true;
            } else
              J.add$1$ax(parts, parseHex.call$2(partStart, i));
            partStart = t1.$add(i, 1);
          }
        if (J.get$length$asx(parts) === 0)
          error.call$1("too few parts");
        atEnd = J.$eq(partStart, end);
        isLastWildcard = J.$eq(J.get$last$ax(parts), -1);
        if (atEnd && !isLastWildcard)
          error.call$2("expected a part after last `:`", end);
        if (!atEnd)
          try {
            J.add$1$ax(parts, parseHex.call$2(partStart, end));
          } catch (exception) {
            H.unwrapException(exception);
            try {
              last = P.Uri_parseIPv4Address(J.substring$2$s(host, partStart, end));
              t1 = J.$shl$n(J.$index$asx(last, 0), 8);
              t2 = J.$index$asx(last, 1);
              if (typeof t2 !== "number")
                return H.iae(t2);
              J.add$1$ax(parts, (t1 | t2) >>> 0);
              t2 = J.$shl$n(J.$index$asx(last, 2), 8);
              t1 = J.$index$asx(last, 3);
              if (typeof t1 !== "number")
                return H.iae(t1);
              J.add$1$ax(parts, (t2 | t1) >>> 0);
            } catch (exception) {
              H.unwrapException(exception);
              error.call$2("invalid end of IPv6 address.", partStart);
            }

          }

        if (wildcardSeen) {
          if (J.get$length$asx(parts) > 7)
            error.call$1("an address with a wildcard must have less than 7 parts");
        } else if (J.get$length$asx(parts) !== 8)
          error.call$1("an address without a wildcard must contain exactly 8 parts");
        bytes = Array(16);
        bytes.$builtinTypeInfo = [P.$int];
        i = 0;
        index = 0;
        while (true) {
          t1 = J.get$length$asx(parts);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          value = J.$index$asx(parts, i);
          t1 = J.getInterceptor(value);
          if (t1.$eq(value, -1)) {
            wildCardLength = 9 - J.get$length$asx(parts);
            for (j = 0; j < wildCardLength; ++j) {
              if (index < 0 || index >= 16)
                return H.ioore(bytes, index);
              bytes[index] = 0;
              t1 = index + 1;
              if (t1 >= 16)
                return H.ioore(bytes, t1);
              bytes[t1] = 0;
              index += 2;
            }
          } else {
            t2 = t1.$shr(value, 8);
            if (index < 0 || index >= 16)
              return H.ioore(bytes, index);
            bytes[index] = t2;
            t2 = index + 1;
            t1 = t1.$and(value, 255);
            if (t2 >= 16)
              return H.ioore(bytes, t2);
            bytes[t2] = t1;
            index += 2;
          }
          ++i;
        }
        return bytes;
      }, Uri__uriEncode: function(canonicalTable, text, encoding, spaceToPlus) {
        var t1, result, bytes, t2, i, $byte, t3;
        t1 = new P.Uri__uriEncode_byteToHex();
        result = P.StringBuffer$("");
        bytes = encoding.get$encoder().convert$1(text);
        for (t2 = bytes.length, i = 0; i < t2; ++i) {
          $byte = bytes[i];
          if ($byte < 128) {
            t3 = $byte >>> 4;
            if (t3 >= 8)
              return H.ioore(canonicalTable, t3);
            t3 = (canonicalTable[t3] & C.JSInt_methods._shlPositive$1(1, $byte & 15)) !== 0;
          } else
            t3 = false;
          if (t3) {
            t3 = H.Primitives_stringFromCharCode($byte);
            result._contents += t3;
          } else if (spaceToPlus && $byte === 32) {
            t3 = H.Primitives_stringFromCharCode(43);
            result._contents += t3;
          } else {
            t3 = H.Primitives_stringFromCharCode(37);
            result._contents += t3;
            t1.call$2($byte, result);
          }
        }
        t1 = result._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, Uri__hexCharPairToByte: function(s, pos) {
        var t1, $byte, i, charCode;
        for (t1 = J.getInterceptor$s(s), $byte = 0, i = 0; i < 2; ++i) {
          charCode = t1.codeUnitAt$1(s, pos + i);
          if (48 <= charCode && charCode <= 57)
            $byte = $byte * 16 + charCode - 48;
          else {
            charCode |= 32;
            if (97 <= charCode && charCode <= 102)
              $byte = $byte * 16 + charCode - 87;
            else
              throw H.wrapException(P.ArgumentError$("Invalid URL encoding"));
          }
        }
        return $byte;
      }, Uri__uriDecode: function(text, encoding, plusToSpace) {
        var t1, simple, i, t2, codeUnit, bytes, allowMalformed;
        t1 = J.getInterceptor$asx(text);
        simple = true;
        i = 0;
        while (true) {
          t2 = t1.get$length(text);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2 && simple))
            break;
          codeUnit = t1.codeUnitAt$1(text, i);
          simple = codeUnit !== 37 && codeUnit !== 43;
          ++i;
        }
        if (simple)
          if (encoding === C.Utf8Codec_false || false)
            return text;
          else
            bytes = t1.get$codeUnits(text);
        else {
          bytes = [];
          i = 0;
          while (true) {
            t2 = t1.get$length(text);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            codeUnit = t1.codeUnitAt$1(text, i);
            if (codeUnit > 127)
              throw H.wrapException(P.ArgumentError$("Illegal percent encoding in URI"));
            if (codeUnit === 37) {
              t2 = t1.get$length(text);
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (i + 3 > t2)
                throw H.wrapException(P.ArgumentError$("Truncated URI"));
              bytes.push(P.Uri__hexCharPairToByte(text, i + 1));
              i += 2;
            } else if (plusToSpace && codeUnit === 43)
              bytes.push(32);
            else
              bytes.push(codeUnit);
            ++i;
          }
        }
        allowMalformed = encoding._allowMalformed;
        return new P.Utf8Decoder(allowMalformed).convert$1(bytes);
      }}
  },
  Uri_parse_isRegName: {
    "^": "Closure:413;",
    call$1: function(ch) {
      ch.$lt(0, 128);
      return false;
    }
  },
  Uri_parse_parseAuth: {
    "^": "Closure:17;box_0,uri_1,EOI_2",
    call$0: function() {
      var t1, t2, t3, authStart, $char, lastColon, lastAt, char0, endBracket, hostEnd, t4, hostStart, i, portNumber, digit;
      t1 = this.box_0;
      t2 = this.uri_1;
      t3 = J.getInterceptor$asx(t2);
      if (J.$eq(t1.index_4, t3.get$length(t2))) {
        t1.char_5 = this.EOI_2;
        return;
      }
      authStart = t1.index_4;
      t1.char_5 = t3.codeUnitAt$1(t2, authStart);
      for ($char = this.EOI_2, lastColon = -1, lastAt = -1; J.$lt$n(t1.index_4, t3.get$length(t2));) {
        char0 = t3.codeUnitAt$1(t2, t1.index_4);
        t1.char_5 = char0;
        if (char0 === 47 || char0 === 63 || char0 === 35)
          break;
        if (char0 === 64) {
          lastAt = t1.index_4;
          lastColon = -1;
        } else if (char0 === 58)
          lastColon = t1.index_4;
        else if (char0 === 91) {
          endBracket = t3.indexOf$2(t2, "]", J.$add$ns(t1.index_4, 1));
          if (J.$eq(endBracket, -1)) {
            t1.index_4 = t3.get$length(t2);
            t1.char_5 = $char;
            lastColon = -1;
            break;
          } else
            t1.index_4 = endBracket;
          lastColon = -1;
        }
        t1.index_4 = J.$add$ns(t1.index_4, 1);
        t1.char_5 = $char;
      }
      hostEnd = t1.index_4;
      t4 = J.getInterceptor$n(lastAt);
      if (t4.$ge(lastAt, 0)) {
        t1.userinfo_1 = P.Uri__makeUserInfo(t2, authStart, lastAt);
        hostStart = t4.$add(lastAt, 1);
      } else
        hostStart = authStart;
      t4 = J.getInterceptor$n(lastColon);
      if (t4.$ge(lastColon, 0)) {
        if (J.$lt$n(t4.$add(lastColon, 1), t1.index_4))
          for (i = t4.$add(lastColon, 1), portNumber = 0; t4 = J.getInterceptor$n(i), t4.$lt(i, t1.index_4); i = t4.$add(i, 1)) {
            digit = t3.codeUnitAt$1(t2, i);
            if (48 > digit || 57 < digit)
              P.Uri__fail(t2, i, "Invalid port number");
            portNumber = portNumber * 10 + (digit - 48);
          }
        else
          portNumber = null;
        t1.port_3 = P.Uri__makePort(portNumber, t1.scheme_0);
        hostEnd = lastColon;
      }
      t1.host_2 = P.Uri__makeHost(t2, hostStart, hostEnd, true);
      if (J.$lt$n(t1.index_4, t3.get$length(t2)))
        t1.char_5 = t3.codeUnitAt$1(t2, t1.index_4);
    }
  },
  Uri__makePath_closure: {
    "^": "Closure:102;",
    call$1: function(s) {
      return P.Uri__uriEncode(C.List_qg40, s, C.Utf8Codec_false, false);
    }
  },
  Uri__makeQuery_closure: {
    "^": "Closure:959;box_0,result_1",
    call$2: function(key, value) {
      var t1 = this.box_0;
      if (!t1.first_0)
        this.result_1.write$1("&");
      t1.first_0 = false;
      t1 = this.result_1;
      t1.write$1(P.Uri__uriEncode(C.List_nxB, key, C.Utf8Codec_false, true));
      if (value != null && J.get$isEmpty$asx(value) !== true) {
        t1.write$1("=");
        t1.write$1(P.Uri__uriEncode(C.List_nxB, value, C.Utf8Codec_false, true));
      }
    }
  },
  Uri_hashCode_combine: {
    "^": "Closure:1716;",
    call$2: function(part, current) {
      var t1 = J.get$hashCode$(part);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return current * 31 + t1 & 1073741823;
    }
  },
  Uri_parseIPv4Address_error: {
    "^": "Closure:1717;",
    call$1: function(msg) {
      throw H.wrapException(P.FormatException$("Illegal IPv4 address, " + msg, null, null));
    }
  },
  Uri_parseIPv4Address_closure: {
    "^": "Closure:102;error_0",
    call$1: [function(byteString) {
      var $byte, t1;
      $byte = H.Primitives_parseInt(byteString, null, null);
      t1 = J.getInterceptor$n($byte);
      if (t1.$lt($byte, 0) || t1.$gt($byte, 255))
        this.error_0.call$1("each part must be in the range of `0..255`");
      return $byte;
    }, "call$1", null, 2, 0, null, 1718, [], "call"]
  },
  Uri_parseIPv6Address_error: {
    "^": "Closure:1719;host_0",
    call$2: function(msg, position) {
      throw H.wrapException(P.FormatException$("Illegal IPv6 address, " + msg, this.host_0, position));
    },
    call$1: function(msg) {
      return this.call$2(msg, null);
    }
  },
  Uri_parseIPv6Address_parseHex: {
    "^": "Closure:1122;host_1,error_2",
    call$2: function(start, end) {
      var value, t1;
      if (J.$gt$n(J.$sub$n(end, start), 4))
        this.error_2.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
      value = H.Primitives_parseInt(J.substring$2$s(this.host_1, start, end), 16, null);
      t1 = J.getInterceptor$n(value);
      if (t1.$lt(value, 0) || t1.$gt(value, 65535))
        this.error_2.call$2("each part must be in the range of `0x0..0xFFFF`", start);
      return value;
    }
  },
  Uri__uriEncode_byteToHex: {
    "^": "Closure:959;",
    call$2: function($byte, buffer) {
      var t1 = J.getInterceptor$n($byte);
      buffer.write$1(H.Primitives_stringFromCharCode(C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", t1.$shr($byte, 4))));
      buffer.write$1(H.Primitives_stringFromCharCode(C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", t1.$and($byte, 15))));
    }
  },
  "^": "override<"
}],
["dart.dom.html", "dart:html", , W, {
  "^": "",
  HtmlElement: {
    "^": "Element;",
    $isHtmlElement: true,
    "%": "HTMLAppletElement|HTMLBRElement|HTMLContentElement|HTMLDListElement|HTMLDirectoryElement|HTMLDivElement|HTMLFontElement|HTMLFrameElement|HTMLHeadElement|HTMLHeadingElement|HTMLHtmlElement|HTMLLabelElement|HTMLLegendElement|HTMLMarqueeElement|HTMLModElement|HTMLParagraphElement|HTMLPictureElement|HTMLPreElement|HTMLQuoteElement|HTMLShadowElement|HTMLSpanElement|HTMLTableCaptionElement|HTMLTableCellElement|HTMLTableColElement|HTMLTableDataCellElement|HTMLTableHeaderCellElement|HTMLTitleElement|HTMLUListElement|HTMLUnknownElement;HTMLElement"
  },
  AnchorElement: {
    "^": "HtmlElement;target%,type%",
    hash$1: function($receiver, arg0) {
      return $receiver.hash.call$1(arg0);
    },
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "HTMLAnchorElement"
  },
  AnimationEvent: {
    "^": "Event;",
    $isAnimationEvent: true,
    "%": "WebKitAnimationEvent"
  },
  AnimationPlayerEvent: {
    "^": "Event;currentTime=",
    "%": "AnimationPlayerEvent"
  },
  ApplicationCacheErrorEvent: {
    "^": "Event;status=,url=",
    "%": "ApplicationCacheErrorEvent"
  },
  AreaElement: {
    "^": "HtmlElement;target%",
    hash$1: function($receiver, arg0) {
      return $receiver.hash.call$1(arg0);
    },
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "HTMLAreaElement"
  },
  AudioElement: {
    "^": "MediaElement;",
    $isAudioElement: true,
    "%": "HTMLAudioElement"
  },
  BaseElement: {
    "^": "HtmlElement;target%",
    "%": "HTMLBaseElement"
  },
  Blob: {
    "^": "Interceptor;size=,type=",
    size$1: function($receiver, arg0) {
      return $receiver.size.call$1(arg0);
    },
    $isBlob: true,
    "%": ";Blob"
  },
  BodyElement: {
    "^": "HtmlElement;",
    get$onBlur: function(receiver) {
      return C.EventStreamProvider_blur.forElement$1(receiver);
    },
    get$onError: function(receiver) {
      return C.EventStreamProvider_error.forElement$1(receiver);
    },
    onError$0: function($receiver) {
      return this.get$onError($receiver).call$0();
    },
    get$onFocus: function(receiver) {
      return C.EventStreamProvider_focus.forElement$1(receiver);
    },
    get$onLoad: function(receiver) {
      return C.EventStreamProvider_load.forElement$1(receiver);
    },
    get$onResize: function(receiver) {
      return C.EventStreamProvider_resize.forElement$1(receiver);
    },
    onResize$2: function($receiver, arg0, arg1) {
      return this.get$onResize($receiver).call$2(arg0, arg1);
    },
    $isEventTarget: true,
    "%": "HTMLBodyElement"
  },
  ButtonElement: {
    "^": "HtmlElement;disabled%,name%,type%,value%",
    "%": "HTMLButtonElement"
  },
  CanvasElement: {
    "^": "HtmlElement;height%,width%",
    getContext$2: function(receiver, contextId, attrs) {
      if (attrs != null)
        return receiver.getContext(contextId, P.convertDartToNative_Dictionary(attrs));
      return receiver.getContext(contextId);
    },
    getContext$1: function($receiver, contextId) {
      return this.getContext$2($receiver, contextId, null);
    },
    get$onWebGlContextLost: function(receiver) {
      return C.EventStreamProvider_webglcontextlost.forElement$1(receiver);
    },
    get$onWebGlContextRestored: function(receiver) {
      return C.EventStreamProvider_webglcontextrestored.forElement$1(receiver);
    },
    getContext3d$6$alpha$antialias$depth$premultipliedAlpha$preserveDrawingBuffer$stencil: function(receiver, alpha, antialias, depth, premultipliedAlpha, preserveDrawingBuffer, stencil) {
      var options, context;
      options = P.LinkedHashMap_LinkedHashMap$_literal(["alpha", alpha, "depth", depth, "stencil", stencil, "antialias", antialias, "premultipliedAlpha", premultipliedAlpha, "preserveDrawingBuffer", preserveDrawingBuffer], null, null);
      context = this.getContext$2(receiver, "webgl", options);
      return context == null ? this.getContext$2(receiver, "experimental-webgl", options) : context;
    },
    getContext3d$0: function($receiver) {
      return this.getContext3d$6$alpha$antialias$depth$premultipliedAlpha$preserveDrawingBuffer$stencil($receiver, true, true, true, true, false, false);
    },
    toDataUrl$2: function(receiver, type, quality) {
      return receiver.toDataURL(type, quality);
    },
    toDataUrl$0: function($receiver) {
      return this.toDataUrl$2($receiver, "image/png", null);
    },
    $isCanvasElement: true,
    "%": "HTMLCanvasElement"
  },
  CanvasRenderingContext2D: {
    "^": "Interceptor;canvas=,fillStyle},font%,globalAlpha%,globalCompositeOperation%,imageSmoothingEnabled},lineCap},lineJoin},lineWidth%,shadowBlur%,shadowColor%,shadowOffsetX%,shadowOffsetY%,strokeStyle},textBaseline}",
    beginPath$0: function(receiver) {
      return receiver.beginPath();
    },
    clearRect$4: function(receiver, x, y, width, height) {
      return receiver.clearRect(x, y, width, height);
    },
    clip$2: function(receiver, path_OR_winding, winding) {
      return receiver.clip(path_OR_winding, winding);
    },
    clip$0: function($receiver) {
      return $receiver.clip();
    },
    createPattern$2: function(receiver, canvas_OR_image, repetitionType) {
      return receiver.createPattern(canvas_OR_image, repetitionType);
    },
    createPatternFromImage$2: function(receiver, image, repetitionType) {
      return receiver.createPattern(image, repetitionType);
    },
    fillRect$4: function(receiver, x, y, width, height) {
      return receiver.fillRect(x, y, width, height);
    },
    getImageData$4: function(receiver, sx, sy, sw, sh) {
      return P.convertNativeToDart_ImageData(receiver.getImageData(sx, sy, sw, sh));
    },
    measureText$1: function(receiver, text) {
      return receiver.measureText(text);
    },
    putImageData$7: function(receiver, imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
      receiver.putImageData(P.convertDartToNative_ImageData(imagedata), dx, dy);
      return;
    },
    putImageData$3: function($receiver, imagedata, dx, dy) {
      return this.putImageData$7($receiver, imagedata, dx, dy, null, null, null, null);
    },
    restore$0: function(receiver) {
      return receiver.restore();
    },
    rotate$1: [function(receiver, angle) {
      return receiver.rotate(angle);
    }, "call$1", "get$rotate", 2, 0, 6, 7, []],
    save$0: function(receiver) {
      return receiver.save();
    },
    scale$2: [function(receiver, x, y) {
      return receiver.scale(x, y);
    }, "call$2", "get$scale", 4, 0, 8, 9, [], 10, []],
    setTransform$6: function(receiver, a, b, c, d, e, f) {
      return receiver.setTransform(a, b, c, d, e, f);
    },
    stroke$1: [function(receiver, path) {
      return receiver.stroke(path);
    }, function($receiver) {
      return $receiver.stroke();
    }, "stroke$0", "call$1", "call$0", "get$stroke", 0, 2, 11, 12, 13, []],
    strokeRect$4: function(receiver, x, y, width, height) {
      return receiver.strokeRect(x, y, width, height);
    },
    strokeText$4: function(receiver, text, x, y, maxWidth) {
      return receiver.strokeText(text, x, y, maxWidth);
    },
    strokeText$3: function($receiver, text, x, y) {
      return $receiver.strokeText(text, x, y);
    },
    transform$6: function(receiver, a, b, c, d, e, f) {
      return receiver.transform(a, b, c, d, e, f);
    },
    translate$2: function(receiver, x, y) {
      return receiver.translate(x, y);
    },
    arcTo$5: function(receiver, x1, y1, x2, y2, radius) {
      return receiver.arcTo(x1, y1, x2, y2, radius);
    },
    bezierCurveTo$6: function(receiver, cp1x, cp1y, cp2x, cp2y, x, y) {
      return receiver.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    },
    closePath$0: function(receiver) {
      return receiver.closePath();
    },
    lineTo$2: function(receiver, x, y) {
      return receiver.lineTo(x, y);
    },
    moveTo$2: function(receiver, x, y) {
      return receiver.moveTo(x, y);
    },
    quadraticCurveTo$4: function(receiver, cpx, cpy, x, y) {
      return receiver.quadraticCurveTo(cpx, cpy, x, y);
    },
    rect$4: function(receiver, x, y, width, height) {
      return receiver.rect(x, y, width, height);
    },
    arc$6: function(receiver, x, y, radius, startAngle, endAngle, anticlockwise) {
      receiver.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    },
    arc$5: function($receiver, x, y, radius, startAngle, endAngle) {
      return this.arc$6($receiver, x, y, radius, startAngle, endAngle, false);
    },
    drawImage$3: function(receiver, source, destX, destY) {
      return receiver.drawImage(source, destX, destY);
    },
    drawImageScaledFromSource$9: function(receiver, source, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {
      return receiver.drawImage(source, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
    },
    fillText$4: function(receiver, text, x, y, maxWidth) {
      receiver.fillText(text, x, y);
    },
    fillText$3: function($receiver, text, x, y) {
      return this.fillText$4($receiver, text, x, y, null);
    },
    fill$1: [function(receiver, winding) {
      receiver.fill(winding);
    }, function($receiver) {
      return this.fill$1($receiver, "nonzero");
    }, "fill$0", "call$1", "call$0", "get$fill", 0, 2, 14, 15, 16, []],
    "%": "CanvasRenderingContext2D"
  },
  CharacterData: {
    "^": "Node0;data%,length=",
    "%": "CDATASection|Comment|Text;CharacterData"
  },
  CompositionEvent: {
    "^": "UIEvent;data=",
    "%": "CompositionEvent"
  },
  CssStyleDeclaration: {
    "^": "Interceptor_CssStyleDeclarationBase;length=",
    getPropertyValue$1: function(receiver, propertyName) {
      var propValue = this._getPropertyValueHelper$1(receiver, propertyName);
      return propValue != null ? propValue : "";
    },
    _getPropertyValueHelper$1: function(receiver, propertyName) {
      var t1;
      if (W.CssStyleDeclaration__camelCase(propertyName) in receiver)
        return receiver.getPropertyValue(propertyName);
      else {
        t1 = P.Device_cssPrefix();
        if (t1 == null)
          return t1.$add();
        return receiver.getPropertyValue(t1 + propertyName);
      }
    },
    setProperty$3: function(receiver, propertyName, value, priority) {
      var t1;
      if (W.CssStyleDeclaration__camelCase(propertyName) in receiver)
        return this._setPropertyHelper$3(receiver, propertyName, value, priority);
      else {
        t1 = P.Device_cssPrefix();
        if (t1 == null)
          return t1.$add();
        return this._setPropertyHelper$3(receiver, t1 + propertyName, value, priority);
      }
    },
    _setPropertyHelper$3: function(receiver, propertyName, value, priority) {
      var exception;
      try {
        if (value == null)
          value = "";
        if (priority == null)
          priority = "";
        receiver.setProperty(propertyName, value, priority);
        if (!!receiver.setAttribute)
          receiver.setAttribute(propertyName, value);
      } catch (exception) {
        H.unwrapException(exception);
      }

    },
    "%": "CSS2Properties|CSSStyleDeclaration|MSStyleCSSProperties"
  },
  DataListElement: {
    "^": "HtmlElement;options=",
    "%": "HTMLDataListElement"
  },
  DetailsElement: {
    "^": "HtmlElement;",
    open$3$async: function($receiver, arg0, arg1, arg2) {
      return $receiver.open.call$3$async(arg0, arg1, arg2);
    },
    "%": "HTMLDetailsElement"
  },
  DeviceAcceleration: {
    "^": "Interceptor;x=,y=,z=",
    "%": "DeviceAcceleration"
  },
  DeviceLightEvent: {
    "^": "Event;value=",
    "%": "DeviceLightEvent"
  },
  DeviceMotionEvent: {
    "^": "Event;acceleration=",
    "%": "DeviceMotionEvent"
  },
  DeviceOrientationEvent: {
    "^": "Event;alpha=",
    "%": "DeviceOrientationEvent"
  },
  DialogElement: {
    "^": "HtmlElement;",
    open$3$async: function($receiver, arg0, arg1, arg2) {
      return $receiver.open.call$3$async(arg0, arg1, arg2);
    },
    "%": "HTMLDialogElement"
  },
  Document: {
    "^": "Node0;readyState=",
    getElementsByTagName$1: function(receiver, localName) {
      return receiver.getElementsByTagName(localName);
    },
    get$onBlur: function(receiver) {
      return C.EventStreamProvider_blur.forTarget$1(receiver);
    },
    get$onDragStart: function(receiver) {
      return C.EventStreamProvider_dragstart.forTarget$1(receiver);
    },
    get$onError: function(receiver) {
      return C.EventStreamProvider_error.forTarget$1(receiver);
    },
    onError$0: function($receiver) {
      return this.get$onError($receiver).call$0();
    },
    get$onFocus: function(receiver) {
      return C.EventStreamProvider_focus.forTarget$1(receiver);
    },
    get$onLoad: function(receiver) {
      return C.EventStreamProvider_load.forTarget$1(receiver);
    },
    get$onMouseDown: function(receiver) {
      return C.EventStreamProvider_mousedown.forTarget$1(receiver);
    },
    onMouseDown$1: function($receiver, arg0) {
      return this.get$onMouseDown($receiver).call$1(arg0);
    },
    get$onMouseMove: function(receiver) {
      return C.EventStreamProvider_mousemove.forTarget$1(receiver);
    },
    onMouseMove$1: function($receiver, arg0) {
      return this.get$onMouseMove($receiver).call$1(arg0);
    },
    get$onMouseOut: function(receiver) {
      return C.EventStreamProvider_mouseout.forTarget$1(receiver);
    },
    onMouseOut$1: function($receiver, arg0) {
      return this.get$onMouseOut($receiver).call$1(arg0);
    },
    get$onMouseOver: function(receiver) {
      return C.EventStreamProvider_mouseover.forTarget$1(receiver);
    },
    onMouseOver$1: function($receiver, arg0) {
      return this.get$onMouseOver($receiver).call$1(arg0);
    },
    get$onMouseUp: function(receiver) {
      return C.EventStreamProvider_mouseup.forTarget$1(receiver);
    },
    onMouseUp$1: function($receiver, arg0) {
      return this.get$onMouseUp($receiver).call$1(arg0);
    },
    get$onMouseWheel: function(receiver) {
      return C._CustomEventStreamProvider__determineMouseWheelEventType.forTarget$1(receiver);
    },
    onMouseWheel$1: function($receiver, arg0) {
      return this.get$onMouseWheel($receiver).call$1(arg0);
    },
    get$onPause: function(receiver) {
      return C.EventStreamProvider_pause.forTarget$1(receiver);
    },
    get$onPlay: function(receiver) {
      return C.EventStreamProvider_play.forTarget$1(receiver);
    },
    get$onResize: function(receiver) {
      return C.EventStreamProvider_resize.forTarget$1(receiver);
    },
    onResize$2: function($receiver, arg0, arg1) {
      return this.get$onResize($receiver).call$2(arg0, arg1);
    },
    get$onTouchCancel: function(receiver) {
      return C.EventStreamProvider_touchcancel.forTarget$1(receiver);
    },
    onTouchCancel$1: function($receiver, arg0) {
      return this.get$onTouchCancel($receiver).call$1(arg0);
    },
    get$onTouchEnd: function(receiver) {
      return C.EventStreamProvider_touchend.forTarget$1(receiver);
    },
    onTouchEnd$1: function($receiver, arg0) {
      return this.get$onTouchEnd($receiver).call$1(arg0);
    },
    get$onTouchMove: function(receiver) {
      return C.EventStreamProvider_touchmove.forTarget$1(receiver);
    },
    onTouchMove$1: function($receiver, arg0) {
      return this.get$onTouchMove($receiver).call$1(arg0);
    },
    get$onTouchStart: function(receiver) {
      return C.EventStreamProvider_touchstart.forTarget$1(receiver);
    },
    onTouchStart$1: function($receiver, arg0) {
      return this.get$onTouchStart($receiver).call$1(arg0);
    },
    $isDocument: true,
    "%": "XMLDocument;Document"
  },
  DocumentFragment: {
    "^": "Node0;",
    get$children: function(receiver) {
      if (receiver._docChildren == null)
        receiver._docChildren = H.setRuntimeTypeInfo(new P.FilteredElementList(receiver, new W._ChildNodeListLazy(receiver)), [null]);
      return receiver._docChildren;
    },
    set$children: function(receiver, value) {
      var copy, children, t1;
      copy = P.List_List$from(value, true, null);
      children = this.get$children(receiver);
      t1 = J.getInterceptor$ax(children);
      t1.clear$0(children);
      t1.addAll$1(children, copy);
    },
    "%": ";DocumentFragment"
  },
  DomError: {
    "^": "Interceptor;name=",
    "%": "DOMError|FileError"
  },
  DomException: {
    "^": "Interceptor;",
    get$name: function(receiver) {
      var errorName = receiver.name;
      if (P.Device_isWebKit() === true && errorName === "SECURITY_ERR")
        return "SecurityError";
      if (P.Device_isWebKit() === true && errorName === "SYNTAX_ERR")
        return "SyntaxError";
      return errorName;
    },
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "DOMException"
  },
  DomParser: {
    "^": "Interceptor;",
    parseFromString$2: function(receiver, str, contentType) {
      return receiver.parseFromString(str, contentType);
    },
    "%": "DOMParser"
  },
  DomRectReadOnly: {
    "^": "Interceptor;bottom=,height=,left=,right=,top=,width=,x=,y=",
    toString$0: function(receiver) {
      return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(this.get$width(receiver)) + " x " + H.S(this.get$height(receiver));
    },
    $eq: function(receiver, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isRectangle)
        return false;
      t2 = receiver.left;
      t3 = t1.get$left(other);
      if (t2 == null ? t3 == null : t2 === t3) {
        t2 = receiver.top;
        t3 = t1.get$top(other);
        if (t2 == null ? t3 == null : t2 === t3) {
          t2 = this.get$width(receiver);
          t3 = t1.get$width(other);
          if (t2 == null ? t3 == null : t2 === t3) {
            t2 = this.get$height(receiver);
            t1 = t1.get$height(other);
            t1 = t2 == null ? t1 == null : t2 === t1;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(receiver) {
      var t1, t2, t3, t4;
      t1 = J.get$hashCode$(receiver.left);
      t2 = J.get$hashCode$(receiver.top);
      t3 = J.get$hashCode$(this.get$width(receiver));
      t4 = J.get$hashCode$(this.get$height(receiver));
      return W._JenkinsSmiHash_finish(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, t1), t2), t3), t4));
    },
    intersects$1: function(receiver, other) {
      var t1, t2, t3, t4;
      t1 = receiver.left;
      t2 = J.getInterceptor$x(other);
      t3 = J.$add$ns(t2.get$left(other), t2.get$width(other));
      if (typeof t1 !== "number")
        return t1.$le();
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (t1 <= t3) {
        t1 = t2.get$left(other);
        t3 = receiver.left;
        t4 = this.get$width(receiver);
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (J.$le$n(t1, t3 + t4)) {
          t1 = receiver.top;
          t3 = J.$add$ns(t2.get$top(other), t2.get$height(other));
          if (typeof t1 !== "number")
            return t1.$le();
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (t1 <= t3) {
            t1 = t2.get$top(other);
            t2 = receiver.top;
            t3 = this.get$height(receiver);
            if (typeof t2 !== "number")
              return t2.$add();
            if (typeof t3 !== "number")
              return H.iae(t3);
            t3 = J.$le$n(t1, t2 + t3);
            t1 = t3;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$topLeft: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(receiver.left, receiver.top), [null]);
    },
    get$topRight: function(receiver) {
      var t1, t2;
      t1 = receiver.left;
      t2 = this.get$width(receiver);
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return H.setRuntimeTypeInfo(new P.Point1(t1 + t2, receiver.top), [null]);
    },
    get$bottomRight: function(receiver) {
      var t1, t2, t3, t4;
      t1 = receiver.left;
      t2 = this.get$width(receiver);
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = receiver.top;
      t4 = this.get$height(receiver);
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return H.setRuntimeTypeInfo(new P.Point1(t1 + t2, t3 + t4), [null]);
    },
    get$bottomLeft: function(receiver) {
      var t1, t2, t3;
      t1 = receiver.left;
      t2 = receiver.top;
      t3 = this.get$height(receiver);
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      return H.setRuntimeTypeInfo(new P.Point1(t1, t2 + t3), [null]);
    },
    $isRectangle: true,
    $asRectangle: function() {
      return [null];
    },
    "%": ";DOMRectReadOnly"
  },
  Element: {
    "^": "Node0;draggable%,id%,style=",
    get$attributes: function(receiver) {
      return new W._ElementAttributeMap(receiver);
    },
    set$attributes: function(receiver, value) {
      var t1, key;
      new W._ElementAttributeMap(receiver).clear$0(0);
      for (t1 = value.get$keys(value), t1 = t1.get$iterator(t1); t1.moveNext$0(), false;) {
        key = t1.get$current();
        receiver.setAttribute(key, value.$index(0, key));
      }
    },
    get$children: function(receiver) {
      return new W._ChildrenElementList(receiver, receiver.children);
    },
    set$children: function(receiver, value) {
      var copy, children;
      copy = P.List_List$from(value, true, null);
      children = this.get$children(receiver);
      children.clear$0(0);
      children.addAll$1(0, copy);
    },
    get$dataset: function(receiver) {
      return new W._DataAttributeMap(new W._ElementAttributeMap(receiver));
    },
    get$client: function(receiver) {
      return P.Rectangle$(C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientLeft)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientTop)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientWidth)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientHeight)), null);
    },
    get$offset: function(receiver) {
      return P.Rectangle$(C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.offsetLeft)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.offsetTop)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.offsetWidth)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.offsetHeight)), null);
    },
    offset$2: function($receiver, arg0, arg1) {
      return this.get$offset($receiver).call$2(arg0, arg1);
    },
    toString$0: function(receiver) {
      return receiver.localName;
    },
    get$on: function(receiver) {
      return new W.ElementEvents(receiver, receiver);
    },
    on$2: function($receiver, arg0, arg1) {
      return this.get$on($receiver).call$2(arg0, arg1);
    },
    get$clientLeft: function(receiver) {
      return C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientLeft));
    },
    get$clientTop: function(receiver) {
      return C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientTop));
    },
    translate$2: function($receiver, arg0, arg1) {
      return $receiver.translate.call$2(arg0, arg1);
    },
    click$0: [function(receiver) {
      return receiver.click();
    }, "call$0", "get$click", 0, 0, 17],
    blur$0: [function(receiver) {
      return receiver.blur();
    }, "call$0", "get$blur", 0, 0, 17],
    getAttribute$1: function(receiver, $name) {
      return receiver.getAttribute($name);
    },
    getBoundingClientRect$0: function(receiver) {
      return receiver.getBoundingClientRect();
    },
    requestFullscreen$0: [function(receiver) {
      return receiver.requestFullscreen();
    }, "call$0", "get$requestFullscreen", 0, 0, 17],
    requestPointerLock$0: [function(receiver) {
      return receiver.requestPointerLock();
    }, "call$0", "get$requestPointerLock", 0, 0, 17],
    get$onBlur: function(receiver) {
      return C.EventStreamProvider_blur.forElement$1(receiver);
    },
    get$onDragStart: function(receiver) {
      return C.EventStreamProvider_dragstart.forElement$1(receiver);
    },
    get$onError: function(receiver) {
      return C.EventStreamProvider_error.forElement$1(receiver);
    },
    onError$0: function($receiver) {
      return this.get$onError($receiver).call$0();
    },
    get$onFocus: function(receiver) {
      return C.EventStreamProvider_focus.forElement$1(receiver);
    },
    get$onLoad: function(receiver) {
      return C.EventStreamProvider_load.forElement$1(receiver);
    },
    get$onMouseDown: function(receiver) {
      return C.EventStreamProvider_mousedown.forElement$1(receiver);
    },
    onMouseDown$1: function($receiver, arg0) {
      return this.get$onMouseDown($receiver).call$1(arg0);
    },
    get$onMouseMove: function(receiver) {
      return C.EventStreamProvider_mousemove.forElement$1(receiver);
    },
    onMouseMove$1: function($receiver, arg0) {
      return this.get$onMouseMove($receiver).call$1(arg0);
    },
    get$onMouseOut: function(receiver) {
      return C.EventStreamProvider_mouseout.forElement$1(receiver);
    },
    onMouseOut$1: function($receiver, arg0) {
      return this.get$onMouseOut($receiver).call$1(arg0);
    },
    get$onMouseOver: function(receiver) {
      return C.EventStreamProvider_mouseover.forElement$1(receiver);
    },
    onMouseOver$1: function($receiver, arg0) {
      return this.get$onMouseOver($receiver).call$1(arg0);
    },
    get$onMouseUp: function(receiver) {
      return C.EventStreamProvider_mouseup.forElement$1(receiver);
    },
    onMouseUp$1: function($receiver, arg0) {
      return this.get$onMouseUp($receiver).call$1(arg0);
    },
    get$onMouseWheel: function(receiver) {
      return C._CustomEventStreamProvider__determineMouseWheelEventType.forElement$1(receiver);
    },
    onMouseWheel$1: function($receiver, arg0) {
      return this.get$onMouseWheel($receiver).call$1(arg0);
    },
    get$onPause: function(receiver) {
      return C.EventStreamProvider_pause.forElement$1(receiver);
    },
    get$onPlay: function(receiver) {
      return C.EventStreamProvider_play.forElement$1(receiver);
    },
    get$onResize: function(receiver) {
      return C.EventStreamProvider_resize.forElement$1(receiver);
    },
    onResize$2: function($receiver, arg0, arg1) {
      return this.get$onResize($receiver).call$2(arg0, arg1);
    },
    get$onTouchCancel: function(receiver) {
      return C.EventStreamProvider_touchcancel.forElement$1(receiver);
    },
    onTouchCancel$1: function($receiver, arg0) {
      return this.get$onTouchCancel($receiver).call$1(arg0);
    },
    get$onTouchEnd: function(receiver) {
      return C.EventStreamProvider_touchend.forElement$1(receiver);
    },
    onTouchEnd$1: function($receiver, arg0) {
      return this.get$onTouchEnd($receiver).call$1(arg0);
    },
    get$onTouchEnter: function(receiver) {
      return C.EventStreamProvider_touchenter.forElement$1(receiver);
    },
    onTouchEnter$1: function($receiver, arg0) {
      return this.get$onTouchEnter($receiver).call$1(arg0);
    },
    get$onTouchLeave: function(receiver) {
      return C.EventStreamProvider_touchleave.forElement$1(receiver);
    },
    onTouchLeave$1: function($receiver, arg0) {
      return this.get$onTouchLeave($receiver).call$1(arg0);
    },
    get$onTouchMove: function(receiver) {
      return C.EventStreamProvider_touchmove.forElement$1(receiver);
    },
    onTouchMove$1: function($receiver, arg0) {
      return this.get$onTouchMove($receiver).call$1(arg0);
    },
    get$onTouchStart: function(receiver) {
      return C.EventStreamProvider_touchstart.forElement$1(receiver);
    },
    onTouchStart$1: function($receiver, arg0) {
      return this.get$onTouchStart($receiver).call$1(arg0);
    },
    $isElement: true,
    $isEventTarget: true,
    "%": ";Element"
  },
  EmbedElement: {
    "^": "HtmlElement;height%,name%,src%,type%,width%",
    "%": "HTMLEmbedElement"
  },
  ErrorEvent: {
    "^": "Event;error=",
    "%": "ErrorEvent"
  },
  Event: {
    "^": "Interceptor;type=",
    get$target: function(receiver) {
      return W._convertNativeToDart_EventTarget(receiver.target);
    },
    preventDefault$0: [function(receiver) {
      return receiver.preventDefault();
    }, "call$0", "get$preventDefault", 0, 0, 17],
    $isEvent: true,
    "%": "AudioProcessingEvent|AutocompleteErrorEvent|BeforeUnloadEvent|CloseEvent|CustomEvent|FetchEvent|FontFaceSetLoadEvent|GamepadEvent|HashChangeEvent|IDBVersionChangeEvent|InstallEvent|InstallPhaseEvent|MIDIConnectionEvent|MediaKeyEvent|MediaKeyMessageEvent|MediaKeyNeededEvent|MediaStreamEvent|MediaStreamTrackEvent|MutationEvent|OfflineAudioCompletionEvent|OverflowEvent|PageTransitionEvent|RTCDTMFToneChangeEvent|RTCDataChannelEvent|RTCIceCandidateEvent|RelatedEvent|SecurityPolicyViolationEvent|SpeechRecognitionEvent|TrackEvent|TransitionEvent|WebKitTransitionEvent;ClipboardEvent|Event|InputEvent"
  },
  EventTarget: {
    "^": "Interceptor;",
    get$on: function(receiver) {
      return new W.Events0(receiver);
    },
    on$2: function($receiver, arg0, arg1) {
      return this.get$on($receiver).call$2(arg0, arg1);
    },
    addEventListener$3: function(receiver, type, listener, useCapture) {
      if (listener != null)
        this._addEventListener$3(receiver, type, listener, useCapture);
    },
    addEventListener$2: function($receiver, type, listener) {
      return this.addEventListener$3($receiver, type, listener, null);
    },
    removeEventListener$3: function(receiver, type, listener, useCapture) {
      if (listener != null)
        this._removeEventListener$3(receiver, type, listener, useCapture);
    },
    removeEventListener$2: function($receiver, type, listener) {
      return this.removeEventListener$3($receiver, type, listener, null);
    },
    _addEventListener$3: function(receiver, type, listener, useCapture) {
      return receiver.addEventListener(type, H.convertDartClosureToJS(listener, 1), useCapture);
    },
    dispatchEvent$1: function(receiver, $event) {
      return receiver.dispatchEvent($event);
    },
    _removeEventListener$3: function(receiver, type, listener, useCapture) {
      return receiver.removeEventListener(type, H.convertDartClosureToJS(listener, 1), useCapture);
    },
    $isEventTarget: true,
    "%": ";EventTarget"
  },
  "+EventTarget": 0,
  FieldSetElement: {
    "^": "HtmlElement;disabled%,name%,type=",
    "%": "HTMLFieldSetElement"
  },
  File: {
    "^": "Blob;name=",
    $isFile: true,
    "%": "File"
  },
  FileList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isFileList: true,
    $isList: true,
    $asList: function() {
      return [W.File];
    },
    $isEfficientLength: true,
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "FileList"
  },
  FileReader: {
    "^": "EventTarget;error=,readyState=",
    get$result: function(receiver) {
      var res = receiver.result;
      if (!!J.getInterceptor(res).$isByteBuffer)
        return new Uint8Array(res, 0);
      return res;
    },
    get$onError: function(receiver) {
      return C.EventStreamProvider_error.forTarget$1(receiver);
    },
    onError$0: function($receiver) {
      return this.get$onError($receiver).call$0();
    },
    get$onLoad: function(receiver) {
      return C.EventStreamProvider_load0.forTarget$1(receiver);
    },
    get$onLoadStart: function(receiver) {
      return C.EventStreamProvider_loadstart.forTarget$1(receiver);
    },
    get$onProgress: function(receiver) {
      return C.EventStreamProvider_progress.forTarget$1(receiver);
    },
    "%": "FileReader"
  },
  FormElement: {
    "^": "HtmlElement;length=,name%,target%",
    reset$0: function(receiver) {
      return receiver.reset();
    },
    "%": "HTMLFormElement"
  },
  HRElement: {
    "^": "HtmlElement;color%",
    "%": "HTMLHRElement"
  },
  HtmlCollection: {
    "^": "Interceptor_ListMixin_ImmutableListMixin0;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node0];
    },
    $isEfficientLength: true,
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "HTMLCollection|HTMLFormControlsCollection|HTMLOptionsCollection"
  },
  HtmlDocument: {
    "^": "Document;body%",
    body$3: function($receiver, arg0, arg1, arg2) {
      return $receiver.body.call$3(arg0, arg1, arg2);
    },
    "%": "HTMLDocument"
  },
  HttpRequest: {
    "^": "HttpRequestEventTarget;readyState=,responseText=,responseType%,responseXml:responseXML=,status=",
    get$response: function(receiver) {
      return W._convertNativeToDart_XHR_Response(receiver.response);
    },
    upload$0: function($receiver) {
      return $receiver.upload.call$0();
    },
    open$5$async$password$user: function(receiver, method, url, async, password, user) {
      return receiver.open(method, url, async, user, password);
    },
    open$3$async: function($receiver, method, url, async) {
      return $receiver.open(method, url, async);
    },
    overrideMimeType$1: function(receiver, override) {
      return receiver.overrideMimeType(override);
    },
    send$1: function(receiver, data) {
      return receiver.send(data);
    },
    send$0: function($receiver) {
      return $receiver.send();
    },
    get$onReadyStateChange: function(receiver) {
      return C.EventStreamProvider_readystatechange.forTarget$1(receiver);
    },
    "%": "XMLHttpRequest"
  },
  HttpRequestEventTarget: {
    "^": "EventTarget;",
    get$onError: function(receiver) {
      return C.EventStreamProvider_error0.forTarget$1(receiver);
    },
    onError$0: function($receiver) {
      return this.get$onError($receiver).call$0();
    },
    get$onLoad: function(receiver) {
      return C.EventStreamProvider_load0.forTarget$1(receiver);
    },
    get$onLoadStart: function(receiver) {
      return C.EventStreamProvider_loadstart.forTarget$1(receiver);
    },
    get$onProgress: function(receiver) {
      return C.EventStreamProvider_progress.forTarget$1(receiver);
    },
    "%": "XMLHttpRequestUpload;XMLHttpRequestEventTarget"
  },
  IFrameElement: {
    "^": "HtmlElement;height%,name%,src%,width%",
    "%": "HTMLIFrameElement"
  },
  ImageData: {
    "^": "Interceptor;data=,height=,width=",
    $isImageData: true,
    "%": "ImageData"
  },
  ImageElement: {
    "^": "HtmlElement;complete=,crossOrigin%,height%,src%,width%",
    complete$0: function($receiver) {
      return $receiver.complete.call$0();
    },
    $isImageElement: true,
    "%": "HTMLImageElement"
  },
  InputElement: {
    "^": "HtmlElement;capture%,checked%,defaultValue=,disabled%,files=,height%,name%,size%,src%,step%,type%,value%,width%",
    size$1: function($receiver, arg0) {
      return $receiver.size.call$1(arg0);
    },
    step$0: function($receiver) {
      return $receiver.step.call$0();
    },
    step$1: function($receiver, arg0) {
      return $receiver.step.call$1(arg0);
    },
    $isElement: true,
    $isEventTarget: true,
    $isNode0: true,
    "%": "HTMLInputElement"
  },
  KeyboardEvent: {
    "^": "UIEvent;altKey=,ctrlKey=,shiftKey=",
    get$keyCode: function(receiver) {
      return receiver.keyCode;
    },
    get$charCode: function(receiver) {
      return receiver.charCode;
    },
    repeat$1: function($receiver, arg0) {
      return $receiver.repeat.call$1(arg0);
    },
    repeat$4: function($receiver, arg0, arg1, arg2, arg3) {
      return $receiver.repeat.call$4(arg0, arg1, arg2, arg3);
    },
    "%": "KeyboardEvent"
  },
  KeygenElement: {
    "^": "HtmlElement;disabled%,name%,type=",
    "%": "HTMLKeygenElement"
  },
  LIElement: {
    "^": "HtmlElement;value%",
    "%": "HTMLLIElement"
  },
  LinkElement: {
    "^": "HtmlElement;crossOrigin%,disabled%,type%",
    "%": "HTMLLinkElement"
  },
  Location: {
    "^": "Interceptor;",
    hash$1: function($receiver, arg0) {
      return $receiver.hash.call$1(arg0);
    },
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "Location"
  },
  MapElement: {
    "^": "HtmlElement;name%",
    "%": "HTMLMapElement"
  },
  MediaElement: {
    "^": "HtmlElement;autoplay%,crossOrigin%,currentTime%,duration=,error=,loop%,muted},paused=,preload=,readyState=,src%,volume%",
    loop$0: function($receiver) {
      return $receiver.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return $receiver.loop.call$3(arg0, arg1, arg2);
    },
    paused$0: function($receiver) {
      return $receiver.paused.call$0();
    },
    preload$0: function($receiver) {
      return $receiver.preload.call$0();
    },
    load$0: [function(receiver) {
      return receiver.load();
    }, "call$0", "get$load", 0, 0, 17],
    pause$0: function(receiver) {
      return receiver.pause();
    },
    play$0: function(receiver) {
      return receiver.play();
    },
    "%": ";HTMLMediaElement"
  },
  MediaStream: {
    "^": "EventTarget;id=",
    clone$0: function(receiver) {
      return receiver.clone();
    },
    stop$0: [function(receiver) {
      return receiver.stop();
    }, "call$0", "get$stop", 0, 0, 17],
    $isMediaStream: true,
    "%": "MediaStream"
  },
  MenuElement: {
    "^": "HtmlElement;type%",
    "%": "HTMLMenuElement"
  },
  MenuItemElement: {
    "^": "HtmlElement;checked%,defaultValue:default=,disabled%,type%",
    "%": "HTMLMenuItemElement"
  },
  MessageEvent: {
    "^": "Event;",
    get$data: function(receiver) {
      return P.convertNativeToDart_AcceptStructuredClone(receiver.data, true);
    },
    get$source: function(receiver) {
      return W._convertNativeToDart_EventTarget(receiver.source);
    },
    "%": "MessageEvent"
  },
  MetaElement: {
    "^": "HtmlElement;content%,name%",
    "%": "HTMLMetaElement"
  },
  MeterElement: {
    "^": "HtmlElement;value%",
    "%": "HTMLMeterElement"
  },
  MidiMessageEvent: {
    "^": "Event;data=",
    "%": "MIDIMessageEvent"
  },
  MidiOutput: {
    "^": "MidiPort;",
    send$2: function(receiver, data, timestamp) {
      return receiver.send(data, timestamp);
    },
    send$1: function($receiver, data) {
      return $receiver.send(data);
    },
    "%": "MIDIOutput"
  },
  MidiPort: {
    "^": "EventTarget;id=,name=,type=,version=",
    "%": "MIDIInput;MIDIPort"
  },
  MouseEvent: {
    "^": "UIEvent;altKey=,button=,ctrlKey=,shiftKey=",
    button$9: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
      return $receiver.button.call$9(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    },
    button$8: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      return $receiver.button.call$8(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
    },
    get$client: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(receiver.clientX, receiver.clientY), [null]);
    },
    get$movement: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(receiver.webkitMovementX, receiver.webkitMovementY), [null]);
    },
    get$offset: function(receiver) {
      var target, point;
      if (!!receiver.offsetX)
        return H.setRuntimeTypeInfo(new P.Point1(receiver.offsetX, receiver.offsetY), [null]);
      else {
        if (!J.getInterceptor(W._convertNativeToDart_EventTarget(receiver.target)).$isElement)
          throw H.wrapException(P.UnsupportedError$("offsetX is only supported on elements"));
        target = W._convertNativeToDart_EventTarget(receiver.target);
        point = H.setRuntimeTypeInfo(new P.Point1(receiver.clientX, receiver.clientY), [null]).$sub(0, J.get$topLeft$x(J.getBoundingClientRect$0$x(target)));
        return H.setRuntimeTypeInfo(new P.Point1(J.toInt$0$n(point.x), J.toInt$0$n(point.y)), [null]);
      }
    },
    offset$2: function($receiver, arg0, arg1) {
      return this.get$offset($receiver).call$2(arg0, arg1);
    },
    get$screen: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(receiver.screenX, receiver.screenY), [null]);
    },
    $isMouseEvent: true,
    "%": ";DragEvent|MSPointerEvent|MouseEvent|PointerEvent"
  },
  Navigator: {
    "^": "Interceptor;",
    getUserMedia$2$audio$video: [function(receiver, audio, video) {
      var t1, completer, options;
      t1 = W.MediaStream;
      completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [t1])), [t1]);
      options = P.LinkedHashMap_LinkedHashMap$_literal(["audio", audio, "video", video], null, null);
      if (!receiver.getUserMedia)
        receiver.getUserMedia = receiver.getUserMedia || receiver.webkitGetUserMedia || receiver.mozGetUserMedia || receiver.msGetUserMedia;
      this._getUserMedia$3(receiver, P._convertDartToNative_PrepareForStructuredClone(options), new W.Navigator_getUserMedia_closure(completer), new W.Navigator_getUserMedia_closure0(completer));
      return completer.future;
    }, function($receiver) {
      return this.getUserMedia$2$audio$video($receiver, false, false);
    }, "getUserMedia$0", "call$2$audio$video", "call$0", "get$getUserMedia", 0, 5, 18, 19, 19],
    _getUserMedia$3: function(receiver, options, success, error) {
      return receiver.getUserMedia(options, H.convertDartClosureToJS(success, 1), H.convertDartClosureToJS(error, 1));
    },
    "%": "Navigator"
  },
  NavigatorUserMediaError: {
    "^": "Interceptor;name=",
    "%": "NavigatorUserMediaError"
  },
  Node0: {
    "^": "EventTarget;parent:parentElement=,parentNode=,text:textContent%",
    get$nodes: function(receiver) {
      return new W._ChildNodeListLazy(receiver);
    },
    set$nodes: function(receiver, value) {
      var copy, t1;
      copy = P.List_List$from(value, true, null);
      this.set$text(receiver, "");
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(copy, copy.length, 0, null), [H.getTypeArgumentByIndex(copy, 0)]); t1.moveNext$0();)
        receiver.appendChild(t1.__internal$_current);
    },
    remove$0: function(receiver) {
      var t1 = receiver.parentNode;
      if (t1 != null)
        t1.removeChild(receiver);
    },
    replaceWith$1: function(receiver, otherNode) {
      var $parent, exception;
      try {
        $parent = receiver.parentNode;
        J._replaceChild$2$x($parent, otherNode, receiver);
      } catch (exception) {
        H.unwrapException(exception);
      }

      return receiver;
    },
    _clearChildren$0: function(receiver) {
      var t1;
      for (; t1 = receiver.firstChild, t1 != null;)
        receiver.removeChild(t1);
    },
    toString$0: function(receiver) {
      var t1 = receiver.nodeValue;
      return t1 == null ? J.Interceptor.prototype.toString$0.call(this, receiver) : t1;
    },
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return $receiver.textContent.call$4(arg0, arg1, arg2, arg3);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return $receiver.textContent.call$3(arg0, arg1, arg2);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return $receiver.textContent.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    append$1: function(receiver, newChild) {
      return receiver.appendChild(newChild);
    },
    clone$1: function(receiver, deep) {
      return receiver.cloneNode(deep);
    },
    contains$1: [function(receiver, other) {
      return receiver.contains(other);
    }, "call$1", "get$contains", 2, 0, 20],
    _replaceChild$2: function(receiver, newChild, oldChild) {
      return receiver.replaceChild(newChild, oldChild);
    },
    $isNode0: true,
    "%": "DocumentType|Notation;Node"
  },
  NodeList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin1;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node0];
    },
    $isEfficientLength: true,
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "NodeList|RadioNodeList"
  },
  OListElement: {
    "^": "HtmlElement;reversed=,start%,type%",
    start$1: function($receiver, arg0) {
      return $receiver.start.call$1(arg0);
    },
    start$0: function($receiver) {
      return $receiver.start.call$0();
    },
    start$2: function($receiver, arg0, arg1) {
      return $receiver.start.call$2(arg0, arg1);
    },
    start$3: function($receiver, arg0, arg1, arg2) {
      return $receiver.start.call$3(arg0, arg1, arg2);
    },
    start$4: function($receiver, arg0, arg1, arg2, arg3) {
      return $receiver.start.call$4(arg0, arg1, arg2, arg3);
    },
    start$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return $receiver.start.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    "%": "HTMLOListElement"
  },
  ObjectElement: {
    "^": "HtmlElement;data%,height%,name%,type%,width%",
    "%": "HTMLObjectElement"
  },
  OptGroupElement: {
    "^": "HtmlElement;disabled%",
    "%": "HTMLOptGroupElement"
  },
  OptionElement: {
    "^": "HtmlElement;disabled%,index=,value%",
    $isOptionElement: true,
    "%": "HTMLOptionElement"
  },
  OutputElement: {
    "^": "HtmlElement;defaultValue=,name%,type=,value%",
    "%": "HTMLOutputElement"
  },
  ParamElement: {
    "^": "HtmlElement;name%,value%",
    "%": "HTMLParamElement"
  },
  Performance: {
    "^": "EventTarget;",
    now$0: [function(receiver) {
      return receiver.now();
    }, "call$0", "get$now", 0, 0, 21],
    "%": "Performance"
  },
  PopStateEvent: {
    "^": "Event;",
    get$state: function(receiver) {
      return P.convertNativeToDart_AcceptStructuredClone(receiver.state, true);
    },
    "%": "PopStateEvent"
  },
  ProcessingInstruction: {
    "^": "CharacterData;target=",
    "%": "ProcessingInstruction"
  },
  ProgressElement: {
    "^": "HtmlElement;position=,value%",
    "%": "HTMLProgressElement"
  },
  ProgressEvent: {
    "^": "Event;loaded=,total=",
    $isProgressEvent: true,
    "%": "XMLHttpRequestProgressEvent;ProgressEvent"
  },
  PushEvent: {
    "^": "Event;data=",
    "%": "PushEvent"
  },
  ResourceProgressEvent: {
    "^": "ProgressEvent;url=",
    "%": "ResourceProgressEvent"
  },
  Screen: {
    "^": "Interceptor;height=,orientation=,width=",
    "%": "Screen"
  },
  ScreenOrientation: {
    "^": "EventTarget;angle=,type=",
    angle$0: function($receiver) {
      return $receiver.angle.call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return $receiver.angle.call$2(arg0, arg1);
    },
    unlock$0: function(receiver) {
      return receiver.unlock();
    },
    "%": "ScreenOrientation"
  },
  ScriptElement: {
    "^": "HtmlElement;crossOrigin%,src%,type%",
    "%": "HTMLScriptElement"
  },
  SelectElement: {
    "^": "HtmlElement;disabled%,length%,name%,size%,type=,value%",
    size$1: function($receiver, arg0) {
      return $receiver.size.call$1(arg0);
    },
    add$2: [function(receiver, element, before) {
      return receiver.add(element, before);
    }, "call$2", "get$add", 4, 0, 22, 23, [], 24, []],
    get$options: function(receiver) {
      var t1 = W._FrozenElementList$_wrap(receiver.querySelectorAll("option"), null);
      t1 = t1.where$1(t1, new W.SelectElement_options_closure());
      return H.setRuntimeTypeInfo(new P.UnmodifiableListView(P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0))), [null]);
    },
    "%": "HTMLSelectElement"
  },
  ShadowRoot: {
    "^": "DocumentFragment;",
    clone$1: function(receiver, deep) {
      return receiver.cloneNode(deep);
    },
    getElementsByTagName$1: function(receiver, tagName) {
      return receiver.getElementsByTagName(tagName);
    },
    "%": "ShadowRoot"
  },
  SourceElement: {
    "^": "HtmlElement;src%,type%",
    "%": "HTMLSourceElement"
  },
  SpeechRecognitionError: {
    "^": "Event;error=",
    "%": "SpeechRecognitionError"
  },
  SpeechSynthesisEvent: {
    "^": "Event;name=",
    "%": "SpeechSynthesisEvent"
  },
  Storage: {
    "^": "Interceptor;",
    addAll$1: function(receiver, other) {
      J.forEach$1$ax(other, new W.Storage_addAll_closure(receiver));
    },
    containsKey$1: function(receiver, key) {
      return receiver.getItem(key) != null;
    },
    $index: function(receiver, key) {
      return receiver.getItem(key);
    },
    $indexSet: function(receiver, key, value) {
      receiver.setItem(key, value);
    },
    remove$1: function(receiver, key) {
      var value = receiver.getItem(key);
      receiver.removeItem(key);
      return value;
    },
    clear$0: function(receiver) {
      return receiver.clear();
    },
    forEach$1: function(receiver, f) {
      var i, key;
      for (i = 0; true; ++i) {
        key = receiver.key(i);
        if (key == null)
          return;
        f.call$2(key, receiver.getItem(key));
      }
    },
    get$keys: function(receiver) {
      var keys = [];
      this.forEach$1(receiver, new W.Storage_keys_closure(keys));
      return keys;
    },
    get$values: function(receiver) {
      var values = [];
      this.forEach$1(receiver, new W.Storage_values_closure(values));
      return values;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    get$isEmpty: function(receiver) {
      return receiver.key(0) == null;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.key(0) != null;
    },
    $isMap: true,
    $asMap: function() {
      return [P.String, P.String];
    },
    "%": "Storage"
  },
  StorageEvent: {
    "^": "Event;key=,url=",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return $receiver.key.call$4(arg0, arg1, arg2, arg3);
    },
    "%": "StorageEvent"
  },
  StyleElement: {
    "^": "HtmlElement;disabled%,type%",
    "%": "HTMLStyleElement"
  },
  TableElement: {
    "^": "HtmlElement;",
    get$rows: function(receiver) {
      return H.setRuntimeTypeInfo(new W._WrappedList(receiver.rows), [W.TableRowElement]);
    },
    "%": "HTMLTableElement"
  },
  TableRowElement: {
    "^": "HtmlElement;",
    $isTableRowElement: true,
    "%": "HTMLTableRowElement"
  },
  TableSectionElement: {
    "^": "HtmlElement;",
    get$rows: function(receiver) {
      return H.setRuntimeTypeInfo(new W._WrappedList(receiver.rows), [W.TableRowElement]);
    },
    "%": "HTMLTableSectionElement"
  },
  TemplateElement: {
    "^": "HtmlElement;content=",
    "%": "HTMLTemplateElement"
  },
  TextAreaElement: {
    "^": "HtmlElement;defaultValue=,disabled%,name%,rows%,type=,value%,wrap%",
    wrap$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return $receiver.wrap.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    "%": "HTMLTextAreaElement"
  },
  TextEvent: {
    "^": "UIEvent;data=",
    "%": "TextEvent"
  },
  TextMetrics: {
    "^": "Interceptor;width=",
    "%": "TextMetrics"
  },
  Touch0: {
    "^": "Interceptor;force=,identifier=",
    get$target: function(receiver) {
      return W._convertNativeToDart_EventTarget(receiver.target);
    },
    get$client: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientX)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientY))), [null]);
    },
    get$page: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.pageX)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.pageY))), [null]);
    },
    get$screen: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.screenX)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.screenY))), [null]);
    },
    "%": "Touch"
  },
  "+Touch": 0,
  TouchEvent: {
    "^": "UIEvent;altKey=,changedTouches=,ctrlKey=,shiftKey=",
    $isTouchEvent: true,
    "%": "TouchEvent"
  },
  TouchList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin2;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Touch0];
    },
    $isEfficientLength: true,
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "TouchList"
  },
  TrackElement: {
    "^": "HtmlElement;defaultValue:default=,readyState=,src%",
    "%": "HTMLTrackElement"
  },
  UIEvent: {
    "^": "Event;",
    get$view: function(receiver) {
      return W._convertNativeToDart_Window(receiver.view);
    },
    get$layer: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(receiver.layerX, receiver.layerY), [null]);
    },
    get$page: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(receiver.pageX, receiver.pageY), [null]);
    },
    "%": "FocusEvent|SVGZoomEvent;UIEvent"
  },
  VideoElement: {
    "^": "MediaElement;height%,width%",
    $isVideoElement: true,
    "%": "HTMLVideoElement"
  },
  WheelEvent: {
    "^": "MouseEvent;deltaZ=",
    get$deltaY: function(receiver) {
      var detail;
      if (receiver.deltaY !== undefined)
        return receiver.deltaY;
      else if (receiver.wheelDelta !== undefined)
        return -receiver.wheelDelta;
      else if (receiver.detail !== undefined) {
        if (receiver.axis == MouseScrollEvent.VERTICAL_AXIS) {
          detail = receiver.detail;
          if (Math.abs(detail) < 100)
            return -detail * 40;
          return -detail;
        }
        return 0;
      }
      throw H.wrapException(P.UnsupportedError$("deltaY is not supported"));
    },
    get$deltaX: function(receiver) {
      var detail;
      if (receiver.deltaX !== undefined)
        return receiver.deltaX;
      else if (receiver.wheelDeltaX !== undefined)
        return -receiver.wheelDeltaX;
      else if (receiver.detail !== undefined) {
        if (receiver.axis !== undefined && receiver.axis == MouseScrollEvent.HORIZONTAL_AXIS) {
          detail = receiver.detail;
          if (detail < 100)
            return -detail * 40;
          return -detail;
        }
        return 0;
      }
      throw H.wrapException(P.UnsupportedError$("deltaX is not supported"));
    },
    $isWheelEvent: true,
    "%": "MouseScrollEvent|MouseWheelEvent|WheelEvent"
  },
  Window: {
    "^": "EventTarget;localStorage=,name%,orientation=,screen=,screenX=,screenY=,status=",
    requestAnimationFrame$1: [function(receiver, callback) {
      this._ensureRequestAnimationFrame$0(receiver);
      return this._requestAnimationFrame$1(receiver, W._wrapZone(callback));
    }, "call$1", "get$requestAnimationFrame", 2, 0, 25, 26, []],
    _requestAnimationFrame$1: function(receiver, callback) {
      return receiver.requestAnimationFrame(H.convertDartClosureToJS(callback, 1));
    },
    _ensureRequestAnimationFrame$0: function(receiver) {
      if (!!(receiver.requestAnimationFrame && receiver.cancelAnimationFrame))
        return;
      (function($this) {
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var i = 0; i < vendors.length && !$this.requestAnimationFrame; ++i) {
          $this.requestAnimationFrame = $this[vendors[i] + 'RequestAnimationFrame'];
          $this.cancelAnimationFrame = $this[vendors[i] + 'CancelAnimationFrame'] || $this[vendors[i] + 'CancelRequestAnimationFrame'];
        }
        if ($this.requestAnimationFrame && $this.cancelAnimationFrame)
          return;
        $this.requestAnimationFrame = function(callback) {
          return window.setTimeout(function() {
            callback(Date.now());
          }, 16);
        };
        $this.cancelAnimationFrame = function(id) {
          clearTimeout(id);
        };
      })(receiver);
    },
    get$parent: function(receiver) {
      return W._convertNativeToDart_Window(receiver.parent);
    },
    get$top: function(receiver) {
      return W._convertNativeToDart_Window(receiver.top);
    },
    scrollTo$3: function(receiver, x, y, scrollOptions) {
      receiver.scrollTo(x, y);
      return;
    },
    scrollTo$2: function($receiver, x, y) {
      return this.scrollTo$3($receiver, x, y, null);
    },
    stop$0: [function(receiver) {
      return receiver.stop();
    }, "call$0", "get$stop", 0, 0, 17],
    get$onBlur: function(receiver) {
      return C.EventStreamProvider_blur.forTarget$1(receiver);
    },
    get$onDragStart: function(receiver) {
      return C.EventStreamProvider_dragstart.forTarget$1(receiver);
    },
    get$onError: function(receiver) {
      return C.EventStreamProvider_error.forTarget$1(receiver);
    },
    onError$0: function($receiver) {
      return this.get$onError($receiver).call$0();
    },
    get$onFocus: function(receiver) {
      return C.EventStreamProvider_focus.forTarget$1(receiver);
    },
    get$onLoad: function(receiver) {
      return C.EventStreamProvider_load.forTarget$1(receiver);
    },
    get$onLoadStart: function(receiver) {
      return C.EventStreamProvider_loadstart0.forTarget$1(receiver);
    },
    get$onMouseDown: function(receiver) {
      return C.EventStreamProvider_mousedown.forTarget$1(receiver);
    },
    onMouseDown$1: function($receiver, arg0) {
      return this.get$onMouseDown($receiver).call$1(arg0);
    },
    get$onMouseMove: function(receiver) {
      return C.EventStreamProvider_mousemove.forTarget$1(receiver);
    },
    onMouseMove$1: function($receiver, arg0) {
      return this.get$onMouseMove($receiver).call$1(arg0);
    },
    get$onMouseOut: function(receiver) {
      return C.EventStreamProvider_mouseout.forTarget$1(receiver);
    },
    onMouseOut$1: function($receiver, arg0) {
      return this.get$onMouseOut($receiver).call$1(arg0);
    },
    get$onMouseOver: function(receiver) {
      return C.EventStreamProvider_mouseover.forTarget$1(receiver);
    },
    onMouseOver$1: function($receiver, arg0) {
      return this.get$onMouseOver($receiver).call$1(arg0);
    },
    get$onMouseUp: function(receiver) {
      return C.EventStreamProvider_mouseup.forTarget$1(receiver);
    },
    onMouseUp$1: function($receiver, arg0) {
      return this.get$onMouseUp($receiver).call$1(arg0);
    },
    get$onMouseWheel: function(receiver) {
      return C._CustomEventStreamProvider__determineMouseWheelEventType.forTarget$1(receiver);
    },
    onMouseWheel$1: function($receiver, arg0) {
      return this.get$onMouseWheel($receiver).call$1(arg0);
    },
    get$onPause: function(receiver) {
      return C.EventStreamProvider_pause.forTarget$1(receiver);
    },
    get$onPlay: function(receiver) {
      return C.EventStreamProvider_play.forTarget$1(receiver);
    },
    get$onProgress: function(receiver) {
      return C.EventStreamProvider_progress0.forTarget$1(receiver);
    },
    get$onResize: function(receiver) {
      return C.EventStreamProvider_resize.forTarget$1(receiver);
    },
    onResize$2: function($receiver, arg0, arg1) {
      return this.get$onResize($receiver).call$2(arg0, arg1);
    },
    get$onTouchCancel: function(receiver) {
      return C.EventStreamProvider_touchcancel.forTarget$1(receiver);
    },
    onTouchCancel$1: function($receiver, arg0) {
      return this.get$onTouchCancel($receiver).call$1(arg0);
    },
    get$onTouchEnd: function(receiver) {
      return C.EventStreamProvider_touchend.forTarget$1(receiver);
    },
    onTouchEnd$1: function($receiver, arg0) {
      return this.get$onTouchEnd($receiver).call$1(arg0);
    },
    get$onTouchMove: function(receiver) {
      return C.EventStreamProvider_touchmove.forTarget$1(receiver);
    },
    onTouchMove$1: function($receiver, arg0) {
      return this.get$onTouchMove($receiver).call$1(arg0);
    },
    get$onTouchStart: function(receiver) {
      return C.EventStreamProvider_touchstart.forTarget$1(receiver);
    },
    onTouchStart$1: function($receiver, arg0) {
      return this.get$onTouchStart($receiver).call$1(arg0);
    },
    get$onAnimationStart: function(receiver) {
      return C.EventStreamProvider_webkitAnimationStart.forTarget$1(receiver);
    },
    get$scrollX: function(receiver) {
      var t1;
      if ("scrollX" in receiver)
        t1 = receiver.scrollX;
      else {
        t1 = receiver.document.documentElement;
        t1.toString;
        t1 = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t1.scrollLeft));
      }
      return t1;
    },
    get$scrollY: function(receiver) {
      var t1;
      if ("scrollY" in receiver)
        t1 = receiver.scrollY;
      else {
        t1 = receiver.document.documentElement;
        t1.toString;
        t1 = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t1.scrollTop));
      }
      return t1;
    },
    $isWindow: true,
    $isEventTarget: true,
    "%": "DOMWindow|Window"
  },
  _Attr: {
    "^": "Node0;name=,value%",
    get$text: function(receiver) {
      return receiver.textContent;
    },
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$text($receiver).call$4(arg0, arg1, arg2, arg3);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return this.get$text($receiver).call$3(arg0, arg1, arg2);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.get$text($receiver).call$5(arg0, arg1, arg2, arg3, arg4);
    },
    set$text: function(receiver, value) {
      receiver.textContent = value;
    },
    "%": "Attr"
  },
  _ClientRect: {
    "^": "Interceptor;bottom=,height=,left=,right=,top=,width=",
    toString$0: function(receiver) {
      return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(receiver.width) + " x " + H.S(receiver.height);
    },
    $eq: function(receiver, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isRectangle)
        return false;
      t2 = receiver.left;
      t3 = t1.get$left(other);
      if (t2 == null ? t3 == null : t2 === t3) {
        t2 = receiver.top;
        t3 = t1.get$top(other);
        if (t2 == null ? t3 == null : t2 === t3) {
          t2 = receiver.width;
          t3 = t1.get$width(other);
          if (t2 == null ? t3 == null : t2 === t3) {
            t2 = receiver.height;
            t1 = t1.get$height(other);
            t1 = t2 == null ? t1 == null : t2 === t1;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(receiver) {
      var t1, t2, t3, t4;
      t1 = J.get$hashCode$(receiver.left);
      t2 = J.get$hashCode$(receiver.top);
      t3 = J.get$hashCode$(receiver.width);
      t4 = J.get$hashCode$(receiver.height);
      return W._JenkinsSmiHash_finish(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, t1), t2), t3), t4));
    },
    intersects$1: function(receiver, other) {
      var t1, t2, t3, t4;
      t1 = receiver.left;
      t2 = J.getInterceptor$x(other);
      t3 = J.$add$ns(t2.get$left(other), t2.get$width(other));
      if (typeof t1 !== "number")
        return t1.$le();
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (t1 <= t3) {
        t1 = t2.get$left(other);
        t3 = receiver.left;
        t4 = receiver.width;
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (J.$le$n(t1, t3 + t4)) {
          t1 = receiver.top;
          t3 = J.$add$ns(t2.get$top(other), t2.get$height(other));
          if (typeof t1 !== "number")
            return t1.$le();
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (t1 <= t3) {
            t1 = t2.get$top(other);
            t2 = receiver.top;
            t3 = receiver.height;
            if (typeof t2 !== "number")
              return t2.$add();
            if (typeof t3 !== "number")
              return H.iae(t3);
            t3 = J.$le$n(t1, t2 + t3);
            t1 = t3;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$topLeft: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(receiver.left, receiver.top), [null]);
    },
    get$topRight: function(receiver) {
      var t1, t2;
      t1 = receiver.left;
      t2 = receiver.width;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return H.setRuntimeTypeInfo(new P.Point1(t1 + t2, receiver.top), [null]);
    },
    get$bottomRight: function(receiver) {
      var t1, t2, t3, t4;
      t1 = receiver.left;
      t2 = receiver.width;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = receiver.top;
      t4 = receiver.height;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return H.setRuntimeTypeInfo(new P.Point1(t1 + t2, t3 + t4), [null]);
    },
    get$bottomLeft: function(receiver) {
      var t1, t2, t3;
      t1 = receiver.left;
      t2 = receiver.top;
      t3 = receiver.height;
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      return H.setRuntimeTypeInfo(new P.Point1(t1, t2 + t3), [null]);
    },
    $isRectangle: true,
    $asRectangle: function() {
      return [null];
    },
    "%": "ClientRect"
  },
  _DomRect: {
    "^": "DomRectReadOnly;",
    get$height: function(receiver) {
      return receiver.height;
    },
    set$height: function(receiver, value) {
      receiver.height = value;
    },
    get$width: function(receiver) {
      return receiver.width;
    },
    set$width: function(receiver, value) {
      receiver.width = value;
    },
    get$x: function(receiver) {
      return receiver.x;
    },
    set$x: function(receiver, value) {
      receiver.x = value;
    },
    get$y: function(receiver) {
      return receiver.y;
    },
    set$y: function(receiver, value) {
      receiver.y = value;
    },
    "%": "DOMRect"
  },
  _HTMLFrameSetElement: {
    "^": "HtmlElement;",
    $isEventTarget: true,
    "%": "HTMLFrameSetElement"
  },
  _NamedNodeMap: {
    "^": "Interceptor_ListMixin_ImmutableListMixin3;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node0];
    },
    $isEfficientLength: true,
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "MozNamedAttrMap|NamedNodeMap"
  },
  AudioElement_AudioElement: function(src) {
    return new Audio();
  },
  CanvasElement_CanvasElement: function(height, width) {
    var e = document.createElement("canvas", null);
    return e;
  },
  CssStyleDeclaration__camelCase: function(hyphenated) {
    return hyphenated.replace(/^-ms-/, "ms-").replace(/-([\da-z])/ig, C.JS_CONST_s8I);
  },
  Element__determineMouseWheelEventType: [function(e) {
    if (e.onwheel !== undefined)
      return "wheel";
    else if (e.onmousewheel !== undefined)
      return "mousewheel";
    else
      return "DOMMouseScroll";
  }, "call$1", "Element__determineMouseWheelEventType$closure", 2, 0, 604, 356, []],
  ImageElement_ImageElement: function(height, src, width) {
    var e = document.createElement("img", null);
    return e;
  },
  _JenkinsSmiHash_combine: function(hash, value) {
    hash = 536870911 & hash + value;
    hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
    return hash ^ hash >>> 6;
  },
  _JenkinsSmiHash_finish: function(hash) {
    hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
    hash ^= hash >>> 11;
    return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
  },
  _convertNativeToDart_Window: function(win) {
    if (win == null)
      return;
    return W._DOMWindowCrossFrame__createSafe(win);
  },
  _convertNativeToDart_EventTarget: function(e) {
    var $window;
    if (e == null)
      return;
    if ("postMessage" in e) {
      $window = W._DOMWindowCrossFrame__createSafe(e);
      if (!!J.getInterceptor($window).$isEventTarget)
        return $window;
      return;
    } else
      return e;
  },
  _convertNativeToDart_XHR_Response: function(o) {
    if (!!J.getInterceptor(o).$isDocument)
      return o;
    return P.convertNativeToDart_AcceptStructuredClone(o, true);
  },
  _wrapZone: function(callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone)
      return callback;
    if (callback == null)
      return;
    return t1.bindUnaryCallback$2$runGuarded(callback, true);
  },
  Interceptor_CssStyleDeclarationBase: {
    "^": "Interceptor+CssStyleDeclarationBase;"
  },
  _CssStyleDeclarationSet: {
    "^": "Object_CssStyleDeclarationBase;_elementIterable,_elementCssStyleDeclarationSetIterable",
    getPropertyValue$1: function(_, propertyName) {
      var t1 = this._elementCssStyleDeclarationSetIterable;
      return J.getPropertyValue$1$x(t1.get$first(t1), propertyName);
    },
    setProperty$3: function(_, propertyName, value, priority) {
      this._elementCssStyleDeclarationSetIterable.forEach$1(0, new W._CssStyleDeclarationSet_setProperty_closure(propertyName, value, priority));
    },
    _CssStyleDeclarationSet$1: function(_elementIterable) {
      this._elementCssStyleDeclarationSetIterable = H.setRuntimeTypeInfo(new H.MappedListIterable(P.List_List$from(this._elementIterable, true, null), new W._CssStyleDeclarationSet_closure()), [null, null]);
    },
    static: {_CssStyleDeclarationSet$: function(_elementIterable) {
        var t1 = new W._CssStyleDeclarationSet(_elementIterable, null);
        t1._CssStyleDeclarationSet$1(_elementIterable);
        return t1;
      }}
  },
  Object_CssStyleDeclarationBase: {
    "^": "Object+CssStyleDeclarationBase;"
  },
  _CssStyleDeclarationSet_closure: {
    "^": "Closure:102;",
    call$1: [function(e) {
      return J.get$style$x(e);
    }, "call$1", null, 2, 0, null, 356, [], "call"]
  },
  _CssStyleDeclarationSet_setProperty_closure: {
    "^": "Closure:102;propertyName_0,value_1,priority_2",
    call$1: function(e) {
      return J.setProperty$3$x(e, this.propertyName_0, this.value_1, this.priority_2);
    }
  },
  CssStyleDeclarationBase: {
    "^": "Object;",
    get$animation: function(receiver) {
      return this.getPropertyValue$1(receiver, "animation");
    },
    set$animation: function(receiver, value) {
      this.setProperty$3(receiver, "animation", value, "");
    },
    get$aspectRatio: function(receiver) {
      return this.getPropertyValue$1(receiver, "aspect-ratio");
    },
    set$aspectRatio: function(receiver, value) {
      this.setProperty$3(receiver, "aspect-ratio", value, "");
    },
    get$backgroundColor: function(receiver) {
      return this.getPropertyValue$1(receiver, "background-color");
    },
    set$backgroundColor: function(receiver, value) {
      this.setProperty$3(receiver, "background-color", value, "");
    },
    get$border: function(receiver) {
      return this.getPropertyValue$1(receiver, "border");
    },
    get$bottom: function(receiver) {
      return this.getPropertyValue$1(receiver, "bottom");
    },
    set$bottom: function(receiver, value) {
      this.setProperty$3(receiver, "bottom", value, "");
    },
    get$clear: function(receiver) {
      return this.getPropertyValue$1(receiver, "clear");
    },
    clear$0: function($receiver) {
      return this.get$clear($receiver).call$0();
    },
    clear$1: function($receiver, arg0) {
      return this.get$clear($receiver).call$1(arg0);
    },
    get$clip: function(receiver) {
      return this.getPropertyValue$1(receiver, "clip");
    },
    clip$0: function($receiver) {
      return this.get$clip($receiver).call$0();
    },
    get$color: function(receiver) {
      return this.getPropertyValue$1(receiver, "color");
    },
    set$color: function(receiver, value) {
      this.setProperty$3(receiver, "color", value, "");
    },
    get$columnWidth: function(receiver) {
      return this.getPropertyValue$1(receiver, "column-width");
    },
    set$columnWidth: function(receiver, value) {
      this.setProperty$3(receiver, "column-width", value, "");
    },
    get$columns: function(receiver) {
      return this.getPropertyValue$1(receiver, "columns");
    },
    set$columns: function(receiver, value) {
      this.setProperty$3(receiver, "columns", value, "");
    },
    get$content: function(receiver) {
      return this.getPropertyValue$1(receiver, "content");
    },
    set$content: function(receiver, value) {
      this.setProperty$3(receiver, "content", value, "");
    },
    get$cursor: function(receiver) {
      return this.getPropertyValue$1(receiver, "cursor");
    },
    set$cursor: function(receiver, value) {
      this.setProperty$3(receiver, "cursor", value, "");
    },
    set$display: function(receiver, value) {
      this.setProperty$3(receiver, "display", value, "");
    },
    get$filter: function(receiver) {
      return this.getPropertyValue$1(receiver, "filter");
    },
    filter$2: function($receiver, arg0, arg1) {
      return this.get$filter($receiver).call$2(arg0, arg1);
    },
    filter$1: function($receiver, arg0) {
      return this.get$filter($receiver).call$1(arg0);
    },
    get$font: function(receiver) {
      return this.getPropertyValue$1(receiver, "font");
    },
    set$font: function(receiver, value) {
      this.setProperty$3(receiver, "font", value, "");
    },
    get$fontSize: function(receiver) {
      return this.getPropertyValue$1(receiver, "font-size");
    },
    set$fontSize: function(receiver, value) {
      this.setProperty$3(receiver, "font-size", value, "");
    },
    get$fontWeight: function(receiver) {
      return this.getPropertyValue$1(receiver, "font-weight");
    },
    set$fontWeight: function(receiver, value) {
      this.setProperty$3(receiver, "font-weight", value, "");
    },
    get$grid: function(receiver) {
      return this.getPropertyValue$1(receiver, "grid");
    },
    set$grid: function(receiver, value) {
      this.setProperty$3(receiver, "grid", value, "");
    },
    get$height: function(receiver) {
      return this.getPropertyValue$1(receiver, "height");
    },
    set$height: function(receiver, value) {
      this.setProperty$3(receiver, "height", value, "");
    },
    set$imageRendering: function(receiver, value) {
      this.setProperty$3(receiver, "image-rendering", value, "");
    },
    get$left: function(receiver) {
      return this.getPropertyValue$1(receiver, "left");
    },
    set$left: function(receiver, value) {
      this.setProperty$3(receiver, "left", value, "");
    },
    get$lineHeight: function(receiver) {
      return this.getPropertyValue$1(receiver, "line-height");
    },
    set$lineHeight: function(receiver, value) {
      this.setProperty$3(receiver, "line-height", value, "");
    },
    get$margin: function(receiver) {
      return this.getPropertyValue$1(receiver, "margin");
    },
    set$margin: function(receiver, value) {
      this.setProperty$3(receiver, "margin", value, "");
    },
    set$marginLeft: function(receiver, value) {
      this.setProperty$3(receiver, "margin-left", value, "");
    },
    set$marginTop: function(receiver, value) {
      this.setProperty$3(receiver, "margin-top", value, "");
    },
    get$mask: function(receiver) {
      return this.getPropertyValue$1(receiver, "mask");
    },
    set$mask: function(receiver, value) {
      this.setProperty$3(receiver, "mask", value, "");
    },
    get$maskPosition: function(receiver) {
      return this.getPropertyValue$1(receiver, "mask-position");
    },
    set$maskPosition: function(receiver, value) {
      this.setProperty$3(receiver, "mask-position", value, "");
    },
    get$maxHeight: function(receiver) {
      return this.getPropertyValue$1(receiver, "max-height");
    },
    set$maxHeight: function(receiver, value) {
      this.setProperty$3(receiver, "max-height", value, "");
    },
    get$maxWidth: function(receiver) {
      return this.getPropertyValue$1(receiver, "max-width");
    },
    set$maxWidth: function(receiver, value) {
      this.setProperty$3(receiver, "max-width", value, "");
    },
    get$minHeight: function(receiver) {
      return this.getPropertyValue$1(receiver, "min-height");
    },
    set$minHeight: function(receiver, value) {
      this.setProperty$3(receiver, "min-height", value, "");
    },
    get$minWidth: function(receiver) {
      return this.getPropertyValue$1(receiver, "min-width");
    },
    set$minWidth: function(receiver, value) {
      this.setProperty$3(receiver, "min-width", value, "");
    },
    get$order: function(receiver) {
      return this.getPropertyValue$1(receiver, "order");
    },
    order$0: function($receiver) {
      return this.get$order($receiver).call$0();
    },
    get$orientation: function(receiver) {
      return this.getPropertyValue$1(receiver, "orientation");
    },
    set$orientation: function(receiver, value) {
      this.setProperty$3(receiver, "orientation", value, "");
    },
    set$overflow: function(receiver, value) {
      this.setProperty$3(receiver, "overflow", value, "");
    },
    get$padding: function(receiver) {
      return this.getPropertyValue$1(receiver, "padding");
    },
    set$padding: function(receiver, value) {
      this.setProperty$3(receiver, "padding", value, "");
    },
    get$page: function(receiver) {
      return this.getPropertyValue$1(receiver, "page");
    },
    set$page: function(receiver, value) {
      this.setProperty$3(receiver, "page", value, "");
    },
    get$position: function(receiver) {
      return this.getPropertyValue$1(receiver, "position");
    },
    set$position: function(receiver, value) {
      this.setProperty$3(receiver, "position", value, "");
    },
    get$resize: function(receiver) {
      return this.getPropertyValue$1(receiver, "resize");
    },
    resize$2: function($receiver, arg0, arg1) {
      return this.get$resize($receiver).call$2(arg0, arg1);
    },
    resize$0: function($receiver) {
      return this.get$resize($receiver).call$0();
    },
    resize$3: function($receiver, arg0, arg1, arg2) {
      return this.get$resize($receiver).call$3(arg0, arg1, arg2);
    },
    get$right: function(receiver) {
      return this.getPropertyValue$1(receiver, "right");
    },
    set$right: function(receiver, value) {
      this.setProperty$3(receiver, "right", value, "");
    },
    get$size: function(receiver) {
      return this.getPropertyValue$1(receiver, "size");
    },
    size$1: function($receiver, arg0) {
      return this.get$size($receiver).call$1(arg0);
    },
    set$size: function(receiver, value) {
      this.setProperty$3(receiver, "size", value, "");
    },
    get$src: function(receiver) {
      return this.getPropertyValue$1(receiver, "src");
    },
    set$src: function(receiver, value) {
      this.setProperty$3(receiver, "src", value, "");
    },
    set$tapHighlightColor: function(receiver, value) {
      this.setProperty$3(receiver, "tap-highlight-color", value, "");
    },
    get$top: function(receiver) {
      return this.getPropertyValue$1(receiver, "top");
    },
    set$top: function(receiver, value) {
      this.setProperty$3(receiver, "top", value, "");
    },
    set$touchAction: function(receiver, value) {
      this.setProperty$3(receiver, "touch-action", value, "");
    },
    get$transform: function(receiver) {
      return this.getPropertyValue$1(receiver, "transform");
    },
    transform$6: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5) {
      return this.get$transform($receiver).call$6(arg0, arg1, arg2, arg3, arg4, arg5);
    },
    set$userSelect: function(receiver, value) {
      this.setProperty$3(receiver, "user-select", value, "");
    },
    get$width: function(receiver) {
      return this.getPropertyValue$1(receiver, "width");
    },
    set$width: function(receiver, value) {
      this.setProperty$3(receiver, "width", value, "");
    },
    get$wordWrap: function(receiver) {
      return this.getPropertyValue$1(receiver, "word-wrap");
    },
    wordWrap$1: function($receiver, arg0) {
      return this.get$wordWrap($receiver).call$1(arg0);
    },
    set$wordWrap: function(receiver, value) {
      this.setProperty$3(receiver, "word-wrap", value, "");
    }
  },
  _ChildrenElementList: {
    "^": "ListBase;_element,_childElements",
    contains$1: [function(_, element) {
      return J.contains$1$asx(this._childElements, element);
    }, "call$1", "get$contains", 2, 0, 1693],
    get$isEmpty: function(_) {
      return this._element.firstElementChild == null;
    },
    get$length: function(_) {
      return this._childElements.length;
    },
    $index: function(_, index) {
      var t1 = this._childElements;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      var t1 = this._childElements;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      this._element.replaceChild(value, t1[index]);
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize element lists"));
    },
    add$1: [function(_, value) {
      this._element.appendChild(value);
      return value;
    }, "call$1", "get$add", 2, 0, 1720, 138, []],
    get$iterator: function(_) {
      var t1 = this.toList$0(this);
      return H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]);
    },
    addAll$1: function(_, iterable) {
      var t1, t2;
      for (t1 = J.get$iterator$ax(!!J.getInterceptor(iterable).$is_ChildNodeListLazy ? P.List_List$from(iterable, true, null) : iterable), t2 = this._element; t1.moveNext$0();)
        t2.appendChild(t1.get$current());
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort element lists"));
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    remove$1: function(_, object) {
      var t1;
      if (!!J.getInterceptor(object).$isElement) {
        t1 = this._element;
        if (object.parentNode === t1) {
          t1.removeChild(object);
          return true;
        }
      }
      return false;
    },
    insert$2: function(_, index, element) {
      var t1, t2, t3;
      t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$gt(index, this._childElements.length))
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this), null, null));
      t2 = this._childElements;
      t3 = this._element;
      if (t1.$eq(index, t2.length))
        t3.appendChild(element);
      else {
        if (index >>> 0 !== index || index >= t2.length)
          return H.ioore(t2, index);
        t3.insertBefore(element, t2[index]);
      }
    },
    clear$0: function(_) {
      J._clearChildren$0$x(this._element);
    },
    removeAt$1: function(_, index) {
      var t1, result;
      t1 = this._childElements;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      result = t1[index];
      this._element.removeChild(result);
      return result;
    },
    removeLast$0: function(_) {
      var result = this.get$last(this);
      this._element.removeChild(result);
      return result;
    },
    get$last: function(_) {
      var result = this._element.lastElementChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    $asListBase: function() {
      return [W.Element];
    },
    $asObject_ListMixin: function() {
      return [W.Element];
    },
    $asList: function() {
      return [W.Element];
    }
  },
  _FrozenElementList: {
    "^": "ListBase;_nodeList,_elementList",
    get$length: function(_) {
      return this._nodeList.length;
    },
    $index: function(_, index) {
      var t1 = this._nodeList;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify list"));
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify list"));
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort list"));
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    get$last: function(_) {
      return C.NodeList_methods.get$last(this._nodeList);
    },
    get$style: function(_) {
      return W._CssStyleDeclarationSet$(this._elementList);
    },
    get$onBlur: function(_) {
      return C.EventStreamProvider_blur._forElementList$1(this);
    },
    get$onDragStart: function(_) {
      return C.EventStreamProvider_dragstart._forElementList$1(this);
    },
    get$onError: function(_) {
      return C.EventStreamProvider_error._forElementList$1(this);
    },
    onError$0: function($receiver) {
      return this.get$onError(this).call$0();
    },
    get$onFocus: function(_) {
      return C.EventStreamProvider_focus._forElementList$1(this);
    },
    get$onLoad: function(_) {
      return C.EventStreamProvider_load._forElementList$1(this);
    },
    get$onMouseDown: function(_) {
      return C.EventStreamProvider_mousedown._forElementList$1(this);
    },
    onMouseDown$1: function($receiver, arg0) {
      return this.get$onMouseDown(this).call$1(arg0);
    },
    get$onMouseMove: function(_) {
      return C.EventStreamProvider_mousemove._forElementList$1(this);
    },
    onMouseMove$1: function($receiver, arg0) {
      return this.get$onMouseMove(this).call$1(arg0);
    },
    get$onMouseOut: function(_) {
      return C.EventStreamProvider_mouseout._forElementList$1(this);
    },
    onMouseOut$1: function($receiver, arg0) {
      return this.get$onMouseOut(this).call$1(arg0);
    },
    get$onMouseOver: function(_) {
      return C.EventStreamProvider_mouseover._forElementList$1(this);
    },
    onMouseOver$1: function($receiver, arg0) {
      return this.get$onMouseOver(this).call$1(arg0);
    },
    get$onMouseUp: function(_) {
      return C.EventStreamProvider_mouseup._forElementList$1(this);
    },
    onMouseUp$1: function($receiver, arg0) {
      return this.get$onMouseUp(this).call$1(arg0);
    },
    get$onMouseWheel: function(_) {
      return C._CustomEventStreamProvider__determineMouseWheelEventType._forElementList$1(this);
    },
    onMouseWheel$1: function($receiver, arg0) {
      return this.get$onMouseWheel(this).call$1(arg0);
    },
    get$onPause: function(_) {
      return C.EventStreamProvider_pause._forElementList$1(this);
    },
    get$onPlay: function(_) {
      return C.EventStreamProvider_play._forElementList$1(this);
    },
    get$onResize: function(_) {
      return C.EventStreamProvider_resize._forElementList$1(this);
    },
    onResize$2: function($receiver, arg0, arg1) {
      return this.get$onResize(this).call$2(arg0, arg1);
    },
    get$onTouchCancel: function(_) {
      return C.EventStreamProvider_touchcancel._forElementList$1(this);
    },
    onTouchCancel$1: function($receiver, arg0) {
      return this.get$onTouchCancel(this).call$1(arg0);
    },
    get$onTouchEnd: function(_) {
      return C.EventStreamProvider_touchend._forElementList$1(this);
    },
    onTouchEnd$1: function($receiver, arg0) {
      return this.get$onTouchEnd(this).call$1(arg0);
    },
    get$onTouchEnter: function(_) {
      return C.EventStreamProvider_touchenter._forElementList$1(this);
    },
    onTouchEnter$1: function($receiver, arg0) {
      return this.get$onTouchEnter(this).call$1(arg0);
    },
    get$onTouchLeave: function(_) {
      return C.EventStreamProvider_touchleave._forElementList$1(this);
    },
    onTouchLeave$1: function($receiver, arg0) {
      return this.get$onTouchLeave(this).call$1(arg0);
    },
    get$onTouchMove: function(_) {
      return C.EventStreamProvider_touchmove._forElementList$1(this);
    },
    onTouchMove$1: function($receiver, arg0) {
      return this.get$onTouchMove(this).call$1(arg0);
    },
    get$onTouchStart: function(_) {
      return C.EventStreamProvider_touchstart._forElementList$1(this);
    },
    onTouchStart$1: function($receiver, arg0) {
      return this.get$onTouchStart(this).call$1(arg0);
    },
    _html$_FrozenElementList$_wrap$1: function(_nodeList, $T) {
      var t1 = C.NodeList_methods.where$1(this._nodeList, new W._FrozenElementList$_wrap_closure());
      this._elementList = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    static: {_FrozenElementList$_wrap: function(_nodeList, $T) {
        var t1 = H.setRuntimeTypeInfo(new W._FrozenElementList(_nodeList, null), [$T]);
        t1._html$_FrozenElementList$_wrap$1(_nodeList, $T);
        return t1;
      }}
  },
  _FrozenElementList$_wrap_closure: {
    "^": "Closure:102;",
    call$1: function(e) {
      return !!J.getInterceptor(e).$isElement;
    }
  },
  Events0: {
    "^": "Object;_ptr<",
    $index: function(_, type) {
      return H.setRuntimeTypeInfo(new W._EventStream(this.get$_ptr(), type, false), [null]);
    }
  },
  "+Events": 0,
  ElementEvents: {
    "^": "Events0;_ptr:html$ElementEvents$_ptr<,_ptr",
    $index: function(_, type) {
      var t1, t2;
      t1 = $.get$ElementEvents_webkitEvents();
      t2 = J.getInterceptor$s(type);
      if (t1.get$keys(t1).contains$1(0, t2.toLowerCase$0(type)))
        if (P.Device_isWebKit() === true)
          return H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(this.html$ElementEvents$_ptr, t1.$index(0, t2.toLowerCase$0(type)), false), [null]);
      return H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(this.html$ElementEvents$_ptr, type, false), [null]);
    },
    static: {"^": "ElementEvents_webkitEvents"}
  },
  Interceptor_ListMixin: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.File];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin_ImmutableListMixin: {
    "^": "Interceptor_ListMixin+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.File];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin0: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node0];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin_ImmutableListMixin0: {
    "^": "Interceptor_ListMixin0+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node0];
    },
    $isEfficientLength: true
  },
  Navigator_getUserMedia_closure: {
    "^": "Closure:102;completer_0",
    call$1: [function(stream) {
      this.completer_0.complete$1(0, stream);
    }, "call$1", null, 2, 0, null, 1721, [], "call"]
  },
  Navigator_getUserMedia_closure0: {
    "^": "Closure:102;completer_1",
    call$1: [function(error) {
      this.completer_1.completeError$1(error);
    }, "call$1", null, 2, 0, null, 598, [], "call"]
  },
  _ChildNodeListLazy: {
    "^": "ListBase;_this",
    get$last: function(_) {
      var result = this._this.lastChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    add$1: [function(_, value) {
      this._this.appendChild(value);
    }, "call$1", "get$add", 2, 0, 1722, 138, []],
    addAll$1: function(_, iterable) {
      var t1, t2, len, i;
      t1 = J.getInterceptor(iterable);
      if (!!t1.$is_ChildNodeListLazy) {
        t1 = iterable._this;
        t2 = this._this;
        if (t1 !== t2)
          for (len = t1.childNodes.length, i = 0; i < len; ++i)
            t2.appendChild(t1.firstChild);
        return;
      }
      for (t1 = t1.get$iterator(iterable), t2 = this._this; t1.moveNext$0();)
        t2.appendChild(t1.get$current());
    },
    insert$2: function(_, index, node) {
      var t1, t2;
      t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$gt(index, this._this.childNodes.length))
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this), null, null));
      t2 = this._this;
      if (t1.$eq(index, t2.childNodes.length))
        t2.appendChild(node);
      else {
        t1 = t2.childNodes;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        t2.insertBefore(node, t1[index]);
      }
    },
    removeLast$0: function(_) {
      var result = this.get$last(this);
      this._this.removeChild(result);
      return result;
    },
    removeAt$1: function(_, index) {
      var t1, t2, result;
      t1 = this._this;
      t2 = t1.childNodes;
      if (index >>> 0 !== index || index >= t2.length)
        return H.ioore(t2, index);
      result = t2[index];
      t1.removeChild(result);
      return result;
    },
    remove$1: function(_, object) {
      var t1;
      if (!J.getInterceptor(object).$isNode0)
        return false;
      t1 = this._this;
      if (t1 !== object.parentNode)
        return false;
      t1.removeChild(object);
      return true;
    },
    clear$0: function(_) {
      J._clearChildren$0$x(this._this);
    },
    $indexSet: function(_, index, value) {
      var t1, t2;
      t1 = this._this;
      t2 = t1.childNodes;
      if (index >>> 0 !== index || index >= t2.length)
        return H.ioore(t2, index);
      t1.replaceChild(value, t2[index]);
    },
    get$iterator: function(_) {
      return C.NodeList_methods.get$iterator(this._this.childNodes);
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort Node list"));
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on Node list"));
    },
    get$length: function(_) {
      return this._this.childNodes.length;
    },
    set$length: function(_, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot set length on immutable List."));
    },
    $index: function(_, index) {
      var t1 = this._this.childNodes;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $is_ChildNodeListLazy: true,
    $asListBase: function() {
      return [W.Node0];
    },
    $asObject_ListMixin: function() {
      return [W.Node0];
    },
    $asList: function() {
      return [W.Node0];
    }
  },
  Interceptor_ListMixin1: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node0];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin_ImmutableListMixin1: {
    "^": "Interceptor_ListMixin1+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node0];
    },
    $isEfficientLength: true
  },
  Path2D: {
    "^": "Interceptor;"
  },
  SelectElement_options_closure: {
    "^": "Closure:102;",
    call$1: function(e) {
      return !!J.getInterceptor(e).$isOptionElement;
    }
  },
  Storage_addAll_closure: {
    "^": "Closure:959;this_0",
    call$2: [function(k, v) {
      this.this_0.setItem(k, v);
    }, "call$2", null, 4, 0, null, 420, [], 37, [], "call"]
  },
  Storage_keys_closure: {
    "^": "Closure:959;keys_0",
    call$2: function(k, v) {
      return this.keys_0.push(k);
    }
  },
  Storage_values_closure: {
    "^": "Closure:959;values_0",
    call$2: function(k, v) {
      return this.values_0.push(v);
    }
  },
  Interceptor_ListMixin2: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Touch0];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin_ImmutableListMixin2: {
    "^": "Interceptor_ListMixin2+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Touch0];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin3: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node0];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin_ImmutableListMixin3: {
    "^": "Interceptor_ListMixin3+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node0];
    },
    $isEfficientLength: true
  },
  _AttributeMap: {
    "^": "Object;",
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new W._AttributeMap_addAll_closure(this));
    },
    clear$0: function(_) {
      var t1;
      for (t1 = this.get$keys(this), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        this.remove$1(0, t1.__internal$_current);
    },
    forEach$1: function(_, f) {
      var t1, key;
      for (t1 = this.get$keys(this), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        key = t1.__internal$_current;
        f.call$2(key, this.$index(0, key));
      }
    },
    get$keys: function(_) {
      var attributes, keys, len, i;
      attributes = this._element.attributes;
      keys = H.setRuntimeTypeInfo([], [P.String]);
      for (len = attributes.length, i = 0; i < len; ++i) {
        if (i >= attributes.length)
          return H.ioore(attributes, i);
        if (this._matches$1(attributes[i])) {
          if (i >= attributes.length)
            return H.ioore(attributes, i);
          keys.push(J.get$name$x(attributes[i]));
        }
      }
      return keys;
    },
    get$values: function(_) {
      var attributes, values, len, i;
      attributes = this._element.attributes;
      values = H.setRuntimeTypeInfo([], [P.String]);
      for (len = attributes.length, i = 0; i < len; ++i) {
        if (i >= attributes.length)
          return H.ioore(attributes, i);
        if (this._matches$1(attributes[i])) {
          if (i >= attributes.length)
            return H.ioore(attributes, i);
          values.push(J.get$value$x(attributes[i]));
        }
      }
      return values;
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$isNotEmpty: function(_) {
      return this.get$length(this) !== 0;
    },
    $isMap: true,
    $asMap: function() {
      return [P.String, P.String];
    }
  },
  _AttributeMap_addAll_closure: {
    "^": "Closure:959;this_0",
    call$2: [function(k, v) {
      this.this_0.$indexSet(0, k, v);
    }, "call$2", null, 4, 0, null, 420, [], 37, [], "call"]
  },
  _ElementAttributeMap: {
    "^": "_AttributeMap;_element",
    containsKey$1: function(_, key) {
      return this._element.hasAttribute(key);
    },
    $index: function(_, key) {
      return this._element.getAttribute(key);
    },
    $indexSet: function(_, key, value) {
      this._element.setAttribute(key, value);
    },
    remove$1: function(_, key) {
      var t1, value;
      t1 = this._element;
      value = t1.getAttribute(key);
      t1.removeAttribute(key);
      return value;
    },
    get$length: function(_) {
      return this.get$keys(this).length;
    },
    _matches$1: function(node) {
      return node.namespaceURI == null;
    }
  },
  _DataAttributeMap: {
    "^": "Object;_attributes",
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new W._DataAttributeMap_addAll_closure(this));
    },
    containsKey$1: function(_, key) {
      return this._attributes._element.hasAttribute("data-" + H.S(this._toHyphenedName$1(key)));
    },
    $index: function(_, key) {
      return this._attributes._element.getAttribute("data-" + H.S(this._toHyphenedName$1(key)));
    },
    $indexSet: function(_, key, value) {
      this._attributes._element.setAttribute("data-" + H.S(this._toHyphenedName$1(key)), value);
    },
    remove$1: function(_, key) {
      var t1, t2, value;
      t1 = "data-" + H.S(this._toHyphenedName$1(key));
      t2 = this._attributes._element;
      value = t2.getAttribute(t1);
      t2.removeAttribute(t1);
      return value;
    },
    clear$0: function(_) {
      var t1, t2, t3;
      for (t1 = this.get$keys(this), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this._attributes._element; t1.moveNext$0();) {
        t3 = "data-" + H.S(this._toHyphenedName$1(t1.__internal$_current));
        t2.getAttribute(t3);
        t2.removeAttribute(t3);
      }
    },
    forEach$1: function(_, f) {
      this._attributes.forEach$1(0, new W._DataAttributeMap_forEach_closure(this, f));
    },
    get$keys: function(_) {
      var keys = H.setRuntimeTypeInfo([], [P.String]);
      this._attributes.forEach$1(0, new W._DataAttributeMap_keys_closure(this, keys));
      return keys;
    },
    get$values: function(_) {
      var values = H.setRuntimeTypeInfo([], [P.String]);
      this._attributes.forEach$1(0, new W._DataAttributeMap_values_closure(this, values));
      return values;
    },
    get$length: function(_) {
      return this.get$keys(this).length;
    },
    get$isEmpty: function(_) {
      return this.get$keys(this).length === 0;
    },
    get$isNotEmpty: function(_) {
      return this.get$keys(this).length !== 0;
    },
    _toCamelCase$2$startUppercase: function(hyphenedName, startUppercase) {
      var segments, start, i, segment, t1;
      segments = hyphenedName.split("-");
      start = startUppercase ? 0 : 1;
      for (i = start; i < segments.length; ++i) {
        segment = segments[i];
        t1 = J.getInterceptor$asx(segment);
        if (J.$gt$n(t1.get$length(segment), 0)) {
          t1 = J.toUpperCase$0$s(t1.$index(segment, 0)) + t1.substring$1(segment, 1);
          if (i >= segments.length)
            return H.ioore(segments, i);
          segments[i] = t1;
        }
      }
      return C.JSArray_methods.join$1(segments, "");
    },
    _toCamelCase$1: function(hyphenedName) {
      return this._toCamelCase$2$startUppercase(hyphenedName, false);
    },
    _toHyphenedName$1: function(word) {
      var sb, t1, i, t2, lower;
      sb = P.StringBuffer$("");
      t1 = J.getInterceptor$asx(word);
      i = 0;
      while (true) {
        t2 = t1.get$length(word);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        lower = J.toLowerCase$0$s(t1.$index(word, i));
        if (!J.$eq(t1.$index(word, i), lower) && i > 0)
          sb._contents += "-";
        sb._contents += lower;
        ++i;
      }
      t1 = sb._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isMap: true,
    $asMap: function() {
      return [P.String, P.String];
    }
  },
  _DataAttributeMap_addAll_closure: {
    "^": "Closure:959;this_0",
    call$2: [function(k, v) {
      var t1 = this.this_0;
      t1._attributes._element.setAttribute("data-" + H.S(t1._toHyphenedName$1(k)), v);
    }, "call$2", null, 4, 0, null, 420, [], 37, [], "call"]
  },
  _DataAttributeMap_forEach_closure: {
    "^": "Closure:772;this_0,f_1",
    call$2: function(key, value) {
      var t1 = J.getInterceptor$s(key);
      if (t1.startsWith$1(key, "data-"))
        this.f_1.call$2(this.this_0._toCamelCase$1(t1.substring$1(key, 5)), value);
    }
  },
  _DataAttributeMap_keys_closure: {
    "^": "Closure:772;this_0,keys_1",
    call$2: function(key, value) {
      var t1 = J.getInterceptor$s(key);
      if (t1.startsWith$1(key, "data-"))
        this.keys_1.push(this.this_0._toCamelCase$1(t1.substring$1(key, 5)));
    }
  },
  _DataAttributeMap_values_closure: {
    "^": "Closure:772;this_0,values_1",
    call$2: function(key, value) {
      if (J.startsWith$1$s(key, "data-"))
        this.values_1.push(value);
    }
  },
  CanvasImageSource: {
    "^": "Object;"
  },
  EventStreamProvider: {
    "^": "Object;_eventType",
    forTarget$2$useCapture: function(e, useCapture) {
      return H.setRuntimeTypeInfo(new W._EventStream(e, this._eventType, useCapture), [null]);
    },
    forTarget$1: function(e) {
      return this.forTarget$2$useCapture(e, false);
    },
    forElement$2$useCapture: function(e, useCapture) {
      return H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(e, this._eventType, useCapture), [null]);
    },
    forElement$1: function(e) {
      return this.forElement$2$useCapture(e, false);
    },
    _forElementList$2$useCapture: function(e, useCapture) {
      return H.setRuntimeTypeInfo(new W._ElementListEventStreamImpl(e, useCapture, this._eventType), [null]);
    },
    _forElementList$1: function(e) {
      return this._forElementList$2$useCapture(e, false);
    }
  },
  _EventStream: {
    "^": "Stream;_target,_eventType,_useCapture",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1 = new W._EventStreamSubscription(0, this._target, this._eventType, W._wrapZone(onData), this._useCapture);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      t1._tryResume$0();
      return t1;
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    }
  },
  _ElementEventStreamImpl: {
    "^": "_EventStream;_target,_eventType,_useCapture",
    capture$1: [function(_, onData) {
      var t1 = new W._EventStreamSubscription(0, this._target, this._eventType, W._wrapZone(onData), true);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      t1._tryResume$0();
      return t1;
    }, "call$1", "get$capture", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "StreamSubscription__void__T", ret: [P.StreamSubscription, T], args: [{func: "void__T0", void: true, args: [T]}]};
      }, this.$receiver, "_ElementEventStreamImpl");
    }],
    $isStream: true
  },
  _ElementListEventStreamImpl: {
    "^": "Stream;_targetList,_useCapture,_eventType",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var pool, t1, t2, t3, t4;
      pool = W._StreamPool$broadcast(null);
      for (t1 = this._targetList, t1 = t1.get$iterator(t1), t2 = this._eventType, t3 = this._useCapture; t1.moveNext$0();) {
        t4 = new W._EventStream(t1.__internal$_current, t2, t3);
        t4.$builtinTypeInfo = [null];
        pool.add$1(0, t4);
      }
      t1 = pool._controller;
      t1.toString;
      return H.setRuntimeTypeInfo(new P._BroadcastStream(t1), [H.getTypeArgumentByIndex(t1, 0)]).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    capture$1: [function(_, onData) {
      var pool, t1, t2, t3;
      pool = W._StreamPool$broadcast(null);
      for (t1 = this._targetList, t1 = t1.get$iterator(t1), t2 = this._eventType; t1.moveNext$0();) {
        t3 = new W._EventStream(t1.__internal$_current, t2, true);
        t3.$builtinTypeInfo = [null];
        pool.add$1(0, t3);
      }
      t1 = pool._controller;
      t1.toString;
      return H.setRuntimeTypeInfo(new P._BroadcastStream(t1), [H.getTypeArgumentByIndex(t1, 0)]).listen$1(onData);
    }, "call$1", "get$capture", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "StreamSubscription__void__T0", ret: [P.StreamSubscription, T], args: [{func: "void__T1", void: true, args: [T]}]};
      }, this.$receiver, "_ElementListEventStreamImpl");
    }],
    $isStream: true
  },
  _EventStreamSubscription: {
    "^": "StreamSubscription;_pauseCount,_target,_eventType,_onData,_useCapture",
    cancel$0: function() {
      if (this._target == null)
        return;
      this._unlisten$0();
      this._target = null;
      this._onData = null;
      return;
    },
    onError$1: [function(_, handleError) {
    }, "call$1", "get$onError", 2, 0, 1705],
    pause$1: function(_, resumeSignal) {
      if (this._target == null)
        return;
      ++this._pauseCount;
      this._unlisten$0();
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    get$isPaused: function() {
      return this._pauseCount > 0;
    },
    resume$0: function() {
      if (this._target == null || this._pauseCount <= 0)
        return;
      --this._pauseCount;
      this._tryResume$0();
    },
    _tryResume$0: function() {
      var t1 = this._onData;
      if (t1 != null && this._pauseCount <= 0)
        J.addEventListener$3$x(this._target, this._eventType, t1, this._useCapture);
    },
    _unlisten$0: function() {
      var t1 = this._onData;
      if (t1 != null)
        J.removeEventListener$3$x(this._target, this._eventType, t1, this._useCapture);
    }
  },
  _StreamPool: {
    "^": "Object;_controller,_subscriptions",
    add$1: [function(_, stream) {
      var t1, t2;
      t1 = this._subscriptions;
      if (t1.containsKey$1(0, stream))
        return;
      t2 = this._controller;
      t1.$indexSet(0, stream, stream.listen$3$onDone$onError(t2.get$add(t2), new W._StreamPool_add_closure(this, stream), this._controller.get$addError()));
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "void__Stream", void: true, args: [[P.Stream, T]]};
      }, this.$receiver, "_StreamPool");
    }, 1721, []],
    remove$1: function(_, stream) {
      var subscription = this._subscriptions.remove$1(0, stream);
      if (subscription != null)
        subscription.cancel$0();
    },
    close$0: [function(_) {
      var t1, t2;
      for (t1 = this._subscriptions, t2 = t1.get$values(t1), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();)
        t2.__internal$_current.cancel$0();
      t1.clear$0(0);
      this._controller.close$0(0);
    }, "call$0", "get$close", 0, 0, 17],
    _html$_StreamPool$broadcast$0: function($T) {
      var t1 = this.get$close(this);
      t1 = H.setRuntimeTypeInfo(new P._SyncBroadcastStreamController(null, t1, 0, null, null, null, null), [$T]);
      t1._async$_previous = t1;
      t1._async$_next = t1;
      this._controller = t1;
    },
    static: {_StreamPool$broadcast: function($T) {
        var t1 = H.setRuntimeTypeInfo(new W._StreamPool(null, P.LinkedHashMap_LinkedHashMap(null, null, null, [P.Stream, $T], [P.StreamSubscription, $T])), [$T]);
        t1._html$_StreamPool$broadcast$0($T);
        return t1;
      }}
  },
  _StreamPool_add_closure: {
    "^": "Closure:54;this_0,stream_1",
    call$0: [function() {
      return this.this_0.remove$1(0, this.stream_1);
    }, "call$0", null, 0, 0, null, "call"]
  },
  _CustomEventStreamProvider: {
    "^": "Object;_eventTypeGetter",
    _eventTypeGetter$1: function(arg0) {
      return this._eventTypeGetter.call$1(arg0);
    },
    forTarget$2$useCapture: function(e, useCapture) {
      return H.setRuntimeTypeInfo(new W._EventStream(e, this._eventTypeGetter$1(e), useCapture), [null]);
    },
    forTarget$1: function(e) {
      return this.forTarget$2$useCapture(e, false);
    },
    forElement$2$useCapture: function(e, useCapture) {
      return H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(e, this._eventTypeGetter$1(e), useCapture), [null]);
    },
    forElement$1: function(e) {
      return this.forElement$2$useCapture(e, false);
    },
    _forElementList$2$useCapture: function(e, useCapture) {
      return H.setRuntimeTypeInfo(new W._ElementListEventStreamImpl(e, useCapture, this._eventTypeGetter$1(e)), [null]);
    },
    _forElementList$1: function(e) {
      return this._forElementList$2$useCapture(e, false);
    }
  },
  ImmutableListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      return H.setRuntimeTypeInfo(new W.FixedSizeListIterator(receiver, this.get$length(receiver), -1, null), [H.getRuntimeTypeArgument(receiver, "ImmutableListMixin", 0)]);
    },
    add$1: [function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E5", void: true, args: [E]};
      }, this.$receiver, "ImmutableListMixin");
    }, 138, []],
    addAll$1: function(receiver, iterable) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
    },
    sort$1: function(receiver, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort immutable List."));
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    insert$2: function(receiver, index, element) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
    },
    removeAt$1: function(receiver, pos) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
    },
    removeLast$0: function(receiver) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
    },
    remove$1: function(receiver, object) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on immutable List."));
    },
    removeRange$2: function(receiver, start, end) {
      throw H.wrapException(P.UnsupportedError$("Cannot removeRange on immutable List."));
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  _WrappedList: {
    "^": "ListBase;_list",
    get$iterator: function(_) {
      return H.setRuntimeTypeInfo(new W._WrappedIterator(J.get$iterator$ax(this._list)), [null]);
    },
    get$length: function(_) {
      return this._list.length;
    },
    add$1: [function(_, element) {
      J.add$1$ax(this._list, element);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E6", void: true, args: [E]};
      }, this.$receiver, "_WrappedList");
    }, 23, []],
    remove$1: function(_, element) {
      return J.remove$1$ax(this._list, element);
    },
    clear$0: function(_) {
      J.clear$0$ax(this._list);
    },
    $index: function(_, index) {
      var t1 = this._list;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      var t1 = this._list;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = value;
    },
    set$length: function(_, newLength) {
      J.set$length$asx(this._list, newLength);
    },
    sort$1: function(_, compare) {
      J.sort$1$ax(this._list, compare);
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    indexOf$2: function(_, element, start) {
      return J.indexOf$2$asx(this._list, element, start);
    },
    indexOf$1: function($receiver, element) {
      return this.indexOf$2($receiver, element, 0);
    },
    insert$2: function(_, index, element) {
      return J.insert$2$ax(this._list, index, element);
    },
    removeAt$1: function(_, index) {
      return J.removeAt$1$ax(this._list, index);
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      J.setRange$4$ax(this._list, start, end, iterable, skipCount);
    },
    removeRange$2: function(_, start, end) {
      J.removeRange$2$ax(this._list, start, end);
    }
  },
  _WrappedIterator: {
    "^": "Object;_html$_iterator",
    moveNext$0: function() {
      return this._html$_iterator.moveNext$0();
    },
    get$current: function() {
      return this._html$_iterator._current;
    }
  },
  FixedSizeListIterator: {
    "^": "Object;_array,_length,_position,_current",
    moveNext$0: function() {
      var nextPosition, t1;
      nextPosition = this._position + 1;
      t1 = this._length;
      if (nextPosition < t1) {
        this._current = J.$index$asx(this._array, nextPosition);
        this._position = nextPosition;
        return true;
      }
      this._current = null;
      this._position = t1;
      return false;
    },
    get$current: function() {
      return this._current;
    }
  },
  _DOMWindowCrossFrame: {
    "^": "Object;_window",
    get$parent: function(_) {
      return W._DOMWindowCrossFrame__createSafe(this._window.parent);
    },
    get$top: function(_) {
      return W._DOMWindowCrossFrame__createSafe(this._window.top);
    },
    get$on: function(_) {
      return H.throwExpression(P.UnsupportedError$("You can only attach EventListeners to your own window."));
    },
    on$2: function($receiver, arg0, arg1) {
      return this.get$on(this).call$2(arg0, arg1);
    },
    addEventListener$3: function(_, type, listener, useCapture) {
      return H.throwExpression(P.UnsupportedError$("You can only attach EventListeners to your own window."));
    },
    addEventListener$2: function($receiver, type, listener) {
      return this.addEventListener$3($receiver, type, listener, null);
    },
    dispatchEvent$1: function(_, $event) {
      return H.throwExpression(P.UnsupportedError$("You can only attach EventListeners to your own window."));
    },
    removeEventListener$3: function(_, type, listener, useCapture) {
      return H.throwExpression(P.UnsupportedError$("You can only attach EventListeners to your own window."));
    },
    removeEventListener$2: function($receiver, type, listener) {
      return this.removeEventListener$3($receiver, type, listener, null);
    },
    $isEventTarget: true,
    static: {_DOMWindowCrossFrame__createSafe: function(w) {
        if (w === window)
          return w;
        else
          return new W._DOMWindowCrossFrame(w);
      }}
  }
}],
["dart.dom.indexed_db", "dart:indexed_db", , P, {
  "^": "",
  KeyRange: {
    "^": "Interceptor;",
    $isKeyRange: true,
    "%": "IDBKeyRange"
  }
}],
["dart.dom.svg", "dart:svg", , P, {
  "^": "",
  AElement: {
    "^": "GraphicsElement;target=",
    "%": "SVGAElement"
  },
  AltGlyphElement: {
    "^": "TextPositioningElement;format%",
    "%": "SVGAltGlyphElement"
  },
  CircleElement: {
    "^": "GeometryElement;r=",
    "%": "SVGCircleElement"
  },
  FEBlendElement: {
    "^": "SvgElement;mode=,height=,result=,width=,x=,y=",
    "%": "SVGFEBlendElement"
  },
  FEColorMatrixElement: {
    "^": "SvgElement;type=,values=,height=,result=,width=,x=,y=",
    "%": "SVGFEColorMatrixElement"
  },
  FEComponentTransferElement: {
    "^": "SvgElement;height=,result=,width=,x=,y=",
    "%": "SVGFEComponentTransferElement"
  },
  FECompositeElement: {
    "^": "SvgElement;height=,result=,width=,x=,y=",
    "%": "SVGFECompositeElement"
  },
  FEConvolveMatrixElement: {
    "^": "SvgElement;height=,result=,width=,x=,y=",
    "%": "SVGFEConvolveMatrixElement"
  },
  FEDiffuseLightingElement: {
    "^": "SvgElement;height=,result=,width=,x=,y=",
    "%": "SVGFEDiffuseLightingElement"
  },
  FEDisplacementMapElement: {
    "^": "SvgElement;scale=,height=,result=,width=,x=,y=",
    scale$2: function($receiver, arg0, arg1) {
      return $receiver.scale.call$2(arg0, arg1);
    },
    "%": "SVGFEDisplacementMapElement"
  },
  FEFloodElement: {
    "^": "SvgElement;height=,result=,width=,x=,y=",
    "%": "SVGFEFloodElement"
  },
  FEGaussianBlurElement: {
    "^": "SvgElement;height=,result=,width=,x=,y=",
    "%": "SVGFEGaussianBlurElement"
  },
  FEImageElement: {
    "^": "SvgElement;height=,result=,width=,x=,y=",
    "%": "SVGFEImageElement"
  },
  FEMergeElement: {
    "^": "SvgElement;height=,result=,width=,x=,y=",
    "%": "SVGFEMergeElement"
  },
  FEMorphologyElement: {
    "^": "SvgElement;height=,result=,width=,x=,y=",
    "%": "SVGFEMorphologyElement"
  },
  FEOffsetElement: {
    "^": "SvgElement;dx=,dy=,height=,result=,width=,x=,y=",
    "%": "SVGFEOffsetElement"
  },
  FEPointLightElement: {
    "^": "SvgElement;x=,y=,z=",
    "%": "SVGFEPointLightElement"
  },
  FESpecularLightingElement: {
    "^": "SvgElement;height=,result=,width=,x=,y=",
    "%": "SVGFESpecularLightingElement"
  },
  FESpotLightElement: {
    "^": "SvgElement;x=,y=,z=",
    "%": "SVGFESpotLightElement"
  },
  FETileElement: {
    "^": "SvgElement;height=,result=,width=,x=,y=",
    "%": "SVGFETileElement"
  },
  FETurbulenceElement: {
    "^": "SvgElement;type=,height=,result=,width=,x=,y=",
    "%": "SVGFETurbulenceElement"
  },
  FilterElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFilterElement"
  },
  ForeignObjectElement: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGForeignObjectElement"
  },
  GeometryElement: {
    "^": "GraphicsElement;",
    "%": "SVGEllipseElement|SVGPathElement;SVGGeometryElement"
  },
  GraphicsElement: {
    "^": "SvgElement;",
    transform$6: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5) {
      return $receiver.transform.call$6(arg0, arg1, arg2, arg3, arg4, arg5);
    },
    "%": "SVGClipPathElement|SVGDefsElement|SVGGElement|SVGSwitchElement;SVGGraphicsElement"
  },
  ImageElement0: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGImageElement"
  },
  LineElement: {
    "^": "GeometryElement;x1=,x2=,y1=,y2=",
    "%": "SVGLineElement"
  },
  LinearGradientElement: {
    "^": "_GradientElement;x1=,x2=,y1=,y2=",
    "%": "SVGLinearGradientElement"
  },
  MaskElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGMaskElement"
  },
  PatternElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGPatternElement"
  },
  PointList: {
    "^": "Interceptor;length=",
    clear$0: function(receiver) {
      return receiver.clear();
    },
    "%": "SVGPointList"
  },
  PolygonElement: {
    "^": "GeometryElement;points=",
    "%": "SVGPolygonElement"
  },
  PolylineElement: {
    "^": "GeometryElement;points=",
    "%": "SVGPolylineElement"
  },
  RadialGradientElement: {
    "^": "_GradientElement;r=",
    "%": "SVGRadialGradientElement"
  },
  Rect: {
    "^": "Interceptor;height%,width%,x%,y%",
    "%": "SVGRect"
  },
  RectElement: {
    "^": "GeometryElement;height=,width=,x=,y=",
    "%": "SVGRectElement"
  },
  ScriptElement0: {
    "^": "SvgElement;type%",
    "%": "SVGScriptElement"
  },
  StyleElement0: {
    "^": "SvgElement;disabled%,type%",
    "%": "SVGStyleElement"
  },
  SvgElement: {
    "^": "Element;",
    get$children: function(receiver) {
      return H.setRuntimeTypeInfo(new P.FilteredElementList(receiver, new W._ChildNodeListLazy(receiver)), [W.Element]);
    },
    set$children: function(receiver, value) {
      var children = H.setRuntimeTypeInfo(new P.FilteredElementList(receiver, new W._ChildNodeListLazy(receiver)), [W.Element]);
      J._clearChildren$0$x(children._childNodes._this);
      children.addAll$1(0, value);
    },
    click$0: [function(receiver) {
      throw H.wrapException(P.UnsupportedError$("Cannot invoke click SVG."));
    }, "call$0", "get$click", 0, 0, 17],
    get$onBlur: function(receiver) {
      return C.EventStreamProvider_blur.forElement$1(receiver);
    },
    get$onDragStart: function(receiver) {
      return C.EventStreamProvider_dragstart.forElement$1(receiver);
    },
    get$onError: function(receiver) {
      return C.EventStreamProvider_error.forElement$1(receiver);
    },
    onError$0: function($receiver) {
      return this.get$onError($receiver).call$0();
    },
    get$onFocus: function(receiver) {
      return C.EventStreamProvider_focus.forElement$1(receiver);
    },
    get$onLoad: function(receiver) {
      return C.EventStreamProvider_load.forElement$1(receiver);
    },
    get$onMouseDown: function(receiver) {
      return C.EventStreamProvider_mousedown.forElement$1(receiver);
    },
    onMouseDown$1: function($receiver, arg0) {
      return this.get$onMouseDown($receiver).call$1(arg0);
    },
    get$onMouseMove: function(receiver) {
      return C.EventStreamProvider_mousemove.forElement$1(receiver);
    },
    onMouseMove$1: function($receiver, arg0) {
      return this.get$onMouseMove($receiver).call$1(arg0);
    },
    get$onMouseOut: function(receiver) {
      return C.EventStreamProvider_mouseout.forElement$1(receiver);
    },
    onMouseOut$1: function($receiver, arg0) {
      return this.get$onMouseOut($receiver).call$1(arg0);
    },
    get$onMouseOver: function(receiver) {
      return C.EventStreamProvider_mouseover.forElement$1(receiver);
    },
    onMouseOver$1: function($receiver, arg0) {
      return this.get$onMouseOver($receiver).call$1(arg0);
    },
    get$onMouseUp: function(receiver) {
      return C.EventStreamProvider_mouseup.forElement$1(receiver);
    },
    onMouseUp$1: function($receiver, arg0) {
      return this.get$onMouseUp($receiver).call$1(arg0);
    },
    get$onMouseWheel: function(receiver) {
      return C.EventStreamProvider_mousewheel.forElement$1(receiver);
    },
    onMouseWheel$1: function($receiver, arg0) {
      return this.get$onMouseWheel($receiver).call$1(arg0);
    },
    get$onPause: function(receiver) {
      return C.EventStreamProvider_pause.forElement$1(receiver);
    },
    get$onPlay: function(receiver) {
      return C.EventStreamProvider_play.forElement$1(receiver);
    },
    get$onResize: function(receiver) {
      return C.EventStreamProvider_resize.forElement$1(receiver);
    },
    onResize$2: function($receiver, arg0, arg1) {
      return this.get$onResize($receiver).call$2(arg0, arg1);
    },
    $isEventTarget: true,
    "%": "SVGAltGlyphDefElement|SVGAltGlyphItemElement|SVGAnimateElement|SVGAnimateMotionElement|SVGAnimateTransformElement|SVGAnimationElement|SVGComponentTransferFunctionElement|SVGCursorElement|SVGDescElement|SVGDiscardElement|SVGFEDistantLightElement|SVGFEDropShadowElement|SVGFEFuncAElement|SVGFEFuncBElement|SVGFEFuncGElement|SVGFEFuncRElement|SVGFEMergeNodeElement|SVGFontElement|SVGFontFaceElement|SVGFontFaceFormatElement|SVGFontFaceNameElement|SVGFontFaceSrcElement|SVGFontFaceUriElement|SVGGlyphElement|SVGGlyphRefElement|SVGHKernElement|SVGMPathElement|SVGMarkerElement|SVGMetadataElement|SVGMissingGlyphElement|SVGSetElement|SVGStopElement|SVGSymbolElement|SVGTitleElement|SVGVKernElement|SVGViewElement;SVGElement"
  },
  SvgSvgElement: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    viewport$4: function($receiver, arg0, arg1, arg2, arg3) {
      return $receiver.viewport.call$4(arg0, arg1, arg2, arg3);
    },
    "%": "SVGSVGElement"
  },
  TextContentElement: {
    "^": "GraphicsElement;",
    "%": "SVGTextPathElement;SVGTextContentElement"
  },
  TextPositioningElement: {
    "^": "TextContentElement;dx=,dy=,rotate=,x=,y=",
    rotate$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return $receiver.rotate.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    "%": "SVGTSpanElement|SVGTextElement;SVGTextPositioningElement"
  },
  UseElement: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGUseElement"
  },
  _GradientElement: {
    "^": "SvgElement;",
    "%": ";SVGGradientElement"
  }
}],
["dart.dom.web_audio", "dart:web_audio", , P, {
  "^": "",
  AudioBuffer: {
    "^": "Interceptor;duration=,length=",
    $isAudioBuffer: true,
    "%": "AudioBuffer"
  },
  AudioBufferSourceNode: {
    "^": "AudioSourceNode;buffer%,loop%",
    start$3: [function(receiver, when, grainOffset, grainDuration) {
      if (!!receiver.start)
        if (grainDuration != null)
          receiver.start(when, grainOffset, grainDuration);
        else if (grainOffset != null)
          receiver.start(when, grainOffset);
        else
          receiver.start(when);
      else if (grainDuration != null)
        receiver.noteOn(when, grainOffset, grainDuration);
      else if (grainOffset != null)
        receiver.noteOn(when, grainOffset);
      else
        receiver.noteOn(when);
    }, function($receiver, when) {
      return this.start$3($receiver, when, null, null);
    }, "start$1", function($receiver, when, grainOffset) {
      return this.start$3($receiver, when, grainOffset, null);
    }, "start$2", "call$3", "call$1", "call$2", "get$start", 2, 4, 27, 12, 12, 28, [], 29, [], 30, []],
    stop$1: [function(receiver, when) {
      if (!!receiver.stop)
        receiver.stop(when);
      else
        receiver.noteOff(when);
    }, "call$1", "get$stop", 2, 0, 6],
    loop$0: function($receiver) {
      return $receiver.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return $receiver.loop.call$3(arg0, arg1, arg2);
    },
    "%": "AudioBufferSourceNode"
  },
  AudioContext: {
    "^": "EventTarget;currentTime=,destination=",
    createBuffer$3: function(receiver, numberOfChannels, numberOfFrames, sampleRate) {
      return receiver.createBuffer(numberOfChannels, numberOfFrames, sampleRate);
    },
    createBufferSource$0: function(receiver) {
      return receiver.createBufferSource();
    },
    _decodeAudioData$3: function(receiver, audioData, successCallback, errorCallback) {
      return receiver.decodeAudioData(audioData, H.convertDartClosureToJS(successCallback, 1), H.convertDartClosureToJS(errorCallback, 1));
    },
    get$onComplete: function(receiver) {
      return C.EventStreamProvider_complete.forTarget$1(receiver);
    },
    createGain$0: function(receiver) {
      if (receiver.createGain !== undefined)
        return receiver.createGain();
      else
        return receiver.createGainNode();
    },
    decodeAudioData$1: function(receiver, audioData) {
      var t1, completer;
      t1 = P.AudioBuffer;
      completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [t1])), [t1]);
      this._decodeAudioData$3(receiver, audioData, new P.AudioContext_decodeAudioData_closure(completer), new P.AudioContext_decodeAudioData_closure0(completer));
      return completer.future;
    },
    "%": "AudioContext|OfflineAudioContext|webkitAudioContext"
  },
  AudioNode: {
    "^": "EventTarget;context=",
    connectNode$3: function(receiver, destination, output, input) {
      return receiver.connect(destination, output, input);
    },
    connectNode$1: function($receiver, destination) {
      return this.connectNode$3($receiver, destination, 0, 0);
    },
    "%": "AudioDestinationNode;AudioNode"
  },
  AudioParam: {
    "^": "Interceptor;defaultValue=,value%",
    "%": "AudioParam"
  },
  AudioSourceNode: {
    "^": "AudioNode;",
    "%": ";AudioSourceNode"
  },
  GainNode: {
    "^": "AudioNode;gain=",
    "%": "AudioGainNode|GainNode"
  },
  AudioContext_decodeAudioData_closure: {
    "^": "Closure:102;completer_0",
    call$1: [function(value) {
      this.completer_0.complete$1(0, value);
    }, "call$1", null, 2, 0, null, 138, [], "call"]
  },
  AudioContext_decodeAudioData_closure0: {
    "^": "Closure:102;completer_1",
    call$1: [function(error) {
      var t1 = this.completer_1;
      if (error == null)
        t1.completeError$1("");
      else
        t1.completeError$1(error);
    }, "call$1", null, 2, 0, null, 598, [], "call"]
  }
}],
["dart.dom.web_gl", "dart:web_gl", , P, {
  "^": "",
  ContextEvent: {
    "^": "Event;",
    $isContextEvent: true,
    "%": "WebGLContextEvent"
  },
  RenderingContext: {
    "^": "Interceptor;canvas=",
    activeTexture$1: function(receiver, texture) {
      return receiver.activeTexture(texture);
    },
    attachShader$2: function(receiver, program, shader) {
      return receiver.attachShader(program, shader);
    },
    bindBuffer$2: function(receiver, target, buffer) {
      return receiver.bindBuffer(target, buffer);
    },
    bindFramebuffer$2: function(receiver, target, framebuffer) {
      return receiver.bindFramebuffer(target, framebuffer);
    },
    bindRenderbuffer$2: function(receiver, target, renderbuffer) {
      return receiver.bindRenderbuffer(target, renderbuffer);
    },
    bindTexture$2: function(receiver, target, texture) {
      return receiver.bindTexture(target, texture);
    },
    blendFunc$2: function(receiver, sfactor, dfactor) {
      return receiver.blendFunc(sfactor, dfactor);
    },
    bufferData$3: function(receiver, target, data_OR_size, usage) {
      return receiver.bufferData(target, data_OR_size, usage);
    },
    bufferSubData$3: function(receiver, target, offset, data) {
      return receiver.bufferSubData(target, offset, data);
    },
    clear$1: function(receiver, mask) {
      return receiver.clear(mask);
    },
    clearColor$4: function(receiver, red, green, blue, alpha) {
      return receiver.clearColor(red, green, blue, alpha);
    },
    colorMask$4: function(receiver, red, green, blue, alpha) {
      return receiver.colorMask(red, green, blue, alpha);
    },
    compileShader$1: function(receiver, shader) {
      return receiver.compileShader(shader);
    },
    createBuffer$0: function(receiver) {
      return receiver.createBuffer();
    },
    createFramebuffer$0: function(receiver) {
      return receiver.createFramebuffer();
    },
    createProgram$0: function(receiver) {
      return receiver.createProgram();
    },
    createRenderbuffer$0: function(receiver) {
      return receiver.createRenderbuffer();
    },
    createShader$1: function(receiver, type) {
      return receiver.createShader(type);
    },
    createTexture$0: function(receiver) {
      return receiver.createTexture();
    },
    deleteBuffer$1: function(receiver, buffer) {
      return receiver.deleteBuffer(buffer);
    },
    deleteFramebuffer$1: function(receiver, framebuffer) {
      return receiver.deleteFramebuffer(framebuffer);
    },
    deleteProgram$1: function(receiver, program) {
      return receiver.deleteProgram(program);
    },
    deleteTexture$1: function(receiver, texture) {
      return receiver.deleteTexture(texture);
    },
    disable$1: function(receiver, cap) {
      return receiver.disable(cap);
    },
    disableVertexAttribArray$1: function(receiver, index) {
      return receiver.disableVertexAttribArray(index);
    },
    drawElements$4: function(receiver, mode, count, type, offset) {
      return receiver.drawElements(mode, count, type, offset);
    },
    enable$1: function(receiver, cap) {
      return receiver.enable(cap);
    },
    enableVertexAttribArray$1: function(receiver, index) {
      return receiver.enableVertexAttribArray(index);
    },
    flush$0: function(receiver) {
      return receiver.flush();
    },
    framebufferRenderbuffer$4: function(receiver, target, attachment, renderbuffertarget, renderbuffer) {
      return receiver.framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    },
    framebufferTexture2D$5: function(receiver, target, attachment, textarget, texture, level) {
      return receiver.framebufferTexture2D(target, attachment, textarget, texture, level);
    },
    getAttribLocation$2: function(receiver, program, $name) {
      return receiver.getAttribLocation(program, $name);
    },
    getProgramParameter$2: function(receiver, program, pname) {
      return receiver.getProgramParameter(program, pname);
    },
    getShaderInfoLog$1: function(receiver, shader) {
      return receiver.getShaderInfoLog(shader);
    },
    getShaderParameter$2: function(receiver, shader, pname) {
      return receiver.getShaderParameter(shader, pname);
    },
    getUniformLocation$2: function(receiver, program, $name) {
      return receiver.getUniformLocation(program, $name);
    },
    lineWidth$1: [function(receiver, width) {
      return receiver.lineWidth(width);
    }, "call$1", "get$lineWidth", 2, 0, 6, 31, []],
    linkProgram$1: function(receiver, program) {
      return receiver.linkProgram(program);
    },
    pixelStorei$2: function(receiver, pname, param) {
      return receiver.pixelStorei(pname, param);
    },
    renderbufferStorage$4: function(receiver, target, internalformat, width, height) {
      return receiver.renderbufferStorage(target, internalformat, width, height);
    },
    shaderSource$2: function(receiver, shader, string) {
      return receiver.shaderSource(shader, string);
    },
    stencilFunc$3: function(receiver, func, ref, mask) {
      return receiver.stencilFunc(func, ref, mask);
    },
    stencilOp$3: function(receiver, fail, zfail, zpass) {
      return receiver.stencilOp(fail, zfail, zpass);
    },
    texImage2D$9: function(receiver, target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels) {
      var t1 = J.getInterceptor(border_OR_canvas_OR_image_OR_pixels_OR_video);
      if ((!!t1.$isImageData || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && format == null && type == null && true) {
        receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, P.convertDartToNative_ImageData(border_OR_canvas_OR_image_OR_pixels_OR_video));
        return;
      }
      if (!!t1.$isImageElement && format == null && type == null && true) {
        receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
        return;
      }
      if (!!t1.$isCanvasElement && format == null && type == null && true) {
        receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
        return;
      }
      if (!!t1.$isVideoElement && format == null && type == null && true) {
        receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
        return;
      }
      throw H.wrapException(P.ArgumentError$("Incorrect number or type of arguments"));
    },
    texImage2D$6: function($receiver, target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video) {
      return this.texImage2D$9($receiver, target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, null, null, null);
    },
    texParameteri$3: function(receiver, target, pname, param) {
      return receiver.texParameteri(target, pname, param);
    },
    uniform1f$2: [function(receiver, $location, x) {
      return receiver.uniform1f($location, x);
    }, "call$2", "get$uniform1f", 4, 0, 32, 33, [], 9, []],
    uniform1i$2: [function(receiver, $location, x) {
      return receiver.uniform1i($location, x);
    }, "call$2", "get$uniform1i", 4, 0, 34, 33, [], 9, []],
    uniform2f$3: [function(receiver, $location, x, y) {
      return receiver.uniform2f($location, x, y);
    }, "call$3", "get$uniform2f", 6, 0, 35, 33, [], 9, [], 10, []],
    uniform2fv$2: [function(receiver, $location, v) {
      return receiver.uniform2fv($location, v);
    }, "call$2", "get$uniform2fv", 4, 0, 36, 33, [], 37, []],
    uniform2i$3: [function(receiver, $location, x, y) {
      return receiver.uniform2i($location, x, y);
    }, "call$3", "get$uniform2i", 6, 0, 38, 33, [], 9, [], 10, []],
    uniform3f$4: [function(receiver, $location, x, y, z) {
      return receiver.uniform3f($location, x, y, z);
    }, "call$4", "get$uniform3f", 8, 0, 39, 33, [], 9, [], 10, [], 40, []],
    uniform3fv$2: [function(receiver, $location, v) {
      return receiver.uniform3fv($location, v);
    }, "call$2", "get$uniform3fv", 4, 0, 36, 33, [], 37, []],
    uniform3i$4: [function(receiver, $location, x, y, z) {
      return receiver.uniform3i($location, x, y, z);
    }, "call$4", "get$uniform3i", 8, 0, 41, 33, [], 9, [], 10, [], 40, []],
    uniform4f$5: [function(receiver, $location, x, y, z, w) {
      return receiver.uniform4f($location, x, y, z, w);
    }, "call$5", "get$uniform4f", 10, 0, 42, 33, [], 9, [], 10, [], 40, [], 43, []],
    uniform4fv$2: [function(receiver, $location, v) {
      return receiver.uniform4fv($location, v);
    }, "call$2", "get$uniform4fv", 4, 0, 36, 33, [], 37, []],
    uniform4i$5: [function(receiver, $location, x, y, z, w) {
      return receiver.uniform4i($location, x, y, z, w);
    }, "call$5", "get$uniform4i", 10, 0, 44, 33, [], 9, [], 10, [], 40, [], 43, []],
    uniformMatrix2fv$3: [function(receiver, $location, transpose, array) {
      return receiver.uniformMatrix2fv($location, transpose, array);
    }, "call$3", "get$uniformMatrix2fv", 6, 0, 45, 33, [], 46, [], 47, []],
    uniformMatrix3fv$3: [function(receiver, $location, transpose, array) {
      return receiver.uniformMatrix3fv($location, transpose, array);
    }, "call$3", "get$uniformMatrix3fv", 6, 0, 45, 33, [], 46, [], 47, []],
    uniformMatrix4fv$3: [function(receiver, $location, transpose, array) {
      return receiver.uniformMatrix4fv($location, transpose, array);
    }, "call$3", "get$uniformMatrix4fv", 6, 0, 45, 33, [], 46, [], 47, []],
    useProgram$1: function(receiver, program) {
      return receiver.useProgram(program);
    },
    vertexAttribPointer$6: function(receiver, indx, size, type, normalized, stride, offset) {
      return receiver.vertexAttribPointer(indx, size, type, normalized, stride, offset);
    },
    viewport$4: function(receiver, x, y, width, height) {
      return receiver.viewport(x, y, width, height);
    },
    texImage2DTyped$9: function(receiver, targetTexture, levelOfDetail, internalFormat, width, height, border, format, type, data) {
      return receiver.texImage2D(targetTexture, levelOfDetail, internalFormat, width, height, border, format, type, data);
    },
    $isRenderingContext: true,
    "%": "WebGLRenderingContext"
  },
  UniformLocation: {
    "^": "Interceptor;",
    "%": "WebGLUniformLocation"
  }
}],
["dart.isolate", "dart:isolate", , P, {
  "^": "",
  Capability: {
    "^": "Object;",
    $isCapability: true
  }
}],
["dart.js", "dart:js", , P, {
  "^": "",
  _callDartFunction: [function(callback, captureThis, $self, $arguments) {
    var arguments0;
    if (captureThis === true) {
      arguments0 = [$self];
      C.JSArray_methods.addAll$1(arguments0, $arguments);
      $arguments = arguments0;
    }
    return P._convertToJS(H.Primitives_applyFunction(callback, P.List_List$from(J.map$1$ax($arguments, P._convertToDart$closure()), true, null), P.Function__toMangledNames(null)));
  }, "call$4", "_callDartFunction$closure", 8, 0, null, 26, [], 605, [], 606, [], 607, []],
  _defineProperty: function(o, $name, value) {
    var exception;
    if (Object.isExtensible(o) && !Object.prototype.hasOwnProperty.call(o, $name))
      try {
        Object.defineProperty(o, $name, {value: value});
        return true;
      } catch (exception) {
        H.unwrapException(exception);
      }

    return false;
  },
  _getOwnProperty: function(o, $name) {
    if (Object.prototype.hasOwnProperty.call(o, $name))
      return o[$name];
    return;
  },
  _convertToJS: [function(o) {
    var t1;
    if (o == null || typeof o === "string" || typeof o === "number" || typeof o === "boolean")
      return o;
    else {
      t1 = J.getInterceptor(o);
      if (!!t1.$isBlob || !!t1.$isEvent || !!t1.$isKeyRange || !!t1.$isImageData || !!t1.$isNode0 || !!t1.$isTypedData || !!t1.$isWindow)
        return o;
      else if (!!t1.$isDateTime)
        return H.Primitives_lazyAsJsDate(o);
      else if (!!t1.$isJsObject)
        return o._js$_jsObject;
      else if (!!t1.$isFunction)
        return P._getJsProxy(o, "$dart_jsFunction", new P._convertToJS_closure());
      else
        return P._getJsProxy(o, "_$dart_jsObject", new P._convertToJS_closure0($.get$_dartProxyCtor()));
    }
  }, "call$1", "_convertToJS$closure", 2, 0, 102, 608, []],
  _getJsProxy: function(o, propertyName, createProxy) {
    var jsProxy = P._getOwnProperty(o, propertyName);
    if (jsProxy == null) {
      jsProxy = createProxy.call$1(o);
      P._defineProperty(o, propertyName, jsProxy);
    }
    return jsProxy;
  },
  _convertToDart: [function(o) {
    var t1;
    if (o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean")
      return o;
    else {
      if (o instanceof Object) {
        t1 = J.getInterceptor(o);
        t1 = !!t1.$isBlob || !!t1.$isEvent || !!t1.$isKeyRange || !!t1.$isImageData || !!t1.$isNode0 || !!t1.$isTypedData || !!t1.$isWindow;
      } else
        t1 = false;
      if (t1)
        return o;
      else if (o instanceof Date)
        return P.DateTime$fromMillisecondsSinceEpoch(o.getTime(), false);
      else if (o.constructor === $.get$_dartProxyCtor())
        return o.o;
      else
        return P._wrapToDart(o);
    }
  }, "call$1", "_convertToDart$closure", 2, 0, 609, 608, []],
  _wrapToDart: function(o) {
    if (typeof o == "function")
      return P._getDartProxy(o, $.get$_DART_CLOSURE_PROPERTY_NAME(), new P._wrapToDart_closure());
    else if (o instanceof Array)
      return P._getDartProxy(o, $.get$_DART_OBJECT_PROPERTY_NAME(), new P._wrapToDart_closure0());
    else
      return P._getDartProxy(o, $.get$_DART_OBJECT_PROPERTY_NAME(), new P._wrapToDart_closure1());
  },
  _getDartProxy: function(o, propertyName, createProxy) {
    var dartProxy = P._getOwnProperty(o, propertyName);
    if (dartProxy == null || !(o instanceof Object)) {
      dartProxy = createProxy.call$1(o);
      P._defineProperty(o, propertyName, dartProxy);
    }
    return dartProxy;
  },
  JsObject: {
    "^": "Object;_js$_jsObject",
    $index: function(_, property) {
      if (typeof property !== "string" && typeof property !== "number")
        throw H.wrapException(P.ArgumentError$("property is not a String or num"));
      return P._convertToDart(this._js$_jsObject[property]);
    },
    $indexSet: function(_, property, value) {
      if (typeof property !== "string" && typeof property !== "number")
        throw H.wrapException(P.ArgumentError$("property is not a String or num"));
      this._js$_jsObject[property] = P._convertToJS(value);
    },
    get$hashCode: function(_) {
      return 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isJsObject && this._js$_jsObject === other._js$_jsObject;
    },
    toString$0: function(_) {
      var t1, exception;
      try {
        t1 = String(this._js$_jsObject);
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
        return P.Object.prototype.toString$0.call(this, this);
      }

    },
    callMethod$2: function(method, args) {
      var t1, t2;
      t1 = this._js$_jsObject;
      t2 = args == null ? null : P.List_List$from(J.map$1$ax(args, P._convertToJS$closure()), true, null);
      return P._convertToDart(t1[method].apply(t1, t2));
    },
    callMethod$1: function(method) {
      return this.callMethod$2(method, null);
    },
    $isJsObject: true,
    static: {JsObject_JsObject$fromBrowserObject: function(object) {
        if (typeof object === "number" || typeof object === "string" || typeof object === "boolean" || object == null)
          throw H.wrapException(P.ArgumentError$("object cannot be a num, string, bool, or null"));
        return P._wrapToDart(P._convertToJS(object));
      }}
  },
  JsFunction: {
    "^": "JsObject;_js$_jsObject",
    apply$2$thisArg: function(args, thisArg) {
      var t1, t2;
      t1 = P._convertToJS(thisArg);
      t2 = args == null ? null : P.List_List$from(J.map$1$ax(args, P._convertToJS$closure()), true, null);
      return P._convertToDart(this._js$_jsObject.apply(t1, t2));
    },
    apply$1: function(args) {
      return this.apply$2$thisArg(args, null);
    }
  },
  JsArray: {
    "^": "JsObject_ListMixin;_js$_jsObject",
    _js$_checkIndex$1: function(_, index) {
      var t1;
      if (typeof index === "number" && Math.floor(index) === index)
        t1 = index < 0 || index >= this.get$length(this);
      else
        t1 = false;
      if (t1)
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this), null, null));
    },
    $index: function(_, index) {
      var t1;
      if (typeof index === "number" && index === C.JSNumber_methods.toInt$0(index)) {
        if (typeof index === "number" && Math.floor(index) === index)
          t1 = index < 0 || index >= this.get$length(this);
        else
          t1 = false;
        if (t1)
          H.throwExpression(P.RangeError$range(index, 0, this.get$length(this), null, null));
      }
      return P.JsObject.prototype.$index.call(this, this, index);
    },
    $indexSet: function(_, index, value) {
      var t1;
      if (typeof index === "number" && index === C.JSNumber_methods.toInt$0(index)) {
        if (typeof index === "number" && Math.floor(index) === index)
          t1 = index < 0 || index >= this.get$length(this);
        else
          t1 = false;
        if (t1)
          H.throwExpression(P.RangeError$range(index, 0, this.get$length(this), null, null));
      }
      P.JsObject.prototype.$indexSet.call(this, this, index, value);
    },
    get$length: function(_) {
      var len = this._js$_jsObject.length;
      if (typeof len === "number" && len >>> 0 === len)
        return len;
      throw H.wrapException(P.StateError$("Bad JsArray length"));
    },
    set$length: function(_, $length) {
      P.JsObject.prototype.$indexSet.call(this, this, "length", $length);
    },
    add$1: [function(_, value) {
      this.callMethod$2("push", [value]);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E7", void: true, args: [E]};
      }, this.$receiver, "JsArray");
    }, 138, []],
    addAll$1: function(_, iterable) {
      this.callMethod$2("push", iterable instanceof Array ? iterable : P.List_List$from(iterable, true, null));
    },
    insert$2: function(_, index, element) {
      var t1;
      if (typeof index === "number" && Math.floor(index) === index)
        t1 = index < 0 || index >= this.get$length(this) + 1;
      else
        t1 = false;
      if (t1)
        H.throwExpression(P.RangeError$range(index, 0, this.get$length(this), null, null));
      this.callMethod$2("splice", [index, 0, element]);
    },
    removeAt$1: function(_, index) {
      this._js$_checkIndex$1(0, index);
      return J.$index$asx(this.callMethod$2("splice", [index, 1]), 0);
    },
    removeLast$0: function(_) {
      if (this.get$length(this) === 0)
        throw H.wrapException(P.RangeError$(-1));
      return this.callMethod$1("pop");
    },
    removeRange$2: function(_, start, end) {
      P.JsArray__checkRange(start, end, this.get$length(this));
      this.callMethod$2("splice", [start, J.$sub$n(end, start)]);
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      var $length, args;
      P.JsArray__checkRange(start, end, this.get$length(this));
      $length = J.$sub$n(end, start);
      if (J.$eq($length, 0))
        return;
      if (J.$lt$n(skipCount, 0))
        throw H.wrapException(P.ArgumentError$(skipCount));
      args = [start, $length];
      C.JSArray_methods.addAll$1(args, H.SubListIterable$(iterable, skipCount, null, H.getRuntimeTypeArgument(iterable, "ListMixin", 0)).take$1(0, $length));
      this.callMethod$2("splice", args);
    },
    sort$1: function(_, compare) {
      this.callMethod$2("sort", compare == null ? [] : [compare]);
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    static: {JsArray__checkRange: function(start, end, $length) {
        var t1 = J.getInterceptor$n(start);
        if (t1.$lt(start, 0) || t1.$gt(start, $length))
          throw H.wrapException(P.RangeError$range(start, 0, $length, null, null));
        t1 = J.getInterceptor$n(end);
        if (t1.$lt(end, start) || t1.$gt(end, $length))
          throw H.wrapException(P.RangeError$range(end, start, $length, null, null));
      }}
  },
  JsObject_ListMixin: {
    "^": "JsObject+ListMixin;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  _convertToJS_closure: {
    "^": "Closure:102;",
    call$1: function(o) {
      var jsFunction = function(_call, f, captureThis) {
        return function() {
          return _call(f, captureThis, this, Array.prototype.slice.apply(arguments));
        };
      }(P._callDartFunction, o, false);
      P._defineProperty(jsFunction, $.get$_DART_CLOSURE_PROPERTY_NAME(), o);
      return jsFunction;
    }
  },
  _convertToJS_closure0: {
    "^": "Closure:102;ctor_0",
    call$1: function(o) {
      return new this.ctor_0(o);
    }
  },
  _wrapToDart_closure: {
    "^": "Closure:102;",
    call$1: function(o) {
      return new P.JsFunction(o);
    }
  },
  _wrapToDart_closure0: {
    "^": "Closure:102;",
    call$1: function(o) {
      return H.setRuntimeTypeInfo(new P.JsArray(o), [null]);
    }
  },
  _wrapToDart_closure1: {
    "^": "Closure:102;",
    call$1: function(o) {
      return new P.JsObject(o);
    }
  },
  "^": "context<"
}],
["dart.math", "dart:math", , P, {
  "^": "",
  _JenkinsSmiHash_combine0: function(hash, value) {
    hash = 536870911 & hash + value;
    hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
    return hash ^ hash >>> 6;
  },
  _JenkinsSmiHash_finish0: function(hash) {
    hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
    hash ^= hash >>> 11;
    return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
  },
  min: function(a, b) {
    if (typeof a !== "number")
      throw H.wrapException(P.ArgumentError$(a));
    if (typeof b !== "number")
      throw H.wrapException(P.ArgumentError$(b));
    if (a > b)
      return b;
    if (a < b)
      return a;
    if (typeof b === "number") {
      if (typeof a === "number")
        if (a === 0)
          return (a + b) * a * b;
      if (a === 0 && C.JSDouble_methods.get$isNegative(b) || C.JSDouble_methods.get$isNaN(b))
        return b;
      return a;
    }
    return a;
  },
  max: function(a, b) {
    if (typeof a !== "number")
      throw H.wrapException(P.ArgumentError$(a));
    if (typeof b !== "number")
      throw H.wrapException(P.ArgumentError$(b));
    if (a > b)
      return a;
    if (a < b)
      return b;
    if (typeof b === "number") {
      if (typeof a === "number")
        if (a === 0)
          return a + b;
      if (C.JSDouble_methods.get$isNaN(b))
        return b;
      return a;
    }
    if (b === 0 && C.JSNumber_methods.get$isNegative(a))
      return b;
    return a;
  },
  _JSRandom: {
    "^": "Object;",
    nextInt$1: function(max) {
      var t1 = J.getInterceptor$n(max);
      if (t1.$le(max, 0) || t1.$gt(max, 4294967296))
        throw H.wrapException(P.RangeError$("max must be in range 0 < max \u2264 2^32, was " + H.S(max)));
      return Math.random() * max >>> 0;
    },
    nextDouble$0: [function() {
      return Math.random();
    }, "call$0", "get$nextDouble", 0, 0, 21]
  },
  Point1: {
    "^": "Object;x>,y>",
    toString$0: function(_) {
      return "Point(" + H.S(this.x) + ", " + H.S(this.y) + ")";
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isPoint1)
        return false;
      t1 = this.x;
      t2 = other.x;
      if (t1 == null ? t2 == null : t1 === t2) {
        t1 = this.y;
        t2 = other.y;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1, t2;
      t1 = J.get$hashCode$(this.x);
      t2 = J.get$hashCode$(this.y);
      return P._JenkinsSmiHash_finish0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(0, t1), t2));
    },
    $add: function(_, other) {
      var t1, t2, t3, t4;
      t1 = this.x;
      t2 = J.getInterceptor$x(other);
      t3 = t2.get$x(other);
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = this.y;
      t2 = t2.get$y(other);
      if (typeof t4 !== "number")
        return t4.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = new P.Point1(t1 + t3, t4 + t2);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      return t2;
    },
    $sub: function(_, other) {
      var t1, t2, t3, t4;
      t1 = this.x;
      t2 = J.getInterceptor$x(other);
      t3 = t2.get$x(other);
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = this.y;
      t2 = t2.get$y(other);
      if (typeof t4 !== "number")
        return t4.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = new P.Point1(t1 - t3, t4 - t2);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      return t2;
    },
    $mul: function(_, factor) {
      var t1, t2;
      t1 = this.x;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof factor !== "number")
        return H.iae(factor);
      t2 = this.y;
      if (typeof t2 !== "number")
        return t2.$mul();
      t2 = new P.Point1(t1 * factor, t2 * factor);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      return t2;
    },
    $isPoint1: true
  },
  "+Point": 0,
  _RectangleBase: {
    "^": "Object;",
    get$right: function(_) {
      return this.get$left(this) + this.width;
    },
    get$bottom: function(_) {
      return this.get$top(this) + this.height;
    },
    toString$0: function(_) {
      return "Rectangle (" + this.get$left(this) + ", " + this.top + ") " + this.width + " x " + this.height;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isRectangle)
        return false;
      if (this.get$left(this) === t1.get$left(other)) {
        t2 = this.top;
        t1 = t2 === t1.get$top(other) && this.left + this.width === t1.get$right(other) && t2 + this.height === t1.get$bottom(other);
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1 = this.top;
      return P._JenkinsSmiHash_finish0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(0, this.get$left(this) & 0x1FFFFFFF), t1 & 0x1FFFFFFF), this.left + this.width & 0x1FFFFFFF), t1 + this.height & 0x1FFFFFFF));
    },
    intersects$1: function(_, other) {
      var t1, t2, t3;
      t1 = this.get$left(this);
      t2 = J.getInterceptor$x(other);
      t3 = J.$add$ns(t2.get$left(other), t2.get$width(other));
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (t1 <= t3)
        if (J.$le$n(t2.get$left(other), this.left + this.width)) {
          t1 = this.top;
          t3 = J.$add$ns(t2.get$top(other), t2.get$height(other));
          if (typeof t3 !== "number")
            return H.iae(t3);
          t1 = t1 <= t3 && J.$le$n(t2.get$top(other), t1 + this.height);
        } else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$topLeft: function(_) {
      var t1 = new P.Point1(this.get$left(this), this.top);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$topRight: function(_) {
      var t1 = new P.Point1(this.get$left(this) + this.width, this.top);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$bottomRight: function(_) {
      var t1 = new P.Point1(this.get$left(this) + this.width, this.top + this.height);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$bottomLeft: function(_) {
      var t1 = new P.Point1(this.get$left(this), this.top + this.height);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    }
  },
  Rectangle: {
    "^": "_RectangleBase;left>,top>,width>,height>",
    $isRectangle: true,
    $asRectangle: null,
    static: {Rectangle$: function(left, $top, width, height, $T) {
        var t1, t2;
        t1 = width < 0 ? -width * 0 : width;
        t2 = height < 0 ? -height * 0 : height;
        return H.setRuntimeTypeInfo(new P.Rectangle(left, $top, t1, t2), [$T]);
      }}
  },
  "+Rectangle": 0
}],
["dart.mirrors", "dart:mirrors", , P, {
  "^": "",
  reflectClass: function(key) {
    var t1, tm;
    t1 = J.getInterceptor(key);
    if (!t1.$isType || t1.$eq(key, C.Type_dynamic))
      throw H.wrapException(P.ArgumentError$(H.S(key) + " does not denote a class"));
    tm = P.reflectType(key);
    if (!J.getInterceptor(tm).$isClassMirror)
      throw H.wrapException(P.ArgumentError$(H.S(key) + " does not denote a class"));
    return tm.get$originalDeclaration();
  },
  reflectType: function(key) {
    if (J.$eq(key, C.Type_dynamic)) {
      $.get$currentJsMirrorSystem().toString;
      return $.get$JsMirrorSystem__dynamicType();
    }
    return H.reflectClassByMangledName(key.get$_typeName());
  },
  InstanceMirror: {
    "^": "Object;"
  },
  LibraryMirror: {
    "^": "Object;",
    $isLibraryMirror: true
  },
  TypeMirror: {
    "^": "Object;",
    $isTypeMirror: true
  },
  ClassMirror: {
    "^": "Object;",
    $isClassMirror: true,
    $isTypeMirror: true
  },
  TypeVariableMirror: {
    "^": "TypeMirror;",
    $isTypeVariableMirror: true
  },
  MethodMirror: {
    "^": "Object;",
    $isMethodMirror: true
  },
  ParameterMirror: {
    "^": "Object;",
    $isParameterMirror: true
  },
  MirrorsUsed: {
    "^": "Object;symbols,targets,metaTargets,override<"
  }
}],
["dart.typed_data", "dart:typed_data", , P, {
  "^": "",
  Float32List: {
    "^": "Object;",
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: true
  }
}],
["dart.typed_data.implementation", "dart:_native_typed_data", , H, {
  "^": "",
  NativeByteBuffer: {
    "^": "Interceptor;",
    get$runtimeType: function(receiver) {
      return C.Type_wAg;
    },
    $isNativeByteBuffer: true,
    $isByteBuffer: true,
    "%": "ArrayBuffer"
  },
  NativeTypedData: {
    "^": "Interceptor;buffer=",
    _invalidIndex$2: function(receiver, index, $length) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$ge(index, $length)) {
        if (!!this.$isList)
          if ($length === receiver.length)
            throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        throw H.wrapException(P.RangeError$range(index, 0, $length - 1, null, null));
      } else
        throw H.wrapException(P.ArgumentError$("Invalid list index " + H.S(index)));
    },
    _checkIndex$2: function(receiver, index, $length) {
      if (index >>> 0 !== index || index >= $length)
        this._invalidIndex$2(receiver, index, $length);
    },
    _checkSublistArguments$3: function(receiver, start, end, $length) {
      var t1 = $length + 1;
      this._checkIndex$2(receiver, start, t1);
      if (end == null)
        return $length;
      this._checkIndex$2(receiver, end, t1);
      if (typeof end !== "number")
        return H.iae(end);
      if (start > end)
        throw H.wrapException(P.RangeError$range(start, 0, end, null, null));
      return end;
    },
    $isNativeTypedData: true,
    $isTypedData: true,
    "%": ";ArrayBufferView;NativeTypedArray|NativeTypedArray_ListMixin|NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfDouble|NativeTypedArray_ListMixin0|NativeTypedArray_ListMixin_FixedLengthListMixin0|NativeTypedArrayOfInt"
  },
  NativeByteData: {
    "^": "NativeTypedData;",
    get$runtimeType: function(receiver) {
      return C.Type_oGP;
    },
    $isTypedData: true,
    "%": "DataView"
  },
  NativeFloat32List: {
    "^": "NativeTypedArrayOfDouble;",
    get$runtimeType: function(receiver) {
      return C.Type_Art;
    },
    sublist$2: function(receiver, start, end) {
      return new Float32Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: true,
    "%": "Float32Array"
  },
  NativeFloat64List: {
    "^": "NativeTypedArrayOfDouble;",
    get$runtimeType: function(receiver) {
      return C.Type_ckn;
    },
    sublist$2: function(receiver, start, end) {
      return new Float64Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: true,
    "%": "Float64Array"
  },
  NativeInt16List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_UoK;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Int16Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": "Int16Array"
  },
  NativeInt32List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_dTZ;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Int32Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": "Int32Array"
  },
  NativeInt8List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_mp3;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Int8Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": "Int8Array"
  },
  NativeUint16List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_CAk;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint16Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": "Uint16Array"
  },
  NativeUint32List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_irB;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint32Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": "Uint32Array"
  },
  NativeUint8ClampedList: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_QuW;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint8ClampedArray(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": "CanvasPixelArray|Uint8ClampedArray"
  },
  NativeUint8List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_6L0;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint8Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": ";Uint8Array"
  },
  _checkLength: function($length) {
    if (typeof $length !== "number" || Math.floor($length) !== $length)
      throw H.wrapException(P.ArgumentError$("Invalid length " + H.S($length)));
    return $length;
  },
  _ensureNativeList: function(list) {
    var t1, t2, result, i, t3;
    t1 = J.getInterceptor(list);
    if (!!t1.$isJSIndexable)
      return list;
    t2 = t1.get$length(list);
    if (typeof t2 !== "number")
      return H.iae(t2);
    result = Array(t2);
    result.fixed$length = init;
    t2 = result.length;
    i = 0;
    while (true) {
      t3 = t1.get$length(list);
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (!(i < t3))
        break;
      t3 = t1.$index(list, i);
      if (i >= t2)
        return H.ioore(result, i);
      result[i] = t3;
      ++i;
    }
    return result;
  },
  NativeTypedArray: {
    "^": "NativeTypedData;",
    get$length: function(receiver) {
      return receiver.length;
    },
    _setRangeFast$4: function(receiver, start, end, source, skipCount) {
      var t1, count, sourceLength;
      t1 = receiver.length + 1;
      this._checkIndex$2(receiver, start, t1);
      this._checkIndex$2(receiver, end, t1);
      if (J.$gt$n(start, end))
        throw H.wrapException(P.RangeError$range(start, 0, end, null, null));
      count = J.$sub$n(end, start);
      if (J.$lt$n(skipCount, 0))
        throw H.wrapException(P.ArgumentError$(skipCount));
      sourceLength = source.length;
      if (typeof skipCount !== "number")
        return H.iae(skipCount);
      if (typeof count !== "number")
        return H.iae(count);
      if (sourceLength - skipCount < count)
        throw H.wrapException(P.StateError$("Not enough elements"));
      if (skipCount !== 0 || sourceLength !== count)
        source = source.subarray(skipCount, skipCount + count);
      receiver.set(source, start);
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true
  },
  NativeTypedArrayOfDouble: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfDouble) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      P.ListMixin.prototype.setRange$4.call(this, receiver, start, end, iterable, skipCount);
    },
    $isNativeTypedArrayOfDouble: true
  },
  NativeTypedArray_ListMixin: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: true
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin: {
    "^": "NativeTypedArray_ListMixin+FixedLengthListMixin;"
  },
  NativeTypedArrayOfInt: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin0;",
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfInt) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      P.ListMixin.prototype.setRange$4.call(this, receiver, start, end, iterable, skipCount);
    },
    $isNativeTypedArrayOfInt: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true
  },
  NativeTypedArray_ListMixin0: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin0: {
    "^": "NativeTypedArray_ListMixin0+FixedLengthListMixin;"
  }
}],
["dart2js._js_primitives", "dart:_js_primitives", , H, {
  "^": "",
  printString: function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log != "undefined") {
      console.log(string);
      return;
    }
    if (typeof window == "object")
      return;
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  }
}],
["html_common", "dart:html_common", , P, {
  "^": "",
  convertDartToNative_Dictionary: function(dict) {
    var object;
    if (dict == null)
      return;
    object = {};
    J.forEach$1$ax(dict, new P.convertDartToNative_Dictionary_closure(object));
    return object;
  },
  _convertDartToNative_PrepareForStructuredClone: function(value) {
    var copies, copy;
    copies = [];
    copy = new P._convertDartToNative_PrepareForStructuredClone_walk(new P._convertDartToNative_PrepareForStructuredClone_findSlot([], copies), new P._convertDartToNative_PrepareForStructuredClone_readSlot(copies), new P._convertDartToNative_PrepareForStructuredClone_writeSlot(copies)).call$1(value);
    new P._convertDartToNative_PrepareForStructuredClone_cleanupSlots().call$0();
    return copy;
  },
  convertNativeToDart_AcceptStructuredClone: function(object, mustCopy) {
    var copies = [];
    return new P.convertNativeToDart_AcceptStructuredClone_walk(mustCopy, new P.convertNativeToDart_AcceptStructuredClone_findSlot([], copies), new P.convertNativeToDart_AcceptStructuredClone_readSlot(copies), new P.convertNativeToDart_AcceptStructuredClone_writeSlot(copies)).call$1(object);
  },
  convertNativeToDart_ImageData: function(nativeImageData) {
    var t1, data;
    t1 = J.getInterceptor(nativeImageData);
    if (!!t1.$isImageData) {
      data = t1.get$data(nativeImageData);
      if (data.constructor === Array)
        if (typeof CanvasPixelArray !== "undefined") {
          data.constructor = CanvasPixelArray;
          data.BYTES_PER_ELEMENT = 1;
        }
      return nativeImageData;
    }
    return new P._TypedImageData(nativeImageData.data, nativeImageData.height, nativeImageData.width);
  },
  convertDartToNative_ImageData: function(imageData) {
    if (!!J.getInterceptor(imageData).$is_TypedImageData)
      return {data: imageData.data, height: imageData.height, width: imageData.width};
    return imageData;
  },
  Device_isOpera: function() {
    var t1 = $.Device__isOpera;
    if (t1 == null) {
      t1 = J.contains$2$asx(window.navigator.userAgent, "Opera", 0);
      $.Device__isOpera = t1;
    }
    return t1;
  },
  Device_isWebKit: function() {
    var t1 = $.Device__isWebKit;
    if (t1 == null) {
      t1 = P.Device_isOpera() !== true && J.contains$2$asx(window.navigator.userAgent, "WebKit", 0);
      $.Device__isWebKit = t1;
    }
    return t1;
  },
  Device_cssPrefix: function() {
    var t1 = $.Device__cachedCssPrefix;
    if (t1 == null) {
      t1 = $.Device__isFirefox;
      if (t1 == null) {
        t1 = J.contains$2$asx(window.navigator.userAgent, "Firefox", 0);
        $.Device__isFirefox = t1;
      }
      if (t1 === true) {
        $.Device__cachedCssPrefix = "-moz-";
        t1 = "-moz-";
      } else {
        t1 = $.Device__isIE;
        if (t1 == null) {
          t1 = P.Device_isOpera() !== true && J.contains$2$asx(window.navigator.userAgent, "Trident/", 0);
          $.Device__isIE = t1;
        }
        if (t1 === true) {
          $.Device__cachedCssPrefix = "-ms-";
          t1 = "-ms-";
        } else if (P.Device_isOpera() === true) {
          $.Device__cachedCssPrefix = "-o-";
          t1 = "-o-";
        } else {
          $.Device__cachedCssPrefix = "-webkit-";
          t1 = "-webkit-";
        }
      }
    }
    return t1;
  },
  convertDartToNative_Dictionary_closure: {
    "^": "Closure:119;object_0",
    call$2: [function(key, value) {
      this.object_0[key] = value;
    }, "call$2", null, 4, 0, null, 269, [], 138, [], "call"]
  },
  _convertDartToNative_PrepareForStructuredClone_findSlot: {
    "^": "Closure:156;values_1,copies_2",
    call$1: function(value) {
      var t1, $length, i;
      t1 = this.values_1;
      $length = t1.length;
      for (i = 0; i < $length; ++i)
        if (t1[i] === value)
          return i;
      t1.push(value);
      this.copies_2.push(null);
      return $length;
    }
  },
  _convertDartToNative_PrepareForStructuredClone_readSlot: {
    "^": "Closure:99;copies_3",
    call$1: function(i) {
      var t1 = this.copies_3;
      if (i >= t1.length)
        return H.ioore(t1, i);
      return t1[i];
    }
  },
  _convertDartToNative_PrepareForStructuredClone_writeSlot: {
    "^": "Closure:773;copies_4",
    call$2: function(i, x) {
      var t1 = this.copies_4;
      if (i >= t1.length)
        return H.ioore(t1, i);
      t1[i] = x;
    }
  },
  _convertDartToNative_PrepareForStructuredClone_cleanupSlots: {
    "^": "Closure:54;",
    call$0: function() {
    }
  },
  _convertDartToNative_PrepareForStructuredClone_walk: {
    "^": "Closure:102;findSlot_5,readSlot_6,writeSlot_7",
    call$1: function(e) {
      var t1, t2, slot, copy, $length, i;
      t1 = {};
      if (e == null)
        return e;
      if (typeof e === "boolean")
        return e;
      if (typeof e === "number")
        return e;
      if (typeof e === "string")
        return e;
      t2 = J.getInterceptor(e);
      if (!!t2.$isDateTime)
        return new Date(e.millisecondsSinceEpoch);
      if (!!t2.$isRegExp)
        throw H.wrapException(P.UnimplementedError$("structured clone of RegExp"));
      if (!!t2.$isFile)
        return e;
      if (!!t2.$isBlob)
        return e;
      if (!!t2.$isFileList)
        return e;
      if (!!t2.$isImageData)
        return e;
      if (!!t2.$isNativeByteBuffer)
        return e;
      if (!!t2.$isNativeTypedData)
        return e;
      if (!!t2.$isMap) {
        slot = this.findSlot_5.call$1(e);
        copy = this.readSlot_6.call$1(slot);
        t1.copy_0 = copy;
        if (copy != null)
          return copy;
        copy = {};
        t1.copy_0 = copy;
        this.writeSlot_7.call$2(slot, copy);
        t2.forEach$1(e, new P._convertDartToNative_PrepareForStructuredClone_walk_closure(t1, this));
        return t1.copy_0;
      }
      if (!!t2.$isList) {
        $length = t2.get$length(e);
        slot = this.findSlot_5.call$1(e);
        copy = this.readSlot_6.call$1(slot);
        if (copy != null) {
          if (true === copy) {
            copy = new Array($length);
            this.writeSlot_7.call$2(slot, copy);
          }
          return copy;
        }
        copy = new Array($length);
        this.writeSlot_7.call$2(slot, copy);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          t1 = this.call$1(t2.$index(e, i));
          if (i >= copy.length)
            return H.ioore(copy, i);
          copy[i] = t1;
        }
        return copy;
      }
      throw H.wrapException(P.UnimplementedError$("structured clone of other type"));
    }
  },
  _convertDartToNative_PrepareForStructuredClone_walk_closure: {
    "^": "Closure:959;box_0,walk_8",
    call$2: function(key, value) {
      this.box_0.copy_0[key] = this.walk_8.call$1(value);
    }
  },
  convertNativeToDart_AcceptStructuredClone_findSlot: {
    "^": "Closure:156;values_0,copies_1",
    call$1: function(value) {
      var t1, $length, i, t2;
      t1 = this.values_0;
      $length = t1.length;
      for (i = 0; i < $length; ++i) {
        t2 = t1[i];
        if (t2 == null ? value == null : t2 === value)
          return i;
      }
      t1.push(value);
      this.copies_1.push(null);
      return $length;
    }
  },
  convertNativeToDart_AcceptStructuredClone_readSlot: {
    "^": "Closure:99;copies_2",
    call$1: function(i) {
      var t1 = this.copies_2;
      if (i >= t1.length)
        return H.ioore(t1, i);
      return t1[i];
    }
  },
  convertNativeToDart_AcceptStructuredClone_writeSlot: {
    "^": "Closure:773;copies_3",
    call$2: function(i, x) {
      var t1 = this.copies_3;
      if (i >= t1.length)
        return H.ioore(t1, i);
      t1[i] = x;
    }
  },
  convertNativeToDart_AcceptStructuredClone_walk: {
    "^": "Closure:102;mustCopy_4,findSlot_5,readSlot_6,writeSlot_7",
    call$1: function(e) {
      var slot, copy, t1, key, $length, t2, i;
      if (e == null)
        return e;
      if (typeof e === "boolean")
        return e;
      if (typeof e === "number")
        return e;
      if (typeof e === "string")
        return e;
      if (e instanceof Date)
        return P.DateTime$fromMillisecondsSinceEpoch(e.getTime(), true);
      if (e instanceof RegExp)
        throw H.wrapException(P.UnimplementedError$("structured clone of RegExp"));
      if (Object.getPrototypeOf(e) === Object.prototype) {
        slot = this.findSlot_5.call$1(e);
        copy = this.readSlot_6.call$1(slot);
        if (copy != null)
          return copy;
        copy = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        this.writeSlot_7.call$2(slot, copy);
        for (t1 = Object.keys(e), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
          key = t1.__internal$_current;
          copy.$indexSet(0, key, this.call$1(e[key]));
        }
        return copy;
      }
      if (e instanceof Array) {
        slot = this.findSlot_5.call$1(e);
        copy = this.readSlot_6.call$1(slot);
        if (copy != null)
          return copy;
        t1 = J.getInterceptor$asx(e);
        $length = t1.get$length(e);
        copy = this.mustCopy_4 ? new Array($length) : e;
        this.writeSlot_7.call$2(slot, copy);
        if (typeof $length !== "number")
          return H.iae($length);
        t2 = J.getInterceptor$ax(copy);
        i = 0;
        for (; i < $length; ++i)
          t2.$indexSet(copy, i, this.call$1(t1.$index(e, i)));
        return copy;
      }
      return e;
    }
  },
  _TypedImageData: {
    "^": "Object;data>,height>,width>",
    $is_TypedImageData: true,
    $isImageData: true
  },
  FilteredElementList: {
    "^": "ListBase;_node,_childNodes",
    get$_filtered: function() {
      var t1 = this._childNodes;
      return P.List_List$from(t1.where$1(t1, new P.FilteredElementList__filtered_closure()), true, W.Element);
    },
    forEach$1: function(_, f) {
      C.JSArray_methods.forEach$1(this.get$_filtered(), f);
    },
    $indexSet: function(_, index, value) {
      var t1 = this.get$_filtered();
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      J.replaceWith$1$x(t1[index], value);
    },
    set$length: function(_, newLength) {
      var len, t1;
      len = this.get$_filtered().length;
      t1 = J.getInterceptor$n(newLength);
      if (t1.$ge(newLength, len))
        return;
      else if (t1.$lt(newLength, 0))
        throw H.wrapException(P.ArgumentError$("Invalid list length"));
      this.removeRange$2(0, newLength, len);
    },
    add$1: [function(_, value) {
      this._childNodes._this.appendChild(value);
    }, "call$1", "get$add", 2, 0, 841, 138, []],
    addAll$1: function(_, iterable) {
      var t1, t2;
      for (t1 = J.get$iterator$ax(iterable), t2 = this._childNodes._this; t1.moveNext$0();)
        t2.appendChild(t1.get$current());
    },
    contains$1: [function(_, needle) {
      return false;
    }, "call$1", "get$contains", 2, 0, 1693],
    get$reversed: function(_) {
      var t1 = this.get$_filtered();
      return H.setRuntimeTypeInfo(new H.ReversedListIterable(t1), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0)]);
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort filtered list"));
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on filtered list"));
    },
    removeRange$2: function(_, start, end) {
      C.JSArray_methods.forEach$1(C.JSArray_methods.sublist$2(this.get$_filtered(), start, end), new P.FilteredElementList_removeRange_closure());
    },
    clear$0: function(_) {
      J._clearChildren$0$x(this._childNodes._this);
    },
    removeLast$0: function(_) {
      var result = this.get$last(this);
      if (result != null)
        J.remove$0$ax(result);
      return result;
    },
    insert$2: function(_, index, value) {
      this._childNodes.insert$2(0, index, value);
    },
    removeAt$1: function(_, index) {
      var t1, result;
      t1 = this.get$_filtered();
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      result = t1[index];
      J.remove$0$ax(result);
      return result;
    },
    remove$1: function(_, element) {
      var i, t1, indexElement;
      if (!J.getInterceptor(element).$isElement)
        return false;
      for (i = 0; i < this.get$_filtered().length; ++i) {
        t1 = this.get$_filtered();
        if (i >= t1.length)
          return H.ioore(t1, i);
        indexElement = t1[i];
        if (indexElement === element) {
          J.remove$0$ax(indexElement);
          return true;
        }
      }
      return false;
    },
    get$length: function(_) {
      return this.get$_filtered().length;
    },
    $index: function(_, index) {
      var t1 = this.get$_filtered();
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    get$iterator: function(_) {
      var t1 = this.get$_filtered();
      return H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]);
    }
  },
  FilteredElementList__filtered_closure: {
    "^": "Closure:102;",
    call$1: function(n) {
      return !!J.getInterceptor(n).$isElement;
    }
  },
  FilteredElementList_removeRange_closure: {
    "^": "Closure:102;",
    call$1: function(el) {
      return J.remove$0$ax(el);
    }
  }
}],
["metadata", "packages/$sdk/lib/html/html_common/metadata.dart", , B, {
  "^": "",
  SupportedBrowser: {
    "^": "Object;browserName,minimumVersion",
    static: {"^": "SupportedBrowser_CHROME,SupportedBrowser_FIREFOX,SupportedBrowser_IE,SupportedBrowser_OPERA,SupportedBrowser_SAFARI"}
  },
  Experimental: {
    "^": "Object;"
  },
  DomName: {
    "^": "Object;name>"
  },
  DocsEditable: {
    "^": "Object;"
  },
  Unstable: {
    "^": "Object;"
  }
}],
["p2", "package:p2/p2.dart", , A, {
  "^": "",
  Broadphase_canCollide: function(bodyA, bodyB) {
    var t1, t2;
    t1 = J.getInterceptor$x(bodyA);
    if (J.$eq(t1.get$type(bodyA), 2) && J.$eq(J.get$type$x(bodyB), 2))
      return false;
    if (!(J.$eq(t1.get$type(bodyA), 4) && J.$eq(J.get$type$x(bodyB), 2)))
      t2 = J.$eq(t1.get$type(bodyA), 2) && J.$eq(J.get$type$x(bodyB), 4);
    else
      t2 = true;
    if (t2)
      return false;
    if (J.$eq(t1.get$type(bodyA), 4) && J.$eq(J.get$type$x(bodyB), 4))
      return false;
    if (bodyA.get$sleepState() === 2 && bodyB.get$sleepState() === 2)
      return false;
    if (!(bodyA.get$sleepState() === 2 && J.$eq(J.get$type$x(bodyB), 2)))
      t1 = bodyB.get$sleepState() === 2 && J.$eq(t1.get$type(bodyA), 2);
    else
      t1 = true;
    if (t1)
      return false;
    return true;
  },
  Polyk_Triangulate: function(p) {
    var n, tgs, avl, i, al, t1, t2, i0, i1, i10, t3, i2, ax, ay, bx, by, cx, cy, t4, earFound, t5, j, vi, t6, t7, t8, v0x, v0y, v1x, v1y, v2x, v2y, dot00, dot01, dot02, dot11, dot12, invDenom, u, v;
    n = p.length >>> 1;
    if (n < 3)
      return Array(0);
    tgs = [];
    avl = [];
    for (i = 0; i < n; ++i)
      avl.push(i);
    for (al = n, i = 0; al > 3;) {
      t1 = C.JSInt_methods.$mod(i, al);
      t2 = avl.length;
      if (t1 >= t2)
        return H.ioore(avl, t1);
      i0 = avl[t1];
      i1 = i + 1;
      t1 = C.JSInt_methods.$mod(i1, al);
      if (t1 >= t2)
        return H.ioore(avl, t1);
      i10 = avl[t1];
      t3 = C.JSInt_methods.$mod(i + 2, al);
      if (t3 >= t2)
        return H.ioore(avl, t3);
      i2 = avl[t3];
      t3 = 2 * i0;
      t2 = p.length;
      if (t3 >= t2)
        return H.ioore(p, t3);
      ax = p[t3];
      ++t3;
      if (t3 >= t2)
        return H.ioore(p, t3);
      ay = p[t3];
      t3 = 2 * i10;
      if (t3 >= t2)
        return H.ioore(p, t3);
      bx = p[t3];
      ++t3;
      if (t3 >= t2)
        return H.ioore(p, t3);
      by = p[t3];
      t3 = 2 * i2;
      if (t3 >= t2)
        return H.ioore(p, t3);
      cx = p[t3];
      ++t3;
      if (t3 >= t2)
        return H.ioore(p, t3);
      cy = p[t3];
      t2 = J.getInterceptor$n(cx);
      t3 = J.getInterceptor$n(bx);
      t4 = J.getInterceptor$n(cy);
      if (J.$ge$n(J.$add$ns(J.$mul$ns(J.$sub$n(ay, by), t2.$sub(cx, bx)), J.$mul$ns(t3.$sub(bx, ax), t4.$sub(cy, by))), 0)) {
        t5 = J.getInterceptor$n(by);
        j = 0;
        while (true) {
          if (!(j < al)) {
            earFound = true;
            break;
          }
          c$1: {
            if (j >= avl.length)
              return H.ioore(avl, j);
            vi = avl[j];
            if (vi === i0 || vi === i10 || vi === i2)
              break c$1;
            t6 = 2 * vi;
            t7 = p.length;
            if (t6 >= t7)
              return H.ioore(p, t6);
            t8 = p[t6];
            ++t6;
            if (t6 >= t7)
              return H.ioore(p, t6);
            t6 = p[t6];
            v0x = t2.$sub(cx, ax);
            v0y = t4.$sub(cy, ay);
            v1x = t3.$sub(bx, ax);
            v1y = t5.$sub(by, ay);
            v2x = J.$sub$n(t8, ax);
            v2y = J.$sub$n(t6, ay);
            t6 = J.getInterceptor$ns(v0x);
            t8 = J.getInterceptor$ns(v0y);
            dot00 = J.$add$ns(t6.$mul(v0x, v0x), t8.$mul(v0y, v0y));
            dot01 = J.$add$ns(t6.$mul(v0x, v1x), t8.$mul(v0y, v1y));
            dot02 = J.$add$ns(t6.$mul(v0x, v2x), t8.$mul(v0y, v2y));
            t8 = J.getInterceptor$ns(v1x);
            t6 = J.getInterceptor$ns(v1y);
            dot11 = J.$add$ns(t8.$mul(v1x, v1x), t6.$mul(v1y, v1y));
            dot12 = J.$add$ns(t8.$mul(v1x, v2x), t6.$mul(v1y, v2y));
            t6 = J.getInterceptor$ns(dot00);
            t8 = J.getInterceptor$ns(dot01);
            t7 = J.$sub$n(t6.$mul(dot00, dot11), t8.$mul(dot01, dot01));
            if (typeof t7 !== "number")
              return H.iae(t7);
            invDenom = 1 / t7;
            u = J.$mul$ns(J.$sub$n(J.$mul$ns(dot11, dot02), t8.$mul(dot01, dot12)), invDenom);
            v = J.$mul$ns(J.$sub$n(t6.$mul(dot00, dot12), t8.$mul(dot01, dot02)), invDenom);
            t6 = J.getInterceptor$n(u);
            if (t6.$ge(u, 0) && J.$ge$n(v, 0) && J.$lt$n(t6.$add(u, v), 1)) {
              earFound = false;
              break;
            }
          }
          ++j;
        }
      } else
        earFound = false;
      if (earFound) {
        C.JSArray_methods.addAll$1(tgs, [i0, i10, i2]);
        C.JSArray_methods.removeAt$1(avl, t1);
        --al;
        i = 0;
      } else {
        if (i > 3 * al)
          break;
        i = i1;
      }
    }
    t1 = avl.length;
    if (0 >= t1)
      return H.ioore(avl, 0);
    t2 = avl[0];
    if (1 >= t1)
      return H.ioore(avl, 1);
    t3 = avl[1];
    if (2 >= t1)
      return H.ioore(avl, 2);
    C.JSArray_methods.addAll$1(tgs, [t2, t3, avl[2]]);
    return tgs;
  },
  AABB0: {
    "^": "Object;lowerBound>,upperBound>",
    setFromPoints$4: function(points, position, angle, skinSize) {
      var l, u, t1, t2, t3, t4, cosAngle, sinAngle, i, p, x, y;
      l = this.lowerBound;
      u = this.upperBound;
      t1 = J.getInterceptor(angle);
      t2 = t1.$eq(angle, 0);
      t3 = points[0];
      t4 = points.length;
      if (!t2) {
        if (0 >= t4)
          return H.ioore(points, 0);
        A.vec2_rotate(l, t3, angle);
      } else {
        if (0 >= t4)
          return H.ioore(points, 0);
        A.vec2_copy(l, t3);
      }
      A.vec2_copy(u, l);
      cosAngle = Math.cos(H.checkNum(angle));
      sinAngle = Math.sin(H.checkNum(angle));
      for (i = 1; i < points.length; ++i) {
        p = points[i];
        if (!t1.$eq(angle, 0)) {
          t2 = J.getInterceptor$x(p);
          x = t2.get$x(p);
          y = t2.get$y(p);
          p = $.get$AABB_tmp();
          if (typeof x !== "number")
            return H.iae(x);
          if (typeof y !== "number")
            return H.iae(y);
          p.x = cosAngle * x - sinAngle * y;
          p.y = sinAngle * x + cosAngle * y;
        }
        t2 = J.getInterceptor$x(p);
        if (J.$gt$n(t2.get$x(p), u.x))
          u.x = t2.get$x(p);
        if (J.$lt$n(t2.get$x(p), l.x))
          l.x = t2.get$x(p);
        if (J.$gt$n(t2.get$y(p), u.y))
          u.y = t2.get$y(p);
        if (J.$lt$n(t2.get$y(p), l.y))
          l.y = t2.get$y(p);
      }
      if (position != null) {
        A.vec2_add(l, l, position);
        A.vec2_add(u, u, position);
      }
      if (skinSize !== 0) {
        l.x = J.$sub$n(l.x, skinSize);
        l.y = J.$sub$n(l.y, skinSize);
        u.x = J.$add$ns(u.x, skinSize);
        u.y = J.$add$ns(u.y, skinSize);
      }
    },
    copy$1: function(aabb) {
      var t1 = J.getInterceptor$x(aabb);
      A.vec2_copy(this.lowerBound, t1.get$lowerBound(aabb));
      A.vec2_copy(this.upperBound, t1.get$upperBound(aabb));
    },
    AABB$2$lowerBound$upperBound: function(lowerBound, upperBound) {
    },
    static: {"^": "AABB_tmp", AABB$: function(lowerBound, upperBound) {
        var out, out0, t1;
        out = new A.vec2(0, 0);
        out.x = 0;
        out.y = 0;
        out0 = new A.vec2(0, 0);
        out0.x = 0;
        out0.y = 0;
        t1 = new A.AABB0(out, out0);
        t1.AABB$2$lowerBound$upperBound(lowerBound, upperBound);
        return t1;
      }}
  },
  "+AABB": 0,
  Broadphase: {
    "^": "Object;type*,result>,world@",
    setWorld$1: function(world) {
      this.world = world;
    },
    getCollisionPairs$1: function(world) {
      throw H.wrapException(P.Exception_Exception("getCollisionPairs must be implemented in a subclass!"));
    },
    Broadphase$1: function(type) {
      this.type = type;
      this.result = H.setRuntimeTypeInfo([], [A.Body3]);
      this.world = null;
      this.boundingVolumeType = 1;
    }
  },
  Narrowphase: {
    "^": "Object;contactEquations<,frictionEquations,enableFriction,slipForce,frictionCoefficient?,surfaceVelocity,reuseObjects,reusableContactEquations,reusableFrictionEquations,restitution?,stiffness?,relaxation?,frictionStiffness,frictionRelaxation,enableFrictionReduction,collidingBodiesLastStep,contactSkinSize,compareMap",
    reset$0: function(_) {
      var eqs, l, l0, eq, id1, id2, ce, fe, rfe;
      this.collidingBodiesLastStep.reset$0(0);
      eqs = this.contactEquations;
      l = eqs.length;
      for (; l0 = l - 1, l > 0; l = l0) {
        if (l0 < 0 || l0 >= eqs.length)
          return H.ioore(eqs, l0);
        eq = eqs[l0];
        id1 = J.get$id$x(eq.get$bodyA());
        id2 = J.get$id$x(eq.get$bodyB());
        this.collidingBodiesLastStep.set$3(id1, id2, true);
      }
      if (this.reuseObjects) {
        ce = this.contactEquations;
        fe = this.frictionEquations;
        rfe = this.reusableFrictionEquations;
        C.JSArray_methods.addAll$1(this.reusableContactEquations, ce);
        C.JSArray_methods.addAll$1(rfe, fe);
      }
      C.JSArray_methods.set$length(this.contactEquations, 0);
      C.JSArray_methods.set$length(this.frictionEquations, 0);
    },
    createContactEquation$4: function(bodyA, bodyB, shapeA, shapeB) {
      var t1, t2, c, out, out0, out1, out2, id1, id2;
      t1 = this.reusableContactEquations;
      t2 = t1.length;
      if (t2 !== 0) {
        if (0 >= t2)
          return H.ioore(t1, 0);
        c = t1.pop();
      } else {
        out = new A.vec2(0, 0);
        out.x = 0;
        out.y = 0;
        out0 = new A.vec2(0, 0);
        out0.x = 0;
        out0.y = 0;
        out1 = new A.vec2(0, 0);
        out1.x = 0;
        out1.y = 0;
        out2 = new A.vec2(0, 0);
        out2.x = 0;
        out2.y = 0;
        c = new A.ContactEquation(out, out0, out1, out2, null, null, null, null, null, null, bodyA, bodyB, null, null, new Float32Array(6), 0, 0, 0, 0, 0.016666666666666666, true, 0, 0, true, null, null, null);
        c.Equation$4(bodyA, bodyB, 0, 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368);
        c.restitution = 0;
        c.firstImpact = false;
        c.shapeA = null;
        c.shapeB = null;
      }
      c.set$bodyA(bodyA);
      c.set$bodyB(bodyB);
      c.set$shapeA(shapeA);
      c.set$shapeB(shapeB);
      c.set$restitution(this.restitution);
      id1 = J.$or$n(J.get$id$x(bodyA), 0);
      id2 = J.$or$n(J.get$id$x(bodyB), 0);
      t1 = this.collidingBodiesLastStep;
      c.set$firstImpact(J.$index$asx(t1.data, t1.getKey$2(id1, id2)) == null);
      c.set$stiffness(this.stiffness);
      c.set$relaxation(this.relaxation);
      c.set$needsUpdate(true);
      c.set$enabled(true);
      J.set$offset$x(c, this.contactSkinSize);
      return c;
    },
    createFrictionEquation$4: function(bodyA, bodyB, shapeA, shapeB) {
      var t1, t2, c, out, out0, out1;
      t1 = this.reusableFrictionEquations;
      t2 = t1.length;
      if (t2 !== 0) {
        if (0 >= t2)
          return H.ioore(t1, 0);
        c = t1.pop();
      } else {
        out = new A.vec2(0, 0);
        out.x = 0;
        out.y = 0;
        out0 = new A.vec2(0, 0);
        out0.x = 0;
        out0.y = 0;
        out1 = new A.vec2(0, 0);
        out1.x = 0;
        out1.y = 0;
        c = new A.FrictionEquation(out, out0, out1, null, null, null, 0.3, null, null, bodyA, bodyB, null, null, new Float32Array(H._checkLength(6)), 0, 0, 0, 0, 0.016666666666666666, true, 0, 0, true, null, null, null);
        c.Equation$4(bodyA, bodyB, -0.0, 0);
        c.FrictionEquation$3$slipForce(bodyA, bodyB, 0);
      }
      c.set$bodyA(bodyA);
      c.set$bodyB(bodyB);
      c.set$shapeA(shapeA);
      c.set$shapeB(shapeB);
      c.setSlipForce$1(this.slipForce);
      c.set$frictionCoefficient(this.frictionCoefficient);
      c.set$relativeVelocity(this.surfaceVelocity);
      c.set$enabled(true);
      c.set$needsUpdate(true);
      c.set$stiffness(this.frictionStiffness);
      c.set$relaxation(this.frictionRelaxation);
      C.JSArray_methods.set$length(c.get$contactEquations(), 0);
      return c;
    },
    createFrictionFromContact$1: function(c) {
      var eq, t1, t2, x;
      eq = this.createFrictionEquation$4(c.get$bodyA(), c.get$bodyB(), c.get$shapeA(), c.get$shapeB());
      t1 = eq.get$contactPointA();
      t2 = c.get$contactPointA();
      t1.x = t2.x;
      t1.y = t2.y;
      t2 = eq.get$contactPointB();
      t1 = c.get$contactPointB();
      t2.x = t1.x;
      t2.y = t1.y;
      t1 = eq.get$t();
      t2 = c.get$normalA();
      x = t2.x;
      t1.x = t2.y;
      t1.y = J.$negate$n(x);
      eq.get$contactEquations().push(c);
      return eq;
    },
    createFrictionFromAverage$1: function(numContacts) {
      var t1, t2, t3, c, eq, bodyA, i, invNumContacts;
      if (numContacts === 0)
        throw H.wrapException(P.Exception_Exception("numContacts == 0!"));
      t1 = this.contactEquations;
      t2 = t1.length;
      t3 = t2 - 1;
      if (t3 < 0)
        return H.ioore(t1, t3);
      c = t1[t3];
      eq = this.createFrictionEquation$4(c.get$bodyA(), c.get$bodyB(), c.get$shapeA(), c.get$shapeB());
      bodyA = c.get$bodyA();
      c.get$bodyB();
      t3 = eq.get$contactPointA();
      t3.x = 0;
      t3.y = 0;
      t3 = eq.get$contactPointB();
      t3.x = 0;
      t3.y = 0;
      t3 = eq.get$t();
      t3.x = 0;
      t3.y = 0;
      for (i = 0; i !== numContacts; ++i) {
        t1 = this.contactEquations;
        t2 = t1.length;
        t3 = t2 - 1 - i;
        if (t3 < 0)
          return H.ioore(t1, t3);
        c = t1[t3];
        if (J.$eq(c.get$bodyA(), bodyA)) {
          t1 = eq.get$t();
          t2 = eq.get$t();
          t3 = c.get$normalA();
          t1.x = J.$add$ns(t2.x, t3.x);
          t1.y = J.$add$ns(t2.y, t3.y);
          t3 = eq.get$contactPointA();
          t2 = eq.get$contactPointA();
          t1 = c.get$contactPointA();
          t3.x = J.$add$ns(t2.x, t1.x);
          t3.y = J.$add$ns(t2.y, t1.y);
          t1 = eq.get$contactPointB();
          t2 = eq.get$contactPointB();
          t3 = c.get$contactPointB();
          t1.x = J.$add$ns(t2.x, t3.x);
          t1.y = J.$add$ns(t2.y, t3.y);
        } else {
          $.vec2_sub.call$3(eq.get$t(), eq.get$t(), c.get$normalA());
          t1 = eq.get$contactPointA();
          t2 = eq.get$contactPointA();
          t3 = c.get$contactPointB();
          t1.x = J.$add$ns(t2.x, t3.x);
          t1.y = J.$add$ns(t2.y, t3.y);
          t3 = eq.get$contactPointB();
          t2 = eq.get$contactPointB();
          t1 = c.get$contactPointA();
          t3.x = J.$add$ns(t2.x, t1.x);
          t3.y = J.$add$ns(t2.y, t1.y);
        }
        eq.get$contactEquations().push(c);
      }
      invNumContacts = 1 / numContacts;
      A.vec2_scale(eq.get$contactPointA(), eq.get$contactPointA(), invNumContacts);
      A.vec2_scale(eq.get$contactPointB(), eq.get$contactPointB(), invNumContacts);
      A.vec2_normalize(eq.get$t(), eq.get$t());
      A.vec2_rotate90cw(eq.get$t(), eq.get$t());
      return eq;
    },
    convexLine$9: [function(convexBody, convexShape, convexOffset, convexAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
      if (justTest === true)
        return 0;
      else
        return 0;
    }, "call$9", "get$convexLine", 18, 0, 1723, 1724, [], 1725, [], 1726, [], 1727, [], 1728, [], 1729, [], 1730, [], 1731, [], 1732, []],
    lineRectangle$9: [function(lineBody, lineShape, lineOffset, lineAngle, rectangleBody, rectangleShape, rectangleOffset, rectangleAngle, justTest) {
      if (justTest === true)
        return 0;
      else
        return 0;
    }, "call$9", "get$lineRectangle", 18, 0, 1733, 1728, [], 1729, [], 1730, [], 1731, [], 1734, [], 1735, [], 1736, [], 1737, [], 1732, []],
    setConvexToCapsuleShapeMiddle$2: function(convexShape, capsuleShape) {
      var t1, t2, t3, t4, t5, t6;
      t1 = convexShape.vertices;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t2 = t1[0];
      t3 = J.getInterceptor$asx(capsuleShape);
      t4 = J.$mul$ns(J.$negate$n(t3.get$length(capsuleShape)), 0.5);
      t5 = J.$negate$n(capsuleShape.get$radius());
      t6 = J.getInterceptor$x(t2);
      t6.set$x(t2, t4);
      t6.set$y(t2, t5);
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      t5 = t1[1];
      t2 = J.$mul$ns(t3.get$length(capsuleShape), 0.5);
      t6 = J.$negate$n(capsuleShape.get$radius());
      t4 = J.getInterceptor$x(t5);
      t4.set$x(t5, t2);
      t4.set$y(t5, t6);
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t6 = t1[2];
      t5 = J.$mul$ns(t3.get$length(capsuleShape), 0.5);
      t4 = capsuleShape.get$radius();
      t2 = J.getInterceptor$x(t6);
      t2.set$x(t6, t5);
      t2.set$y(t6, t4);
      if (3 >= t1.length)
        return H.ioore(t1, 3);
      t1 = t1[3];
      t3 = J.$mul$ns(J.$negate$n(t3.get$length(capsuleShape)), 0.5);
      t4 = capsuleShape.get$radius();
      t6 = J.getInterceptor$x(t1);
      t6.set$x(t1, t3);
      t6.set$y(t1, t4);
    },
    convexCapsule$9: [function(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
      var circlePos, t1, result1, result2, r;
      circlePos = $.get$Narrowphase_convexCapsule_tempVec();
      t1 = J.getInterceptor$asx(capsuleShape);
      circlePos.x = J.$div$n(t1.get$length(capsuleShape), 2);
      circlePos.y = 0;
      A.vec2_rotate(circlePos, circlePos, capsuleAngle);
      A.vec2_add(circlePos, circlePos, capsulePosition);
      result1 = this.circleConvex$10(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.get$radius());
      circlePos.x = J.$div$n(J.$negate$n(t1.get$length(capsuleShape)), 2);
      circlePos.y = 0;
      A.vec2_rotate(circlePos, circlePos, capsuleAngle);
      A.vec2_add(circlePos, circlePos, capsulePosition);
      result2 = this.circleConvex$10(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.get$radius());
      if (justTest === true)
        t1 = result1 !== 0 || result2 !== 0;
      else
        t1 = false;
      if (t1)
        return 1;
      r = $.get$Narrowphase_convexCapsule_tempRect();
      this.setConvexToCapsuleShapeMiddle$2(r, capsuleShape);
      return this.convexConvex$9(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, r, capsulePosition, capsuleAngle, justTest) + result1 + result2;
    }, "call$9", "get$convexCapsule", 18, 0, 1738, 1724, [], 1725, [], 1739, [], 1727, [], 1740, [], 1741, [], 1742, [], 1743, [], 1732, []],
    capsuleCapsule$9: [function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
      var circlePosi, circlePosj, t1, t2, t3, t4, t5, enableFrictionBefore, numContacts, i, t6, t7, j, result, rect, result1, result2;
      circlePosi = $.get$Narrowphase_capsuleCapsule_tempVec1();
      circlePosj = $.get$Narrowphase_capsuleCapsule_tempVec2();
      for (t1 = justTest === true, t2 = J.getInterceptor$asx(sj), t3 = J.getInterceptor$x(xj), t4 = J.getInterceptor$asx(si), t5 = J.getInterceptor$x(xi), enableFrictionBefore = null, numContacts = 0, i = 0; i < 2; ++i) {
        t6 = i === 0 ? -1 : 1;
        t7 = t4.get$length(si);
        if (typeof t7 !== "number")
          return H.iae(t7);
        circlePosi.x = t6 * t7 / 2;
        circlePosi.y = 0;
        A.vec2_rotate(circlePosi, circlePosi, ai);
        circlePosi.x = J.$add$ns(circlePosi.x, t5.get$x(xi));
        circlePosi.y = J.$add$ns(circlePosi.y, t5.get$y(xi));
        for (j = 0; j < 2; ++j) {
          t6 = j === 0 ? -1 : 1;
          t7 = t2.get$length(sj);
          if (typeof t7 !== "number")
            return H.iae(t7);
          circlePosj.x = t6 * t7 / 2;
          circlePosj.y = 0;
          A.vec2_rotate(circlePosj, circlePosj, aj);
          circlePosj.x = J.$add$ns(circlePosj.x, t3.get$x(xj));
          circlePosj.y = J.$add$ns(circlePosj.y, t3.get$y(xj));
          if (this.enableFrictionReduction) {
            enableFrictionBefore = this.enableFriction;
            this.enableFriction = false;
          }
          result = this.circleCircle$11(bi, si, circlePosi, ai, bj, sj, circlePosj, aj, justTest, si.get$radius(), sj.get$radius());
          if (this.enableFrictionReduction)
            this.enableFriction = enableFrictionBefore;
          if (t1 && result !== 0)
            return 1;
          numContacts += result;
        }
      }
      if (this.enableFrictionReduction) {
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
      }
      rect = $.get$Narrowphase_capsuleCapsule_tempRect1();
      this.setConvexToCapsuleShapeMiddle$2(rect, si);
      result1 = this.convexCapsule$9(bi, rect, xi, ai, bj, sj, xj, aj, justTest);
      t2 = this.enableFrictionReduction;
      if (t2)
        this.enableFriction = enableFrictionBefore;
      if (t1 && result1 !== 0)
        return 1;
      if (t2) {
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
      }
      this.setConvexToCapsuleShapeMiddle$2(rect, sj);
      result2 = this.convexCapsule$9(bj, rect, xj, aj, bi, si, xi, ai, justTest);
      t2 = this.enableFrictionReduction;
      if (t2)
        this.enableFriction = enableFrictionBefore;
      if (t1 && result2 !== 0)
        return 1;
      numContacts = numContacts + result1 + result2;
      if (t2)
        if (numContacts !== 0 && this.enableFriction === true)
          this.frictionEquations.push(this.createFrictionFromAverage$1(numContacts));
      return numContacts;
    }, "call$9", "get$capsuleCapsule", 18, 0, 1744, 1745, [], 1746, [], 1747, [], 1748, [], 1749, [], 1750, [], 1751, [], 1752, [], 1732, []],
    lineLine$9: [function(bodyA, shapeA, positionA, angleA, bodyB, shapeB, positionB, angleB, justTest) {
      if (justTest === true)
        return 0;
      else
        return 0;
    }, "call$9", "get$lineLine", 18, 0, 1753, 1754, [], 1755, [], 1756, [], 1757, [], 1758, [], 1759, [], 1760, [], 1761, [], 1732, []],
    planeLine$9: [function(planeBody, planeShape, planeOffset, planeAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
      var worldVertex0, worldVertex1, worldVertex01, worldVertex11, worldEdge, worldEdgeUnit, dist, worldNormal, worldTangent, verts, t1, t2, t3, t4, numContacts, i, v, d, c, t5, t6;
      worldVertex0 = $.get$Narrowphase_tmp1();
      worldVertex1 = $.get$Narrowphase_tmp2();
      worldVertex01 = $.get$Narrowphase_tmp3();
      worldVertex11 = $.get$Narrowphase_tmp4();
      worldEdge = $.get$Narrowphase_tmp5();
      worldEdgeUnit = $.get$Narrowphase_tmp6();
      dist = $.get$Narrowphase_tmp7();
      worldNormal = $.get$Narrowphase_tmp8();
      worldTangent = $.get$Narrowphase_tmp9();
      verts = $.get$Narrowphase_tmpArray();
      t1 = J.getInterceptor$asx(lineShape);
      worldVertex0.x = J.$div$n(J.$negate$n(t1.get$length(lineShape)), 2);
      worldVertex0.y = 0;
      worldVertex1.x = J.$div$n(t1.get$length(lineShape), 2);
      worldVertex1.y = 0;
      A.vec2_rotate(worldVertex01, worldVertex0, lineAngle);
      A.vec2_rotate(worldVertex11, worldVertex1, lineAngle);
      A.vec2_add(worldVertex01, worldVertex01, lineOffset);
      A.vec2_add(worldVertex11, worldVertex11, lineOffset);
      A.vec2_copy(worldVertex0, worldVertex01);
      A.vec2_copy(worldVertex1, worldVertex11);
      $.vec2_sub.call$3(worldEdge, worldVertex1, worldVertex0);
      A.vec2_normalize(worldEdgeUnit, worldEdge);
      A.vec2_rotate90cw(worldTangent, worldEdgeUnit);
      A.vec2_rotate(worldNormal, $.get$Narrowphase_yAxis(), planeAngle);
      verts[0] = worldVertex0;
      verts[1] = worldVertex1;
      for (t1 = J.getInterceptor$x(planeBody), t2 = J.getInterceptor$x(lineOffset), t3 = J.getInterceptor$x(lineBody), t4 = justTest === true, numContacts = 0, i = 0; i < 2; ++i) {
        v = verts[i];
        $.vec2_sub.call$3(dist, v, planeOffset);
        d = J.$add$ns(J.$mul$ns(dist.x, worldNormal.x), J.$mul$ns(dist.y, worldNormal.y));
        if (J.$lt$n(d, 0)) {
          if (t4)
            return 1;
          c = this.createContactEquation$4(planeBody, lineBody, planeShape, lineShape);
          ++numContacts;
          t5 = c.get$normalA();
          t5.x = worldNormal.x;
          t5.y = worldNormal.y;
          A.vec2_normalize(c.get$normalA(), c.get$normalA());
          dist.x = J.$mul$ns(worldNormal.x, d);
          dist.y = J.$mul$ns(worldNormal.y, d);
          $.vec2_sub.call$3(c.get$contactPointA(), v, dist);
          $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), t1.get$position(planeBody));
          $.vec2_sub.call$3(c.get$contactPointB(), v, lineOffset);
          t5 = c.get$contactPointB();
          t6 = c.get$contactPointB();
          t5.x = J.$add$ns(t6.x, t2.get$x(lineOffset));
          t5.y = J.$add$ns(t6.y, t2.get$y(lineOffset));
          $.vec2_sub.call$3(c.get$contactPointB(), c.get$contactPointB(), t3.get$position(lineBody));
          this.contactEquations.push(c);
          if (!this.enableFrictionReduction)
            if (this.enableFriction === true)
              this.frictionEquations.push(this.createFrictionFromContact$1(c));
        }
      }
      if (t4)
        return 0;
      if (!this.enableFrictionReduction)
        if (numContacts !== 0 && this.enableFriction === true)
          this.frictionEquations.push(this.createFrictionFromAverage$1(numContacts));
      return numContacts;
    }, "call$9", "get$planeLine", 18, 0, 1762, 1763, [], 1764, [], 1765, [], 1766, [], 1728, [], 1729, [], 1730, [], 1731, [], 1732, []],
    particleCapsule$9: [function(particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
      return this.circleLine$11(particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest, capsuleShape.get$radius(), 0);
    }, "call$9", "get$particleCapsule", 18, 0, 1767, 1768, [], 1769, [], 1770, [], 1771, [], 1740, [], 1741, [], 1742, [], 1743, [], 1732, []],
    circleLine$11: [function(circleBody, circleShape, circleOffset, circleAngle, lineBody, lineShape, lineOffset, lineAngle, justTest, lineRadius, circleRadius) {
      var orthoDist, lineToCircleOrthoUnit, projectedPoint, centerDist, worldTangent, worldEdge, worldEdgeUnit, worldVertex0, worldVertex1, worldVertex01, worldVertex11, dist, lineToCircle, lineEndToLineRadius, verts, t1, d, radiusSum, pos, pos0, pos1, c, i, v, x, y, t2, t3;
      circleRadius = circleRadius != null ? circleRadius : H.interceptedTypeCast(circleShape, "$isCircle2").radius;
      orthoDist = $.get$Narrowphase_tmp1();
      lineToCircleOrthoUnit = $.get$Narrowphase_tmp2();
      projectedPoint = $.get$Narrowphase_tmp3();
      centerDist = $.get$Narrowphase_tmp4();
      worldTangent = $.get$Narrowphase_tmp5();
      worldEdge = $.get$Narrowphase_tmp6();
      worldEdgeUnit = $.get$Narrowphase_tmp7();
      worldVertex0 = $.get$Narrowphase_tmp8();
      worldVertex1 = $.get$Narrowphase_tmp9();
      worldVertex01 = $.get$Narrowphase_tmp10();
      worldVertex11 = $.get$Narrowphase_tmp11();
      dist = $.get$Narrowphase_tmp12();
      lineToCircle = $.get$Narrowphase_tmp13();
      lineEndToLineRadius = $.get$Narrowphase_tmp14();
      verts = $.get$Narrowphase_tmpArray();
      t1 = J.getInterceptor$asx(lineShape);
      worldVertex0.x = J.$div$n(J.$negate$n(t1.get$length(lineShape)), 2);
      worldVertex0.y = 0;
      worldVertex1.x = J.$div$n(t1.get$length(lineShape), 2);
      worldVertex1.y = 0;
      A.vec2_rotate(worldVertex01, worldVertex0, lineAngle);
      A.vec2_rotate(worldVertex11, worldVertex1, lineAngle);
      A.vec2_add(worldVertex01, worldVertex01, lineOffset);
      A.vec2_add(worldVertex11, worldVertex11, lineOffset);
      A.vec2_copy(worldVertex0, worldVertex01);
      A.vec2_copy(worldVertex1, worldVertex11);
      $.vec2_sub.call$3(worldEdge, worldVertex1, worldVertex0);
      A.vec2_normalize(worldEdgeUnit, worldEdge);
      A.vec2_rotate90cw(worldTangent, worldEdgeUnit);
      $.vec2_sub.call$3(dist, circleOffset, worldVertex0);
      d = A.vec2_dot(dist, worldTangent);
      $.vec2_sub.call$3(centerDist, worldVertex0, lineOffset);
      $.vec2_sub.call$3(lineToCircle, circleOffset, lineOffset);
      radiusSum = J.$add$ns(circleRadius, lineRadius);
      if (J.$lt$n(J.abs$0$n(d), radiusSum)) {
        A.vec2_scale(orthoDist, worldTangent, d);
        $.vec2_sub.call$3(projectedPoint, circleOffset, orthoDist);
        A.vec2_scale(lineToCircleOrthoUnit, worldTangent, A.vec2_dot(worldTangent, lineToCircle));
        A.vec2_normalize(lineToCircleOrthoUnit, lineToCircleOrthoUnit);
        A.vec2_scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
        A.vec2_add(projectedPoint, projectedPoint, lineToCircleOrthoUnit);
        pos = A.vec2_dot(worldEdgeUnit, projectedPoint);
        pos0 = A.vec2_dot(worldEdgeUnit, worldVertex0);
        pos1 = A.vec2_dot(worldEdgeUnit, worldVertex1);
        t1 = J.getInterceptor$n(pos);
        if (t1.$gt(pos, pos0) && t1.$lt(pos, pos1)) {
          if (justTest === true)
            return 1;
          c = this.createContactEquation$4(circleBody, lineBody, circleShape, lineShape);
          A.vec2_scale(c.get$normalA(), orthoDist, -1);
          A.vec2_normalize(c.get$normalA(), c.get$normalA());
          A.vec2_scale(c.get$contactPointA(), c.get$normalA(), circleRadius);
          A.vec2_add(c.get$contactPointA(), c.get$contactPointA(), circleOffset);
          $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), J.get$position$x(circleBody));
          $.vec2_sub.call$3(c.get$contactPointB(), projectedPoint, lineOffset);
          A.vec2_add(c.get$contactPointB(), c.get$contactPointB(), lineOffset);
          $.vec2_sub.call$3(c.get$contactPointB(), c.get$contactPointB(), J.get$position$x(lineBody));
          this.contactEquations.push(c);
          if (this.enableFriction === true)
            this.frictionEquations.push(this.createFrictionFromContact$1(c));
          return 1;
        }
      }
      verts[0] = worldVertex0;
      verts[1] = worldVertex1;
      for (t1 = typeof radiusSum !== "number", i = 0; i < 2; ++i) {
        v = verts[i];
        $.vec2_sub.call$3(dist, v, circleOffset);
        x = dist.x;
        y = dist.y;
        t2 = J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
        if (t1)
          H.throwExpression(P.ArgumentError$(radiusSum));
        if (J.$lt$n(t2, Math.pow(radiusSum, 2))) {
          if (justTest === true)
            return 1;
          c = this.createContactEquation$4(circleBody, lineBody, circleShape, lineShape);
          t1 = c.get$normalA();
          t1.x = dist.x;
          t1.y = dist.y;
          A.vec2_normalize(c.get$normalA(), c.get$normalA());
          t1 = c.get$contactPointA();
          t2 = c.get$normalA();
          t1.x = J.$mul$ns(t2.x, circleRadius);
          t1.y = J.$mul$ns(t2.y, circleRadius);
          t2 = c.get$contactPointA();
          t1 = c.get$contactPointA();
          t3 = J.getInterceptor$x(circleOffset);
          t2.x = J.$add$ns(t1.x, t3.get$x(circleOffset));
          t2.y = J.$add$ns(t1.y, t3.get$y(circleOffset));
          $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), J.get$position$x(circleBody));
          $.vec2_sub.call$3(c.get$contactPointB(), v, lineOffset);
          t3 = c.get$normalA();
          t1 = J.$negate$n(lineRadius);
          lineEndToLineRadius.x = J.$mul$ns(t3.x, t1);
          lineEndToLineRadius.y = J.$mul$ns(t3.y, t1);
          t1 = c.get$contactPointB();
          t3 = c.get$contactPointB();
          t1.x = J.$add$ns(t3.x, lineEndToLineRadius.x);
          t1.y = J.$add$ns(t3.y, lineEndToLineRadius.y);
          t3 = c.get$contactPointB();
          t1 = c.get$contactPointB();
          t2 = J.getInterceptor$x(lineOffset);
          t3.x = J.$add$ns(t1.x, t2.get$x(lineOffset));
          t3.y = J.$add$ns(t1.y, t2.get$y(lineOffset));
          $.vec2_sub.call$3(c.get$contactPointB(), c.get$contactPointB(), J.get$position$x(lineBody));
          this.contactEquations.push(c);
          if (this.enableFriction === true)
            this.frictionEquations.push(this.createFrictionFromContact$1(c));
          return 1;
        }
      }
      return 0;
    }, function(circleBody, circleShape, circleOffset, circleAngle, lineBody, lineShape, lineOffset, lineAngle, justTest, lineRadius) {
      return this.circleLine$11(circleBody, circleShape, circleOffset, circleAngle, lineBody, lineShape, lineOffset, lineAngle, justTest, lineRadius, null);
    }, "circleLine$10", function(circleBody, circleShape, circleOffset, circleAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
      return this.circleLine$11(circleBody, circleShape, circleOffset, circleAngle, lineBody, lineShape, lineOffset, lineAngle, justTest, 0, null);
    }, "circleLine$9", "call$11", "call$10", "call$9", "get$circleLine", 18, 4, 1772, 49, 12, 1773, [], 1774, [], 1775, [], 1776, [], 1728, [], 1729, [], 1730, [], 1731, [], 1732, [], 1777, [], 1778, []],
    circleCapsule$9: [function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
      return this.circleLine$10(bi, si, xi, ai, bj, sj, xj, aj, justTest, sj.get$radius());
    }, "call$9", "get$circleCapsule", 18, 0, 1779, 1745, [], 1746, [], 1747, [], 1748, [], 1749, [], 1750, [], 1751, [], 1752, [], 1732, []],
    circleConvex$10: [function(circleBody, circleShape, circleOffset, circleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest, circleRadius) {
      var worldVertex0, worldVertex1, worldEdge, worldEdgeUnit, worldNormal, dist, worldVertex, closestEdgeProjectedPoint, candidate, candidateDist, minCandidate, verts, t1, t2, t3, found, minCandidateDistance, i, t4, v0, v1, x, candidateDistance, c, t5, y;
      if (circleRadius == null)
        circleRadius = H.interceptedTypeCast(circleShape, "$isCircle2").radius;
      worldVertex0 = $.get$Narrowphase_tmp1();
      worldVertex1 = $.get$Narrowphase_tmp2();
      worldEdge = $.get$Narrowphase_tmp3();
      worldEdgeUnit = $.get$Narrowphase_tmp4();
      worldNormal = $.get$Narrowphase_tmp5();
      $.get$Narrowphase_tmp6();
      $.get$Narrowphase_tmp7();
      $.get$Narrowphase_tmp8();
      $.get$Narrowphase_tmp9();
      dist = $.get$Narrowphase_tmp10();
      worldVertex = $.get$Narrowphase_tmp11();
      $.get$Narrowphase_tmp12();
      closestEdgeProjectedPoint = $.get$Narrowphase_tmp13();
      candidate = $.get$Narrowphase_tmp14();
      candidateDist = $.get$Narrowphase_tmp15();
      minCandidate = $.get$Narrowphase_tmp16();
      verts = convexShape.get$vertices();
      for (t1 = J.getInterceptor$asx(verts), t2 = J.getInterceptor$x(convexOffset), t3 = J.getInterceptor$x(circleOffset), found = false, minCandidateDistance = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368, i = 0; i !== J.$add$ns(t1.get$length(verts), 1);) {
        t4 = t1.get$length(verts);
        if (typeof t4 !== "number")
          return H.iae(t4);
        v0 = t1.$index(verts, C.JSInt_methods.$mod(i, t4));
        ++i;
        t4 = t1.get$length(verts);
        if (typeof t4 !== "number")
          return H.iae(t4);
        v1 = t1.$index(verts, C.JSInt_methods.$mod(i, t4));
        A.vec2_rotate(worldVertex0, v0, convexAngle);
        A.vec2_rotate(worldVertex1, v1, convexAngle);
        worldVertex0.x = J.$add$ns(worldVertex0.x, t2.get$x(convexOffset));
        worldVertex0.y = J.$add$ns(worldVertex0.y, t2.get$y(convexOffset));
        worldVertex1.x = J.$add$ns(worldVertex1.x, t2.get$x(convexOffset));
        worldVertex1.y = J.$add$ns(worldVertex1.y, t2.get$y(convexOffset));
        $.vec2_sub.call$3(worldEdge, worldVertex1, worldVertex0);
        A.vec2_normalize(worldEdgeUnit, worldEdge);
        x = worldEdgeUnit.x;
        worldNormal.x = worldEdgeUnit.y;
        worldNormal.y = J.$negate$n(x);
        t4 = J.$negate$n(circleShape.get$radius());
        candidate.x = J.$mul$ns(worldNormal.x, t4);
        candidate.y = J.$mul$ns(worldNormal.y, t4);
        candidate.x = J.$add$ns(candidate.x, t3.get$x(circleOffset));
        candidate.y = J.$add$ns(candidate.y, t3.get$y(circleOffset));
        if (this.pointInConvex$4(candidate, convexShape, convexOffset, convexAngle) !== 0) {
          $.vec2_sub.call$3(candidateDist, worldVertex0, candidate);
          candidateDistance = J.abs$0$n(J.$add$ns(J.$mul$ns(candidateDist.x, worldNormal.x), J.$mul$ns(candidateDist.y, worldNormal.y)));
          if (J.$lt$n(candidateDistance, minCandidateDistance)) {
            minCandidate.x = candidate.x;
            minCandidate.y = candidate.y;
            closestEdgeProjectedPoint.x = J.$mul$ns(worldNormal.x, candidateDistance);
            closestEdgeProjectedPoint.y = J.$mul$ns(worldNormal.y, candidateDistance);
            closestEdgeProjectedPoint.x = J.$add$ns(closestEdgeProjectedPoint.x, candidate.x);
            closestEdgeProjectedPoint.y = J.$add$ns(closestEdgeProjectedPoint.y, candidate.y);
            minCandidateDistance = candidateDistance;
            found = true;
          }
        }
      }
      if (found) {
        if (justTest === true)
          return 1;
        c = this.createContactEquation$4(circleBody, convexBody, circleShape, convexShape);
        $.vec2_sub.call$3(c.get$normalA(), minCandidate, circleOffset);
        A.vec2_normalize(c.get$normalA(), c.get$normalA());
        A.vec2_scale(c.get$contactPointA(), c.get$normalA(), circleRadius);
        A.vec2_add(c.get$contactPointA(), c.get$contactPointA(), circleOffset);
        $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), J.get$position$x(circleBody));
        $.vec2_sub.call$3(c.get$contactPointB(), closestEdgeProjectedPoint, convexOffset);
        A.vec2_add(c.get$contactPointB(), c.get$contactPointB(), convexOffset);
        $.vec2_sub.call$3(c.get$contactPointB(), c.get$contactPointB(), J.get$position$x(convexBody));
        this.contactEquations.push(c);
        if (this.enableFriction === true)
          this.frictionEquations.push(this.createFrictionFromContact$1(c));
        return 1;
      }
      if (J.$gt$n(circleRadius, 0)) {
        t4 = typeof circleRadius !== "number";
        i = 0;
        while (true) {
          t5 = t1.get$length(verts);
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (!(i < t5))
            break;
          A.vec2_rotate(worldVertex, t1.$index(verts, i), convexAngle);
          worldVertex.x = J.$add$ns(worldVertex.x, t2.get$x(convexOffset));
          worldVertex.y = J.$add$ns(worldVertex.y, t2.get$y(convexOffset));
          $.vec2_sub.call$3(dist, worldVertex, circleOffset);
          x = dist.x;
          y = dist.y;
          t5 = J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
          if (t4)
            H.throwExpression(P.ArgumentError$(circleRadius));
          if (J.$lt$n(t5, Math.pow(circleRadius, 2))) {
            if (justTest === true)
              return 1;
            c = this.createContactEquation$4(circleBody, convexBody, circleShape, convexShape);
            t1 = c.get$normalA();
            t1.x = dist.x;
            t1.y = dist.y;
            A.vec2_normalize(c.get$normalA(), c.get$normalA());
            t1 = c.get$contactPointA();
            t4 = c.get$normalA();
            t1.x = J.$mul$ns(t4.x, circleRadius);
            t1.y = J.$mul$ns(t4.y, circleRadius);
            t4 = c.get$contactPointA();
            t1 = c.get$contactPointA();
            t4.x = J.$add$ns(t1.x, t3.get$x(circleOffset));
            t4.y = J.$add$ns(t1.y, t3.get$y(circleOffset));
            $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), J.get$position$x(circleBody));
            $.vec2_sub.call$3(c.get$contactPointB(), worldVertex, convexOffset);
            t1 = c.get$contactPointB();
            t4 = c.get$contactPointB();
            t1.x = J.$add$ns(t4.x, t2.get$x(convexOffset));
            t1.y = J.$add$ns(t4.y, t2.get$y(convexOffset));
            $.vec2_sub.call$3(c.get$contactPointB(), c.get$contactPointB(), J.get$position$x(convexBody));
            this.contactEquations.push(c);
            if (this.enableFriction === true)
              this.frictionEquations.push(this.createFrictionFromContact$1(c));
            return 1;
          }
          ++i;
        }
      }
      return 0;
    }, function(circleBody, circleShape, circleOffset, circleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
      return this.circleConvex$10(circleBody, circleShape, circleOffset, circleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest, null);
    }, "circleConvex$9", "call$10", "call$9", "get$circleConvex", 18, 2, 1780, 12, 1773, [], 1774, [], 1775, [], 1776, [], 1724, [], 1725, [], 1726, [], 1727, [], 1732, [], 1778, []],
    pointInConvex$4: function(worldPoint, convexShape, convexOffset, convexAngle) {
      var worldVertex0, worldVertex1, r0, r1, verts, t1, t2, lastCross, i, t3, v0, v1, cross;
      worldVertex0 = $.get$Narrowphase_pic_worldVertex0();
      worldVertex1 = $.get$Narrowphase_pic_worldVertex1();
      r0 = $.get$Narrowphase_pic_r0();
      r1 = $.get$Narrowphase_pic_r1();
      verts = convexShape.get$vertices();
      for (t1 = J.getInterceptor$asx(verts), t2 = J.getInterceptor$x(convexOffset), lastCross = null, i = 0; i !== J.$add$ns(t1.get$length(verts), 1); lastCross = cross) {
        t3 = t1.get$length(verts);
        if (typeof t3 !== "number")
          return H.iae(t3);
        v0 = t1.$index(verts, C.JSInt_methods.$mod(i, t3));
        ++i;
        t3 = t1.get$length(verts);
        if (typeof t3 !== "number")
          return H.iae(t3);
        v1 = t1.$index(verts, C.JSInt_methods.$mod(i, t3));
        A.vec2_rotate(worldVertex0, v0, convexAngle);
        A.vec2_rotate(worldVertex1, v1, convexAngle);
        worldVertex0.x = J.$add$ns(worldVertex0.x, t2.get$x(convexOffset));
        worldVertex0.y = J.$add$ns(worldVertex0.y, t2.get$y(convexOffset));
        worldVertex1.x = J.$add$ns(worldVertex1.x, t2.get$x(convexOffset));
        worldVertex1.y = J.$add$ns(worldVertex1.y, t2.get$y(convexOffset));
        $.vec2_sub.call$3(r0, worldVertex0, worldPoint);
        $.vec2_sub.call$3(r1, worldVertex1, worldPoint);
        cross = J.$sub$n(J.$mul$ns(r0.x, r1.y), J.$mul$ns(r0.y, r1.x));
        if (J.$le$n(J.$mul$ns(cross, lastCross == null ? cross : lastCross), 0))
          return 0;
      }
      return 1;
    },
    particleConvex$9: [function(particleBody, particleShape, particleOffset, particleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
      var worldVertex0, worldVertex1, worldEdge, worldEdgeUnit, worldTangent, centerDist, convexToparticle, dist, closestEdgeProjectedPoint, candidateDist, minEdgeNormal, verts, t1, t2, t3, minCandidateDistance, found, i, t4, v0, v1, x, candidateDistance, c;
      worldVertex0 = $.get$Narrowphase_tmp1();
      worldVertex1 = $.get$Narrowphase_tmp2();
      worldEdge = $.get$Narrowphase_tmp3();
      worldEdgeUnit = $.get$Narrowphase_tmp4();
      worldTangent = $.get$Narrowphase_tmp5();
      centerDist = $.get$Narrowphase_tmp6();
      convexToparticle = $.get$Narrowphase_tmp7();
      $.get$Narrowphase_tmp8();
      $.get$Narrowphase_tmp9();
      dist = $.get$Narrowphase_tmp10();
      $.get$Narrowphase_tmp11();
      $.get$Narrowphase_tmp12();
      closestEdgeProjectedPoint = $.get$Narrowphase_tmp13();
      $.get$Narrowphase_tmp14();
      $.get$Narrowphase_tmp15();
      $.get$Narrowphase_tmp16();
      candidateDist = $.get$Narrowphase_tmp17();
      minEdgeNormal = $.get$Narrowphase_tmp18();
      verts = convexShape.get$vertices();
      if (this.pointInConvex$4(particleOffset, convexShape, convexOffset, convexAngle) === 0)
        return 0;
      if (justTest === true)
        return 1;
      for (t1 = J.getInterceptor$asx(verts), t2 = J.getInterceptor$x(convexOffset), t3 = J.getInterceptor$x(particleOffset), minCandidateDistance = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368, found = false, i = 0; i !== J.$add$ns(t1.get$length(verts), 1);) {
        t4 = t1.get$length(verts);
        if (typeof t4 !== "number")
          return H.iae(t4);
        v0 = t1.$index(verts, C.JSInt_methods.$mod(i, t4));
        ++i;
        t4 = t1.get$length(verts);
        if (typeof t4 !== "number")
          return H.iae(t4);
        v1 = t1.$index(verts, C.JSInt_methods.$mod(i, t4));
        A.vec2_rotate(worldVertex0, v0, convexAngle);
        A.vec2_rotate(worldVertex1, v1, convexAngle);
        worldVertex0.x = J.$add$ns(worldVertex0.x, t2.get$x(convexOffset));
        worldVertex0.y = J.$add$ns(worldVertex0.y, t2.get$y(convexOffset));
        worldVertex1.x = J.$add$ns(worldVertex1.x, t2.get$x(convexOffset));
        worldVertex1.y = J.$add$ns(worldVertex1.y, t2.get$y(convexOffset));
        $.vec2_sub.call$3(worldEdge, worldVertex1, worldVertex0);
        A.vec2_normalize(worldEdgeUnit, worldEdge);
        x = worldEdgeUnit.x;
        worldTangent.x = worldEdgeUnit.y;
        worldTangent.y = J.$negate$n(x);
        $.vec2_sub.call$3(dist, particleOffset, worldVertex0);
        J.$add$ns(J.$mul$ns(dist.x, worldTangent.x), J.$mul$ns(dist.y, worldTangent.y));
        $.vec2_sub.call$3(centerDist, worldVertex0, convexOffset);
        $.vec2_sub.call$3(convexToparticle, particleOffset, convexOffset);
        $.vec2_sub.call$3(candidateDist, worldVertex0, particleOffset);
        candidateDistance = J.abs$0$n(J.$add$ns(J.$mul$ns(candidateDist.x, worldTangent.x), J.$mul$ns(candidateDist.y, worldTangent.y)));
        if (J.$lt$n(candidateDistance, minCandidateDistance)) {
          closestEdgeProjectedPoint.x = J.$mul$ns(worldTangent.x, candidateDistance);
          closestEdgeProjectedPoint.y = J.$mul$ns(worldTangent.y, candidateDistance);
          closestEdgeProjectedPoint.x = J.$add$ns(closestEdgeProjectedPoint.x, t3.get$x(particleOffset));
          closestEdgeProjectedPoint.y = J.$add$ns(closestEdgeProjectedPoint.y, t3.get$y(particleOffset));
          minEdgeNormal.x = worldTangent.x;
          minEdgeNormal.y = worldTangent.y;
          minCandidateDistance = candidateDistance;
          found = true;
        }
      }
      if (found) {
        c = this.createContactEquation$4(particleBody, convexBody, particleShape, convexShape);
        A.vec2_scale(c.get$normalA(), minEdgeNormal, -1);
        A.vec2_normalize(c.get$normalA(), c.get$normalA());
        t1 = c.get$contactPointA();
        t1.x = 0;
        t1.y = 0;
        A.vec2_add(c.get$contactPointA(), c.get$contactPointA(), particleOffset);
        $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), J.get$position$x(particleBody));
        $.vec2_sub.call$3(c.get$contactPointB(), closestEdgeProjectedPoint, convexOffset);
        A.vec2_add(c.get$contactPointB(), c.get$contactPointB(), convexOffset);
        $.vec2_sub.call$3(c.get$contactPointB(), c.get$contactPointB(), J.get$position$x(convexBody));
        this.contactEquations.push(c);
        if (this.enableFriction === true)
          this.frictionEquations.push(this.createFrictionFromContact$1(c));
        return 1;
      }
      return 0;
    }, "call$9", "get$particleConvex", 18, 0, 1781, 1768, [], 1769, [], 1782, [], 1771, [], 1724, [], 1725, [], 1726, [], 1727, [], 1732, []],
    circleCircle$11: [function(bodyA, shapeA, offsetA, angleA, bodyB, shapeB, offsetB, angleB, justTest, radiusA, radiusB) {
      var dist, r, x, y, t1, c, t2, t3;
      dist = $.get$Narrowphase_tmp1();
      if (radiusA == null)
        radiusA = H.interceptedTypeCast(shapeA, "$isCircle2").radius;
      if (radiusB == null)
        radiusB = H.interceptedTypeCast(shapeB, "$isCircle2").radius;
      $.vec2_sub.call$3(dist, offsetA, offsetB);
      r = J.$add$ns(radiusA, radiusB);
      x = dist.x;
      y = dist.y;
      t1 = J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
      if (typeof r !== "number")
        H.throwExpression(P.ArgumentError$(r));
      if (J.$gt$n(t1, Math.pow(r, 2)))
        return 0;
      if (justTest === true)
        return 1;
      c = this.createContactEquation$4(bodyA, bodyB, shapeA, shapeB);
      $.vec2_sub.call$3(c.get$normalA(), offsetB, offsetA);
      A.vec2_normalize(c.get$normalA(), c.get$normalA());
      t1 = c.get$contactPointA();
      t2 = c.get$normalA();
      t1.x = J.$mul$ns(t2.x, radiusA);
      t1.y = J.$mul$ns(t2.y, radiusA);
      t2 = c.get$contactPointB();
      t1 = c.get$normalA();
      t3 = J.$negate$n(radiusB);
      t2.x = J.$mul$ns(t1.x, t3);
      t2.y = J.$mul$ns(t1.y, t3);
      t3 = c.get$contactPointA();
      t1 = c.get$contactPointA();
      t2 = J.getInterceptor$x(offsetA);
      t3.x = J.$add$ns(t1.x, t2.get$x(offsetA));
      t3.y = J.$add$ns(t1.y, t2.get$y(offsetA));
      $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), J.get$position$x(bodyA));
      t2 = c.get$contactPointB();
      t1 = c.get$contactPointB();
      t3 = J.getInterceptor$x(offsetB);
      t2.x = J.$add$ns(t1.x, t3.get$x(offsetB));
      t2.y = J.$add$ns(t1.y, t3.get$y(offsetB));
      $.vec2_sub.call$3(c.get$contactPointB(), c.get$contactPointB(), J.get$position$x(bodyB));
      this.contactEquations.push(c);
      if (this.enableFriction === true)
        this.frictionEquations.push(this.createFrictionFromContact$1(c));
      return 1;
    }, function(bodyA, shapeA, offsetA, angleA, bodyB, shapeB, offsetB, angleB, justTest) {
      return this.circleCircle$11(bodyA, shapeA, offsetA, angleA, bodyB, shapeB, offsetB, angleB, justTest, null, null);
    }, "circleCircle$9", function(bodyA, shapeA, offsetA, angleA, bodyB, shapeB, offsetB, angleB, justTest, radiusA) {
      return this.circleCircle$11(bodyA, shapeA, offsetA, angleA, bodyB, shapeB, offsetB, angleB, justTest, radiusA, null);
    }, "circleCircle$10", "call$11", "call$9", "call$10", "get$circleCircle", 18, 4, 1783, 12, 12, 1754, [], 1755, [], 1784, [], 1757, [], 1758, [], 1759, [], 1785, [], 1761, [], 1732, [], 1786, [], 1787, []],
    planeConvex$9: [function(planeBody, planeShape, planeOffset, planeAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
      var worldVertex, worldNormal, dist, t1, t2, t3, t4, numReported, i, c, t5, d;
      worldVertex = $.get$Narrowphase_tmp1();
      worldNormal = $.get$Narrowphase_tmp2();
      dist = $.get$Narrowphase_tmp3();
      A.vec2_rotate(worldNormal, $.get$Narrowphase_yAxis(), planeAngle);
      for (t1 = J.getInterceptor$x(convexOffset), t2 = J.getInterceptor$x(convexBody), t3 = J.getInterceptor$x(planeBody), t4 = justTest === true, numReported = 0, i = 0; i !== J.get$length$asx(convexShape.get$vertices()); ++i) {
        A.vec2_rotate(worldVertex, J.$index$asx(convexShape.get$vertices(), i), convexAngle);
        worldVertex.x = J.$add$ns(worldVertex.x, t1.get$x(convexOffset));
        worldVertex.y = J.$add$ns(worldVertex.y, t1.get$y(convexOffset));
        $.vec2_sub.call$3(dist, worldVertex, planeOffset);
        if (J.$le$n(J.$add$ns(J.$mul$ns(dist.x, worldNormal.x), J.$mul$ns(dist.y, worldNormal.y)), 0)) {
          if (t4)
            return 1;
          ++numReported;
          c = this.createContactEquation$4(planeBody, convexBody, planeShape, convexShape);
          $.vec2_sub.call$3(dist, worldVertex, planeOffset);
          t5 = c.get$normalA();
          t5.x = worldNormal.x;
          t5.y = worldNormal.y;
          t5 = c.get$normalA();
          d = J.$add$ns(J.$mul$ns(dist.x, t5.x), J.$mul$ns(dist.y, t5.y));
          t5 = c.get$normalA();
          dist.x = J.$mul$ns(t5.x, d);
          dist.y = J.$mul$ns(t5.y, d);
          $.vec2_sub.call$3(c.get$contactPointB(), worldVertex, t2.get$position(convexBody));
          $.vec2_sub.call$3(c.get$contactPointA(), worldVertex, dist);
          $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), t3.get$position(planeBody));
          this.contactEquations.push(c);
          if (!this.enableFrictionReduction)
            if (this.enableFriction === true)
              this.frictionEquations.push(this.createFrictionFromContact$1(c));
        }
      }
      if (this.enableFrictionReduction)
        if (this.enableFriction === true && numReported !== 0)
          this.frictionEquations.push(this.createFrictionFromAverage$1(numReported));
      return numReported;
    }, "call$9", "get$planeConvex", 18, 0, 1781, 1763, [], 1764, [], 1765, [], 1766, [], 1724, [], 1725, [], 1726, [], 1727, [], 1732, []],
    particlePlane$9: [function(particleBody, particleShape, particleOffset, particleAngle, planeBody, planeShape, planeOffset, planeAngle, justTest) {
      var dist, worldNormal, d, c;
      dist = $.get$Narrowphase_tmp1();
      worldNormal = $.get$Narrowphase_tmp2();
      $.vec2_sub.call$3(dist, particleOffset, planeOffset);
      A.vec2_rotate(worldNormal, $.get$Narrowphase_yAxis(), planeAngle);
      d = A.vec2_dot(dist, worldNormal);
      if (J.$gt$n(d, 0))
        return 0;
      if (justTest === true)
        return 1;
      c = this.createContactEquation$4(planeBody, particleBody, planeShape, particleShape);
      A.vec2_copy(c.get$normalA(), worldNormal);
      A.vec2_scale(dist, c.get$normalA(), d);
      $.vec2_sub.call$3(c.get$contactPointA(), particleOffset, dist);
      $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), J.get$position$x(planeBody));
      $.vec2_sub.call$3(c.get$contactPointB(), particleOffset, J.get$position$x(particleBody));
      this.contactEquations.push(c);
      if (this.enableFriction === true)
        this.frictionEquations.push(this.createFrictionFromContact$1(c));
      return 1;
    }, "call$9", "get$particlePlane", 18, 0, 1781, 1768, [], 1769, [], 1782, [], 1771, [], 1763, [], 1764, [], 1765, [], 1766, [], 1732, []],
    circleParticle$9: [function(circleBody, circleShape, circleOffset, circleAngle, particleBody, particleShape, particleOffset, particleAngle, justTest) {
      var dist, t1, t2, c;
      dist = $.get$Narrowphase_tmp1();
      $.vec2_sub.call$3(dist, particleOffset, circleOffset);
      t1 = A.vec2_squaredLength(dist);
      t2 = circleShape.get$radius();
      H.checkNum(t2);
      H.checkNum(2);
      if (J.$gt$n(t1, Math.pow(t2, 2)))
        return 0;
      if (justTest === true)
        return 1;
      c = this.createContactEquation$4(circleBody, particleBody, circleShape, particleShape);
      A.vec2_copy(c.get$normalA(), dist);
      A.vec2_normalize(c.get$normalA(), c.get$normalA());
      A.vec2_scale(c.get$contactPointA(), c.get$normalA(), circleShape.get$radius());
      A.vec2_add(c.get$contactPointA(), c.get$contactPointA(), circleOffset);
      $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), J.get$position$x(circleBody));
      $.vec2_sub.call$3(c.get$contactPointB(), particleOffset, J.get$position$x(particleBody));
      this.contactEquations.push(c);
      if (this.enableFriction === true)
        this.frictionEquations.push(this.createFrictionFromContact$1(c));
      return 1;
    }, "call$9", "get$circleParticle", 18, 0, 1781, 1773, [], 1774, [], 1775, [], 1776, [], 1768, [], 1769, [], 1782, [], 1771, [], 1732, []],
    planeCapsule$9: [function(planeBody, planeShape, planeOffset, planeAngle, capsuleBody, capsuleShape, capsuleOffset, capsuleAngle, justTest) {
      var end1, end2, circle, t1, enableFrictionBefore, numContacts1, numContacts2, numTotal;
      end1 = $.get$Narrowphase_planeCapsule_tmp1();
      end2 = $.get$Narrowphase_planeCapsule_tmp2();
      $.get$Narrowphase_planeCapsule_tmp3();
      circle = $.get$Narrowphase_planeCapsule_tmpCircle();
      t1 = J.getInterceptor$asx(capsuleShape);
      end1.x = J.$div$n(J.$negate$n(t1.get$length(capsuleShape)), 2);
      end1.y = 0;
      A.vec2_rotate(end1, end1, capsuleAngle);
      A.vec2_add(end1, end1, capsuleOffset);
      end2.x = J.$div$n(t1.get$length(capsuleShape), 2);
      end2.y = 0;
      A.vec2_rotate(end2, end2, capsuleAngle);
      A.vec2_add(end2, end2, capsuleOffset);
      circle.radius = capsuleShape.get$radius();
      if (this.enableFrictionReduction) {
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
      } else
        enableFrictionBefore = null;
      numContacts1 = this.circlePlane$9(capsuleBody, circle, end1, 0, planeBody, planeShape, planeOffset, planeAngle, justTest);
      numContacts2 = this.circlePlane$9(capsuleBody, circle, end2, 0, planeBody, planeShape, planeOffset, planeAngle, justTest);
      t1 = this.enableFrictionReduction;
      if (t1)
        this.enableFriction = enableFrictionBefore;
      if (justTest === true)
        return numContacts1 !== 0 || numContacts2 !== 0 ? 1 : 0;
      else {
        numTotal = numContacts1 + numContacts2;
        if (t1)
          if (numTotal !== 0)
            this.frictionEquations.push(this.createFrictionFromAverage$1(numTotal));
        return numTotal;
      }
    }, "call$9", "get$planeCapsule", 18, 0, 1781, 1763, [], 1764, [], 1765, [], 1766, [], 1740, [], 1741, [], 1788, [], 1743, [], 1732, []],
    circlePlane$9: [function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
      var planeToCircle, worldNormal, temp, d, contact;
      planeToCircle = $.get$Narrowphase_tmp1();
      worldNormal = $.get$Narrowphase_tmp2();
      temp = $.get$Narrowphase_tmp3();
      $.vec2_sub.call$3(planeToCircle, xi, xj);
      A.vec2_rotate(worldNormal, $.get$Narrowphase_yAxis(), aj);
      d = A.vec2_dot(worldNormal, planeToCircle);
      if (J.$gt$n(d, si.get$radius()))
        return 0;
      if (justTest === true)
        return 1;
      contact = this.createContactEquation$4(bj, bi, sj, si);
      A.vec2_copy(contact.get$normalA(), worldNormal);
      A.vec2_scale(contact.get$contactPointB(), contact.get$normalA(), J.$negate$n(si.get$radius()));
      A.vec2_add(contact.get$contactPointB(), contact.get$contactPointB(), xi);
      $.vec2_sub.call$3(contact.get$contactPointB(), contact.get$contactPointB(), J.get$position$x(bi));
      A.vec2_scale(temp, contact.get$normalA(), d);
      $.vec2_sub.call$3(contact.get$contactPointA(), planeToCircle, temp);
      A.vec2_add(contact.get$contactPointA(), contact.get$contactPointA(), xj);
      $.vec2_sub.call$3(contact.get$contactPointA(), contact.get$contactPointA(), J.get$position$x(bj));
      this.contactEquations.push(contact);
      if (this.enableFriction === true)
        this.frictionEquations.push(this.createFrictionFromContact$1(contact));
      return 1;
    }, "call$9", "get$circlePlane", 18, 0, 1779, 1745, [], 1746, [], 1747, [], 1748, [], 1749, [], 1750, [], 1751, [], 1752, [], 1732, []],
    convexConvex$10: [function(bi, si, xi, ai, bj, sj, xj, aj, justTest, precision) {
      var sepAxis, worldPoint, worldPoint0, worldPoint1, worldEdge, penetrationVec, dist, worldNormal, closestEdge1, closestEdge2, t1, numContacts, k, bodyB, bodyA, angleB, angleA, offsetB, offsetA, shapeB, shapeA, closestEdgeB, closestEdgeA, t2, i, t3, t4, t5, t6, t7, t8, j, t9, t10, t11, i0, insideNumEdges, v0, i1, v1, x, d, c;
      sepAxis = $.get$Narrowphase_tmp1();
      worldPoint = $.get$Narrowphase_tmp2();
      worldPoint0 = $.get$Narrowphase_tmp3();
      worldPoint1 = $.get$Narrowphase_tmp4();
      worldEdge = $.get$Narrowphase_tmp5();
      $.get$Narrowphase_tmp6();
      penetrationVec = $.get$Narrowphase_tmp7();
      dist = $.get$Narrowphase_tmp8();
      worldNormal = $.get$Narrowphase_tmp9();
      if (!A.Narrowphase_findSeparatingAxis(si, xi, ai, sj, xj, aj, sepAxis))
        return 0;
      $.vec2_sub.call$3(dist, xj, xi);
      if (J.$gt$n(J.$add$ns(J.$mul$ns(sepAxis.x, dist.x), J.$mul$ns(sepAxis.y, dist.y)), 0)) {
        sepAxis.x = J.$mul$ns(sepAxis.x, -1);
        sepAxis.y = J.$mul$ns(sepAxis.y, -1);
      }
      closestEdge1 = A.Narrowphase_getClosestEdge(si, ai, sepAxis, true);
      closestEdge2 = A.Narrowphase_getClosestEdge(sj, aj, sepAxis, false);
      if (closestEdge1 === -1 || closestEdge2 === -1)
        return 0;
      for (t1 = justTest === true, numContacts = 0, k = 0; k < 2; ++k) {
        if (k === 0) {
          bodyB = bi;
          bodyA = bj;
          angleB = ai;
          angleA = aj;
          offsetB = xi;
          offsetA = xj;
          shapeB = si;
          shapeA = sj;
          closestEdgeB = closestEdge1;
          closestEdgeA = closestEdge2;
        } else {
          bodyB = bj;
          bodyA = bi;
          angleB = aj;
          angleA = ai;
          offsetB = xj;
          offsetA = xi;
          shapeB = sj;
          shapeA = si;
          closestEdgeB = closestEdge2;
          closestEdgeA = closestEdge1;
        }
        for (t2 = closestEdgeB + 2, i = closestEdgeA - 1, t3 = closestEdgeA + 2, t4 = J.getInterceptor$x(offsetA), t5 = J.getInterceptor$x(offsetB), t6 = closestEdgeA + 1, t7 = J.getInterceptor$x(bodyA), t8 = J.getInterceptor$x(bodyB), j = closestEdgeB; j < t2; ++j) {
          t9 = shapeB.get$vertices();
          t10 = J.get$length$asx(shapeB.get$vertices());
          if (typeof t10 !== "number")
            return H.iae(t10);
          t11 = J.get$length$asx(shapeB.get$vertices());
          if (typeof t11 !== "number")
            return H.iae(t11);
          A.vec2_rotate(worldPoint, J.$index$asx(t9, C.JSNumber_methods.$mod(j + t10, t11)), angleB);
          worldPoint.x = J.$add$ns(worldPoint.x, t5.get$x(offsetB));
          worldPoint.y = J.$add$ns(worldPoint.y, t5.get$y(offsetB));
          for (i0 = i, insideNumEdges = 0; i0 < t3; i0 = i1) {
            t9 = shapeA.get$vertices();
            t10 = J.get$length$asx(shapeA.get$vertices());
            if (typeof t10 !== "number")
              return H.iae(t10);
            t11 = J.get$length$asx(shapeA.get$vertices());
            if (typeof t11 !== "number")
              return H.iae(t11);
            v0 = J.$index$asx(t9, C.JSNumber_methods.$mod(i0 + t10, t11));
            t11 = shapeA.get$vertices();
            i1 = i0 + 1;
            t10 = J.get$length$asx(shapeA.get$vertices());
            if (typeof t10 !== "number")
              return H.iae(t10);
            t9 = J.get$length$asx(shapeA.get$vertices());
            if (typeof t9 !== "number")
              return H.iae(t9);
            v1 = J.$index$asx(t11, C.JSNumber_methods.$mod(i1 + t10, t9));
            A.vec2_rotate(worldPoint0, v0, angleA);
            A.vec2_rotate(worldPoint1, v1, angleA);
            worldPoint0.x = J.$add$ns(worldPoint0.x, t4.get$x(offsetA));
            worldPoint0.y = J.$add$ns(worldPoint0.y, t4.get$y(offsetA));
            worldPoint1.x = J.$add$ns(worldPoint1.x, t4.get$x(offsetA));
            worldPoint1.y = J.$add$ns(worldPoint1.y, t4.get$y(offsetA));
            $.vec2_sub.call$3(worldEdge, worldPoint1, worldPoint0);
            x = worldEdge.x;
            worldNormal.x = worldEdge.y;
            worldNormal.y = J.$negate$n(x);
            A.vec2_normalize(worldNormal, worldNormal);
            $.vec2_sub.call$3(dist, worldPoint, worldPoint0);
            d = J.$add$ns(J.$mul$ns(worldNormal.x, dist.x), J.$mul$ns(worldNormal.y, dist.y));
            t9 = i0 === closestEdgeA;
            if (!(t9 && J.$le$n(d, precision)))
              t9 = !t9 && J.$le$n(d, 0);
            else
              t9 = true;
            if (t9)
              ++insideNumEdges;
          }
          if (insideNumEdges >= 3) {
            if (t1)
              return 1;
            c = this.createContactEquation$4(bodyA, bodyB, shapeA, shapeB);
            ++numContacts;
            t9 = shapeA.get$vertices();
            t10 = J.get$length$asx(shapeA.get$vertices());
            if (typeof t10 !== "number")
              return H.iae(t10);
            v0 = J.$index$asx(t9, C.JSNumber_methods.$mod(closestEdgeA, t10));
            t10 = shapeA.get$vertices();
            t9 = J.get$length$asx(shapeA.get$vertices());
            if (typeof t9 !== "number")
              return H.iae(t9);
            v1 = J.$index$asx(t10, C.JSNumber_methods.$mod(t6, t9));
            A.vec2_rotate(worldPoint0, v0, angleA);
            A.vec2_rotate(worldPoint1, v1, angleA);
            worldPoint0.x = J.$add$ns(worldPoint0.x, t4.get$x(offsetA));
            worldPoint0.y = J.$add$ns(worldPoint0.y, t4.get$y(offsetA));
            worldPoint1.x = J.$add$ns(worldPoint1.x, t4.get$x(offsetA));
            worldPoint1.y = J.$add$ns(worldPoint1.y, t4.get$y(offsetA));
            $.vec2_sub.call$3(worldEdge, worldPoint1, worldPoint0);
            t9 = c.get$normalA();
            x = worldEdge.x;
            t9.x = worldEdge.y;
            t9.y = J.$negate$n(x);
            A.vec2_normalize(c.get$normalA(), c.get$normalA());
            $.vec2_sub.call$3(dist, worldPoint, worldPoint0);
            t9 = c.get$normalA();
            d = J.$add$ns(J.$mul$ns(t9.x, dist.x), J.$mul$ns(t9.y, dist.y));
            t9 = c.get$normalA();
            penetrationVec.x = J.$mul$ns(t9.x, d);
            penetrationVec.y = J.$mul$ns(t9.y, d);
            $.vec2_sub.call$3(c.get$contactPointA(), worldPoint, offsetA);
            $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), penetrationVec);
            t9 = c.get$contactPointA();
            t10 = c.get$contactPointA();
            t9.x = J.$add$ns(t10.x, t4.get$x(offsetA));
            t9.y = J.$add$ns(t10.y, t4.get$y(offsetA));
            $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), t7.get$position(bodyA));
            $.vec2_sub.call$3(c.get$contactPointB(), worldPoint, offsetB);
            t10 = c.get$contactPointB();
            t9 = c.get$contactPointB();
            t10.x = J.$add$ns(t9.x, t5.get$x(offsetB));
            t10.y = J.$add$ns(t9.y, t5.get$y(offsetB));
            $.vec2_sub.call$3(c.get$contactPointB(), c.get$contactPointB(), t8.get$position(bodyB));
            this.contactEquations.push(c);
            if (!this.enableFrictionReduction)
              if (this.enableFriction === true)
                this.frictionEquations.push(this.createFrictionFromContact$1(c));
          }
        }
      }
      if (this.enableFrictionReduction)
        if (this.enableFriction === true && numContacts !== 0)
          this.frictionEquations.push(this.createFrictionFromAverage$1(numContacts));
      return numContacts;
    }, function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
      return this.convexConvex$10(bi, si, xi, ai, bj, sj, xj, aj, justTest, 0);
    }, "convexConvex$9", "call$10", "call$9", "get$convexConvex", 18, 2, 1789, 49, 1745, [], 1746, [], 1747, [], 1748, [], 1749, [], 1750, [], 1751, [], 1752, [], 1732, [], 1790, []],
    circleHeightfield$10: [function(circleBody, circleShape, circlePos, circleAngle, hfBody, hfShape, hfPos, hfAngle, justTest, radius) {
      var data, w, dist, candidate, minCandidate, minCandidateNormal, worldNormal, v0, v1, t1, t2, idxA, idxB, t3, t4, max, min, i, t5, t6, t7, found, t8, t9, d, c, t10, x, y, t11;
      data = J.get$data$x(hfShape);
      w = hfShape.get$elementWidth();
      dist = $.get$Narrowphase_circleHeightfield_dist();
      candidate = $.get$Narrowphase_circleHeightfield_candidate();
      minCandidate = $.get$Narrowphase_circleHeightfield_minCandidate();
      minCandidateNormal = $.get$Narrowphase_circleHeightfield_minCandidateNormal();
      worldNormal = $.get$Narrowphase_circleHeightfield_worldNormal();
      v0 = $.get$Narrowphase_circleHeightfield_v0();
      v1 = $.get$Narrowphase_circleHeightfield_v1();
      if (radius == null)
        radius = circleShape.get$radius();
      t1 = J.getInterceptor$x(circlePos);
      t2 = J.getInterceptor$x(hfPos);
      idxA = J.floor$0$n(J.$div$n(J.$sub$n(J.$sub$n(t1.get$x(circlePos), radius), t2.get$x(hfPos)), w));
      idxB = J.ceil$0$n(J.$div$n(J.$sub$n(J.$add$ns(t1.get$x(circlePos), radius), t2.get$x(hfPos)), w));
      if (idxA < 0)
        idxA = 0;
      t3 = J.getInterceptor$asx(data);
      t4 = t3.get$length(data);
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (idxB >= t4)
        idxB = J.$sub$n(t3.get$length(data), 1);
      max = t3.$index(data, idxA);
      min = t3.$index(data, idxB);
      if (typeof idxB !== "number")
        return H.iae(idxB);
      i = idxA;
      for (; i < idxB; ++i) {
        if (J.$lt$n(t3.$index(data, i), min))
          min = t3.$index(data, i);
        if (J.$gt$n(t3.$index(data, i), max))
          max = t3.$index(data, i);
      }
      if (J.$gt$n(J.$sub$n(t1.get$y(circlePos), radius), max))
        return justTest === true ? false : 0;
      for (t4 = J.getInterceptor$n(radius), t5 = J.getInterceptor$x(circleBody), t6 = J.getInterceptor$x(hfBody), t7 = justTest === true, i = idxA, found = false; i < idxB;) {
        t8 = C.JSInt_methods.$mul(i, w);
        t9 = t3.$index(data, i);
        v0.x = t8;
        v0.y = t9;
        ++i;
        t9 = C.JSInt_methods.$mul(i, w);
        t8 = t3.$index(data, i);
        v1.x = t9;
        v1.y = t8;
        v0.x = J.$add$ns(v0.x, t2.get$x(hfPos));
        v0.y = J.$add$ns(v0.y, t2.get$y(hfPos));
        v1.x = J.$add$ns(v1.x, t2.get$x(hfPos));
        v1.y = J.$add$ns(v1.y, t2.get$y(hfPos));
        $.vec2_sub.call$3(worldNormal, v1, v0);
        A.vec2_rotate(worldNormal, worldNormal, 1.5707963267948966);
        A.vec2_normalize(worldNormal, worldNormal);
        t8 = t4.$negate(radius);
        candidate.x = J.$mul$ns(worldNormal.x, t8);
        candidate.y = J.$mul$ns(worldNormal.y, t8);
        candidate.x = J.$add$ns(candidate.x, t1.get$x(circlePos));
        candidate.y = J.$add$ns(candidate.y, t1.get$y(circlePos));
        $.vec2_sub.call$3(dist, candidate, v0);
        d = J.$add$ns(J.$mul$ns(dist.x, worldNormal.x), J.$mul$ns(dist.y, worldNormal.y));
        if (J.$ge$n(candidate.x, v0.x) && J.$lt$n(candidate.x, v1.x) && J.$le$n(d, 0)) {
          if (t7)
            return 1;
          t8 = J.$negate$n(d);
          dist.x = J.$mul$ns(worldNormal.x, t8);
          dist.y = J.$mul$ns(worldNormal.y, t8);
          minCandidate.x = J.$add$ns(candidate.x, dist.x);
          minCandidate.y = J.$add$ns(candidate.y, dist.y);
          minCandidateNormal.x = worldNormal.x;
          minCandidateNormal.y = worldNormal.y;
          c = this.createContactEquation$4(hfBody, circleBody, hfShape, circleShape);
          t8 = c.get$normalA();
          t8.x = minCandidateNormal.x;
          t8.y = minCandidateNormal.y;
          t8 = c.get$contactPointB();
          t9 = c.get$normalA();
          t10 = t4.$negate(radius);
          t8.x = J.$mul$ns(t9.x, t10);
          t8.y = J.$mul$ns(t9.y, t10);
          t10 = c.get$contactPointB();
          t9 = c.get$contactPointB();
          t10.x = J.$add$ns(t9.x, t1.get$x(circlePos));
          t10.y = J.$add$ns(t9.y, t1.get$y(circlePos));
          $.vec2_sub.call$3(c.get$contactPointB(), c.get$contactPointB(), t5.get$position(circleBody));
          t9 = c.get$contactPointA();
          t9.x = minCandidate.x;
          t9.y = minCandidate.y;
          $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), t6.get$position(hfBody));
          this.contactEquations.push(c);
          if (this.enableFriction === true)
            this.frictionEquations.push(this.createFrictionFromContact$1(c));
          found = true;
        }
      }
      if (t4.$gt(radius, 0))
        for (t8 = typeof radius !== "number", i = idxA, found = false; i <= idxB; ++i) {
          t9 = C.JSInt_methods.$mul(i, w);
          t10 = t3.$index(data, i);
          v0.x = t9;
          v0.y = t10;
          t10 = t2.get$x(hfPos);
          if (typeof t10 !== "number")
            return H.iae(t10);
          v0.x = t9 + t10;
          v0.y = J.$add$ns(v0.y, t2.get$y(hfPos));
          $.vec2_sub.call$3(dist, circlePos, v0);
          x = dist.x;
          y = dist.y;
          t9 = J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
          if (t8)
            H.throwExpression(P.ArgumentError$(radius));
          if (J.$lt$n(t9, Math.pow(radius, 2))) {
            if (t7)
              return 1;
            c = this.createContactEquation$4(hfBody, circleBody, hfShape, circleShape);
            t9 = c.get$normalA();
            t9.x = dist.x;
            t9.y = dist.y;
            A.vec2_normalize(c.get$normalA(), c.get$normalA());
            t9 = c.get$contactPointB();
            t10 = c.get$normalA();
            t11 = t4.$negate(radius);
            t9.x = J.$mul$ns(t10.x, t11);
            t9.y = J.$mul$ns(t10.y, t11);
            t11 = c.get$contactPointB();
            t10 = c.get$contactPointB();
            t11.x = J.$add$ns(t10.x, t1.get$x(circlePos));
            t11.y = J.$add$ns(t10.y, t1.get$y(circlePos));
            $.vec2_sub.call$3(c.get$contactPointB(), c.get$contactPointB(), t5.get$position(circleBody));
            $.vec2_sub.call$3(c.get$contactPointA(), v0, hfPos);
            t10 = c.get$contactPointA();
            t11 = c.get$contactPointA();
            t10.x = J.$add$ns(t11.x, t2.get$x(hfPos));
            t10.y = J.$add$ns(t11.y, t2.get$y(hfPos));
            $.vec2_sub.call$3(c.get$contactPointA(), c.get$contactPointA(), t6.get$position(hfBody));
            this.contactEquations.push(c);
            if (this.enableFriction === true)
              this.frictionEquations.push(this.createFrictionFromContact$1(c));
            found = true;
          }
        }
      else
        found = false;
      if (found)
        return 1;
      return 0;
    }, function(circleBody, circleShape, circlePos, circleAngle, hfBody, hfShape, hfPos, hfAngle, justTest) {
      return this.circleHeightfield$10(circleBody, circleShape, circlePos, circleAngle, hfBody, hfShape, hfPos, hfAngle, justTest, null);
    }, "circleHeightfield$9", "call$10", "call$9", "get$circleHeightfield", 18, 2, 1791, 12, 1773, [], 1774, [], 1792, [], 1776, [], 1793, [], 1794, [], 1795, [], 1796, [], 1732, [], 50, []],
    convexHeightfield$9: [function(convexBody, convexShape, convexPos, convexAngle, hfBody, hfShape, hfPos, hfAngle, justTest) {
      var data, w, v0, v1, tilePos, tileConvex, t1, t2, idxA, idxB, t3, max, min, i, numContacts, t4, t5, t6, t7;
      data = J.get$data$x(hfShape);
      w = hfShape.get$elementWidth();
      v0 = $.get$Narrowphase_convexHeightfield_v0();
      v1 = $.get$Narrowphase_convexHeightfield_v1();
      tilePos = $.get$Narrowphase_convexHeightfield_tilePos();
      tileConvex = $.get$Narrowphase_convexHeightfield_tempConvexShape();
      t1 = convexBody.get$aabb();
      t2 = J.getInterceptor$x(hfPos);
      idxA = J.floor$0$n(J.$div$n(J.$sub$n(t1.get$lowerBound(t1).x, t2.get$x(hfPos)), w));
      t1 = convexBody.get$aabb();
      idxB = J.ceil$0$n(J.$div$n(J.$sub$n(t1.get$upperBound(t1).x, t2.get$x(hfPos)), w));
      if (idxA < 0)
        idxA = 0;
      t1 = J.getInterceptor$asx(data);
      t3 = t1.get$length(data);
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (idxB >= t3)
        idxB = J.$sub$n(t1.get$length(data), 1);
      max = t1.$index(data, idxA);
      min = t1.$index(data, idxB);
      if (typeof idxB !== "number")
        return H.iae(idxB);
      i = idxA;
      for (; i < idxB; ++i) {
        if (J.$lt$n(t1.$index(data, i), min))
          min = t1.$index(data, i);
        if (J.$gt$n(t1.$index(data, i), max))
          max = t1.$index(data, i);
      }
      t3 = convexBody.get$aabb();
      if (J.$gt$n(t3.get$lowerBound(t3).y, max))
        return 0;
      for (i = idxA, numContacts = 0; i < idxB;) {
        t3 = C.JSInt_methods.$mul(i, w);
        t4 = t1.$index(data, i);
        v0.x = t3;
        v0.y = t4;
        ++i;
        t4 = C.JSInt_methods.$mul(i, w);
        t3 = t1.$index(data, i);
        v1.x = t4;
        v1.y = t3;
        v0.x = J.$add$ns(v0.x, t2.get$x(hfPos));
        v0.y = J.$add$ns(v0.y, t2.get$y(hfPos));
        v1.x = J.$add$ns(v1.x, t2.get$x(hfPos));
        v1.y = J.$add$ns(v1.y, t2.get$y(hfPos));
        t3 = J.$mul$ns(J.$add$ns(v1.x, v0.x), 0.5);
        t4 = J.$mul$ns(J.$sub$n(J.$add$ns(v1.y, v0.y), 100), 0.5);
        tilePos.x = t3;
        tilePos.y = t4;
        t4 = $.vec2_sub;
        t3 = tileConvex.vertices;
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        t4.call$3(t3[0], v1, tilePos);
        t4 = $.vec2_sub;
        if (1 >= t3.length)
          return H.ioore(t3, 1);
        t4.call$3(t3[1], v0, tilePos);
        if (2 >= t3.length)
          return H.ioore(t3, 2);
        t4 = t3[2];
        t5 = t3[1];
        t6 = J.getInterceptor$x(t5);
        t7 = J.getInterceptor$x(t4);
        t7.set$x(t4, t6.get$x(t5));
        t7.set$y(t4, t6.get$y(t5));
        if (3 >= t3.length)
          return H.ioore(t3, 3);
        t5 = t3[3];
        t6 = t3[0];
        t4 = J.getInterceptor$x(t6);
        t7 = J.getInterceptor$x(t5);
        t7.set$x(t5, t4.get$x(t6));
        t7.set$y(t5, t4.get$y(t6));
        if (2 >= t3.length)
          return H.ioore(t3, 2);
        t6 = t3[2];
        t4 = J.getInterceptor$x(t6);
        t4.set$y(t6, J.$sub$n(t4.get$y(t6), 100));
        if (3 >= t3.length)
          return H.ioore(t3, 3);
        t3 = t3[3];
        t6 = J.getInterceptor$x(t3);
        t6.set$y(t3, J.$sub$n(t6.get$y(t3), 100));
        numContacts += this.convexConvex$9(convexBody, convexShape, convexPos, convexAngle, hfBody, tileConvex, tilePos, 0, justTest);
      }
      return numContacts;
    }, "call$9", "get$convexHeightfield", 18, 0, 1797, 1724, [], 1725, [], 1798, [], 1727, [], 1793, [], 1794, [], 1795, [], 1796, [], 1732, []],
    Narrowphase$0: function() {
      var t1, t2;
      this.contactEquations = H.setRuntimeTypeInfo([], [A.ContactEquation]);
      this.frictionEquations = H.setRuntimeTypeInfo([], [A.FrictionEquation]);
      this.enableFriction = true;
      this.slipForce = 10;
      this.frictionCoefficient = 0.3;
      this.surfaceVelocity = 0;
      this.reuseObjects = true;
      this.reusableContactEquations = H.setRuntimeTypeInfo([], [A.ContactEquation]);
      this.reusableFrictionEquations = H.setRuntimeTypeInfo([], [A.FrictionEquation]);
      this.restitution = 0;
      this.stiffness = 1000000;
      this.relaxation = 4;
      this.frictionStiffness = 1000000;
      this.frictionRelaxation = 4;
      this.enableFrictionReduction = true;
      this.collidingBodiesLastStep = A.TupleDictionary$(null);
      this.contactSkinSize = 0.01;
      t1 = this.compareMap;
      t1.$indexSet(0, 24, this.get$convexLine());
      t1.$indexSet(0, 48, this.get$lineRectangle());
      t2 = this.get$convexCapsule();
      t1.$indexSet(0, 96, t2);
      t1.$indexSet(0, 72, t2);
      t1.$indexSet(0, 64, this.get$capsuleCapsule());
      t1.$indexSet(0, 16, this.get$lineLine());
      t1.$indexSet(0, 20, this.get$planeLine());
      t1.$indexSet(0, 66, this.get$particleCapsule());
      t1.$indexSet(0, 17, this.get$circleLine());
      t1.$indexSet(0, 65, this.get$circleCapsule());
      t2 = this.get$circleConvex();
      t1.$indexSet(0, 33, t2);
      t1.$indexSet(0, 9, t2);
      t2 = this.get$particleConvex();
      t1.$indexSet(0, 34, t2);
      t1.$indexSet(0, 10, t2);
      t1.$indexSet(0, 1, this.get$circleCircle());
      t2 = this.get$planeConvex();
      t1.$indexSet(0, 36, t2);
      t1.$indexSet(0, 12, t2);
      t1.$indexSet(0, 6, this.get$particlePlane());
      t1.$indexSet(0, 3, this.get$circleParticle());
      t1.$indexSet(0, 68, this.get$planeCapsule());
      t1.$indexSet(0, 5, this.get$circlePlane());
      t2 = this.get$convexConvex();
      t1.$indexSet(0, 32, t2);
      t1.$indexSet(0, 40, t2);
      t1.$indexSet(0, 8, t2);
      t1.$indexSet(0, 129, this.get$circleHeightfield());
      t2 = this.get$convexHeightfield();
      t1.$indexSet(0, 136, t2);
      t1.$indexSet(0, 160, t2);
    },
    static: {"^": "Narrowphase_yAxis,Narrowphase_tmp1,Narrowphase_tmp2,Narrowphase_tmp3,Narrowphase_tmp4,Narrowphase_tmp5,Narrowphase_tmp6,Narrowphase_tmp7,Narrowphase_tmp8,Narrowphase_tmp9,Narrowphase_tmp10,Narrowphase_tmp11,Narrowphase_tmp12,Narrowphase_tmp13,Narrowphase_tmp14,Narrowphase_tmp15,Narrowphase_tmp16,Narrowphase_tmp17,Narrowphase_tmp18,Narrowphase_tmpArray,Narrowphase_convexCapsule_tempRect,Narrowphase_convexCapsule_tempVec,Narrowphase_capsuleCapsule_tempVec1,Narrowphase_capsuleCapsule_tempVec2,Narrowphase_capsuleCapsule_tempRect1,Narrowphase_pic_worldVertex0,Narrowphase_pic_worldVertex1,Narrowphase_pic_r0,Narrowphase_pic_r1,Narrowphase_planeCapsule_tmpCircle,Narrowphase_planeCapsule_tmp1,Narrowphase_planeCapsule_tmp2,Narrowphase_planeCapsule_tmp3,Narrowphase_pcoa_tmp1,Narrowphase_fsa_tmp1,Narrowphase_fsa_tmp2,Narrowphase_fsa_tmp3,Narrowphase_fsa_tmp4,Narrowphase_fsa_tmp5,Narrowphase_fsa_tmp6,Narrowphase_gce_tmp1,Narrowphase_gce_tmp2,Narrowphase_gce_tmp3,Narrowphase_circleHeightfield_candidate,Narrowphase_circleHeightfield_dist,Narrowphase_circleHeightfield_v0,Narrowphase_circleHeightfield_v1,Narrowphase_circleHeightfield_minCandidate,Narrowphase_circleHeightfield_worldNormal,Narrowphase_circleHeightfield_minCandidateNormal,Narrowphase_convexHeightfield_v0,Narrowphase_convexHeightfield_v1,Narrowphase_convexHeightfield_tilePos,Narrowphase_convexHeightfield_tempConvexShape", Narrowphase_projectConvexOntoAxis: function(convexShape, convexOffset, convexAngle, worldAxis, result) {
        var localAxis, max, min, i, t1, v, value, t0, offset, t2;
        localAxis = $.get$Narrowphase_pcoa_tmp1();
        A.vec2_rotate(localAxis, worldAxis, J.$negate$n(convexAngle));
        max = null;
        min = null;
        i = 0;
        while (true) {
          t1 = J.get$length$asx(convexShape.get$vertices());
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          v = J.$index$asx(convexShape.get$vertices(), i);
          t1 = J.getInterceptor$x(v);
          value = J.$add$ns(J.$mul$ns(t1.get$x(v), localAxis.x), J.$mul$ns(t1.get$y(v), localAxis.y));
          if (max == null || J.$gt$n(value, max))
            max = value;
          if (min == null || J.$lt$n(value, min))
            min = value;
          ++i;
        }
        if (J.$gt$n(min, max)) {
          t0 = min;
          min = max;
          max = t0;
        }
        t1 = J.getInterceptor$x(convexOffset);
        offset = J.$add$ns(J.$mul$ns(t1.get$x(convexOffset), worldAxis.x), J.$mul$ns(t1.get$y(convexOffset), worldAxis.y));
        t1 = J.$add$ns(min, offset);
        t2 = J.$add$ns(max, offset);
        result.x = t1;
        result.y = t2;
      }, Narrowphase_findSeparatingAxis: function(c1, offset1, angle1, c2, offset2, angle2, sepAxis) {
        var edge, worldPoint0, worldPoint1, normal, span1, span2, maxDist, overlap, found, j, angle, t1, i, b, a, dist, t2, c, x;
        edge = $.get$Narrowphase_fsa_tmp1();
        worldPoint0 = $.get$Narrowphase_fsa_tmp2();
        worldPoint1 = $.get$Narrowphase_fsa_tmp3();
        normal = $.get$Narrowphase_fsa_tmp4();
        span1 = $.get$Narrowphase_fsa_tmp5();
        span2 = $.get$Narrowphase_fsa_tmp6();
        if (!!J.getInterceptor(c1).$isRectangle2 && !!J.getInterceptor(c2).$isRectangle2)
          for (maxDist = null, overlap = false, found = false, j = 0; j !== 2; ++j) {
            angle = j === 1 ? angle2 : angle1;
            for (t1 = J.getInterceptor(angle), i = 0; i !== 2; ++i) {
              if (i === 0) {
                normal.x = 0;
                normal.y = 1;
              } else if (i === 1) {
                normal.x = 1;
                normal.y = 0;
              }
              if (!t1.$eq(angle, 0))
                A.vec2_rotate(normal, normal, angle);
              A.Narrowphase_projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
              A.Narrowphase_projectConvexOntoAxis(c2, offset2, angle2, normal, span2);
              if (J.$gt$n(span1.x, span2.x)) {
                b = span1;
                a = span2;
              } else {
                b = span2;
                a = span1;
              }
              dist = J.$sub$n(b.x, a.y);
              t2 = J.getInterceptor$n(dist);
              overlap = t2.$le(dist, 0);
              if (maxDist == null || t2.$gt(dist, maxDist)) {
                sepAxis.x = normal.x;
                sepAxis.y = normal.y;
                found = overlap;
                maxDist = dist;
              }
            }
          }
        else
          for (maxDist = null, overlap = false, found = false, j = 0; j !== 2; ++j) {
            if (j === 1) {
              angle = angle2;
              c = c2;
            } else {
              angle = angle1;
              c = c1;
            }
            for (i = 0; i !== J.get$length$asx(c.get$vertices());) {
              A.vec2_rotate(worldPoint0, J.$index$asx(c.get$vertices(), i), angle);
              t1 = c.get$vertices();
              ++i;
              t2 = J.get$length$asx(c.get$vertices());
              if (typeof t2 !== "number")
                return H.iae(t2);
              A.vec2_rotate(worldPoint1, J.$index$asx(t1, C.JSInt_methods.$mod(i, t2)), angle);
              $.vec2_sub.call$3(edge, worldPoint1, worldPoint0);
              x = edge.x;
              normal.x = edge.y;
              normal.y = J.$negate$n(x);
              A.vec2_normalize(normal, normal);
              A.Narrowphase_projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
              A.Narrowphase_projectConvexOntoAxis(c2, offset2, angle2, normal, span2);
              if (J.$gt$n(span1.x, span2.x)) {
                b = span1;
                a = span2;
              } else {
                b = span2;
                a = span1;
              }
              dist = J.$sub$n(b.x, a.y);
              t1 = J.getInterceptor$n(dist);
              overlap = t1.$le(dist, 0);
              if (maxDist == null || t1.$gt(dist, maxDist)) {
                sepAxis.x = normal.x;
                sepAxis.y = normal.y;
                found = overlap;
                maxDist = dist;
              }
            }
          }
        return found;
      }, Narrowphase_getClosestEdge: function(c, angle, axis, flip) {
        var localAxis, edge, normal, $N, closestEdge, maxDot, i, t1, t2, i0, t3, closestEdge0, x, d;
        localAxis = $.get$Narrowphase_gce_tmp1();
        edge = $.get$Narrowphase_gce_tmp2();
        normal = $.get$Narrowphase_gce_tmp3();
        A.vec2_rotate(localAxis, axis, J.$negate$n(angle));
        if (flip)
          A.vec2_scale(localAxis, localAxis, -1);
        $N = J.get$length$asx(c.get$vertices());
        for (closestEdge = -1, maxDot = -1, i = 0; i !== $N; i = i0) {
          t1 = $.vec2_sub;
          t2 = c.get$vertices();
          i0 = i + 1;
          if (typeof $N !== "number")
            return H.iae($N);
          t2 = J.$index$asx(t2, C.JSInt_methods.$mod(i0, $N));
          t3 = c.get$vertices();
          closestEdge0 = C.JSInt_methods.$mod(i, $N);
          t1.call$3(edge, t2, J.$index$asx(t3, closestEdge0));
          x = edge.x;
          normal.x = edge.y;
          normal.y = J.$negate$n(x);
          A.vec2_normalize(normal, normal);
          d = J.$add$ns(J.$mul$ns(normal.x, localAxis.x), J.$mul$ns(normal.y, localAxis.y));
          if (closestEdge === -1 || J.$gt$n(d, maxDot)) {
            maxDot = d;
            closestEdge = closestEdge0;
          }
        }
        return closestEdge;
      }}
  },
  SAPBroadphase: {
    "^": "Broadphase;axisList,axisIndex,_addBodyHandler,_removeBodyHandler,type,result,world,boundingVolumeType",
    setWorld$1: function(world) {
      C.JSArray_methods.set$length(this.axisList, 0);
      C.JSArray_methods.addAll$1(this.axisList, world.bodies);
      world.off$2("addBody", this._addBodyHandler).off$2("removeBody", this._removeBodyHandler);
      world.on$2(0, "addBody", this._addBodyHandler).on$2(0, "removeBody", this._removeBodyHandler);
      this.world = world;
    },
    getCollisionPairs$1: function(world) {
      var bodies, result, axisIndex, l, l0, b, $N, t1, i, bi, j, t2, j0, bj, t3, t4, overlaps, x, y, d2, r, result0, l1, u1, l2, u2;
      bodies = this.axisList;
      result = this.result;
      axisIndex = this.axisIndex;
      C.JSArray_methods.set$length(result, 0);
      l = bodies.length;
      for (; l0 = l - 1, l > 0; l = l0) {
        if (l0 < 0 || l0 >= bodies.length)
          return H.ioore(bodies, l0);
        b = bodies[l0];
        if (b.get$aabbNeedsUpdate())
          b.updateAABB$0();
      }
      A.SAPBroadphase_sortAxisList(bodies, axisIndex);
      for ($N = (bodies.length | 0) >>> 0, t1 = axisIndex === 0, i = 0; i !== $N; i = j) {
        if (i >= bodies.length)
          return H.ioore(bodies, i);
        bi = bodies[i];
        for (j = i + 1, t2 = J.getInterceptor$x(bi), j0 = j; j0 < $N; ++j0) {
          if (j0 >= bodies.length)
            return H.ioore(bodies, j0);
          bj = bodies[j0];
          if (t1) {
            t3 = bj.get$aabb();
            t3 = t3.get$lowerBound(t3).x;
            t4 = bi.get$aabb();
            overlaps = J.$le$n(t3, t4.get$upperBound(t4).x);
          } else {
            t3 = bj.get$aabb();
            t3 = t3.get$lowerBound(t3).y;
            t4 = bi.get$aabb();
            overlaps = J.$le$n(t3, t4.get$upperBound(t4).y);
          }
          if (!overlaps)
            break;
          if (A.Broadphase_canCollide(bi, bj)) {
            t3 = this.boundingVolumeType;
            switch (t3) {
              case 2:
                $.vec2_sub.call$3($.get$Broadphase_dist(), t2.get$position(bi), J.get$position$x(bj));
                t3 = $.get$Broadphase_dist();
                x = t3.x;
                y = t3.y;
                d2 = J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
                r = J.$add$ns(bi.get$boundingRadius(), bj.get$boundingRadius());
                result0 = J.$le$n(d2, J.$mul$ns(r, r));
                break;
              case 1:
                t3 = bi.getAABB$0();
                t4 = bj.getAABB$0();
                l1 = t3.lowerBound;
                u1 = t3.upperBound;
                l2 = t4.lowerBound;
                u2 = t4.upperBound;
                if (!(J.$le$n(l2.x, u1.x) && J.$le$n(u1.x, u2.x)))
                  t3 = J.$le$n(l1.x, u2.x) && J.$le$n(u2.x, u1.x);
                else
                  t3 = true;
                if (t3)
                  if (!(J.$le$n(l2.y, u1.y) && J.$le$n(u1.y, u2.y))) {
                    t3 = J.$le$n(l1.y, u2.y) && J.$le$n(u2.y, u1.y);
                    result0 = t3;
                  } else
                    result0 = true;
                else
                  result0 = false;
                break;
              default:
                H.throwExpression(P.Exception_Exception("Bounding volume type not recognized: " + t3));
                result0 = null;
            }
            t3 = result0 === true;
          } else
            t3 = false;
          if (t3)
            C.JSArray_methods.addAll$1(result, [bi, bj]);
        }
      }
      return result;
    },
    SAPBroadphase$0: function() {
      this.axisList = H.setRuntimeTypeInfo([], [A.Body3]);
      this.axisIndex = 0;
      this._addBodyHandler = new A.SAPBroadphase_closure(this);
      this._removeBodyHandler = new A.SAPBroadphase_closure0(this);
    },
    static: {SAPBroadphase$: function() {
        var t1 = new A.SAPBroadphase(null, null, null, null, null, null, null, null);
        t1.Broadphase$1(2);
        t1.SAPBroadphase$0();
        return t1;
      }, SAPBroadphase_sortAxisList: function(a, axisIndex) {
        var l, t1, t2, i, v, j, t3, t4;
        for (l = a.length, t1 = axisIndex === 0, t2 = l, i = 1; i < l; ++i, t2 = t3) {
          if (i >= t2)
            return H.ioore(a, i);
          v = a[i];
          for (j = i - 1; j >= 0; --j, t2 = t3) {
            if (t1) {
              if (j >= t2)
                return H.ioore(a, j);
              t2 = a[j].get$aabb();
              t2 = t2.get$lowerBound(t2).x;
              t3 = v.get$aabb();
              if (J.$le$n(t2, t3.get$lowerBound(t3).x))
                break;
            } else {
              if (j >= t2)
                return H.ioore(a, j);
              t2 = a[j].get$aabb();
              t2 = t2.get$lowerBound(t2).y;
              t3 = v.get$aabb();
              if (J.$le$n(t2, t3.get$lowerBound(t3).y))
                break;
            }
            t2 = j + 1;
            t3 = a.length;
            if (j >= t3)
              return H.ioore(a, j);
            t4 = a[j];
            if (t2 >= t3)
              return H.ioore(a, t2);
            a[t2] = t4;
          }
          t2 = j + 1;
          t3 = a.length;
          if (t2 < 0 || t2 >= t3)
            return H.ioore(a, t2);
          a[t2] = v;
        }
        return a;
      }}
  },
  SAPBroadphase_closure: {
    "^": "Closure:665;this_0",
    call$1: [function(e) {
      this.this_0.axisList.push(J.$index$asx(e, "body"));
    }, "call$1", null, 2, 0, null, 356, [], "call"]
  },
  SAPBroadphase_closure0: {
    "^": "Closure:665;this_1",
    call$1: [function(e) {
      var t1, t2, idx;
      t1 = this.this_1;
      t2 = t1.axisList;
      idx = H.Lists_indexOf(t2, J.$index$asx(e, "body"), 0, t2.length);
      if (!J.$eq(idx, -1))
        C.JSArray_methods.removeAt$1(t1.axisList, idx);
    }, "call$1", null, 2, 0, null, 356, [], "call"]
  },
  Constraint: {
    "^": "Object;",
    $isConstraint: true
  },
  ContactEquation: {
    "^": "Equation;contactPointA<,penetrationVec,contactPointB<,normalA<,restitution?,firstImpact@,shapeA@,shapeB@,minForce,maxForce,bodyA,bodyB,stiffness,relaxation,G,offset,a,b,epsilon,timeStep,needsUpdate,multiplier,relativeVelocity,enabled,replacedGq,replacedGW,updateJacobian",
    computeB$3: function(a, b, h) {
      var bi, bj, ri, rj, xi, xj, penetrationVec, n, $G, rixn, rjxn, t1, t2, GW, Gq, GiMf;
      bi = this.bodyA;
      bj = this.bodyB;
      ri = this.contactPointA;
      rj = this.contactPointB;
      xi = J.get$position$x(bi);
      xj = J.get$position$x(bj);
      penetrationVec = this.penetrationVec;
      n = this.normalA;
      $G = this.G;
      rixn = A.vec2_crossLength(ri, n);
      rjxn = A.vec2_crossLength(rj, n);
      $G[0] = J.$negate$n(n.x);
      $G[1] = J.$negate$n(n.y);
      $G[2] = J.$negate$n(rixn);
      $G[3] = n.x;
      $G[4] = n.y;
      $G[5] = rjxn;
      A.vec2_add(penetrationVec, xj, rj);
      $.vec2_sub.call$3(penetrationVec, penetrationVec, xi);
      $.vec2_sub.call$3(penetrationVec, penetrationVec, ri);
      if (this.firstImpact && this.restitution !== 0) {
        if (typeof b !== "number")
          return H.iae(b);
        t1 = this.restitution;
        t2 = this.computeGW$0();
        if (typeof t2 !== "number")
          return H.iae(t2);
        GW = 1 / b * (1 + t1) * t2;
        Gq = 0;
      } else {
        Gq = J.$add$ns(A.vec2_dot(n, penetrationVec), this.offset);
        GW = this.computeGW$0();
      }
      GiMf = this.computeGiMf$0();
      return J.$sub$n(J.$sub$n(J.$mul$ns(J.$negate$n(Gq), a), J.$mul$ns(GW, b)), J.$mul$ns(h, GiMf));
    },
    $isContactEquation: true
  },
  Equation: {
    "^": "Object;minForce<,maxForce<,bodyA@,bodyB@,stiffness?,relaxation?,offset*,a*,b@,epsilon<,timeStep@,needsUpdate@,multiplier@,relativeVelocity?,enabled@",
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    update$0: [function() {
      var k, d, h, t1, t2, t3, t4;
      k = this.stiffness;
      d = this.relaxation;
      h = this.timeStep;
      t1 = 4 * d;
      t2 = 1 + t1;
      t3 = J.getInterceptor$ns(h);
      t4 = t3.$mul(h, t2);
      if (typeof t4 !== "number")
        return H.iae(t4);
      this.a = 4 / t4;
      this.b = t1 / t2;
      t2 = J.$mul$ns(J.$mul$ns(t3.$mul(h, h), k), t2);
      if (typeof t2 !== "number")
        return H.iae(t2);
      this.epsilon = 4 / t2;
      this.needsUpdate = false;
    }, "call$0", "get$update", 0, 0, 54],
    gmult$5: function($G, vi, wi, vj, wj) {
      var t1, t2;
      t1 = J.getInterceptor$x(vi);
      t2 = J.getInterceptor$x(vj);
      return J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns($G[0], t1.get$x(vi)), J.$mul$ns($G[1], t1.get$y(vi))), J.$mul$ns($G[2], wi)), J.$mul$ns($G[3], t2.get$x(vj))), J.$mul$ns($G[4], t2.get$y(vj))), J.$mul$ns($G[5], wj));
    },
    computeB$3: function(a, b, h) {
      var GW, bi, bj, t1, t2, ai, aj, Gq, GiMf;
      GW = this.computeGW$0();
      bi = this.bodyA;
      bj = this.bodyB;
      t1 = J.getInterceptor$x(bi);
      t1.get$position(bi);
      t2 = J.getInterceptor$x(bj);
      t2.get$position(bj);
      ai = t1.get$angle(bi);
      aj = t2.get$angle(bj);
      Gq = J.$add$ns(this.gmult$5(this.G, $.get$Equation_qi(), ai, $.get$Equation_qj(), aj), this.offset);
      GiMf = this.computeGiMf$0();
      return J.$sub$n(J.$sub$n(J.$mul$ns(J.$negate$n(Gq), a), J.$mul$ns(GW, b)), J.$mul$ns(GiMf, h));
    },
    computeGW$0: function() {
      var bi, bj, vi, vj;
      bi = this.bodyA;
      bj = this.bodyB;
      vi = bi.get$velocity();
      vj = bj.get$velocity();
      return J.$add$ns(this.gmult$5(this.G, vi, bi.get$angularVelocity(), vj, bj.get$angularVelocity()), this.relativeVelocity);
    },
    computeGWlambda$0: function() {
      var bi, bj, vi, vj;
      bi = this.bodyA;
      bj = this.bodyB;
      vi = bi.get$vlambda();
      vj = bj.get$vlambda();
      return this.gmult$5(this.G, vi, bi.get$wlambda(), vj, bj.get$wlambda());
    },
    computeGiMf$0: function() {
      var bi, bj, fi, ti, fj, tj, invMassi, invMassj, invIi, invIj, t1, t2;
      bi = this.bodyA;
      bj = this.bodyB;
      fi = J.get$force$x(bi);
      ti = bi.get$angularForce();
      fj = J.get$force$x(bj);
      tj = bj.get$angularForce();
      invMassi = bi.get$invMassSolve();
      invMassj = bj.get$invMassSolve();
      invIi = bi.get$invInertiaSolve();
      invIj = bj.get$invInertiaSolve();
      t1 = $.get$Equation_iMfi();
      A.vec2_scale(t1, fi, invMassi);
      t2 = $.get$Equation_iMfj();
      A.vec2_scale(t2, fj, invMassj);
      return this.gmult$5(this.G, t1, ti * invIi, t2, tj * invIj);
    },
    addToWlambda$1: function(deltalambda) {
      var bi, bj, temp, Gi, Gj, invMassi, invMassj, invIi, invIj, $G, t1, t2;
      bi = this.bodyA;
      bj = this.bodyB;
      temp = $.get$Equation_addToWlambda_temp();
      Gi = $.get$Equation_addToWlambda_Gi();
      Gj = $.get$Equation_addToWlambda_Gj();
      $.get$Equation_addToWlambda_ri();
      $.get$Equation_addToWlambda_rj();
      invMassi = bi.get$invMassSolve();
      invMassj = bj.get$invMassSolve();
      invIi = bi.get$invInertiaSolve();
      invIj = bj.get$invInertiaSolve();
      $.get$Equation_addToWlambda_Mdiag();
      $G = this.G;
      Gi.x = $G[0];
      Gi.y = $G[1];
      Gj.x = $G[3];
      Gj.y = $G[4];
      A.vec2_scale2(temp, Gi, invMassi * deltalambda);
      A.vec2_add(bi.get$vlambda(), bi.get$vlambda(), temp);
      t1 = bi.get$wlambda();
      t2 = $G[2];
      if (typeof t2 !== "number")
        return H.iae(t2);
      bi.set$wlambda(t1 + invIi * t2 * deltalambda);
      A.vec2_scale2(temp, Gj, invMassj * deltalambda);
      A.vec2_add(bj.get$vlambda(), bj.get$vlambda(), temp);
      t2 = bj.get$wlambda();
      t1 = $G[5];
      if (typeof t1 !== "number")
        return H.iae(t1);
      bj.set$wlambda(t2 + invIj * t1 * deltalambda);
    },
    computeInvC$1: function(eps) {
      var bi, bj, invMassi, invMassj, invIi, invIj, $G, t1, t2;
      bi = this.bodyA;
      bj = this.bodyB;
      invMassi = bi.get$invMassSolve();
      invMassj = bj.get$invMassSolve();
      invIi = bi.get$invInertiaSolve();
      invIj = bj.get$invInertiaSolve();
      $G = this.G;
      t1 = $G[0];
      t1 = J.$mul$ns(J.$mul$ns(t1, t1), invMassi);
      t2 = $G[1];
      t2 = J.$add$ns(t1, J.$mul$ns(J.$mul$ns(t2, t2), invMassi));
      t1 = $G[2];
      t1 = J.$add$ns(t2, J.$mul$ns(J.$mul$ns(t1, t1), invIi));
      t2 = $G[3];
      t2 = J.$add$ns(t1, J.$mul$ns(J.$mul$ns(t2, t2), invMassj));
      t1 = $G[4];
      t1 = J.$add$ns(t2, J.$mul$ns(J.$mul$ns(t1, t1), invMassj));
      t2 = $G[5];
      t2 = J.$add$ns(J.$add$ns(t1, J.$mul$ns(J.$mul$ns(t2, t2), invIj)), eps);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return 1 / t2;
    },
    Equation$4: function(bodyA, bodyB, minForce, maxForce) {
      var t1, i;
      this.minForce = minForce;
      this.maxForce = maxForce;
      this.stiffness = 1000000;
      this.relaxation = 4;
      for (t1 = this.G, i = 0; i < 6; ++i)
        t1[i] = 0;
      this.offset = 0;
      this.a = 0;
      this.b = 0;
      this.epsilon = 0;
      this.timeStep = 0.016666666666666666;
      this.needsUpdate = true;
      this.multiplier = 0;
      this.relativeVelocity = 0;
      this.enabled = true;
    },
    $isEquation: true
  },
  FrictionEquation: {
    "^": "Equation;contactPointA<,contactPointB<,t<,contactEquations<,shapeA@,shapeB@,frictionCoefficient?,minForce,maxForce,bodyA,bodyB,stiffness,relaxation,G,offset,a,b,epsilon,timeStep,needsUpdate,multiplier,relativeVelocity,enabled,replacedGq,replacedGW,updateJacobian",
    setSlipForce$1: function(slipForce) {
      this.maxForce = slipForce;
      this.minForce = -slipForce;
    },
    getSlipForce$0: function() {
      return this.maxForce;
    },
    computeB$3: function(a, b, h) {
      var t, $G, GW, GiMf;
      t = this.t;
      $G = this.G;
      $G[0] = J.$negate$n(t.x);
      $G[1] = J.$negate$n(t.y);
      $G[2] = J.$negate$n(A.vec2_crossLength(this.contactPointA, t));
      $G[3] = t.x;
      $G[4] = t.y;
      $G[5] = A.vec2_crossLength(this.contactPointB, t);
      GW = this.computeGW$0();
      GiMf = this.computeGiMf$0();
      return J.$sub$n(J.$mul$ns(J.$negate$n(GW), b), J.$mul$ns(h, GiMf));
    },
    FrictionEquation$3$slipForce: function(bodyA, bodyB, slipForce) {
      this.contactEquations = H.setRuntimeTypeInfo([], [A.ContactEquation]);
      this.shapeA = null;
      this.shapeB = null;
      this.frictionCoefficient = 0.3;
    },
    $isFrictionEquation: true
  },
  EventEmitter: {
    "^": "Object;",
    on$2: [function(_, type, listener) {
      var t1 = this._listeners;
      if (t1 == null) {
        t1 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        this._listeners = t1;
      }
      if (!t1.containsKey$1(0, type))
        t1.$indexSet(0, type, H.setRuntimeTypeInfo([], [{func: "dynamic__Map", args: [P.Map]}]));
      if (!J.contains$1$asx(t1.$index(0, type), listener))
        t1.$index(0, type).push(listener);
      return this;
    }, "call$2", "get$on", 4, 0, 1799],
    has$2: function(type, listener) {
      var t1 = this._listeners;
      if (t1 == null)
        return false;
      if (t1.containsKey$1(0, type))
        return true;
      return false;
    },
    has$1: function(type) {
      return this.has$2(type, null);
    },
    off$2: function(type, listener) {
      var t1, t2, index;
      t1 = this._listeners;
      if (t1 == null)
        return this;
      t2 = t1.$index(0, type);
      index = H.Lists_indexOf(t2, listener, 0, t2.length);
      if (!J.$eq(index, -1))
        J.removeAt$1$ax(t1.$index(0, type), index);
      return this;
    },
    emit$1: function($event) {
      var t1, listenerArray, l, i;
      t1 = this._listeners;
      if (t1 == null)
        return this;
      listenerArray = t1.$index(0, $event.$index(0, "type"));
      if (listenerArray != null) {
        $event.$indexSet(0, "target", this);
        for (l = listenerArray.length, i = 0; i < l; ++i) {
          if (i >= listenerArray.length)
            return H.ioore(listenerArray, i);
          listenerArray[i].call$1($event);
        }
      }
      return this;
    }
  },
  ContactMaterial: {
    "^": "Object;id*,materialA,materialB,friction<,restitution?,stiffness?,relaxation?,frictionStiffness,frictionRelaxation,surfaceVelocity,contactSkinSize",
    ContactMaterial$9$friction$frictionRelaxation$frictionStiffness$relaxation$restitution$stiffness$surfaceVelocity: function(materialA, materialB, friction, frictionRelaxation, frictionStiffness, relaxation, restitution, stiffness, surfaceVelocity) {
      var t1 = $.ContactMaterial_idCounter;
      $.ContactMaterial_idCounter = t1 + 1;
      this.id = t1;
      this.materialA = materialA;
      this.materialB = materialB;
      this.friction = friction;
      this.restitution = restitution;
      this.stiffness = stiffness;
      this.relaxation = relaxation;
      this.frictionStiffness = frictionStiffness;
      this.frictionRelaxation = frictionRelaxation;
      this.surfaceVelocity = surfaceVelocity;
      this.contactSkinSize = 0.005;
    },
    $isContactMaterial: true,
    static: {"^": "ContactMaterial_idCounter"}
  },
  Material: {
    "^": "Object;id*",
    Material$1: function(id) {
      var t1 = $.Material_idCounter;
      $.Material_idCounter = t1 + 1;
      this.id = t1;
    },
    static: {"^": "Material_idCounter"}
  },
  vec2: {
    "^": "Object;x*,y*",
    $isvec2: true,
    static: {"^": "vec2_sub,vec2_mul,vec2_div,vec2_dist,vec2_sqrDist,vec2_len,vec2_sqrLen", vec2_crossLength: function(a, b) {
        var t1, t2;
        t1 = J.getInterceptor$x(a);
        t2 = J.getInterceptor$x(b);
        return J.$sub$n(J.$mul$ns(t1.get$x(a), t2.get$y(b)), J.$mul$ns(t1.get$y(a), t2.get$x(b)));
      }, vec2_rotate: function(out, a, angle) {
        var t1, c, s, x, y;
        if (!J.$eq(angle, 0)) {
          t1 = typeof angle !== "number";
          if (t1)
            H.throwExpression(P.ArgumentError$(angle));
          c = Math.cos(angle);
          if (t1)
            H.throwExpression(P.ArgumentError$(angle));
          s = Math.sin(angle);
          t1 = J.getInterceptor$x(a);
          x = t1.get$x(a);
          y = t1.get$y(a);
          if (typeof x !== "number")
            return H.iae(x);
          if (typeof y !== "number")
            return H.iae(y);
          out.x = c * x - s * y;
          out.y = s * x + c * y;
        } else {
          t1 = J.getInterceptor$x(a);
          out.x = t1.get$x(a);
          out.y = t1.get$y(a);
        }
      }, vec2_rotate90cw: function(out, a) {
        var x = a.x;
        out.x = a.y;
        out.y = J.$negate$n(x);
      }, vec2_fromValues: function(x, y) {
        var t1, t2, out;
        t1 = J.toDouble$0$n(x);
        t2 = J.toDouble$0$n(y);
        out = new A.vec2(0, 0);
        out.x = t1;
        out.y = t2;
        return out;
      }, vec2_copy: function(out, a) {
        var t1, t2;
        t1 = J.getInterceptor$x(a);
        t2 = J.getInterceptor$x(out);
        t2.set$x(out, t1.get$x(a));
        t2.set$y(out, t1.get$y(a));
        return out;
      }, vec2_set: [function(out, x, y) {
        var t1 = J.getInterceptor$x(out);
        t1.set$x(out, x);
        t1.set$y(out, y);
        return out;
      }, "call$3", "vec2_set$closure", 6, 0, 610, 361, [], 9, [], 10, []], vec2_add: [function(out, a, b) {
        var t1, t2, t3;
        t1 = J.getInterceptor$x(a);
        t2 = J.getInterceptor$x(b);
        t3 = J.getInterceptor$x(out);
        t3.set$x(out, J.$add$ns(t1.get$x(a), t2.get$x(b)));
        t3.set$y(out, J.$add$ns(t1.get$y(a), t2.get$y(b)));
        return out;
      }, "call$3", "vec2_add$closure", 6, 0, 611, 361, [], 348, [], 349, []], vec2_subtract: [function(out, a, b) {
        var t1, t2, t3;
        t1 = J.getInterceptor$x(a);
        t2 = J.getInterceptor$x(b);
        t3 = J.getInterceptor$x(out);
        t3.set$x(out, J.$sub$n(t1.get$x(a), t2.get$x(b)));
        t3.set$y(out, J.$sub$n(t1.get$y(a), t2.get$y(b)));
        return out;
      }, "call$3", "vec2_subtract$closure", 6, 0, 611, 361, [], 348, [], 349, []], vec2_scale: function(out, a, b) {
        var t1 = J.getInterceptor$x(a);
        out.x = J.$mul$ns(t1.get$x(a), b);
        out.y = J.$mul$ns(t1.get$y(a), b);
        return out;
      }, vec2_scale2: function(out, a, b) {
        out.x = J.$mul$ns(a.x, b);
        out.y = J.$mul$ns(a.y, b);
        return out;
      }, vec2_length: function(a) {
        var x, y, t1;
        x = a.x;
        y = a.y;
        t1 = J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        return Math.sqrt(t1);
      }, vec2_squaredLength: function(a) {
        var t1, x, y;
        t1 = J.getInterceptor$x(a);
        x = t1.get$x(a);
        y = t1.get$y(a);
        return J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
      }, vec2_normalize: function(out, a) {
        var x, y, len;
        x = a.x;
        y = a.y;
        len = J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
        if (J.$gt$n(len, 0)) {
          if (typeof len !== "number")
            H.throwExpression(P.ArgumentError$(len));
          len = 1 / Math.sqrt(len);
          out.x = J.$mul$ns(a.x, len);
          out.y = J.$mul$ns(a.y, len);
        }
        return out;
      }, vec2_dot: function(a, b) {
        var t1, t2;
        t1 = J.getInterceptor$x(a);
        t2 = J.getInterceptor$x(b);
        return J.$add$ns(J.$mul$ns(t1.get$x(a), t2.get$x(b)), J.$mul$ns(t1.get$y(a), t2.get$y(b)));
      }}
  },
  Body3: {
    "^": "EventEmitter;id*,world@,shapes<,shapeOffsets<,shapeAngles<,mass@,invMass<,inertia,invInertia<,invMassSolve<,invInertiaSolve<,fixedRotation<,position>,interpolatedPosition<,interpolatedAngle?,previousPosition<,previousAngle@,velocity<,vlambda<,wlambda@,angle*,angularVelocity@,force>,angularForce<,damping?,angularDamping?,type*,boundingRadius<,aabb<,aabbNeedsUpdate@,allowSleep<,wantsToSleep<,sleepState<,sleepSpeedLimit<,sleepTimeLimit,gravityScale<,timeLastSleepy,idleTime,concavePath,_wakeUpAfterNarrowphase@,parent*,_listeners",
    angle$0: function($receiver) {
      return this.angle.call$0();
    },
    angle$2: function($receiver, arg0, arg1) {
      return this.angle.call$2(arg0, arg1);
    },
    wantsToSleep$0: function() {
      return this.wantsToSleep.call$0();
    },
    updateSolveMassProperties$0: function() {
      if (this.sleepState === 2 || this.type === 4) {
        this.invMassSolve = 0;
        this.invInertiaSolve = 0;
      } else {
        this.invMassSolve = this.invMass;
        this.invInertiaSolve = this.invInertia;
      }
    },
    getAABB$0: function() {
      if (this.aabbNeedsUpdate)
        this.updateAABB$0();
      return this.aabb;
    },
    updateAABB$0: function() {
      var shapes, shapeOffsets, shapeAngles, $N, offset, bodyAngle, t1, i, shape, angle, t2, t3, t4, t5, l, u;
      shapes = this.shapes;
      shapeOffsets = this.shapeOffsets;
      shapeAngles = this.shapeAngles;
      $N = shapes.length;
      offset = $.get$Body_tmp();
      bodyAngle = this.angle;
      for (t1 = this.position, i = 0; i !== $N; ++i) {
        if (i >= shapes.length)
          return H.ioore(shapes, i);
        shape = shapes[i];
        if (i >= shapeAngles.length)
          return H.ioore(shapeAngles, i);
        angle = J.$add$ns(shapeAngles[i], bodyAngle);
        if (i >= shapeOffsets.length)
          return H.ioore(shapeOffsets, i);
        A.vec2_rotate(offset, shapeOffsets[i], bodyAngle);
        offset.x = J.$add$ns(offset.x, t1.x);
        offset.y = J.$add$ns(offset.y, t1.y);
        t2 = $.get$Body_shapeAABB();
        shape.computeAABB$3(t2, offset, angle);
        t3 = this.aabb;
        if (i === 0) {
          t4 = t3.lowerBound;
          t5 = t2.lowerBound;
          t4.x = t5.x;
          t4.y = t5.y;
          t3 = t3.upperBound;
          t2 = t2.upperBound;
          t3.x = t2.x;
          t3.y = t2.y;
        } else {
          t4 = t2.lowerBound;
          l = t4.x;
          t5 = t3.lowerBound;
          if (J.$gt$n(t5.x, l))
            t5.x = l;
          t2 = t2.upperBound;
          u = t2.x;
          t3 = t3.upperBound;
          if (J.$lt$n(t3.x, u))
            t3.x = u;
          l = t4.y;
          if (J.$gt$n(t5.y, l))
            t5.y = l;
          u = t2.y;
          if (J.$lt$n(t3.y, u))
            t3.y = u;
        }
      }
      this.aabbNeedsUpdate = false;
    },
    updateBoundingRadius$0: function() {
      var shapes, shapeOffsets, $N, radius, i, shape, t1, x, y, offset, r, radius0;
      shapes = this.shapes;
      shapeOffsets = this.shapeOffsets;
      $N = shapes.length;
      for (radius = 0, i = 0; i !== $N; ++i) {
        if (i >= shapes.length)
          return H.ioore(shapes, i);
        shape = shapes[i];
        if (i >= shapeOffsets.length)
          return H.ioore(shapeOffsets, i);
        t1 = shapeOffsets[i];
        x = t1.x;
        y = t1.y;
        t1 = J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        offset = Math.sqrt(t1);
        r = shape.get$boundingRadius();
        if (typeof r !== "number")
          return H.iae(r);
        radius0 = offset + r;
        if (radius0 > radius)
          radius = radius0;
      }
      this.boundingRadius = radius;
    },
    addShape$3: function(shape, offset, angle) {
      offset = offset != null ? A.vec2_fromValues(offset.x, offset.y) : A.vec2_fromValues(0, 0);
      this.shapes.push(shape);
      this.shapeOffsets.push(offset);
      this.shapeAngles.push(angle);
      this.updateMassProperties$0();
      this.updateBoundingRadius$0();
      this.aabbNeedsUpdate = true;
    },
    addShape$1: function(shape) {
      return this.addShape$3(shape, null, 0);
    },
    removeShape$1: function(shape) {
      var t1, idx;
      t1 = this.shapes;
      idx = H.Lists_indexOf(t1, shape, 0, t1.length);
      if (!J.$eq(idx, -1)) {
        C.JSArray_methods.removeAt$1(t1, idx);
        C.JSArray_methods.removeAt$1(this.shapeOffsets, idx);
        C.JSArray_methods.removeAt$1(this.shapeAngles, idx);
        this.aabbNeedsUpdate = true;
        return true;
      } else
        return false;
    },
    updateMassProperties$0: function() {
      var t1, shapes, $N, m, I, i, shape, t2, x, y, r2, Icm;
      t1 = this.type;
      if (t1 === 2 || t1 === 4) {
        this.mass = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        this.invMass = 0;
        this.inertia = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        this.invInertia = 0;
      } else {
        shapes = this.shapes;
        $N = shapes.length;
        m = this.mass / $N;
        if (!this.fixedRotation) {
          for (t1 = this.shapeOffsets, I = 0, i = 0; i < $N; ++i) {
            if (i >= shapes.length)
              return H.ioore(shapes, i);
            shape = shapes[i];
            if (i >= t1.length)
              return H.ioore(t1, i);
            t2 = t1[i];
            x = t2.x;
            y = t2.y;
            r2 = J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
            Icm = shape.computeMomentOfInertia$1(m);
            if (typeof r2 !== "number")
              return H.iae(r2);
            I += Icm + m * r2;
          }
          this.inertia = I;
          this.invInertia = I > 0 ? 1 / I : 0;
        } else {
          this.inertia = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
          this.invInertia = 0;
        }
        this.invMass = 1 / this.mass;
      }
    },
    setZeroForce$0: function() {
      var t1 = this.force;
      t1.x = 0;
      t1.y = 0;
      this.angularForce = 0;
    },
    resetConstraintVelocity$0: function() {
      var vlambda = this.vlambda;
      vlambda.x = 0;
      vlambda.y = 0;
      this.wlambda = 0;
    },
    addConstraintVelocity$0: function() {
      var v = this.velocity;
      A.vec2_add(v, v, this.vlambda);
      this.angularVelocity = J.$add$ns(this.angularVelocity, this.wlambda);
    },
    applyDamping$1: [function(dt) {
      var v, t1, t2;
      if (this.type === 1) {
        v = this.velocity;
        t1 = 1 - this.damping;
        H.checkNum(t1);
        H.checkNum(dt);
        A.vec2_scale(v, v, Math.pow(t1, dt));
        t1 = this.angularVelocity;
        t2 = 1 - this.angularDamping;
        H.checkNum(t2);
        H.checkNum(dt);
        this.angularVelocity = J.$mul$ns(t1, Math.pow(t2, dt));
      }
    }, "call$1", "get$applyDamping", 2, 0, 102],
    wakeUp$0: function() {
      var s = this.sleepState;
      this.sleepState = 0;
      this.idleTime = 0;
      if (s !== 0)
        this.emit$1($.get$Body_wakeUpEvent());
    },
    sleep$0: function() {
      this.sleepState = 2;
      this.angularVelocity = 0;
      this.angularForce = 0;
      var t1 = this.velocity;
      t1.x = 0;
      t1.y = 0;
      t1 = this.force;
      t1.x = 0;
      t1.y = 0;
      this.emit$1($.get$Body_sleepEvent());
    },
    sleepTick$3: function(time, dontSleep, dt) {
      var t1, t2, speedSquared;
      if (!this.allowSleep || this.type === 2)
        return;
      this.wantsToSleep = false;
      t1 = A.vec2_squaredLength(this.velocity);
      t2 = this.angularVelocity;
      H.checkNum(t2);
      H.checkNum(2);
      speedSquared = J.$add$ns(t1, Math.pow(t2, 2));
      t2 = this.sleepSpeedLimit;
      H.checkNum(t2);
      H.checkNum(2);
      if (J.$ge$n(speedSquared, Math.pow(t2, 2))) {
        this.idleTime = 0;
        this.sleepState = 0;
        t1 = 0;
      } else {
        t1 = this.idleTime;
        if (typeof dt !== "number")
          return H.iae(dt);
        t1 += dt;
        this.idleTime = t1;
        this.sleepState = 1;
      }
      if (t1 > this.sleepTimeLimit)
        if (!dontSleep)
          this.sleep$0();
        else
          this.wantsToSleep = true;
    },
    Body$11$angle$angularDamping$angularForce$angularVelocity$damping$fixedRotation$force$mass$position$type$velocity: function(angle, angularDamping, angularForce, angularVelocity, damping, fixedRotation, force, mass, position, type, velocity) {
      var t1 = $.Body__idCounter + 1;
      $.Body__idCounter = t1;
      this.id = t1;
      this.world = null;
      this.mass = mass;
      this.invMass = 0;
      this.inertia = 0;
      this.invInertia = 0;
      this.invMassSolve = 0;
      this.invInertiaSolve = 0;
      this.fixedRotation = fixedRotation;
      if (position != null)
        A.vec2_copy(this.position, position);
      this.interpolatedAngle = 0;
      this.previousAngle = 0;
      this.wlambda = 0;
      this.angle = angle;
      this.angularVelocity = angularVelocity;
      this.angularForce = angularForce;
      this.damping = damping;
      this.angularDamping = angularDamping;
      if (mass === 0)
        this.type = 2;
      else
        this.type = 1;
      this.boundingRadius = 0;
      this.aabb = A.AABB$(null, null);
      this.aabbNeedsUpdate = true;
      this.allowSleep = true;
      this.wantsToSleep = false;
      this.sleepState = 0;
      this.sleepSpeedLimit = 0.2;
      this.sleepTimeLimit = 1;
      this.gravityScale = 1;
      this.timeLastSleepy = 0;
      this.concavePath = null;
      this._wakeUpAfterNarrowphase = false;
      this.updateMassProperties$0();
    },
    $isBody3: true,
    static: {"^": "Body__idCounter,Body_shapeAABB,Body_tmp,Body_Body_applyForce_r,Body_adjustCenterOfMass_tmp1,Body_adjustCenterOfMass_tmp2,Body_adjustCenterOfMass_tmp3,Body_adjustCenterOfMass_tmp4,Body_sleepyEvent,Body_sleepEvent,Body_wakeUpEvent,Body_DYNAMIC0,Body_STATIC0,Body_KINEMATIC0,Body_AWAKE,Body_SLEEPY,Body_SLEEPING", Body$0: function(angle, angularDamping, angularForce, angularVelocity, damping, fixedRotation, force, mass, position, type, velocity) {
        var t1, t2, t3, out, out0, out1, out2, out3, out4;
        t1 = H.setRuntimeTypeInfo([], [A.Shape0]);
        t2 = H.setRuntimeTypeInfo([], [A.vec2]);
        t3 = H.setRuntimeTypeInfo([], [P.num]);
        out = new A.vec2(0, 0);
        out.x = 0;
        out.y = 0;
        out0 = new A.vec2(0, 0);
        out0.x = 0;
        out0.y = 0;
        out1 = new A.vec2(0, 0);
        out1.x = 0;
        out1.y = 0;
        out2 = new A.vec2(0, 0);
        out2.x = 0;
        out2.y = 0;
        out3 = new A.vec2(0, 0);
        out3.x = 0;
        out3.y = 0;
        out4 = new A.vec2(0, 0);
        out4.x = 0;
        out4.y = 0;
        out4 = new A.Body3(null, null, t1, t2, t3, null, null, null, null, null, null, null, out, out0, null, out1, null, out2, out3, 0, null, null, out4, null, null, null, 0, null, null, null, null, null, null, 0.2, null, null, null, 0, null, null, null, null);
        out4.Body$11$angle$angularDamping$angularForce$angularVelocity$damping$fixedRotation$force$mass$position$type$velocity(angle, angularDamping, angularForce, angularVelocity, damping, fixedRotation, force, mass, position, type, velocity);
        return out4;
      }}
  },
  "+Body": 0,
  Spring: {
    "^": "Object;",
    $isSpring: true
  },
  Capsule: {
    "^": "Shape0;",
    static: {"^": "Capsule_r<"}
  },
  Circle2: {
    "^": "Shape0;radius@,type,id,boundingRadius,collisionGroup,collisionMask,material,area,sensor",
    computeMomentOfInertia$1: function(mass) {
      var r = this.radius;
      if (typeof r !== "number")
        return H.iae(r);
      return mass * r * r / 2;
    },
    computeAABB$3: function(out, position, angle) {
      var r, t1, t2, t3, t4;
      r = this.radius;
      t1 = out.upperBound;
      t1.x = r;
      t1.y = r;
      t2 = out.lowerBound;
      t3 = J.getInterceptor$n(r);
      t4 = t3.$negate(r);
      t3 = t3.$negate(r);
      t2.x = t4;
      t2.y = t3;
      if (position != null) {
        A.vec2_add(t2, t2, position);
        A.vec2_add(t1, t1, position);
      }
    },
    $isCircle2: true
  },
  "+Circle": 0,
  Convex: {
    "^": "Shape0;vertices<,axes,centerOfMass,triangles,type,id,boundingRadius,collisionGroup,collisionMask,material,area,sensor",
    init$2: [function(vertices, axes) {
      var t1, t2, i, t3, out, t4, t5, worldPoint0, worldPoint1, x;
      t1 = J.getInterceptor$asx(vertices);
      t2 = this.vertices;
      i = 0;
      while (true) {
        t3 = t1.get$length(vertices);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        out = new A.vec2(0, 0);
        out.x = 0;
        out.y = 0;
        t3 = t1.$index(vertices, i);
        t4 = J.getInterceptor$x(t3);
        out.x = t4.get$x(t3);
        out.y = t4.get$y(t3);
        t2.push(out);
        ++i;
      }
      if (axes != null) {
        t1 = J.getInterceptor$asx(axes);
        t3 = this.axes;
        i = 0;
        while (true) {
          t4 = t1.get$length(axes);
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(i < t4))
            break;
          out = new A.vec2(0, 0);
          out.x = 0;
          out.y = 0;
          t4 = t1.$index(axes, i);
          t5 = J.getInterceptor$x(t4);
          out.x = t5.get$x(t4);
          out.y = t5.get$y(t4);
          t3.push(out);
          ++i;
        }
      } else
        for (t3 = this.axes, i = 0; i < t2.length;) {
          worldPoint0 = t2[i];
          ++i;
          t4 = t1.get$length(vertices);
          if (typeof t4 !== "number")
            return H.iae(t4);
          t4 = C.JSInt_methods.$mod(i, t4);
          if (t4 >>> 0 !== t4 || t4 >= t2.length)
            return H.ioore(t2, t4);
          worldPoint1 = t2[t4];
          out = new A.vec2(0, 0);
          out.x = 0;
          out.y = 0;
          $.vec2_sub.call$3(out, worldPoint1, worldPoint0);
          x = out.x;
          out.x = out.y;
          out.y = J.$negate$n(x);
          A.vec2_normalize(out, out);
          t3.push(out);
        }
      if (t2.length !== 0) {
        this.updateTriangles$0();
        this.updateCenterOfMass$0();
      }
      this.boundingRadius = 0;
      this.updateBoundingRadius$0();
      this.updateArea$0();
      if (J.$lt$n(this.area, 0))
        throw H.wrapException(P.Exception_Exception("Convex vertices must be given in conter-clockwise winding."));
    }, "call$2", "get$init", 4, 0, 1800, 782, [], 1801, []],
    updateTriangles$0: function() {
      var t1, polykVerts, t2, i, v, t3, triangles, id1, id2;
      t1 = this.triangles;
      C.JSArray_methods.set$length(t1, 0);
      polykVerts = [];
      for (t2 = this.vertices, i = 0; i < t2.length; ++i) {
        v = t2[i];
        t3 = J.getInterceptor$x(v);
        C.JSArray_methods.addAll$1(polykVerts, [t3.get$x(v), t3.get$y(v)]);
      }
      triangles = A.Polyk_Triangulate(polykVerts);
      for (i = 0; t2 = triangles.length, i < t2; i += 3) {
        id1 = triangles[i];
        t3 = i + 1;
        if (t3 >= t2)
          return H.ioore(triangles, t3);
        id2 = triangles[t3];
        t3 = i + 2;
        if (t3 >= t2)
          return H.ioore(triangles, t3);
        t1.push([id1, id2, triangles[t3]]);
      }
    },
    updateCenterOfMass$0: function() {
      var triangles, verts, cm, centroid, centroid_times_mass, totalArea, i, t1, t, t2, a, b, c, m;
      triangles = this.triangles;
      verts = this.vertices;
      cm = this.centerOfMass;
      centroid = $.get$Convex_updateCenterOfMass_centroid();
      $.get$Convex_updateCenterOfMass_n();
      $.get$Convex_updateCenterOfMass_a();
      $.get$Convex_updateCenterOfMass_b();
      $.get$Convex_updateCenterOfMass_c();
      $.get$Convex_updateCenterOfMass_ac();
      $.get$Convex_updateCenterOfMass_ca();
      $.get$Convex_updateCenterOfMass_cb();
      centroid_times_mass = $.get$Convex_updateCenterOfMass_centroid_times_mass();
      cm.x = 0;
      cm.y = 0;
      for (totalArea = 0, i = 0; t1 = triangles.length, i !== t1; ++i) {
        if (i >= t1)
          return H.ioore(triangles, i);
        t = triangles[i];
        t1 = t[0];
        t2 = verts.length;
        if (t1 >>> 0 !== t1 || t1 >= t2)
          return H.ioore(verts, t1);
        a = verts[t1];
        t1 = t[1];
        if (t1 >>> 0 !== t1 || t1 >= t2)
          return H.ioore(verts, t1);
        b = verts[t1];
        t1 = t[2];
        if (t1 >>> 0 !== t1 || t1 >= t2)
          return H.ioore(verts, t1);
        c = verts[t1];
        t1 = J.getInterceptor$x(a);
        t2 = J.getInterceptor$x(b);
        centroid.x = J.$add$ns(t1.get$x(a), t2.get$x(b));
        centroid.y = J.$add$ns(t1.get$y(a), t2.get$y(b));
        t2 = J.getInterceptor$x(c);
        centroid.x = J.$add$ns(centroid.x, t2.get$x(c));
        centroid.y = J.$add$ns(centroid.y, t2.get$y(c));
        centroid.x = J.$mul$ns(centroid.x, 0.3333333333333333);
        centroid.y = J.$mul$ns(centroid.y, 0.3333333333333333);
        m = A.Convex_triangleArea(a, b, c);
        if (typeof m !== "number")
          return H.iae(m);
        totalArea += m;
        centroid_times_mass.x = J.$mul$ns(centroid.x, m);
        centroid_times_mass.y = J.$mul$ns(centroid.y, m);
        cm.x = J.$add$ns(cm.x, centroid_times_mass.x);
        cm.y = J.$add$ns(cm.y, centroid_times_mass.y);
      }
      A.vec2_scale(cm, cm, 1 / totalArea);
    },
    computeMomentOfInertia$1: function(mass) {
      var t1, $N, j, denom, numer, i, i0, t2, p0, p1, t3, a;
      t1 = this.vertices;
      $N = t1.length;
      for (j = $N - 1, denom = 0, numer = 0, i = 0; i < $N; i0 = i + 1, j = i, i = i0) {
        t2 = t1.length;
        if (j < 0 || j >= t2)
          return H.ioore(t1, j);
        p0 = t1[j];
        if (i >= t2)
          return H.ioore(t1, i);
        p1 = t1[i];
        t2 = J.getInterceptor$x(p0);
        t3 = J.getInterceptor$x(p1);
        a = J.abs$0$n(J.$sub$n(J.$mul$ns(t2.get$x(p0), t3.get$y(p1)), J.$mul$ns(t2.get$y(p0), t3.get$x(p1))));
        t2 = J.$mul$ns(a, J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(t3.get$x(p1), t3.get$x(p1)), J.$mul$ns(t3.get$y(p1), t3.get$y(p1))), J.$add$ns(J.$mul$ns(t3.get$x(p1), t2.get$x(p0)), J.$mul$ns(t3.get$y(p1), t2.get$y(p0)))), J.$add$ns(J.$mul$ns(t2.get$x(p0), t2.get$x(p0)), J.$mul$ns(t2.get$y(p0), t2.get$y(p0)))));
        if (typeof t2 !== "number")
          return H.iae(t2);
        denom += t2;
        if (typeof a !== "number")
          return H.iae(a);
        numer += a;
      }
      return mass / 6 * (denom / numer);
    },
    updateBoundingRadius$0: function() {
      var verts, r2, i, t1, t2, x, y, l2;
      verts = this.vertices;
      for (r2 = 0, i = 0; t1 = verts.length, i !== t1; ++i) {
        if (i >= t1)
          return H.ioore(verts, i);
        t1 = verts[i];
        t2 = J.getInterceptor$x(t1);
        x = t2.get$x(t1);
        y = t2.get$y(t1);
        l2 = J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
        if (J.$gt$n(l2, r2))
          r2 = l2;
      }
      this.boundingRadius = Math.sqrt(H.checkNum(r2));
    },
    updateArea$0: function() {
      var triangles, verts, i, t1, t, t2, a, b, m;
      this.updateTriangles$0();
      this.area = 0;
      triangles = this.triangles;
      verts = this.vertices;
      for (i = 0; t1 = triangles.length, i !== t1; ++i) {
        if (i >= t1)
          return H.ioore(triangles, i);
        t = triangles[i];
        t1 = t[0];
        t2 = verts.length;
        if (t1 >>> 0 !== t1 || t1 >= t2)
          return H.ioore(verts, t1);
        a = verts[t1];
        t1 = t[1];
        if (t1 >>> 0 !== t1 || t1 >= t2)
          return H.ioore(verts, t1);
        b = verts[t1];
        t1 = t[2];
        if (t1 >>> 0 !== t1 || t1 >= t2)
          return H.ioore(verts, t1);
        m = A.Convex_triangleArea(a, b, verts[t1]);
        this.area = J.$add$ns(this.area, m);
      }
    },
    computeAABB$3: function(out, position, angle) {
      out.setFromPoints$4(this.vertices, position, angle, 0);
    },
    $isConvex: true,
    static: {"^": "Convex_tmpVec1,Convex_tmpVec2,Convex_updateCenterOfMass_centroid,Convex_updateCenterOfMass_centroid_times_mass,Convex_updateCenterOfMass_a,Convex_updateCenterOfMass_b,Convex_updateCenterOfMass_c,Convex_updateCenterOfMass_ac,Convex_updateCenterOfMass_ca,Convex_updateCenterOfMass_cb,Convex_updateCenterOfMass_n", Convex_triangleArea: function(a, b, c) {
        var t1, t2, t3;
        t1 = J.getInterceptor$x(b);
        t2 = J.getInterceptor$x(a);
        t3 = J.getInterceptor$x(c);
        return J.$mul$ns(J.$sub$n(J.$mul$ns(J.$sub$n(t1.get$x(b), t2.get$x(a)), J.$sub$n(t3.get$y(c), t2.get$y(a))), J.$mul$ns(J.$sub$n(t3.get$x(c), t2.get$x(a)), J.$sub$n(t1.get$y(b), t2.get$y(a)))), 0.5);
      }}
  },
  Heightfield: {
    "^": "Shape0;"
  },
  Line0: {
    "^": "Shape0;"
  },
  "+Line": 0,
  Particle0: {
    "^": "Shape0;type,id,boundingRadius,collisionGroup,collisionMask,material,area,sensor",
    computeMomentOfInertia$1: function(mass) {
      return 0;
    },
    computeAABB$3: function(out, position, angle) {
      A.vec2_copy(out.lowerBound, position);
      A.vec2_copy(out.upperBound, position);
    },
    $isParticle0: true
  },
  "+Particle": 0,
  Plane: {
    "^": "Shape0;type,id,boundingRadius,collisionGroup,collisionMask,material,area,sensor",
    computeMomentOfInertia$1: function(mass) {
      return 0;
    },
    computeAABB$3: function(out, position, angle) {
      var a, t1, t2;
      a = typeof angle === "number" ? C.JSNumber_methods.$mod(angle, 6.283185307179586) : 0;
      if (a === 0) {
        t1 = out.lowerBound;
        t1.x = -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        t1.y = -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        t2 = out.upperBound;
        t2.x = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        t2.y = 0;
      } else if (a === 1.5707963267948966) {
        t1 = out.lowerBound;
        t1.x = 0;
        t1.y = -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        t2 = out.upperBound;
        t2.x = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        t2.y = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
      } else if (a === 3.141592653589793) {
        t1 = out.lowerBound;
        t1.x = -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        t1.y = 0;
        t2 = out.upperBound;
        t2.x = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        t2.y = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
      } else if (a === 4.71238898038469) {
        t1 = out.lowerBound;
        t1.x = -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        t1.y = -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        t2 = out.upperBound;
        t2.x = 0;
        t2.y = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
      } else {
        t1 = out.lowerBound;
        t1.x = -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        t1.y = -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        t2 = out.upperBound;
        t2.x = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
        t2.y = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;
      }
      A.vec2_add(t1, t1, position);
      A.vec2_add(t2, t2, position);
    },
    $isPlane: true
  },
  Rectangle2: {
    "^": "Convex;width*,height*,vertices,axes,centerOfMass,triangles,type,id,boundingRadius,collisionGroup,collisionMask,material,area,sensor",
    computeMomentOfInertia$1: function(mass) {
      var w, h, t1;
      w = this.width;
      h = this.height;
      t1 = J.$add$ns(J.$mul$ns(h, h), J.$mul$ns(w, w));
      if (typeof t1 !== "number")
        return H.iae(t1);
      return mass * t1 / 12;
    },
    updateBoundingRadius$0: function() {
      var w, h;
      w = this.width;
      h = this.height;
      this.boundingRadius = Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(w, w), J.$mul$ns(h, h)))) / 2;
    },
    computeAABB$3: function(out, position, angle) {
      out.setFromPoints$4(this.vertices, position, angle, 0);
    },
    updateArea$0: function() {
      this.area = J.$mul$ns(this.width, this.height);
    },
    Rectangle$2: function(width, height) {
      var t1, t2, t3, t4, t5, t6;
      t1 = A.vec2_fromValues(J.$div$n(J.$negate$n(this.width), 2), J.$div$n(J.$negate$n(this.height), 2));
      t2 = A.vec2_fromValues(J.$div$n(this.width, 2), J.$div$n(J.$negate$n(this.height), 2));
      t3 = A.vec2_fromValues(J.$div$n(this.width, 2), J.$div$n(this.height, 2));
      t4 = A.vec2_fromValues(J.$div$n(J.$negate$n(this.width), 2), J.$div$n(this.height, 2));
      t5 = A.vec2_fromValues(1, 0);
      t6 = A.vec2_fromValues(0, 1);
      this.type = 32;
      A.Convex.prototype.init$2.call(this, [t1, t2, t3, t4], [t5, t6]);
    },
    $isRectangle2: true,
    static: {"^": "Rectangle_corner1,Rectangle_corner2,Rectangle_corner3,Rectangle_corner4", Rectangle$0: function(width, height) {
        var t1, t2, out;
        t1 = H.setRuntimeTypeInfo([], [A.vec2]);
        t2 = H.setRuntimeTypeInfo([], [A.vec2]);
        out = new A.vec2(0, 0);
        out.x = 0;
        out.y = 0;
        t2 = new A.Rectangle2(width, height, t1, t2, out, [], null, null, null, null, null, null, null, null);
        t2.Shape$1(8);
        t2.Rectangle$2(width, height);
        return t2;
      }}
  },
  "+Rectangle": 0,
  Shape0: {
    "^": "Object;type*,id*,boundingRadius<,collisionGroup@,collisionMask@,material<,area@,sensor<",
    computeMomentOfInertia$1: function(mass) {
      throw H.wrapException(P.Exception_Exception("Shape.computeMomentOfInertia is not implemented in this Shape..."));
    },
    Shape$1: function(type) {
      var t1;
      this.type = type;
      t1 = $.Shape_idCounter;
      $.Shape_idCounter = t1 + 1;
      this.id = t1;
      this.boundingRadius = 0;
      this.collisionGroup = 1;
      this.collisionMask = 1;
      this.material = null;
      this.area = 0;
      this.sensor = false;
    },
    $isShape0: true
  },
  "+Shape": 0,
  GSSolver: {
    "^": "Solver;iterations,tolerance,arrayStep,lambda,Bs,invCs,useZeroRHS,frictionIterations,usedIterations,type,equations,equationSortFunction,mockWorld,_listeners",
    setArrayZero$1: function(array) {
      var l, l0, l1;
      l = array.length;
      for (l0 = l; l1 = l0 - 1, l0 > 0; l0 = l1) {
        if (l1 < 0)
          return H.ioore(array, l1);
        array[l1] = 0;
      }
    },
    solve$2: function(h, world) {
      var maxIter, maxFrictionIter, equations, Neq, t1, tolSquared, bodies, Nbodies, useZeroRHS, lambda, i, invCs, Bs, t2, t3, t4, c, iter, deltalambdaTot, j, eq, f, k;
      maxIter = this.iterations;
      maxFrictionIter = this.frictionIterations;
      equations = this.equations;
      Neq = equations.length;
      t1 = this.tolerance * Neq;
      H.checkNum(t1);
      H.checkNum(2);
      tolSquared = Math.pow(t1, 2);
      bodies = world.bodies;
      Nbodies = bodies.length;
      useZeroRHS = this.useZeroRHS;
      lambda = this.lambda;
      this.usedIterations = 0;
      t1 = Neq !== 0;
      if (t1)
        for (i = 0; i !== Nbodies; ++i) {
          if (i >= bodies.length)
            return H.ioore(bodies, i);
          bodies[i].updateSolveMassProperties$0();
        }
      if (lambda.length < Neq) {
        lambda = new Float32Array(H._checkLength(Neq + this.arrayStep));
        this.lambda = lambda;
        this.Bs = new Float32Array(H._checkLength(Neq + this.arrayStep));
        this.invCs = new Float32Array(H._checkLength(Neq + this.arrayStep));
      }
      this.setArrayZero$1(lambda);
      invCs = this.invCs;
      Bs = this.Bs;
      lambda = this.lambda;
      for (t2 = Bs.length, t3 = invCs.length, i = 0; t4 = equations.length, i !== t4; ++i) {
        if (i >= t4)
          return H.ioore(equations, i);
        c = equations[i];
        if (!J.$eq(c.get$timeStep(), h) || c.get$needsUpdate() === true) {
          c.set$timeStep(h);
          c.update$0();
        }
        t4 = c.computeB$3(J.get$a$x(c), c.get$b(), h);
        if (i >= t2)
          return H.ioore(Bs, i);
        Bs[i] = t4;
        t4 = c.computeInvC$1(c.get$epsilon());
        if (i >= t3)
          return H.ioore(invCs, i);
        invCs[i] = t4;
      }
      if (t1) {
        for (i = 0; i !== Nbodies; ++i) {
          if (i >= bodies.length)
            return H.ioore(bodies, i);
          bodies[i].resetConstraintVelocity$0();
        }
        if (maxFrictionIter !== 0) {
          for (iter = 0, c = null; iter !== maxFrictionIter; ++iter) {
            for (deltalambdaTot = 0, j = 0; j !== Neq; ++j) {
              if (j >= equations.length)
                return H.ioore(equations, j);
              c = equations[j];
              deltalambdaTot += Math.abs(A.GSSolver_iterateEquation(j, c, c.get$epsilon(), Bs, invCs, lambda, useZeroRHS, h, iter));
            }
            ++this.usedIterations;
            if (deltalambdaTot * deltalambdaTot <= tolSquared)
              break;
          }
          if (typeof h !== "number")
            return H.iae(h);
          A.GSSolver_updateMultipliers(equations, lambda, 1 / h);
          for (j = 0; j !== Neq; ++j) {
            if (j >= equations.length)
              return H.ioore(equations, j);
            eq = equations[j];
            if (!!J.getInterceptor(eq).$isFrictionEquation) {
              for (f = 0, k = 0; t1 = eq.contactEquations, t2 = t1.length, k !== t2; ++k) {
                if (k >= t2)
                  return H.ioore(t1, k);
                t1 = t1[k].get$multiplier();
                if (typeof t1 !== "number")
                  return H.iae(t1);
                f += t1;
              }
              f *= eq.frictionCoefficient / t2;
              eq.maxForce = f;
              eq.minForce = -f;
            }
          }
        } else
          c = null;
        for (iter = 0; iter !== maxIter; ++iter) {
          for (deltalambdaTot = 0, j = 0; j !== Neq; ++j) {
            if (j >= equations.length)
              return H.ioore(equations, j);
            c = equations[j];
            deltalambdaTot += Math.abs(A.GSSolver_iterateEquation(j, c, c.get$epsilon(), Bs, invCs, lambda, useZeroRHS, h, iter));
          }
          ++this.usedIterations;
          if (deltalambdaTot * deltalambdaTot <= tolSquared)
            break;
        }
        for (i = 0; i !== Nbodies; ++i) {
          if (i >= bodies.length)
            return H.ioore(bodies, i);
          bodies[i].addConstraintVelocity$0();
        }
        if (typeof h !== "number")
          return H.iae(h);
        A.GSSolver_updateMultipliers(equations, lambda, 1 / h);
      }
    },
    GSSolver$2$iterations$tolerance: function(iterations, tolerance) {
      this.iterations = iterations;
      this.tolerance = tolerance;
      this.arrayStep = 30;
      this.lambda = new Float32Array(H._checkLength(30));
      this.Bs = new Float32Array(H._checkLength(this.arrayStep));
      this.invCs = new Float32Array(H._checkLength(this.arrayStep));
      this.useZeroRHS = false;
      this.frictionIterations = 0;
      this.usedIterations = 0;
    },
    static: {GSSolver_updateMultipliers: function(equations, lambda, invDt) {
        var l, t1, l0, t2;
        l = equations.length;
        for (t1 = lambda.length; l0 = l - 1, l > 0; l = l0) {
          if (l0 < 0 || l0 >= equations.length)
            return H.ioore(equations, l0);
          t2 = equations[l0];
          if (l0 >= t1)
            return H.ioore(lambda, l0);
          t2.set$multiplier(lambda[l0] * invDt);
        }
      }, GSSolver_iterateEquation: function(j, eq, eps, Bs, invCs, lambda, useZeroRHS, dt, iter) {
        var $B, invC, lambdaj, GWlambda, maxForce, minForce, t1, deltalambda, lambdaj_plus_deltalambda;
        if (j >= Bs.length)
          return H.ioore(Bs, j);
        $B = Bs[j];
        if (j >= invCs.length)
          return H.ioore(invCs, j);
        invC = invCs[j];
        if (j >= lambda.length)
          return H.ioore(lambda, j);
        lambdaj = lambda[j];
        GWlambda = eq.computeGWlambda$0();
        maxForce = eq.get$maxForce();
        minForce = eq.get$minForce();
        t1 = J.$sub$n(J.$sub$n(useZeroRHS ? 0 : $B, GWlambda), eps * lambdaj);
        if (typeof t1 !== "number")
          return H.iae(t1);
        deltalambda = invC * t1;
        lambdaj_plus_deltalambda = lambdaj + deltalambda;
        if (typeof dt !== "number")
          return H.iae(dt);
        t1 = minForce * dt;
        if (lambdaj_plus_deltalambda < t1)
          deltalambda = t1 - lambdaj;
        else {
          t1 = maxForce * dt;
          if (lambdaj_plus_deltalambda > t1)
            deltalambda = t1 - lambdaj;
        }
        lambda[j] = lambda[j] + deltalambda;
        eq.addToWlambda$1(deltalambda);
        return deltalambda;
      }}
  },
  Solver: {
    "^": "EventEmitter;type*,equations<",
    solve$2: function(dt, world) {
      throw H.wrapException(P.Exception_Exception("Solver.solve should be implemented by subclasses!"));
    },
    solveIsland$2: function(dt, island) {
      var t1;
      C.JSArray_methods.set$length(this.equations, 0);
      island.get$equations();
      this.addEquations$1(island.get$equations());
      t1 = this.mockWorld;
      C.JSArray_methods.set$length(t1.bodies, 0);
      island.getBodies$1(t1.bodies);
      if (t1.bodies.length !== 0)
        this.solve$2(dt, t1);
    },
    addEquations$1: function(eqs) {
      var $N, i, eq;
      for ($N = eqs.length, i = 0; i !== $N; ++i) {
        if (i >= eqs.length)
          return H.ioore(eqs, i);
        eq = eqs[i];
        if (eq.get$enabled() === true)
          this.equations.push(eq);
      }
    },
    removeAllEquations$0: function() {
      C.JSArray_methods.set$length(this.equations, 0);
    },
    Solver$2$equationSortFunction: function(type, equationSortFunction) {
      this.type = type;
      this.equations = H.setRuntimeTypeInfo([], [A.Equation]);
      this.equationSortFunction = equationSortFunction;
    }
  },
  OverlapKeeperRecord: {
    "^": "Object;shapeA@,shapeB@,bodyA@,bodyB@",
    set$4: function(bodyA, shapeA, bodyB, shapeB) {
      this.shapeA = shapeA;
      this.shapeB = shapeB;
      this.bodyA = bodyA;
      this.bodyB = bodyB;
    },
    $isOverlapKeeperRecord: true
  },
  OverlapKeeper: {
    "^": "Object;overlappingShapesLastState,overlappingShapesCurrentState,recordPool,tmpDict,tmpArray1",
    tick$0: [function() {
      var last, current, l, l0, t1, key, lastObject, currentObject;
      last = this.overlappingShapesLastState;
      current = this.overlappingShapesCurrentState;
      l = last.keys.length;
      for (; l0 = l - 1, l > 0; l = l0) {
        t1 = last.keys;
        if (l0 < 0 || l0 >= t1.length)
          return H.ioore(t1, l0);
        key = t1[l0];
        lastObject = last.getByKey$1(key);
        currentObject = current.getByKey$1(key);
        if (lastObject != null && currentObject == null)
          this.recordPool.push(lastObject);
      }
      last.reset$0(0);
      last.copy$1(current);
      current.reset$0(0);
    }, "call$0", "get$tick", 0, 0, 54],
    getDiff$3: function(dictA, dictB, result) {
      var l, l0, t1, key, data;
      if (result == null)
        result = H.setRuntimeTypeInfo([], [A.OverlapKeeperRecord]);
      J.set$length$asx(result, 0);
      l = dictB.keys.length;
      for (; l0 = l - 1, l > 0; l = l0) {
        t1 = dictB.keys;
        if (l0 < 0 || l0 >= t1.length)
          return H.ioore(t1, l0);
        key = t1[l0];
        data = J.$index$asx(dictB.data, key);
        if (data == null)
          throw H.wrapException(P.Exception_Exception("Key " + H.S(key) + " had no data!"));
        if (J.$index$asx(dictA.data, key) == null)
          result.push(data);
      }
      return result;
    },
    OverlapKeeper$0: function() {
      this.overlappingShapesLastState = A.TupleDictionary$(A.OverlapKeeperRecord);
      this.overlappingShapesCurrentState = A.TupleDictionary$(A.OverlapKeeperRecord);
      this.recordPool = H.setRuntimeTypeInfo([], [A.OverlapKeeperRecord]);
      this.tmpDict = A.TupleDictionary$(A.OverlapKeeperRecord);
      this.tmpArray1 = H.setRuntimeTypeInfo([], [A.OverlapKeeperRecord]);
    }
  },
  TupleDictionary: {
    "^": "Object;data*,keys>",
    getKey$2: function(id1, id2) {
      var t1, t2;
      t1 = J.getInterceptor(id1);
      if (t1.$eq(id1, id2))
        return -1;
      t2 = J.getInterceptor$n(id2);
      return ((t1.$gt(id1, id2) ? t1.toInt$0(id1) << 16 | t2.toInt$0(id2) & 65535 : t2.toInt$0(id2) << 16 | t1.toInt$0(id1) & 65535) | 0) >>> 0;
    },
    getByKey$1: function(key) {
      if (J.containsKey$1$x(this.data, key))
        return J.$index$asx(this.data, key);
      return;
    },
    set$3: function(i, j, value) {
      var key;
      if (value == null)
        throw H.wrapException(P.Exception_Exception("No data!"));
      key = this.getKey$2(i, j);
      if (J.containsKey$1$x(this.data, key))
        this.keys.push(key);
      J.$indexSet$ax(this.data, key, value);
      return key;
    },
    reset$0: function(_) {
      var l, l0, t1, t2;
      l = this.keys.length;
      for (; l0 = l - 1, l > 0; l = l0) {
        t1 = this.data;
        t2 = this.keys;
        if (l0 < 0 || l0 >= t2.length)
          return H.ioore(t2, l0);
        J.remove$1$ax(t1, t2[l0]);
      }
      C.JSArray_methods.set$length(this.keys, 0);
    },
    copy$1: function(dict) {
      var t1, l, t2, l0, key;
      this.reset$0(0);
      t1 = J.getInterceptor$x(dict);
      C.JSArray_methods.addAll$1(this.keys, t1.get$keys(dict));
      l = J.get$length$asx(t1.get$keys(dict));
      for (; t2 = J.getInterceptor$n(l), l0 = t2.$sub(l, 1), t2.$gt(l, 0); l = l0) {
        key = J.$index$asx(t1.get$keys(dict), l0);
        J.$indexSet$ax(this.data, key, J.$index$asx(t1.get$data(dict), key));
      }
    },
    TupleDictionary$0: function($V) {
      this.data = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this.keys = H.setRuntimeTypeInfo([], [P.$int]);
    },
    static: {TupleDictionary$: function($V) {
        var t1 = H.setRuntimeTypeInfo(new A.TupleDictionary(null, null), [$V]);
        t1.TupleDictionary$0($V);
        return t1;
      }}
  },
  Island: {
    "^": "Object;equations<,bodies@,bodyIds",
    reset$0: function(_) {
      C.JSArray_methods.set$length(this.equations, 0);
      C.JSArray_methods.set$length(this.bodies, 0);
    },
    getBodies$1: function(result) {
      var eqs, t1, i, t2, eq;
      eqs = this.equations;
      t1 = this.bodyIds;
      C.JSArray_methods.set$length(t1, 0);
      for (i = 0; t2 = eqs.length, i !== t2; ++i) {
        if (i >= t2)
          return H.ioore(eqs, i);
        eq = eqs[i];
        if (!C.JSArray_methods.contains$1(t1, J.get$id$x(eq.get$bodyA()))) {
          result.push(eq.get$bodyA());
          t1.push(J.get$id$x(eq.get$bodyA()));
        }
        if (!C.JSArray_methods.contains$1(t1, J.get$id$x(eq.get$bodyB()))) {
          result.push(eq.get$bodyB());
          t1.push(J.get$id$x(eq.get$bodyB()));
        }
      }
      return result;
    },
    wantsToSleep$0: [function() {
      var i, t1, b;
      for (i = 0; t1 = this.bodies, i < t1.length; ++i) {
        b = t1[i];
        if (J.$eq(J.get$type$x(b), 1) && b.get$wantsToSleep() !== true)
          return false;
      }
      return true;
    }, "call$0", "get$wantsToSleep", 0, 0, 247],
    sleep$0: function() {
      var i, t1;
      for (i = 0; t1 = this.bodies, i < t1.length; ++i)
        t1[i].sleep$0();
      return true;
    },
    $isIsland: true
  },
  IslandManager: {
    "^": "Object;_nodePool,_islandPool,equations<,islands,nodes>,queue<",
    visit$3: function(node, bds, eqs) {
      var t1, Neqs, i, eq;
      J.add$1$ax(bds, node.body);
      t1 = node.equations;
      Neqs = t1.length;
      for (i = 0; i !== Neqs; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        eq = t1[i];
        if (J.$eq(H.Lists_indexOf(eqs, eq, 0, eqs.length), -1))
          eqs.push(eq);
      }
    },
    bfs$3: function(root, bds, eqs) {
      var t1, t2, child;
      t1 = this.queue;
      C.JSArray_methods.set$length(t1, 0);
      t1.push(root);
      root.visited = true;
      this.visit$3(root, bds, eqs);
      for (; t2 = t1.length, t2 !== 0;) {
        if (0 >= t2)
          return H.ioore(t1, 0);
        for (t2 = t1.pop().neighbors; child = A.IslandManager_getUnvisitedNode(t2), child != null;) {
          child.visited = true;
          this.visit$3(child, bds, eqs);
          if (J.$eq(J.get$type$x(child.body), 1))
            t1.push(child);
        }
      }
    },
    split$1: function(_, world) {
      var bodies, t1, t2, t3, i, t4, node, t5, t6, k, eq, j, ni, nj, island, child;
      bodies = world.get$bodies();
      for (t1 = this.nodes, t2 = this._nodePool; t3 = t1.length, t3 !== 0;) {
        if (0 >= t3)
          return H.ioore(t1, 0);
        t2.push(t1.pop());
      }
      for (t3 = J.getInterceptor$asx(bodies), i = 0; i !== t3.get$length(bodies); ++i) {
        t4 = t2.length;
        if (t4 !== 0) {
          if (0 >= t4)
            return H.ioore(t2, 0);
          node = t2.pop();
          C.JSArray_methods.set$length(node.equations, 0);
          C.JSArray_methods.set$length(node.neighbors, 0);
          node.visited = false;
          node.body = null;
          node.body = t3.$index(bodies, i);
          t1.push(node);
        } else {
          t4 = t3.$index(bodies, i);
          t5 = [];
          t5.$builtinTypeInfo = [A.IslandNode];
          t6 = [];
          t6.$builtinTypeInfo = [A.Equation];
          t5 = new A.IslandNode(null, t5, t6, false);
          t5.body = t4;
          t1.push(t5);
        }
      }
      for (t2 = this.equations, k = 0; t4 = t2.length, k !== t4; ++k) {
        if (k >= t4)
          return H.ioore(t2, k);
        eq = t2[k];
        i = t3.indexOf$1(bodies, eq.get$bodyA());
        j = t3.indexOf$1(bodies, eq.get$bodyB());
        t4 = t1.length;
        if (i >>> 0 !== i || i >= t4)
          return H.ioore(t1, i);
        ni = t1[i];
        if (j >>> 0 !== j || j >= t4)
          return H.ioore(t1, j);
        nj = t1[j];
        ni.neighbors.push(nj);
        nj.neighbors.push(ni);
        ni.equations.push(eq);
        nj.equations.push(eq);
      }
      for (t2 = this.islands, t3 = this._islandPool; t4 = t2.length, t4 !== 0;) {
        if (0 >= t4)
          return H.ioore(t2, 0);
        island = t2.pop();
        J.reset$0$x(island);
        t3.push(island);
      }
      for (; child = A.IslandManager_getUnvisitedNode(t1), child != null;) {
        t4 = t3.length;
        if (t4 !== 0) {
          if (0 >= t4)
            return H.ioore(t3, 0);
          island = t3.pop();
        } else {
          t4 = [];
          t4.$builtinTypeInfo = [P.$int];
          island = new A.Island(null, null, t4);
          t4 = [];
          t4.$builtinTypeInfo = [A.Equation];
          island.equations = t4;
          t4 = [];
          t4.$builtinTypeInfo = [A.Body3];
          island.bodies = t4;
        }
        this.bfs$3(child, island.get$bodies(), island.get$equations());
        t2.push(island);
      }
      return t2;
    },
    static: {IslandManager_getUnvisitedNode: function(nodes) {
        var Nnodes, i, node;
        Nnodes = nodes.length;
        for (i = 0; i !== Nnodes; ++i) {
          if (i >= nodes.length)
            return H.ioore(nodes, i);
          node = nodes[i];
          if (!node.visited && J.$eq(J.get$type$x(node.body), 1))
            return node;
        }
        return;
      }}
  },
  IslandNode: {
    "^": "Object;body*,neighbors,equations<,visited",
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.body.call$3(arg0, arg1, arg2);
    },
    reset$0: function(_) {
      C.JSArray_methods.set$length(this.equations, 0);
      C.JSArray_methods.set$length(this.neighbors, 0);
      this.visited = false;
      this.body = null;
    },
    $isIslandNode: true
  },
  World0: {
    "^": "EventEmitter;springs,bodies@,disabledBodyCollisionPairs,solver,narrowphase,islandManager,gravity<,frictionGravity,useWorldGravityAsFrictionGravity,useFrictionGravityOnZeroGravity,doProfiling,lastStepTime,broadphase,constraints,defaultMaterial,defaultContactMaterial<,lastTimeStep,applySpringForces,applyDamping<,applyGravity,solveConstraints,contactMaterials,time@,stepping@,bodiesToBeRemoved,fixedStepTime,islandSplit,emitImpactEvent,_constraintIdCounter,_bodyIdCounter,postStepEvent,addBodyEvent,removeBodyEvent,addSpringEvent,impactEvent,postBroadphaseEvent,sleepMode,beginContactEvent,endContactEvent,preSolveEvent,overlappingShapesLastState,overlappingShapesCurrentState,overlapKeeper,_listeners",
    applyDamping$1: function(arg0) {
      return this.applyDamping.call$1(arg0);
    },
    step$3: [function(_, dt, timeSinceLastCalled, maxSubSteps) {
      var internalSteps, t00, t1, i, t2, t3, h, h_div_dt, j, b, t4, t5;
      if (timeSinceLastCalled === 0) {
        this.internalStep$1(dt);
        this.time = J.$add$ns(this.time, dt);
      } else {
        internalSteps = P.min(J.floor$0$n(J.$div$n(J.$add$ns(this.time, timeSinceLastCalled), dt)) - J.floor$0$n(J.$div$n(this.time, dt)), maxSubSteps);
        t00 = window.performance.now();
        for (t1 = J.getInterceptor$ns(dt), i = 0; i !== internalSteps; ++i) {
          this.internalStep$1(dt);
          t2 = window.performance.now();
          if (typeof t2 !== "number")
            return t2.$sub();
          if (typeof t00 !== "number")
            return H.iae(t00);
          t3 = t1.$mul(dt, 1000);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (t2 - t00 > t3)
            break;
        }
        t1 = J.$add$ns(this.time, timeSinceLastCalled);
        this.time = t1;
        h = J.$mod$n(t1, dt);
        if (typeof dt !== "number")
          return H.iae(dt);
        h_div_dt = h / dt;
        for (j = 0; t1 = this.bodies, t2 = t1.length, j !== t2; ++j) {
          if (j >= t2)
            return H.ioore(t1, j);
          b = t1[j];
          t1 = J.getInterceptor$x(b);
          if (!J.$eq(t1.get$type(b), 2) && b.get$sleepState() !== 2) {
            t2 = $.vec2_sub;
            t3 = $.get$World_interpvelo();
            t2.call$3(t3, t1.get$position(b), b.get$previousPosition());
            t3.x = J.$mul$ns(t3.x, h_div_dt);
            t3.y = J.$mul$ns(t3.y, h_div_dt);
            t2 = b.get$interpolatedPosition();
            t4 = t1.get$position(b);
            t5 = J.getInterceptor$x(t4);
            t2.x = J.$add$ns(t5.get$x(t4), t3.x);
            t2.y = J.$add$ns(t5.get$y(t4), t3.y);
            b.set$interpolatedAngle(J.$add$ns(t1.get$angle(b), J.$mul$ns(J.$sub$n(t1.get$angle(b), b.get$previousAngle()), h_div_dt)));
          } else {
            t2 = b.get$interpolatedPosition();
            t3 = t1.get$position(b);
            t4 = J.getInterceptor$x(t3);
            t2.x = t4.get$x(t3);
            t2.y = t4.get$y(t3);
            b.set$interpolatedAngle(t1.get$angle(b));
          }
        }
      }
    }, function($receiver, dt) {
      return this.step$3($receiver, dt, 0, 10);
    }, "step$1", function($receiver, dt, timeSinceLastCalled) {
      return this.step$3($receiver, dt, timeSinceLastCalled, 10);
    }, "step$2", "call$3", "call$1", "call$2", "get$step", 2, 4, 1802, 49, 393],
    internalStep$1: function(dt) {
      var Nsprings, g, Nbodies, np, mg, t00, x, y, t1, gravityLen, i, b, fi, result, ignoredPairs, j, j0, Nconstraints, c, Nresults, bi, t2, bj, Nshapesi, k, si, xi, ai, Nshapesj, l, sj, xj, aj, cm, body, e, l0, data, preSolveEvent, island, minv, f, pos, velo, t3, t4, t5, ev, eq;
      this.stepping = true;
      Nsprings = this.springs.length;
      g = this.gravity;
      Nbodies = this.bodies.length;
      np = this.narrowphase;
      $.get$World_step_fhMinv();
      $.get$World_step_velodt();
      mg = $.get$World_step_mg();
      this.overlapKeeper.tick$0();
      this.lastTimeStep = dt;
      t00 = this.doProfiling === true ? window.performance.now() : null;
      if (this.useWorldGravityAsFrictionGravity) {
        x = g.x;
        y = g.y;
        t1 = J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        gravityLen = Math.sqrt(t1);
        if (!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity))
          this.frictionGravity = gravityLen;
      }
      if (this.applyGravity === true)
        for (i = 0; i !== Nbodies; ++i) {
          t1 = this.bodies;
          if (i >= t1.length)
            return H.ioore(t1, i);
          b = t1[i];
          t1 = J.getInterceptor$x(b);
          fi = t1.get$force(b);
          if (!J.$eq(t1.get$type(b), 1) || b.get$sleepState() === 2)
            continue;
          t1 = b.get$mass() * b.get$gravityScale();
          mg.x = J.$mul$ns(g.x, t1);
          mg.y = J.$mul$ns(g.y, t1);
          t1 = J.getInterceptor$x(fi);
          t1.set$x(fi, J.$add$ns(t1.get$x(fi), mg.x));
          t1.set$y(fi, J.$add$ns(t1.get$y(fi), mg.y));
        }
      if (this.applySpringForces === true)
        for (i = 0; i !== Nsprings; ++i) {
          t1 = this.springs;
          if (i >= t1.length)
            return H.ioore(t1, i);
          t1[i].applyForce$0();
        }
      if (this.applyDamping === true)
        for (i = 0; i !== Nbodies; ++i) {
          t1 = this.bodies;
          if (i >= t1.length)
            return H.ioore(t1, i);
          b = t1[i];
          if (J.$eq(J.get$type$x(b), 1))
            b.applyDamping$1(dt);
        }
      result = this.broadphase.getCollisionPairs$1(this);
      ignoredPairs = this.disabledBodyCollisionPairs;
      for (j = result.length - 2, i = -2; false; i -= 2)
        for (t1 = i + 1, j0 = j; j0 >= 0; j0 -= 2) {
          return H.ioore(ignoredPairs, i);
          return H.ioore(ignoredPairs, t1);
        }
      Nconstraints = this.constraints.length;
      for (i = 0; i !== Nconstraints; ++i) {
        t1 = this.constraints;
        if (i >= t1.length)
          return H.ioore(t1, i);
        c = t1[i];
        c.get$collideConnected();
        for (j = result.length - 2; j >= 0; j -= 2) {
          c.get$bodyA();
          if (j >= result.length)
            return H.ioore(result, j);
          c.get$bodyB();
          if (j >= result.length)
            return H.ioore(result, j);
        }
      }
      this.postBroadphaseEvent.$indexSet(0, "pairs", result);
      this.emit$1(this.postBroadphaseEvent);
      np.reset$0(0);
      for (Nresults = result.length, i = 0; i !== Nresults; i += 2) {
        t1 = result.length;
        if (i >= t1)
          return H.ioore(result, i);
        bi = result[i];
        t2 = i + 1;
        if (t2 >= t1)
          return H.ioore(result, t2);
        bj = result[t2];
        for (Nshapesi = bi.get$shapes().length, k = 0; k !== Nshapesi; ++k) {
          t1 = bi.get$shapes();
          if (k >= t1.length)
            return H.ioore(t1, k);
          si = t1[k];
          t1 = bi.get$shapeOffsets();
          if (k >= t1.length)
            return H.ioore(t1, k);
          xi = t1[k];
          t1 = bi.get$shapeAngles();
          if (k >= t1.length)
            return H.ioore(t1, k);
          ai = t1[k];
          for (Nshapesj = bj.get$shapes().length, l = 0; l !== Nshapesj; ++l) {
            t1 = bj.get$shapes();
            if (l >= t1.length)
              return H.ioore(t1, l);
            sj = t1[l];
            t1 = bj.get$shapeOffsets();
            if (l >= t1.length)
              return H.ioore(t1, l);
            xj = t1[l];
            t1 = bj.get$shapeAngles();
            if (l >= t1.length)
              return H.ioore(t1, l);
            aj = t1[l];
            cm = this.defaultContactMaterial;
            si.get$material();
            this.runNarrowphase$11(np, bi, si, xi, ai, bj, sj, xj, aj, cm, this.frictionGravity);
          }
        }
      }
      for (i = 0; i !== Nbodies; ++i) {
        t1 = this.bodies;
        if (i >= t1.length)
          return H.ioore(t1, i);
        body = t1[i];
        if (body.get$_wakeUpAfterNarrowphase()) {
          body.wakeUp$0();
          body.set$_wakeUpAfterNarrowphase(false);
        }
      }
      if (this.has$1("endContact")) {
        t1 = this.overlapKeeper;
        t2 = $.get$World_endOverlaps();
        t1.getDiff$3(t1.overlappingShapesCurrentState, t1.overlappingShapesLastState, t2);
        e = this.endContactEvent;
        l = t2.length;
        for (t1 = t2; l0 = l - 1, l > 0; l = l0) {
          if (l0 < 0 || l0 >= t1.length)
            return H.ioore(t1, l0);
          data = t1[l0];
          e.$indexSet(0, "shapeA", data.get$shapeA());
          e.$indexSet(0, "shapeB", data.get$shapeB());
          e.$indexSet(0, "bodyA", data.get$bodyA());
          e.$indexSet(0, "bodyB", data.get$bodyB());
          this.emit$1(e);
        }
      }
      preSolveEvent = this.preSolveEvent;
      preSolveEvent.$indexSet(0, "contactEquations", np.contactEquations);
      preSolveEvent.$indexSet(0, "frictionEquations", np.frictionEquations);
      this.emit$1(preSolveEvent);
      Nconstraints = this.constraints.length;
      for (i = 0; i !== Nconstraints; ++i) {
        t1 = this.constraints;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].update$0();
      }
      t1 = np.contactEquations;
      if (t1.length !== 0 || np.frictionEquations.length !== 0 || this.constraints.length !== 0)
        if (this.islandSplit === true) {
          C.JSArray_methods.set$length(this.islandManager.equations, 0);
          C.JSArray_methods.addAll$1(this.islandManager.equations, np.contactEquations);
          C.JSArray_methods.addAll$1(this.islandManager.equations, np.frictionEquations);
          for (i = 0; i !== Nconstraints; ++i) {
            t1 = this.islandManager;
            t2 = this.constraints;
            if (i >= t2.length)
              return H.ioore(t2, i);
            C.JSArray_methods.addAll$1(t1.equations, t2[i].get$equations());
          }
          this.islandManager.split$1(0, this);
          for (i = 0; t1 = this.islandManager.islands, t2 = t1.length, i !== t2; ++i) {
            if (i >= t2)
              return H.ioore(t1, i);
            island = t1[i];
            island.get$equations();
            this.solver.solveIsland$2(dt, island);
          }
        } else {
          this.solver.addEquations$1(t1);
          this.solver.addEquations$1(np.frictionEquations);
          for (i = 0; i !== Nconstraints; ++i) {
            t1 = this.solver;
            t2 = this.constraints;
            if (i >= t2.length)
              return H.ioore(t2, i);
            t1.addEquations$1(t2[i].get$equations());
          }
          if (this.solveConstraints === true)
            this.solver.solve$2(dt, this);
          this.solver.removeAllEquations$0();
        }
      for (t1 = J.getInterceptor$ns(dt), i = 0; i !== Nbodies; ++i) {
        t2 = this.bodies;
        if (i >= t2.length)
          return H.ioore(t2, i);
        body = t2[i];
        if (body.get$sleepState() !== 2 && !J.$eq(J.get$type$x(body), 2)) {
          minv = body.get$invMass();
          t2 = J.getInterceptor$x(body);
          f = t2.get$force(body);
          pos = t2.get$position(body);
          velo = body.get$velocity();
          t3 = body.get$previousPosition();
          t4 = t2.get$position(body);
          t5 = J.getInterceptor$x(t4);
          t3.x = t5.get$x(t4);
          t3.y = t5.get$y(t4);
          body.set$previousAngle(t2.get$angle(body));
          if (!body.get$fixedRotation()) {
            t3 = body.get$angularVelocity();
            t4 = body.get$angularForce();
            t5 = body.get$invInertia();
            if (typeof dt !== "number")
              return H.iae(dt);
            body.set$angularVelocity(J.$add$ns(t3, t4 * t5 * dt));
            t2.set$angle(body, J.$add$ns(t2.get$angle(body), J.$mul$ns(body.get$angularVelocity(), dt)));
          }
          t2 = $.get$World_ib_fhMinv();
          t3 = t1.$mul(dt, minv);
          t4 = J.getInterceptor$x(f);
          t2.x = J.$mul$ns(t4.get$x(f), t3);
          t2.y = J.$mul$ns(t4.get$y(f), t3);
          t3 = J.getInterceptor$x(velo);
          t3.set$x(velo, J.$add$ns(t2.x, t3.get$x(velo)));
          t3.set$y(velo, J.$add$ns(t2.y, t3.get$y(velo)));
          t2 = $.get$World_ib_velodt();
          t2.x = J.$mul$ns(t3.get$x(velo), dt);
          t2.y = J.$mul$ns(t3.get$y(velo), dt);
          t3 = J.getInterceptor$x(pos);
          t3.set$x(pos, J.$add$ns(t3.get$x(pos), t2.x));
          t3.set$y(pos, J.$add$ns(t3.get$y(pos), t2.y));
          body.set$aabbNeedsUpdate(true);
        }
      }
      for (i = 0; i !== Nbodies; ++i) {
        t1 = this.bodies;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].setZeroForce$0();
      }
      if (this.doProfiling === true) {
        t1 = window.performance.now();
        if (typeof t1 !== "number")
          return t1.$sub();
        if (typeof t00 !== "number")
          return H.iae(t00);
        this.lastStepTime = t1 - t00;
      }
      if (this.emitImpactEvent === true && this.has$1("impact")) {
        ev = this.impactEvent;
        for (i = 0; t1 = np.contactEquations, t2 = t1.length, i !== t2; ++i) {
          if (i >= t2)
            return H.ioore(t1, i);
          eq = t1[i];
          if (eq.get$firstImpact()) {
            ev.$indexSet(0, "bodyA", eq.get$bodyA());
            ev.$indexSet(0, "bodyB", eq.get$bodyB());
            ev.$indexSet(0, "shapeA", eq.get$shapeA());
            ev.$indexSet(0, "shapeB", eq.get$shapeB());
            ev.$indexSet(0, "contactEquation", eq);
            this.emit$1(ev);
          }
        }
      }
      t1 = this.sleepMode;
      if (t1 === 2)
        for (i = 0; i !== Nbodies; ++i) {
          t1 = this.bodies;
          if (i >= t1.length)
            return H.ioore(t1, i);
          t1[i].sleepTick$3(this.time, false, dt);
        }
      else if (t1 === 4 && this.islandSplit === true) {
        for (i = 0; i !== Nbodies; ++i) {
          t1 = this.bodies;
          if (i >= t1.length)
            return H.ioore(t1, i);
          t1[i].sleepTick$3(this.time, true, dt);
        }
        for (i = 0; t1 = this.islandManager.islands, i < t1.length; ++i) {
          island = t1[i];
          if (island.wantsToSleep$0() === true)
            island.sleep$0();
        }
      }
      this.stepping = false;
      if (this.bodiesToBeRemoved.length !== 0) {
        for (i = 0; t1 = this.bodiesToBeRemoved, t2 = t1.length, i !== t2; ++i) {
          if (i >= t2)
            return H.ioore(t1, i);
          this.removeBody$1(t1[i]);
        }
        J.set$length$asx(t1, 0);
      }
      this.emit$1(this.postStepEvent);
    },
    runNarrowphase$11: function(np, bi, si, xi, ai, bj, sj, xj, aj, cm, glen) {
      var t1, t2, t3, t4, t5, t6, aiw, ajw, reducedMass, resolver, sensor, numFrictionBefore, numContacts, numFrictionEquations, t7, x, y, speedSquaredB, speedSquaredA, current, data, idA, idB, last, e, i, f;
      if (!((si.get$collisionGroup() & sj.get$collisionMask()) >>> 0 !== 0 && (sj.get$collisionGroup() & si.get$collisionMask()) >>> 0 !== 0))
        return;
      t1 = $.get$World_xiw();
      t2 = J.getInterceptor$x(bi);
      A.vec2_rotate(t1, xi, t2.get$angle(bi));
      t3 = $.get$World_xjw();
      t4 = J.getInterceptor$x(bj);
      A.vec2_rotate(t3, xj, t4.get$angle(bj));
      t5 = t2.get$position(bi);
      t6 = J.getInterceptor$x(t5);
      t1.x = J.$add$ns(t1.x, t6.get$x(t5));
      t1.y = J.$add$ns(t1.y, t6.get$y(t5));
      t5 = t4.get$position(bj);
      t6 = J.getInterceptor$x(t5);
      t3.x = J.$add$ns(t3.x, t6.get$x(t5));
      t3.y = J.$add$ns(t3.y, t6.get$y(t5));
      aiw = J.$add$ns(ai, t2.get$angle(bi));
      ajw = J.$add$ns(aj, t4.get$angle(bj));
      t5 = cm.friction;
      np.enableFriction = t5 > 0;
      np.frictionCoefficient = t5;
      if (J.$eq(t2.get$type(bi), 2) || J.$eq(t2.get$type(bi), 4))
        reducedMass = bj.get$mass();
      else
        reducedMass = J.$eq(t4.get$type(bj), 2) || J.$eq(t4.get$type(bj), 4) ? bi.get$mass() : bi.get$mass() * bj.get$mass() / (bi.get$mass() + bj.get$mass());
      np.slipForce = cm.friction * glen * reducedMass;
      np.restitution = cm.restitution;
      np.surfaceVelocity = cm.surfaceVelocity;
      np.frictionStiffness = cm.frictionStiffness;
      np.frictionRelaxation = cm.frictionRelaxation;
      np.stiffness = cm.stiffness;
      np.relaxation = cm.relaxation;
      np.contactSkinSize = cm.contactSkinSize;
      t5 = J.getInterceptor$x(si);
      t6 = J.getInterceptor$x(sj);
      resolver = np.compareMap.$index(0, J.$or$n(t5.get$type(si), t6.get$type(sj)));
      if (resolver != null) {
        sensor = si.get$sensor() || sj.get$sensor();
        numFrictionBefore = np.frictionEquations.length;
        numContacts = J.$lt$n(t5.get$type(si), t6.get$type(sj)) ? resolver.call$9(bi, si, t1, aiw, bj, sj, t3, ajw, sensor) : resolver.call$9(bj, sj, t3, ajw, bi, si, t1, aiw, sensor);
        numFrictionEquations = np.frictionEquations.length - numFrictionBefore;
        t1 = J.getInterceptor(numContacts);
        if (!t1.$eq(numContacts, 0)) {
          if (bi.get$allowSleep() && J.$eq(t2.get$type(bi), 1) && bi.get$sleepState() === 2 && bj.get$sleepState() === 0 && !J.$eq(t4.get$type(bj), 2)) {
            t3 = bj.get$velocity();
            t7 = J.getInterceptor$x(t3);
            x = t7.get$x(t3);
            y = t7.get$y(t3);
            t3 = J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
            t7 = bj.get$angularVelocity();
            if (typeof t7 !== "number")
              H.throwExpression(P.ArgumentError$(t7));
            speedSquaredB = J.$add$ns(t3, Math.pow(t7, 2));
            t3 = bj.get$sleepSpeedLimit();
            if (J.$ge$n(speedSquaredB, Math.pow(t3, 2) * 2))
              bi.set$_wakeUpAfterNarrowphase(true);
          }
          if (bj.get$allowSleep() && J.$eq(t4.get$type(bj), 1) && bj.get$sleepState() === 2 && bi.get$sleepState() === 0 && !J.$eq(t2.get$type(bi), 2)) {
            t2 = bi.get$velocity();
            t3 = J.getInterceptor$x(t2);
            x = t3.get$x(t2);
            y = t3.get$y(t2);
            t2 = J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y));
            t3 = bi.get$angularVelocity();
            if (typeof t3 !== "number")
              H.throwExpression(P.ArgumentError$(t3));
            speedSquaredA = J.$add$ns(t2, Math.pow(t3, 2));
            t2 = bi.get$sleepSpeedLimit();
            if (J.$ge$n(speedSquaredA, Math.pow(t2, 2) * 2))
              bj.set$_wakeUpAfterNarrowphase(true);
          }
          t2 = this.overlapKeeper;
          current = t2.overlappingShapesCurrentState;
          t3 = t5.get$id(si);
          t4 = t6.get$id(sj);
          if (J.$index$asx(current.data, current.getKey$2(t3, t4)) == null) {
            t2 = t2.recordPool;
            t3 = t2.length;
            if (t3 !== 0) {
              if (0 >= t3)
                return H.ioore(t2, 0);
              data = t2.pop();
              data.set$4(bi, si, bj, sj);
            } else {
              data = new A.OverlapKeeperRecord(null, null, null, null);
              data.shapeA = si;
              data.shapeB = sj;
              data.bodyA = bi;
              data.bodyB = bj;
            }
            current.set$3(t5.get$id(si), t6.get$id(sj), data);
          }
          if (this.has$1("beginContact")) {
            t2 = this.overlapKeeper;
            t2.toString;
            idA = J.$or$n(t5.get$id(si), 0);
            idB = J.$or$n(t6.get$id(sj), 0);
            last = t2.overlappingShapesLastState;
            current = t2.overlappingShapesCurrentState;
            t2 = J.$index$asx(last.data, last.getKey$2(idA, idB)) == null && J.$index$asx(current.data, current.getKey$2(idA, idB)) != null;
          } else
            t2 = false;
          if (t2) {
            e = this.beginContactEvent;
            e.$indexSet(0, "shapeA", si);
            e.$indexSet(0, "shapeB", sj);
            e.$indexSet(0, "bodyA", bi);
            e.$indexSet(0, "bodyB", bj);
            J.clear$0$ax(e.$index(0, "contactEquations"));
            if (!t1.$eq(numContacts, 0)) {
              t2 = np.contactEquations.length;
              if (typeof numContacts !== "number")
                return H.iae(numContacts);
              i = t2 - numContacts;
              for (; t2 = np.contactEquations.length, i < t2; ++i)
                if (t2 > i && i >= 0) {
                  t2 = e.$index(0, "contactEquations");
                  t3 = np.contactEquations;
                  if (i >>> 0 !== i || i >= t3.length)
                    return H.ioore(t3, i);
                  J.add$1$ax(t2, t3[i]);
                } else
                  break;
            }
            this.emit$1(e);
          }
          if (!t1.$eq(numContacts, 0) && numFrictionEquations > 1)
            for (i = np.frictionEquations.length - numFrictionEquations; t1 = np.frictionEquations, t2 = t1.length, i < t2; ++i) {
              if (i < 0)
                return H.ioore(t1, i);
              f = t1[i];
              f.setSlipForce$1(f.getSlipForce$0() / numFrictionEquations);
            }
        }
      }
    },
    addBody$1: function(body) {
      var t1 = this.bodies;
      if (J.$eq(H.Lists_indexOf(t1, body, 0, t1.length), -1)) {
        this.bodies.push(body);
        body.set$world(this);
        this.addBodyEvent.$indexSet(0, "body", body);
        this.emit$1(this.addBodyEvent);
      }
    },
    removeBody$1: function(body) {
      var t1, idx;
      if (this.stepping === true)
        this.bodiesToBeRemoved.push(body);
      else {
        body.set$world(null);
        t1 = this.bodies;
        idx = H.Lists_indexOf(t1, body, 0, t1.length);
        t1 = J.getInterceptor(idx);
        if (!t1.$eq(idx, -1)) {
          C.JSArray_methods.removeRange$2(this.bodies, idx, t1.$add(idx, 1));
          this.removeBodyEvent.$indexSet(0, "body", body);
          body.resetConstraintVelocity$0();
          this.emit$1(this.removeBodyEvent);
        }
      }
    },
    clear$0: function(_) {
      var t1, cs, i, t2, idx, bodies, springs, cms;
      this.time = 0;
      this.fixedStepTime = 0;
      t1 = this.solver;
      if (t1 != null && t1.get$equations().length !== 0)
        this.solver.removeAllEquations$0();
      cs = this.constraints;
      for (i = cs.length - 1; i >= 0; --i) {
        if (i >= cs.length)
          return H.ioore(cs, i);
        t1 = cs[i];
        t2 = this.constraints;
        idx = H.Lists_indexOf(t2, t1, 0, t2.length);
        t1 = J.getInterceptor(idx);
        if (!t1.$eq(idx, -1))
          J.removeRange$2$ax(this.constraints, idx, t1.$add(idx, 1));
      }
      bodies = this.bodies;
      for (i = bodies.length - 1; i >= 0; --i) {
        if (i >= bodies.length)
          return H.ioore(bodies, i);
        this.removeBody$1(bodies[i]);
      }
      springs = this.springs;
      for (i = springs.length - 1; i >= 0; --i) {
        if (i >= springs.length)
          return H.ioore(springs, i);
        t1 = springs[i];
        t2 = this.springs;
        idx = H.Lists_indexOf(t2, t1, 0, t2.length);
        t1 = J.getInterceptor(idx);
        if (!t1.$eq(idx, -1))
          C.JSArray_methods.removeRange$2(this.springs, idx, t1.$add(idx, 1));
      }
      cms = this.contactMaterials;
      for (i = cms.length - 1; i >= 0; --i) {
        if (i >= cms.length)
          return H.ioore(cms, i);
        t1 = cms[i];
        t2 = this.contactMaterials;
        idx = H.Lists_indexOf(t2, t1, 0, t2.length);
        t1 = J.getInterceptor(idx);
        if (!t1.$eq(idx, -1))
          J.removeRange$2$ax(this.contactMaterials, idx, t1.$add(idx, 1));
      }
    },
    hitTest$3: function(worldPoint, bodies, precision) {
      var pb, ps, x, tmp, n, result, t1, $N, t2, i, b, NS, t3, j, t4, s, offset, angle, t5, a, x0, y;
      pb = A.Body$0(0, 0.1, 0, 0, 0.1, false, null, 0, worldPoint, null, null);
      ps = new A.Particle0(null, null, null, null, null, null, null, null);
      ps.Shape$1(2);
      x = $.get$World_hitTest_tmp1();
      $.get$World_hitTest_zero();
      tmp = $.get$World_hitTest_tmp2();
      pb.addShape$1(ps);
      n = this.narrowphase;
      result = H.setRuntimeTypeInfo([], [A.Body3]);
      for (t1 = J.getInterceptor$asx(bodies), $N = t1.get$length(bodies), t2 = J.getInterceptor$ns(precision), i = 0; i !== $N; ++i) {
        b = t1.$index(bodies, i);
        for (NS = b.get$shapes().length, t3 = J.getInterceptor$x(b), j = 0; j !== NS; ++j) {
          t4 = b.get$shapes();
          if (j >= t4.length)
            return H.ioore(t4, j);
          s = t4[j];
          t4 = b.get$shapeOffsets();
          if (j >= t4.length)
            return H.ioore(t4, j);
          t4 = b.get$shapeOffsets();
          if (j >= t4.length)
            return H.ioore(t4, j);
          offset = t4[j];
          t4 = b.get$shapeAngles();
          if (j >= t4.length)
            return H.ioore(t4, j);
          if (t4[j] == null)
            angle = 0;
          else {
            t4 = b.get$shapeAngles();
            if (j >= t4.length)
              return H.ioore(t4, j);
            angle = t4[j];
          }
          A.vec2_rotate(x, offset, t3.get$angle(b));
          t4 = t3.get$position(b);
          t5 = J.getInterceptor$x(t4);
          x.x = J.$add$ns(x.x, t5.get$x(t4));
          x.y = J.$add$ns(x.y, t5.get$y(t4));
          a = J.$add$ns(angle, t3.get$angle(b));
          t4 = J.getInterceptor(s);
          if (!(!!t4.$isCircle2 && n.circleParticle$9(b, s, x, a, pb, ps, worldPoint, 0, true) !== 0))
            if (!(!!t4.$isConvex && n.particleConvex$9(pb, ps, worldPoint, 0, b, s, x, a, true) !== 0))
              if (!(!!t4.$isPlane && n.particlePlane$9(pb, ps, worldPoint, 0, b, s, x, a, true) !== 0))
                if (!!t4.$isParticle0) {
                  t4 = $.vec2_sub.call$3(tmp, x, worldPoint);
                  t5 = J.getInterceptor$x(t4);
                  x0 = t5.get$x(t4);
                  y = t5.get$y(t4);
                  t4 = J.$lt$n(J.$add$ns(J.$mul$ns(x0, x0), J.$mul$ns(y, y)), t2.$mul(precision, precision));
                } else
                  t4 = false;
              else
                t4 = true;
            else
              t4 = true;
          else
            t4 = true;
          if (t4)
            result.push(b);
        }
      }
      return result;
    },
    hitTest$2: function(worldPoint, bodies) {
      return this.hitTest$3(worldPoint, bodies, 0);
    },
    World$6$broadphase$doProfiling$fake$gravity$islandSplit$solver: function(broadphase, doProfiling, fake, gravity, islandSplit, solver) {
      var t1, t2;
      this.springs = H.setRuntimeTypeInfo([], [A.Spring]);
      this.bodies = H.setRuntimeTypeInfo([], [A.Body3]);
      this.disabledBodyCollisionPairs = H.setRuntimeTypeInfo([], [A.Body3]);
      if (solver == null && fake !== true) {
        solver = new A.GSSolver(null, null, null, null, null, null, null, null, null, null, null, null, A.World$(null, false, true, null, false, null), null);
        solver.Solver$2$equationSortFunction(1, null);
        solver.GSSolver$2$iterations$tolerance(10, 0.01);
      }
      this.solver = solver;
      t1 = new A.Narrowphase(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      t1.Narrowphase$0();
      this.narrowphase = t1;
      this.islandManager = new A.IslandManager(H.setRuntimeTypeInfo([], [A.IslandNode]), H.setRuntimeTypeInfo([], [A.Island]), H.setRuntimeTypeInfo([], [A.Equation]), H.setRuntimeTypeInfo([], [A.Island]), H.setRuntimeTypeInfo([], [A.IslandNode]), H.setRuntimeTypeInfo([], [A.IslandNode]));
      if (gravity != null)
        A.vec2_copy(this.gravity, gravity);
      this.frictionGravity = A.vec2_length(this.gravity);
      this.useWorldGravityAsFrictionGravity = true;
      this.useFrictionGravityOnZeroGravity = true;
      this.doProfiling = doProfiling;
      this.lastStepTime = 0;
      this.broadphase = broadphase;
      if (broadphase == null) {
        t1 = A.SAPBroadphase$();
        this.broadphase = t1;
      } else
        t1 = broadphase;
      t1.setWorld$1(this);
      this.constraints = H.setRuntimeTypeInfo([], [A.Constraint]);
      t1 = new A.Material(null);
      t1.Material$1(null);
      this.defaultMaterial = t1;
      t2 = new A.ContactMaterial(null, null, null, null, null, null, null, null, null, null, null);
      t2.ContactMaterial$9$friction$frictionRelaxation$frictionStiffness$relaxation$restitution$stiffness$surfaceVelocity(t1, t1, 0.3, 4, 1000000, 4, 0, 1000000, 0);
      this.defaultContactMaterial = t2;
      this.lastTimeStep = 0.016666666666666666;
      this.applySpringForces = true;
      this.applyDamping = true;
      this.applyGravity = true;
      this.solveConstraints = true;
      this.contactMaterials = H.setRuntimeTypeInfo([], [A.ContactMaterial]);
      this.time = 0;
      this.stepping = false;
      this.bodiesToBeRemoved = H.setRuntimeTypeInfo([], [A.Body3]);
      this.fixedStepTime = 0;
      this.islandSplit = islandSplit;
      this.emitImpactEvent = true;
      this._constraintIdCounter = 0;
      this._bodyIdCounter = 0;
      this.postStepEvent = P.LinkedHashMap_LinkedHashMap$_literal(["type", "postStep"], null, null);
      this.addBodyEvent = P.LinkedHashMap_LinkedHashMap$_literal(["type", "addBody", "body", null], null, null);
      this.removeBodyEvent = P.LinkedHashMap_LinkedHashMap$_literal(["type", "removeBody", "body", null], null, null);
      this.addSpringEvent = P.LinkedHashMap_LinkedHashMap$_literal(["type", "addSpring", "sprint", null], null, null);
      this.impactEvent = P.LinkedHashMap_LinkedHashMap$_literal(["type", "impact", "bodyA", null, "bodyB", null, "shapeA", null, "shapeB", null, "contactEquation", null], null, null);
      this.postBroadphaseEvent = P.LinkedHashMap_LinkedHashMap$_literal(["type", "postBroadphase", "pairs", null], null, null);
      this.sleepMode = 1;
      this.beginContactEvent = P.LinkedHashMap_LinkedHashMap$_literal(["type", "beginContact", "shapeA", null, "shapeB", null, "bodyA", null, "bodyB", null, "contactEquations", H.setRuntimeTypeInfo([], [A.ContactEquation])], null, null);
      this.endContactEvent = P.LinkedHashMap_LinkedHashMap$_literal(["type", "endContact", "shapeA", null, "shapeB", null, "bodyA", null, "bodyB", null], null, null);
      this.preSolveEvent = P.LinkedHashMap_LinkedHashMap$_literal(["type", "preSolve", "contactEquations", null, "frictionEquations", null], null, null);
      this.overlappingShapesLastState = P.LinkedHashMap_LinkedHashMap$_literal(["keys", []], null, null);
      this.overlappingShapesCurrentState = P.LinkedHashMap_LinkedHashMap$_literal(["keys", []], null, null);
      t2 = new A.OverlapKeeper(null, null, null, null, null);
      t2.OverlapKeeper$0();
      this.overlapKeeper = t2;
    },
    static: {"^": "World_NO_SLEEPING,World_BODY_SLEEPING,World_ISLAND_SLEEPING,World_step_r,World_step_runit,World_step_u,World_step_f,World_step_fhMinv,World_step_velodt,World_step_mg,World_xiw,World_xjw,World_zero,World_interpvelo,World_endOverlaps,World_ib_fhMinv,World_ib_velodt,World_hitTest_tmp1,World_hitTest_zero,World_hitTest_tmp2", World$: function(broadphase, doProfiling, fake, gravity, islandSplit, solver) {
        var t1 = new A.World0(null, null, null, null, null, null, A.vec2_fromValues(0, -9.78), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.World$6$broadphase$doProfiling$fake$gravity$islandSplit$solver(broadphase, doProfiling, fake, gravity, islandSplit, solver);
        return t1;
      }}
  },
  "+World": 0,
  "^": "g<,version@"
}],
["", "textfueledcombat.dart", , L, {
  "^": "",
  main: [function() {
    new L.Tfc(null).Tfc$0();
  }, "call$0", "main$closure", 0, 0, 17],
  Tfc: {
    "^": "Object;map*",
    map$1: function($receiver, arg0) {
      return this.map.call$1(arg0);
    },
    Tfc$0: function() {
      var game, state3, t1, state, state2;
      this.map = R.GameMap$(10, 12);
      game = R.Game$(800, 600, 0, "canvasDiv", null, null, null, null);
      game.stage.setBackgroundColor$1(11393254);
      state3 = new L.TitleState(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      state3.State$0();
      state3.assetPath = "assets";
      t1 = this.map;
      state = new L.FileWaitState(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      state.State$0();
      state.map = t1;
      J.add$2$ax(game.state, "wait", state);
      J.add$2$ax(game.state, "titlestate", state3);
      J.start$1$x(game.state, "titlestate");
      t1 = this.map;
      state2 = new L.MapRenderState(null, null, null, null, null, null, null, null, "----\n--/--", null, null, null, 0, -1, -1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      state2.State$0();
      state2.MapRenderState$2(t1, "assets");
      J.add$2$ax(game.state, "maprender", state2);
    }
  },
  MapRenderState: {
    "^": "State;map*,assetPath,attackButtons,chargeDisplays,selected,playerText,enemyText,selectedPlayerAtk,placeholderText,selectorTexture,hpBar@,tileSelector,turnVal,selectedTileX,selectedTileY,game-613,add-1032,make-1033,camera-1046,cache-1034,input-1035,math-1093,load-1036,sound-1038,scale-1022,stage-1040,time-1041,tweens-1043,world-1008,particles-1048,physics-1042,rnd-1044,state-1030",
    map$1: function($receiver, arg0) {
      return this.map.call$1(arg0);
    },
    set$turn: function(val) {
      if (val > 1)
        ;
      else if (val !== this.turnVal) {
        this.turnVal = val;
        if (val === 0) {
          this.playerText.setText$1(this.placeholderText);
          C.JSArray_methods.forEach$1(this.map.playerTeam, new L.MapRenderState_turn_closure());
        } else {
          C.JSArray_methods.forEach$1(this.map.enemyTeam, new L.MapRenderState_turn_closure0());
          this.playEnemyTurn$0();
        }
      }
    },
    preload$0: [function(_) {
      var t1;
      J.get$load$x(this.game).image$2("button", this.assetPath + "/button_blue.png");
      J.get$load$x(this.game).image$2("hpBar", this.assetPath + "/hp_bar_base.png");
      J.get$load$x(this.game).image$2("roshan", this.assetPath + "/roshan.png");
      J.get$load$x(this.game).image$2("devil", this.assetPath + "/devil.png");
      J.get$load$x(this.game).image$2("devilPortrait", this.assetPath + "/devil_portrait.png");
      J.get$load$x(this.game).image$2("playerPortrait", this.assetPath + "/roshan_portrait.png");
      J.get$load$x(this.game).image$2("dirt", this.assetPath + "/dirt.png");
      J.get$load$x(this.game).image$2("dryland", this.assetPath + "/dry_land.png");
      J.get$load$x(this.game).image$2("grass", this.assetPath + "/grass.png");
      J.get$load$x(this.game).image$2("lava", this.assetPath + "/lava.png");
      J.get$load$x(this.game).image$2("void", this.assetPath + "/void.png");
      J.get$load$x(this.game).image$2("water", this.assetPath + "/water.png");
      J.get$load$x(this.game).image$2("wood", this.assetPath + "/wood_tile.png");
      t1 = this.game.get$make().bitmapData$2(32, 32);
      this.selectorTexture = t1;
      t1.fill$4(0, 255, 0, 0, 0.5);
      J.audio$3$x(J.get$load$x(this.game), "sword", this.assetPath + "/sword.ogg", true);
      J.audio$3$x(J.get$load$x(this.game), "waterSound", this.assetPath + "/waterEdit.ogg", true);
      J.audio$3$x(J.get$load$x(this.game), "air", this.assetPath + "/air_attack.ogg", true);
      J.audio$3$x(J.get$load$x(this.game), "fire", this.assetPath + "/fire_attack.ogg", true);
      J.audio$3$x(J.get$load$x(this.game), "earth", this.assetPath + "/earth_attack.ogg", true);
      J.audio$2$x(J.get$load$x(this.game), "mace", this.assetPath + "/mace.ogg");
    }, "call$0", "get$preload", 0, 0, 54, "preload"],
    create$0: [function() {
      var temp, i, t1, j, t2, t3, player, enemy, t4, bmp, t5, style, style2;
      J.set$display$x(document.querySelector("#test").style, "none");
      for (temp = null, i = 0; i < this.map._grid.array.length; ++i) {
        t1 = i * 32 + 32;
        j = 0;
        while (true) {
          t2 = this.map._grid.array;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          t2 = J.get$length$asx(t2[0]);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(j < t2))
            break;
          switch (this.map.whatTile$2(i, j)) {
            case C.TileType_3:
              temp = J.get$add$ax(this.game).sprite$3(j * 32 + 128, t1, "dirt");
              break;
            case C.TileType_5:
              temp = J.get$add$ax(this.game).sprite$3(j * 32 + 128, t1, "dryland");
              break;
            case C.TileType_2:
              temp = J.get$add$ax(this.game).sprite$3(j * 32 + 128, t1, "grass");
              break;
            case C.TileType_6:
              temp = J.get$add$ax(this.game).sprite$3(j * 32 + 128, t1, "lava");
              break;
            case C.TileType_1:
              temp = J.get$add$ax(this.game).sprite$3(j * 32 + 128, t1, "void");
              break;
            case C.TileType_4:
              temp = J.get$add$ax(this.game).sprite$3(j * 32 + 128, t1, "water");
              break;
            case C.TileType_0:
              temp = J.get$add$ax(this.game).sprite$3(j * 32 + 128, t1, "wood");
              break;
          }
          temp.set$inputEnabled(true);
          J.add$1$ax(temp.get$events().get$onInputDown(), this.get$listenerTiles());
          t2 = this.map._spriteGrid.array;
          if (i >= t2.length)
            return H.ioore(t2, i);
          J.$indexSet$ax(t2[i], j, temp);
          ++j;
        }
      }
      for (i = 0; i < 3; ++i) {
        t1 = "Testguy" + i;
        t2 = 3 + i;
        t3 = new R.Point(null, null);
        t3.x = 0;
        t3.y = t2;
        player = R.Character$(t1, C.CharType_0, t3);
        t3 = "Devil" + i;
        t1 = new R.Point(null, null);
        t1.x = this.map._grid.array.length - 1;
        t1.y = t2;
        enemy = R.Character$(t3, C.CharType_1, t1);
        t1 = this.map;
        t3 = player._TextFueledCombat$_name;
        t1 = t1._units.array;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        J.$indexSet$ax(t1[0], t2, t3);
        t3 = this.map;
        t1 = enemy._TextFueledCombat$_name;
        t4 = t3._grid.array.length - 1;
        t3 = t3._units.array;
        if (t4 < 0 || t4 >= t3.length)
          return H.ioore(t3, t4);
        J.$indexSet$ax(t3[t4], t2, t1);
        player.initSprite$1(this.game);
        enemy.initSprite$1(this.game);
        player._sprite.set$inputEnabled(true);
        J.add$1$ax(player._sprite.get$events().get$onInputDown(), this.get$onPlayerClicked());
        enemy._sprite.set$inputEnabled(true);
        J.add$1$ax(enemy._sprite.get$events().get$onInputDown(), this.get$onEnemyClicked());
        this.map.playerTeam.push(player);
        this.map.enemyTeam.push(enemy);
      }
      for (i = 0; t1 = this.map.playerTeam, i < t1.length; ++i) {
        this._assignAttackCharges$1(t1[i]);
        t1 = J.get$add$ax(this.game);
        t2 = 68 * i;
        t3 = this.map.playerTeam;
        if (i >= t3.length)
          return H.ioore(t3, i);
        t1.sprite$3(0, 20 + t2, R.getPortraitKey(J.get$type$x(t3[i])));
        t3 = this.map.playerTeam;
        if (i >= t3.length)
          return H.ioore(t3, i);
        t3 = t3[i];
        t1 = this.game;
        t4 = J.getInterceptor$ax(t1);
        bmp = t4.get$add(t1).bitmapData$2(104, 24);
        bmp.draw$1("hpBar");
        J.set$fillStyle$x(bmp.context, "#00FF00");
        J.fillRect$4$x(bmp.context, 2, 2, 100, 20);
        t3.set$hpBar(t4.get$add(t1).sprite$3(0, 64 + t2, bmp));
      }
      for (i = 0; t1 = this.map.enemyTeam, i < t1.length; ++i) {
        this._assignAttackCharges$1(t1[i]);
        t1 = J.get$add$ax(this.game);
        t2 = J.$sub$n(J.get$width$x(this.world), 104);
        t3 = 68 * i;
        t4 = this.map.enemyTeam;
        if (i >= t4.length)
          return H.ioore(t4, i);
        t1.sprite$3(t2, 20 + t3, R.getPortraitKey(t4[i]._type));
        t4 = this.map.enemyTeam;
        if (i >= t4.length)
          return H.ioore(t4, i);
        t4 = t4[i];
        t2 = this.game;
        t1 = J.$sub$n(J.get$width$x(this.world), 104);
        t5 = J.getInterceptor$ax(t2);
        bmp = t5.get$add(t2).bitmapData$2(104, 24);
        bmp.draw$1("hpBar");
        J.set$fillStyle$x(bmp.context, "#00FF00");
        J.fillRect$4$x(bmp.context, 2, 2, 100, 20);
        t4.hpBar = t5.get$add(t2).sprite$3(t1, 64 + t3, bmp);
      }
      style = R.TextStyle$("left", "#FFFFFF", "10px Arial", "black", 0, 16777215);
      t1 = this.placeholderText;
      this.playerText = J.text$4$x(J.get$add$ax(this.game), 500, 400, t1, style);
      this.enemyText = J.text$4$x(J.get$add$ax(this.game), 500, 420, t1, style);
      R.addGameButton(this.game, 0, 438, "button", "Wait", this.get$onWaitClicked());
      this.attackButtons.$indexSet(0, C.AttackType_4, R.addGameButton(this.game, 0, 500, "button", "Sword Attack", this.get$onSwordButtonClicked()));
      this.attackButtons.$indexSet(0, C.AttackType_5, R.addGameButton(this.game, 110, 500, "button", "Mace Attack", this.get$onMaceButtonClicked()));
      this.attackButtons.$indexSet(0, C.AttackType_1, R.addGameButton(this.game, 220, 500, "button", "Water Magic", this.get$onWaterButtonClicked()));
      this.attackButtons.$indexSet(0, C.AttackType_0, R.addGameButton(this.game, 330, 500, "button", "Fire Magic", this.get$onFireButtonClicked()));
      this.attackButtons.$indexSet(0, C.AttackType_3, R.addGameButton(this.game, 440, 500, "button", "Air Magic", this.get$onAirButtonClicked()));
      this.attackButtons.$indexSet(0, C.AttackType_2, R.addGameButton(this.game, 550, 500, "button", "Earth Magic", this.get$onEarthButtonClicked()));
      style2 = R.TextStyle$("left", "#FFFFFF", "20px Arial", "black", 0, 16777215);
      this.chargeDisplays.$indexSet(0, C.AttackType_4, J.text$4$x(J.get$add$ax(this.game), 0, 545, "--", style2));
      this.chargeDisplays.$indexSet(0, C.AttackType_5, J.text$4$x(J.get$add$ax(this.game), 110, 545, "--", style2));
      this.chargeDisplays.$indexSet(0, C.AttackType_1, J.text$4$x(J.get$add$ax(this.game), 220, 545, "--", style2));
      this.chargeDisplays.$indexSet(0, C.AttackType_0, J.text$4$x(J.get$add$ax(this.game), 330, 545, "--", style2));
      this.chargeDisplays.$indexSet(0, C.AttackType_3, J.text$4$x(J.get$add$ax(this.game), 440, 545, "--", style2));
      this.chargeDisplays.$indexSet(0, C.AttackType_2, J.text$4$x(J.get$add$ax(this.game), 550, 545, "--", style2));
    }, "call$0", "get$create", 0, 0, 54, "create"],
    onPlayerClicked$2: [function(sprite, p) {
      var t1, style, info, t;
      t1 = this.selected;
      if (t1 == null || t1.get$tired()) {
        t1 = H.IterableMixinWorkaround_firstWhere(this.map.playerTeam, new L.MapRenderState_onPlayerClicked_closure(sprite), new L.MapRenderState_onPlayerClicked_closure0());
        this.selected = t1;
        this.playerText.setText$1(H.S(J.get$name$x(t1)) + "\n" + H.S(this.selected.get$hpCurrent()) + "/" + H.S(this.selected.get$hpMax()));
        t1 = J.getInterceptor$x(sprite);
        window.alert("Clicked! Unit " + H.S(J.get$name$x(this.selected)) + " is now selected! pos (" + H.S(J.get$x$x(t1.get$position(sprite))) + "," + H.S(J.get$y$x(t1.get$position(sprite))) + ")");
        this.attackButtons.forEach$1(0, new L.MapRenderState_onPlayerClicked_closure1(this));
        this.chargeDisplays.forEach$1(0, new L.MapRenderState_onPlayerClicked_closure2(this));
      } else if (this.selected.get$hasMoved() && !this.selected.get$tired() && !J.$eq(sprite, this.selected.get$sprite())) {
        style = new R.TextStyle(0, 0, "rgba(0,0,0,0)", 0, "black", "bold 20pt Arial", "left", "black", 0, false, 100, false, 0.5235987755982988, 4, "black", 16777215);
        style.fill = "black";
        style.font = "bold 20pt Arial";
        style.align = "left";
        style.stroke = "black";
        style.strokeThickness = 0;
        style.tint = 16777215;
        style.fill = "#000000";
        style.font = "25px Arial";
        style.align = "left";
        style.stroke = "black";
        style.strokeThickness = 0;
        style.tint = 16777215;
        info = J.text$4$x(J.get$add$ax(this.game), 100, 200, "The character must attack or 'wait' before selecting another", style);
        t = this.game.get$time().create$0();
        t1 = J.getInterceptor$ax(t);
        t1.add$2(t, 2000, new L.MapRenderState_onPlayerClicked_closure3(info));
        t1.start$0(t);
      }
    }, "call$2", "get$onPlayerClicked", 4, 0, 1803, 151, [], 230, []],
    onEnemyClicked$2: [function(sprite, p) {
      var target, t1, t2, exception;
      target = H.IterableMixinWorkaround_firstWhere(this.map.enemyTeam, new L.MapRenderState_onEnemyClicked_closure(sprite), null);
      this.enemyText.setText$1(H.S(J.get$name$x(target)) + "\n" + H.S(target.get$hpCurrent()) + "/" + H.S(target.get$hpMax()));
      t1 = this.selected;
      if (t1 != null) {
        try {
          t2 = this.selectedPlayerAtk;
          if (t2 != null) {
            t1.attack$2(t2, target);
            t1.set$tired(true);
            t1.get$sprite().set$inputEnabled(false);
            this.playAttackSound$1(this.selectedPlayerAtk);
            this.selectedPlayerAtk = null;
            this.selected = null;
            this.enemyText.setText$1(H.S(J.get$name$x(target)) + "\n" + H.S(target.get$hpCurrent()) + "/" + H.S(target.get$hpMax()));
            R.redrawHpBar(this.game, target);
            t1 = target.get$hpCurrent();
            if (typeof t1 !== "number")
              return t1.$le();
            if (t1 <= 0) {
              C.JSArray_methods.remove$1(this.map.enemyTeam, target);
              this.enemyText.setText$1(this.placeholderText);
            }
          } else
            window.alert("You must select an attack type first.");
        } catch (exception) {
          if (!!J.getInterceptor(H.unwrapException(exception)).$isAttackRangeException)
            H.printString("Player failed attack! Out of range.");
          else
            throw exception;
        }

        if (H.IterableMixinWorkaround_every(this.map.playerTeam, new L.MapRenderState_onEnemyClicked_closure0()))
          this.set$turn(1);
      }
    }, "call$2", "get$onEnemyClicked", 4, 0, 1803, 151, [], 230, []],
    listenerTiles$2: [function(sprite, p) {
      var t1, shouldEnd, i, j, t2, line, t3;
      t1 = this.selected;
      if (t1 != null && !t1.get$hasMoved())
        for (t1 = J.getInterceptor(sprite), shouldEnd = false, i = 0; i < this.map._grid.array.length; ++i) {
          j = 0;
          while (true) {
            t2 = this.map._grid.array;
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            t2 = J.get$length$asx(t2[0]);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(j < t2))
              break;
            t2 = this.map._spriteGrid.array;
            if (i >= t2.length)
              return H.ioore(t2, i);
            if (t1.$eq(sprite, J.$index$asx(t2[i], j))) {
              line = "Clicked on (" + i + "," + j + ")";
              H.printString(line);
              t2 = this.selectedTileX;
              if (t2 === -1 && this.selectedTileY === -1) {
                this.tileSelector = J.get$add$ax(this.game).sprite$3(J.get$x$x(t1.get$position(sprite)), J.get$y$x(t1.get$position(sprite)), this.selectorTexture);
                this.selectedTileX = i;
                this.selectedTileY = j;
              } else {
                t2 = i === t2 && j === this.selectedTileY;
                t3 = this.tileSelector;
                if (t2) {
                  t3.destroy$0();
                  J.moveTo$5$finder$x(this.selected, i, j, this.map, this.game, $.finder);
                  this.selectedTileX = -1;
                  this.selectedTileY = -1;
                } else {
                  t3.destroy$0();
                  this.tileSelector = J.get$add$ax(this.game).sprite$3(J.get$x$x(t1.get$position(sprite)), J.get$y$x(t1.get$position(sprite)), this.selectorTexture);
                  this.selectedTileX = i;
                  this.selectedTileY = j;
                }
              }
              shouldEnd = true;
              break;
            }
            ++j;
          }
          if (shouldEnd)
            break;
        }
    }, "call$2", "get$listenerTiles", 4, 0, 1803, 151, [], 230, []],
    onWaitClicked$2: [function(sprite, p) {
      if (window.confirm("Are you sure? Having your character wait means they will not be able to take any further actions this turn.") === true && this.selected != null) {
        this.selected.set$tired(true);
        this.selected = null;
        if (H.IterableMixinWorkaround_every(this.map.playerTeam, new L.MapRenderState_onWaitClicked_closure()))
          this.set$turn(1);
      }
    }, "call$2", "get$onWaitClicked", 4, 0, 1803, 151, [], 230, []],
    onSwordButtonClicked$2: [function(sprite, p) {
      var t1 = this.selected;
      if (t1 != null && t1.hasCharge$1(C.AttackType_4)) {
        P.print("Player mode - Sword attack!");
        this.selectedPlayerAtk = C.AttackType_4;
      }
    }, "call$2", "get$onSwordButtonClicked", 4, 0, 1803, 151, [], 230, []],
    onMaceButtonClicked$2: [function(sprite, p) {
      var t1 = this.selected;
      if (t1 != null && t1.hasCharge$1(C.AttackType_5)) {
        P.print("Player mode - Mace attack!");
        this.selectedPlayerAtk = C.AttackType_5;
      }
    }, "call$2", "get$onMaceButtonClicked", 4, 0, 1803, 151, [], 230, []],
    onWaterButtonClicked$2: [function(sprite, p) {
      var t1 = this.selected;
      if (t1 != null && t1.hasCharge$1(C.AttackType_1)) {
        P.print("Player mode - Water attack!");
        this.selectedPlayerAtk = C.AttackType_1;
      }
    }, "call$2", "get$onWaterButtonClicked", 4, 0, 1803, 151, [], 230, []],
    onFireButtonClicked$2: [function(sprite, p) {
      var t1 = this.selected;
      if (t1 != null && t1.hasCharge$1(C.AttackType_0)) {
        P.print("Player mode - Fire attack!");
        this.selectedPlayerAtk = C.AttackType_0;
      }
    }, "call$2", "get$onFireButtonClicked", 4, 0, 1803, 151, [], 230, []],
    onEarthButtonClicked$2: [function(sprite, p) {
      var t1 = this.selected;
      if (t1 != null && t1.hasCharge$1(C.AttackType_2)) {
        P.print("Player mode - Earth attack!");
        this.selectedPlayerAtk = C.AttackType_2;
      }
    }, "call$2", "get$onEarthButtonClicked", 4, 0, 1803, 151, [], 230, []],
    onAirButtonClicked$2: [function(sprite, p) {
      var t1 = this.selected;
      if (t1 != null && t1.hasCharge$1(C.AttackType_3)) {
        P.print("Player mode - Air attack!");
        this.selectedPlayerAtk = C.AttackType_3;
      }
    }, "call$2", "get$onAirButtonClicked", 4, 0, 1803, 151, [], 230, []],
    playEnemyTurn$0: function() {
      P.Future_forEach(this.map.enemyTeam, new L.MapRenderState_playEnemyTurn_closure(this));
      this.set$turn(0);
    },
    _pickEnemyAttackType$2: function(enemy, target) {
      var weaknessCharges, nonweakCharges;
      if ($.get$RNG().nextInt$1(5) < 3) {
        weaknessCharges = P.LinkedHashMap_LinkedHashMap(null, null, null, R.AttackType, P.$int);
        enemy.get$attackCharges().forEach$1(0, new L.MapRenderState__pickEnemyAttackType_closure(target, weaknessCharges));
        return H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(weaknessCharges), [H.getTypeArgumentByIndex(weaknessCharges, 0)]).reduce$1(0, new L.MapRenderState__pickEnemyAttackType_closure0(weaknessCharges));
      } else {
        nonweakCharges = P.LinkedHashMap_LinkedHashMap(null, null, null, R.AttackType, P.$int);
        enemy.get$attackCharges().forEach$1(0, new L.MapRenderState__pickEnemyAttackType_closure1(target, nonweakCharges));
        return H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(nonweakCharges), [H.getTypeArgumentByIndex(nonweakCharges, 0)]).reduce$1(0, new L.MapRenderState__pickEnemyAttackType_closure2(nonweakCharges));
      }
    },
    _assignAttackCharges$1: function(c) {
      var i;
      for (i = 0; i < 30; ++i)
        c.addCharge$1(this.map.fileProcessor.takeRandAtkType$1(c));
    },
    playAttackSound$1: function(type) {
      var t1, comp, s;
      t1 = {};
      comp = H.setRuntimeTypeInfo(new P._AsyncCompleter(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null])), [null]);
      switch (type) {
        case C.AttackType_4:
          s = J.get$add$ax(this.game).sound$2("sword", 10);
          break;
        case C.AttackType_5:
          s = J.get$add$ax(this.game).sound$2("mace", 10);
          break;
        case C.AttackType_1:
          s = J.get$add$ax(this.game).sound$2("waterSound", 10);
          break;
        case C.AttackType_3:
          s = J.get$add$ax(this.game).sound$2("air", 10);
          break;
        case C.AttackType_0:
          t1.loopCount_0 = 0;
          s = J.get$add$ax(this.game).sound$3("fire", 10, true);
          J.add$1$ax(s.get$onLoop(), new L.MapRenderState_playAttackSound_closure(t1));
          break;
        case C.AttackType_2:
          J.get$add$ax(this.game).sound$2("earth", 10);
          s = null;
          break;
        default:
          s = null;
      }
      J.play$0$x(s);
      comp.complete$1(0, true);
      return comp.future;
    },
    MapRenderState$2: function(map, assetPath) {
      this.map = map;
      this.assetPath = assetPath;
      this.attackButtons = P.LinkedHashMap_LinkedHashMap(null, null, null, R.AttackType, R.Sprite);
      this.chargeDisplays = P.LinkedHashMap_LinkedHashMap(null, null, null, R.AttackType, R.Text);
    }
  },
  MapRenderState_turn_closure: {
    "^": "Closure:1690;",
    call$1: function(player) {
      player.set$tired(false);
      player.set$hasMoved(false);
      player.get$sprite().set$inputEnabled(true);
    }
  },
  MapRenderState_turn_closure0: {
    "^": "Closure:1690;",
    call$1: function(enemy) {
      enemy.set$tired(false);
    }
  },
  MapRenderState_onPlayerClicked_closure: {
    "^": "Closure:1690;sprite_0",
    call$1: function(c) {
      return J.$eq(c.get$sprite(), this.sprite_0);
    }
  },
  MapRenderState_onPlayerClicked_closure0: {
    "^": "Closure:54;",
    call$0: function() {
    }
  },
  MapRenderState_onPlayerClicked_closure1: {
    "^": "Closure:1804;this_1",
    call$2: function(type, sprite) {
      if (this.this_1.selected.hasCharge$1(type))
        sprite.set$inputEnabled(true);
      else {
        sprite.set$inputEnabled(false);
        P.print("No charges of type " + H.S(J.get$value$x(type)) + " remaining..");
      }
    }
  },
  MapRenderState_onPlayerClicked_closure2: {
    "^": "Closure:1805;this_2",
    call$2: function(att, text) {
      text.setText$1(this.this_2.selected.get$attackCharges().$index(0, att));
    }
  },
  MapRenderState_onPlayerClicked_closure3: {
    "^": "Closure:54;info_3",
    call$0: [function() {
      return this.info_3.destroy$0();
    }, "call$0", null, 0, 0, null, "call"]
  },
  MapRenderState_onEnemyClicked_closure: {
    "^": "Closure:1690;sprite_0",
    call$1: function(c) {
      return J.$eq(this.sprite_0, c.get$sprite());
    }
  },
  MapRenderState_onEnemyClicked_closure0: {
    "^": "Closure:1690;",
    call$1: function(player) {
      return player.get$tired();
    }
  },
  MapRenderState_onWaitClicked_closure: {
    "^": "Closure:1690;",
    call$1: function(player) {
      return player.get$tired();
    }
  },
  MapRenderState_playEnemyTurn_closure: {
    "^": "Closure:1690;this_1",
    call$1: function(enemy) {
      var t1, t2, t3, t4, t5, t6, manhattanDistance, i, manhattanDistanceCurr, path, t7, t8, line, n, fut, iter;
      t1 = {};
      t1.chosenType_0 = null;
      t2 = this.this_1;
      t3 = t2.map.playerTeam;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      t1.targetPlayer_1 = t3[0];
      t3 = enemy.get$pos().x;
      t4 = enemy.get$pos().y;
      t5 = t1.targetPlayer_1.get$pos().x;
      t6 = t1.targetPlayer_1.get$pos().y;
      manhattanDistance = J.$add$ns(J.abs$0$n(J.$sub$n(t5, t3)), J.abs$0$n(J.$sub$n(t6, t4)));
      for (i = 1; i < t2.map.playerTeam.length; ++i) {
        t3 = enemy.get$pos().x;
        t4 = enemy.get$pos().y;
        t5 = t2.map.playerTeam;
        if (i >= t5.length)
          return H.ioore(t5, i);
        t5 = t5[i].get$pos().x;
        t6 = t2.map.playerTeam;
        if (i >= t6.length)
          return H.ioore(t6, i);
        t6 = t6[i].get$pos().y;
        manhattanDistanceCurr = J.$add$ns(J.abs$0$n(J.$sub$n(t5, t3)), J.abs$0$n(J.$sub$n(t6, t4)));
        if (J.$lt$n(manhattanDistanceCurr, manhattanDistance)) {
          t3 = t2.map.playerTeam;
          if (i >= t3.length)
            return H.ioore(t3, i);
          t1.targetPlayer_1 = t3[i];
          manhattanDistance = manhattanDistanceCurr;
        }
      }
      t3 = J.getInterceptor$x(enemy);
      t2.enemyText.setText$1(H.S(t3.get$name(enemy)) + "\n" + H.S(enemy.get$hpCurrent()) + "/" + H.S(enemy.get$hpMax()));
      t2.playerText.setText$1(H.S(J.get$name$x(t1.targetPlayer_1)) + "\n" + H.S(t1.targetPlayer_1.get$hpCurrent()) + "/" + H.S(t1.targetPlayer_1.get$hpMax()));
      if (!J.$eq(manhattanDistance, 1)) {
        path = $.finder.findPath$5(enemy, enemy.get$pos().x, enemy.get$pos().y, t1.targetPlayer_1.get$pos().x, t1.targetPlayer_1.get$pos().y);
        if (path != null) {
          t4 = path._steps;
          if (0 >= t4.length)
            return H.ioore(t4, 0);
          t4.pop();
          while (true) {
            t4 = path._steps;
            t5 = t4.length;
            if (t5 > 0) {
              t6 = t2.map;
              t5 = J.get$x$x(t4[t5 - 1]);
              t4 = path._steps;
              t7 = t4.length;
              t8 = t7 - 1;
              if (t8 < 0)
                return H.ioore(t4, t8);
              t8 = J.get$y$x(t4[t8]);
              t6 = t6._units.array;
              if (t5 >>> 0 !== t5 || t5 >= t6.length)
                return H.ioore(t6, t5);
              t8 = !J.$eq(J.$index$asx(t6[t5], t8), "");
              t4 = t8;
            } else
              t4 = false;
            if (!t4)
              break;
            t4 = t2.map;
            t5 = path._steps;
            t6 = t5.length;
            t7 = t6 - 1;
            if (t7 < 0)
              return H.ioore(t5, t7);
            t7 = J.get$x$x(t5[t7]);
            t5 = path._steps;
            t6 = t5.length;
            t8 = t6 - 1;
            if (t8 < 0)
              return H.ioore(t5, t8);
            t8 = J.get$y$x(t5[t8]);
            t4 = t4._units.array;
            if (t7 >>> 0 !== t7 || t7 >= t4.length)
              return H.ioore(t4, t7);
            line = "Unit at dest: " + H.S(J.$index$asx(t4[t7], t8));
            H.printString(line);
            t4 = path._steps;
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            t4.pop();
          }
          t4 = path._steps.length;
          t5 = enemy.get$mobility();
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (t4 - 1 <= t5) {
            t4 = path._steps;
            t5 = t4.length;
            t6 = t5 - 1;
            if (t6 < 0)
              return H.ioore(t4, t6);
            n = t4[t6];
            t6 = J.getInterceptor$x(n);
            fut = t3.moveTo$5$precomputed(enemy, t6.get$x(n), t6.get$y(n), t2.map, t2.game, path);
          } else {
            for (iter = 0; t4 = path._steps, iter < t4.length; ++iter) {
              t4 = J.toInt$0$n(t4[iter].get$cost());
              t5 = enemy.get$mobility();
              if (typeof t5 !== "number")
                return H.iae(t5);
              if (t4 > t5)
                break;
            }
            t4 = C.JSArray_methods.sublist$2(path._steps, 0, iter);
            path._steps = t4;
            t5 = t4.length;
            t6 = t5 - 1;
            if (t6 < 0)
              return H.ioore(t4, t6);
            n = t4[t6];
            t6 = J.getInterceptor$x(n);
            fut = t3.moveTo$5$precomputed(enemy, t6.get$x(n), t6.get$y(n), t2.map, t2.game, path);
          }
        } else
          fut = null;
      } else {
        fut = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
        fut._asyncComplete$1(0);
      }
      return fut.then$1(new L.MapRenderState_playEnemyTurn__closure(t1, t2, enemy));
    }
  },
  MapRenderState_playEnemyTurn__closure: {
    "^": "Closure:102;box_0,this_2,enemy_3",
    call$1: [function(_) {
      var t1, t2, t3, chosenType, exception;
      try {
        P.print("Enemy is attacking!");
        t1 = this.this_2;
        t2 = this.enemy_3;
        t3 = this.box_0;
        chosenType = t1._pickEnemyAttackType$2(t2, t3.targetPlayer_1);
        t3.chosenType_0 = chosenType;
        t2.attack$2(chosenType, t3.targetPlayer_1);
        t1 = P.Future_Future(new L.MapRenderState_playEnemyTurn___closure(t3, t1), null);
        return t1;
      } catch (exception) {
        if (!!J.getInterceptor(H.unwrapException(exception)).$isAttackRangeException)
          P.print("Enemy attack failed! range issue");
        else
          throw exception;
      }
 finally {
        this.enemy_3.set$tired(true);
      }
    }, "call$1", null, 2, 0, null, 1686, [], "call"]
  },
  MapRenderState_playEnemyTurn___closure: {
    "^": "Closure:54;box_0,this_4",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.this_4;
      t2 = this.box_0;
      R.redrawHpBar(t1.game, t2.targetPlayer_1);
      t1.playerText.setText$1(H.S(J.get$name$x(t2.targetPlayer_1)) + "\n" + H.S(t2.targetPlayer_1.get$hpCurrent()) + "/" + H.S(t2.targetPlayer_1.get$hpMax()));
      t3 = t2.targetPlayer_1.get$hpCurrent();
      if (typeof t3 !== "number")
        return t3.$le();
      if (t3 <= 0)
        C.JSArray_methods.remove$1(t1.map.playerTeam, t2.targetPlayer_1);
      return t1.playAttackSound$1(t2.chosenType_0);
    }
  },
  MapRenderState__pickEnemyAttackType_closure: {
    "^": "Closure:1806;target_0,weaknessCharges_1",
    call$2: function(t, charges) {
      if (this.target_0.isWeakTo$1(t))
        this.weaknessCharges_1.$indexSet(0, t, charges);
    }
  },
  MapRenderState__pickEnemyAttackType_closure0: {
    "^": "Closure:1807;weaknessCharges_2",
    call$2: function(t1, t2) {
      var t3 = this.weaknessCharges_2;
      return J.$ge$n(t3.$index(0, t1), t3.$index(0, t2)) ? t1 : t2;
    }
  },
  MapRenderState__pickEnemyAttackType_closure1: {
    "^": "Closure:1806;target_3,nonweakCharges_4",
    call$2: function(t, charges) {
      if (!this.target_3.isWeakTo$1(t))
        this.nonweakCharges_4.$indexSet(0, t, charges);
    }
  },
  MapRenderState__pickEnemyAttackType_closure2: {
    "^": "Closure:1807;nonweakCharges_5",
    call$2: function(t1, t2) {
      var t3 = this.nonweakCharges_5;
      return J.$ge$n(t3.$index(0, t1), t3.$index(0, t2)) ? t1 : t2;
    }
  },
  MapRenderState_playAttackSound_closure: {
    "^": "Closure:1527;box_0",
    call$1: [function(s) {
      if (++this.box_0.loopCount_0 === 3)
        J.stop$0$x(s);
    }, "call$1", null, 2, 0, null, 545, [], "call"]
  },
  FileWaitState: {
    "^": "State;map*,ie@,game-613,add-1032,make-1033,camera-1046,cache-1034,input-1035,math-1093,load-1036,sound-1038,scale-1022,stage-1040,time-1041,tweens-1043,world-1008,particles-1048,physics-1042,rnd-1044,state-1030",
    map$1: function($receiver, arg0) {
      return this.map.call$1(arg0);
    },
    create$0: [function() {
      var style = R.TextStyle$("center", "#ffffff", "45px Arial", "black", 0, 16777215);
      J.text$4$x(J.get$add$ax(this.game), this.game.get$world().get$centerX(), this.game.get$world().get$centerY(), "Waiting for text file...", style);
    }, "call$0", "get$create", 0, 0, 54, "create"],
    update$0: [function() {
      var t1, t2;
      if (C.FileList_methods.get$isNotEmpty(J.get$files$x(this.ie))) {
        t1 = this.map;
        t2 = J.get$files$x(this.ie);
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t1.generateMap$1(t2[0]).then$1(new L.FileWaitState_update_closure(this));
      }
    }, "call$0", "get$update", 0, 0, 54, "update"],
    init$1: [function(args) {
      this.ie = document.querySelector("#test");
    }, function() {
      return this.init$1(null);
    }, "init$0", "call$1", "call$0", "get$init", 0, 2, 944, 12, 383, [], "init"]
  },
  FileWaitState_update_closure: {
    "^": "Closure:102;this_0",
    call$1: [function(_) {
      var t1 = this.this_0;
      $.finder = R.AStarPathFinder$(t1.map, 50, false, null);
      J.start$1$x(J.get$state$x(t1.game), "maprender");
    }, "call$1", null, 2, 0, null, 1686, [], "call"]
  },
  TitleState: {
    "^": "State;assetPath,game-613,add-1032,make-1033,camera-1046,cache-1034,input-1035,math-1093,load-1036,sound-1038,scale-1022,stage-1040,time-1041,tweens-1043,world-1008,particles-1048,physics-1042,rnd-1044,state-1030",
    preload$0: [function(_) {
      J.get$load$x(this.game).image$2("title", this.assetPath + "/title.png");
      J.audio$2$x(J.get$load$x(this.game), "mainTheme", this.assetPath + "/broken_reality.ogg");
    }, "call$0", "get$preload", 0, 0, 54, "preload"],
    create$0: [function() {
      var t, t1;
      J.get$add$ax(this.game).sprite$3(0, 0, "title");
      J.play$4$x(J.audio$3$x(J.get$add$ax(this.game), "mainTheme", 0.5, true), "", 0, 0.5, true);
      t = this.game.get$time().create$0();
      t1 = J.getInterceptor$ax(t);
      t1.add$2(t, 3000, new L.TitleState_create_closure(this));
      t1.start$0(t);
    }, "call$0", "get$create", 0, 0, 54, "create"]
  },
  TitleState_create_closure: {
    "^": "Closure:54;this_0",
    call$0: [function() {
      return J.start$1$x(J.get$state$x(this.this_0.game), "wait");
    }, "call$0", null, 0, 0, null, "call"]
  }
},
1],
]);
Isolate.$finishClasses($$, $, null);
$$ = null;

// Runtime type support
;(function() {
  var TRUE = !0, _;
  _ = P.$int;
  _.$is$int = TRUE;
  _.$isnum = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.num];
  _.$isObject = TRUE;
  _ = P.$double;
  _.$is$double = TRUE;
  _.$isnum = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.num];
  _.$isObject = TRUE;
  _ = W.Node0;
  _.$isNode0 = TRUE;
  _.$isEventTarget = TRUE;
  _.$isObject = TRUE;
  W.File.$isObject = TRUE;
  W.Touch0.$isObject = TRUE;
  _ = P.String;
  _.$isString = TRUE;
  _.$isPattern = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.String];
  _.$isObject = TRUE;
  _ = P.num;
  _.$isnum = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.num];
  _.$isObject = TRUE;
  _ = P.Duration;
  _.$isDuration = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.Duration];
  _.$isObject = TRUE;
  P.Match.$isObject = TRUE;
  P.Object.$isObject = TRUE;
  _ = P.List;
  _.$isList = TRUE;
  _.$isIterable = TRUE;
  _.$isObject = TRUE;
  _ = W.Element;
  _.$isElement = TRUE;
  _.$isNode0 = TRUE;
  _.$isEventTarget = TRUE;
  _.$isEventTarget = TRUE;
  _.$isObject = TRUE;
  _ = R.AttackType;
  _.$isAttackType = TRUE;
  _.$isObject = TRUE;
  _ = R.Sprite;
  _.$isSprite = TRUE;
  _.$isSprite0 = TRUE;
  _.$isSpriteInterface = TRUE;
  _.$isGameObject = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isSpriteInterface = TRUE;
  _.$isObject = TRUE;
  _ = R.Text;
  _.$isText = TRUE;
  _.$isGameObject = TRUE;
  _.$isSprite0 = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  W.Event.$isObject = TRUE;
  _ = R.SignalBinding;
  _.$isSignalBinding = TRUE;
  _.$isObject = TRUE;
  _ = R.Pointer;
  _.$isPointer = TRUE;
  _.$isObject = TRUE;
  _ = P.Symbol0;
  _.$isSymbol0 = TRUE;
  _.$isObject = TRUE;
  _ = R.Node;
  _.$isComparable = TRUE;
  _.$asComparable = [null];
  _.$isObject = TRUE;
  _ = P.bool;
  _.$isbool = TRUE;
  _.$isObject = TRUE;
  P.RenderingContext.$isObject = TRUE;
  _ = P.LibraryMirror;
  _.$isLibraryMirror = TRUE;
  _.$isObject = TRUE;
  _ = P.ClassMirror;
  _.$isTypeMirror = TRUE;
  _.$isObject = TRUE;
  W.ProgressEvent.$isObject = TRUE;
  _ = P.AudioBuffer;
  _.$isAudioBuffer = TRUE;
  _.$isObject = TRUE;
  _ = W.MouseEvent;
  _.$isMouseEvent = TRUE;
  _.$isObject = TRUE;
  W.AnimationEvent.$isObject = TRUE;
  _ = R.Tween;
  _.$isTween = TRUE;
  _.$isObject = TRUE;
  _ = W.TouchEvent;
  _.$isTouchEvent = TRUE;
  _.$isObject = TRUE;
  _ = R.Body;
  _.$isRectangle1 = TRUE;
  _.$isObject = TRUE;
  R.QuadTree.$isObject = TRUE;
  P.ContextEvent.$isObject = TRUE;
  _ = R.Character;
  _.$isCharacter = TRUE;
  _.$isMover = TRUE;
  _.$isObject = TRUE;
  _ = R.TileType;
  _.$isTileType = TRUE;
  _.$isObject = TRUE;
  _ = R.Tile;
  _.$isTile = TRUE;
  _.$isObject = TRUE;
  H.RawReceivePortImpl.$isObject = TRUE;
  H._IsolateEvent.$isObject = TRUE;
  H._IsolateContext.$isObject = TRUE;
  _ = P.Stream;
  _.$isStream = TRUE;
  _.$isObject = TRUE;
  _ = P.StreamSubscription;
  _.$isStreamSubscription = TRUE;
  _.$isObject = TRUE;
  _ = W.WheelEvent;
  _.$isMouseEvent = TRUE;
  _.$isObject = TRUE;
  P.MethodMirror.$isObject = TRUE;
  H.JsMethodMirror.$isObject = TRUE;
  P.ParameterMirror.$isObject = TRUE;
  _ = P.TypeVariableMirror;
  _.$isTypeMirror = TRUE;
  _.$isObject = TRUE;
  _ = P.TypeMirror;
  _.$isTypeMirror = TRUE;
  _.$isObject = TRUE;
  _ = W.TableRowElement;
  _.$isHtmlElement = TRUE;
  _.$isElement = TRUE;
  _.$isNode0 = TRUE;
  _.$isEventTarget = TRUE;
  _.$isEventTarget = TRUE;
  _.$isObject = TRUE;
  _ = P.Map;
  _.$isMap = TRUE;
  _.$isObject = TRUE;
  _ = A.Body3;
  _.$isBody3 = TRUE;
  _.$isEventEmitter = TRUE;
  _.$isObject = TRUE;
  _ = A.Shape0;
  _.$isShape0 = TRUE;
  _.$isObject = TRUE;
  _ = A.vec2;
  _.$isvec2 = TRUE;
  _.$isObject = TRUE;
  A.Spring.$isObject = TRUE;
  A.IslandNode.$isObject = TRUE;
  A.Island.$isObject = TRUE;
  A.Equation.$isObject = TRUE;
  A.Constraint.$isObject = TRUE;
  A.ContactMaterial.$isObject = TRUE;
  A.ContactEquation.$isObject = TRUE;
  A.OverlapKeeperRecord.$isObject = TRUE;
  A.FrictionEquation.$isObject = TRUE;
  _ = W.MediaStream;
  _.$isMediaStream = TRUE;
  _.$isEventTarget = TRUE;
  _.$isObject = TRUE;
  _ = P.StackTrace;
  _.$isStackTrace = TRUE;
  _.$isObject = TRUE;
  _ = R.InputHandler;
  _.$isInputHandler = TRUE;
  _.$isObject = TRUE;
  _ = R.Sound;
  _.$isSound = TRUE;
  _.$isObject = TRUE;
  _ = M.PixiEvent;
  _.$isPixiEvent = TRUE;
  _.$isObject = TRUE;
  _ = P._BufferingStreamSubscription;
  _.$is_BufferingStreamSubscription = TRUE;
  _.$is_EventSink = TRUE;
  _.$isStreamSubscription = TRUE;
  _.$isObject = TRUE;
  _ = P._BroadcastSubscription;
  _.$is_BroadcastSubscription = TRUE;
  _.$is_BufferingStreamSubscription = TRUE;
  _.$is_EventSink = TRUE;
  _.$isStreamSubscription = TRUE;
  _.$isObject = TRUE;
  _ = L.CollisionGroup;
  _.$isCollisionGroup = TRUE;
  _.$isObject = TRUE;
  _ = R.Point;
  _.$isPoint = TRUE;
  _.$isPoint0 = TRUE;
  _.$isObject = TRUE;
  _ = R.Rectangle1;
  _.$isRectangle1 = TRUE;
  _.$isObject = TRUE;
  _ = P.Comparable;
  _.$isComparable = TRUE;
  _.$isObject = TRUE;
  _ = M.Texture;
  _.$isTexture = TRUE;
  _.$isObject = TRUE;
  _ = W.CanvasElement;
  _.$isCanvasElement = TRUE;
  _.$isHtmlElement = TRUE;
  _.$isElement = TRUE;
  _.$isNode0 = TRUE;
  _.$isEventTarget = TRUE;
  _.$isEventTarget = TRUE;
  _.$isObject = TRUE;
  _ = W.EventTarget;
  _.$isEventTarget = TRUE;
  _.$isObject = TRUE;
  _ = P.InstanceMirror;
  _.$isInstanceMirror = TRUE;
  _.$isObject = TRUE;
  _ = P.Iterable;
  _.$isIterable = TRUE;
  _.$isObject = TRUE;
  _ = P._EventSink;
  _.$is_EventSink = TRUE;
  _.$isObject = TRUE;
  _ = P.Future;
  _.$isFuture = TRUE;
  _.$isObject = TRUE;
  _ = P.DateTime;
  _.$isDateTime = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [null];
  _.$isObject = TRUE;
  _ = R.State;
  _.$isState = TRUE;
  _.$isObject = TRUE;
  _ = P._DelayedEvent;
  _.$is_DelayedEvent = TRUE;
  _.$isObject = TRUE;
  _ = P.AsyncError;
  _.$isAsyncError = TRUE;
  _.$isObject = TRUE;
  _ = R.Timer;
  _.$isTimer = TRUE;
  _.$isObject = TRUE;
  _ = R.Emitter;
  _.$isEmitter = TRUE;
  _.$isGroup = TRUE;
  _.$asGroup = [null];
  _.$isDisplayObjectContainer = TRUE;
  _.$isGameObject = TRUE;
  _.$isObject = TRUE;
  _ = R.Plugin;
  _.$isPlugin = TRUE;
  _.$isObject = TRUE;
  _ = R.Loader;
  _.$isLoader = TRUE;
  _.$isObject = TRUE;
  _ = W.HtmlElement;
  _.$isHtmlElement = TRUE;
  _.$isElement = TRUE;
  _.$isNode0 = TRUE;
  _.$isEventTarget = TRUE;
  _.$isEventTarget = TRUE;
  _.$isObject = TRUE;
  _ = R.GameObject;
  _.$isGameObject = TRUE;
  _.$isObject = TRUE;
  _ = R.Group;
  _.$isGroup = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isGameObject = TRUE;
  _.$isObject = TRUE;
  _ = R.Key;
  _.$isKey = TRUE;
  _.$isObject = TRUE;
  _ = R.Animation;
  _.$isAnimation = TRUE;
  _.$isObject = TRUE;
  _ = P.Function;
  _.$isFunction = TRUE;
  _.$isObject = TRUE;
  _ = R.TimerEvent;
  _.$isTimerEvent = TRUE;
  _.$isObject = TRUE;
  _ = R.Button;
  _.$isButton = TRUE;
  _.$isImage = TRUE;
  _.$isSprite0 = TRUE;
  _.$isSpriteInterface = TRUE;
  _.$isGameObject = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isSpriteInterface = TRUE;
  _.$isObject = TRUE;
  _ = R.Circle0;
  _.$isCircle0 = TRUE;
  _.$isObject = TRUE;
  _ = R.TextStyle;
  _.$isTextStyle = TRUE;
  _.$isObject = TRUE;
  _ = W.Path2D;
  _.$isPath2D = TRUE;
  _.$isObject = TRUE;
  _ = M.DisplayObjectContainer;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = M.Point0;
  _.$isPoint0 = TRUE;
  _.$isObject = TRUE;
  _ = R.Mover;
  _.$isMover = TRUE;
  _.$isObject = TRUE;
  _ = R.TilemapLayer;
  _.$isTilemapLayer = TRUE;
  _.$isImage = TRUE;
  _.$isSprite0 = TRUE;
  _.$isSpriteInterface = TRUE;
  _.$isGameObject = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isSpriteInterface = TRUE;
  _.$isObject = TRUE;
  _ = R.Image;
  _.$isImage = TRUE;
  _.$isSprite0 = TRUE;
  _.$isSpriteInterface = TRUE;
  _.$isGameObject = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isSpriteInterface = TRUE;
  _.$isObject = TRUE;
  _ = M.Stage0;
  _.$isStage0 = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = M.Sprite0;
  _.$isSprite0 = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = P.UniformLocation;
  _.$isUniformLocation = TRUE;
  _.$isObject = TRUE;
  _ = P.Float32List;
  _.$isFloat32List = TRUE;
  _.$isList = TRUE;
  _.$asList = [P.$double];
  _.$isIterable = TRUE;
  _.$asIterable = [P.$double];
  _.$isObject = TRUE;
  _ = P.Pattern;
  _.$isPattern = TRUE;
  _.$isObject = TRUE;
  _ = M.Graphics0;
  _.$isGraphics0 = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = M.SpriteBatch0;
  _.$isSpriteBatch0 = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = R.SpriteInterface;
  _.$isSpriteInterface = TRUE;
  _.$isObject = TRUE;
  _ = W.CanvasRenderingContext2D;
  _.$isCanvasRenderingContext2D = TRUE;
  _.$isObject = TRUE;
  _ = E.Circle1;
  _.$isCircle1 = TRUE;
  _.$isObject = TRUE;
  _ = E.Tile1;
  _.$isTile1 = TRUE;
  _.$isObject = TRUE;
  _ = E.AABB;
  _.$isAABB = TRUE;
  _.$isObject = TRUE;
  _ = A.EventEmitter;
  _.$isEventEmitter = TRUE;
  _.$isObject = TRUE;
  _ = A.Line0;
  _.$isLine0 = TRUE;
  _.$isShape0 = TRUE;
  _.$isObject = TRUE;
  _ = A.Rectangle2;
  _.$isRectangle2 = TRUE;
  _.$isConvex = TRUE;
  _.$isShape0 = TRUE;
  _.$isObject = TRUE;
  _ = A.Convex;
  _.$isConvex = TRUE;
  _.$isShape0 = TRUE;
  _.$isObject = TRUE;
  _ = A.Capsule;
  _.$isCapsule = TRUE;
  _.$isShape0 = TRUE;
  _.$isObject = TRUE;
  _ = A.Plane;
  _.$isPlane = TRUE;
  _.$isShape0 = TRUE;
  _.$isObject = TRUE;
  _ = A.Particle0;
  _.$isParticle0 = TRUE;
  _.$isShape0 = TRUE;
  _.$isObject = TRUE;
  _ = A.Circle2;
  _.$isCircle2 = TRUE;
  _.$isShape0 = TRUE;
  _.$isObject = TRUE;
  _ = A.Heightfield;
  _.$isHeightfield = TRUE;
  _.$isShape0 = TRUE;
  _.$isObject = TRUE;
  _ = R.Tile0;
  _.$isTile0 = TRUE;
  _.$isObject = TRUE;
})();
;
// getInterceptor methods
J.getInterceptor = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSDouble.prototype;
  }
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return J.JSNull.prototype;
  if (typeof receiver == "boolean")
    return J.JSBool.prototype;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$asx = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$ax = function(receiver) {
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$i = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSNumber.prototype;
  }
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$n = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$ns = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$s = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$x = function(receiver) {
  if (receiver == null)
    return receiver;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.$add$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver + a0;
  return J.getInterceptor$ns(receiver).$add(receiver, a0);
};
J.$and$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return (receiver & a0) >>> 0;
  return J.getInterceptor$n(receiver).$and(receiver, a0);
};
J.$div$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver / a0;
  return J.getInterceptor$n(receiver).$div(receiver, a0);
};
J.$eq = function(receiver, a0) {
  if (receiver == null)
    return a0 == null;
  if (typeof receiver != "object")
    return a0 != null && receiver === a0;
  return J.getInterceptor(receiver).$eq(receiver, a0);
};
J.$ge$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver >= a0;
  return J.getInterceptor$n(receiver).$ge(receiver, a0);
};
J.$gt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver > a0;
  return J.getInterceptor$n(receiver).$gt(receiver, a0);
};
J.$index$asx = function(receiver, a0) {
  if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
    if (a0 >>> 0 === a0 && a0 < receiver.length)
      return receiver[a0];
  return J.getInterceptor$asx(receiver).$index(receiver, a0);
};
J.$indexSet$ax = function(receiver, a0, a1) {
  if ((receiver.constructor == Array || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName])) && !receiver.immutable$list && a0 >>> 0 === a0 && a0 < receiver.length)
    return receiver[a0] = a1;
  return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
};
J.$le$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver <= a0;
  return J.getInterceptor$n(receiver).$le(receiver, a0);
};
J.$lt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver < a0;
  return J.getInterceptor$n(receiver).$lt(receiver, a0);
};
J.$mod$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).$mod(receiver, a0);
};
J.$mul$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver * a0;
  return J.getInterceptor$ns(receiver).$mul(receiver, a0);
};
J.$negate$n = function(receiver) {
  if (typeof receiver == "number")
    return -receiver;
  return J.getInterceptor$n(receiver).$negate(receiver);
};
J.$not$i = function(receiver) {
  if (typeof receiver == "number" && Math.floor(receiver) == receiver)
    return ~receiver >>> 0;
  return J.getInterceptor$i(receiver).$not(receiver);
};
J.$or$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return (receiver | a0) >>> 0;
  return J.getInterceptor$n(receiver).$or(receiver, a0);
};
J.$shl$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).$shl(receiver, a0);
};
J.$shr$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).$shr(receiver, a0);
};
J.$sub$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver - a0;
  return J.getInterceptor$n(receiver).$sub(receiver, a0);
};
J.$tdiv$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).$tdiv(receiver, a0);
};
J.$xor$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return (receiver ^ a0) >>> 0;
  return J.getInterceptor$n(receiver).$xor(receiver, a0);
};
J._clearChildren$0$x = function(receiver) {
  return J.getInterceptor$x(receiver)._clearChildren$0(receiver);
};
J._replaceChild$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver)._replaceChild$2(receiver, a0, a1);
};
J.abs$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).abs$0(receiver);
};
J.activeTexture$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).activeTexture$1(receiver, a0);
};
J.add$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).add$1(receiver, a0);
};
J.add$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).add$2(receiver, a0, a1);
};
J.add$4$ax = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$ax(receiver).add$4(receiver, a0, a1, a2, a3);
};
J.addAll$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).addAll$1(receiver, a0);
};
J.addEventListener$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).addEventListener$2(receiver, a0, a1);
};
J.addEventListener$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).addEventListener$3(receiver, a0, a1, a2);
};
J.allMatches$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).allMatches$1(receiver, a0);
};
J.any$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).any$1(receiver, a0);
};
J.append$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).append$1(receiver, a0);
};
J.arc$5$x = function(receiver, a0, a1, a2, a3, a4) {
  return J.getInterceptor$x(receiver).arc$5(receiver, a0, a1, a2, a3, a4);
};
J.arc$6$x = function(receiver, a0, a1, a2, a3, a4, a5) {
  return J.getInterceptor$x(receiver).arc$6(receiver, a0, a1, a2, a3, a4, a5);
};
J.audio$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).audio$2(receiver, a0, a1);
};
J.audio$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).audio$3(receiver, a0, a1, a2);
};
J.beginPath$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).beginPath$0(receiver);
};
J.bindBuffer$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).bindBuffer$2(receiver, a0, a1);
};
J.bindFramebuffer$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).bindFramebuffer$2(receiver, a0, a1);
};
J.bindRenderbuffer$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).bindRenderbuffer$2(receiver, a0, a1);
};
J.bindTexture$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).bindTexture$2(receiver, a0, a1);
};
J.blendFunc$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).blendFunc$2(receiver, a0, a1);
};
J.bufferSubData$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).bufferSubData$3(receiver, a0, a1, a2);
};
J.ceil$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).ceil$0(receiver);
};
J.clear$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).clear$0(receiver);
};
J.clear$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).clear$1(receiver, a0);
};
J.clearColor$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).clearColor$4(receiver, a0, a1, a2, a3);
};
J.clearRect$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).clearRect$4(receiver, a0, a1, a2, a3);
};
J.clone$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).clone$0(receiver);
};
J.closePath$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).closePath$0(receiver);
};
J.codeUnitAt$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).codeUnitAt$1(receiver, a0);
};
J.colorMask$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).colorMask$4(receiver, a0, a1, a2, a3);
};
J.compareTo$1$ns = function(receiver, a0) {
  return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
};
J.connectNode$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).connectNode$1(receiver, a0);
};
J.contains$1$asx = function(receiver, a0) {
  return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
};
J.contains$2$asx = function(receiver, a0, a1) {
  return J.getInterceptor$asx(receiver).contains$2(receiver, a0, a1);
};
J.containsKey$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).containsKey$1(receiver, a0);
};
J.containsPoint$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).containsPoint$2(receiver, a0, a1);
};
J.createBuffer$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createBuffer$0(receiver);
};
J.createBuffer$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).createBuffer$3(receiver, a0, a1, a2);
};
J.createBufferSource$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createBufferSource$0(receiver);
};
J.createFramebuffer$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createFramebuffer$0(receiver);
};
J.createGain$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createGain$0(receiver);
};
J.createRenderbuffer$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createRenderbuffer$0(receiver);
};
J.createTexture$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createTexture$0(receiver);
};
J.decodeAudioData$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).decodeAudioData$1(receiver, a0);
};
J.deleteBuffer$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).deleteBuffer$1(receiver, a0);
};
J.deleteProgram$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).deleteProgram$1(receiver, a0);
};
J.disable$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).disable$1(receiver, a0);
};
J.disableVertexAttribArray$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).disableVertexAttribArray$1(receiver, a0);
};
J.dispatchEvent$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).dispatchEvent$1(receiver, a0);
};
J.drawElements$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).drawElements$4(receiver, a0, a1, a2, a3);
};
J.drawImageScaledFromSource$9$x = function(receiver, a0, a1, a2, a3, a4, a5, a6, a7, a8) {
  return J.getInterceptor$x(receiver).drawImageScaledFromSource$9(receiver, a0, a1, a2, a3, a4, a5, a6, a7, a8);
};
J.elementAt$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
};
J.enable$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).enable$1(receiver, a0);
};
J.enable$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).enable$2(receiver, a0, a1);
};
J.enableVertexAttribArray$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).enableVertexAttribArray$1(receiver, a0);
};
J.endsWith$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).endsWith$1(receiver, a0);
};
J.fill$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).fill$0(receiver);
};
J.fillRect$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).fillRect$4(receiver, a0, a1, a2, a3);
};
J.fillText$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).fillText$3(receiver, a0, a1, a2);
};
J.firstWhere$2$orElse$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).firstWhere$2$orElse(receiver, a0, a1);
};
J.floor$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).floor$0(receiver);
};
J.flush$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).flush$0(receiver);
};
J.fold$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).fold$2(receiver, a0, a1);
};
J.forEach$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
};
J.forEach$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).forEach$2(receiver, a0, a1);
};
J.framebufferRenderbuffer$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).framebufferRenderbuffer$4(receiver, a0, a1, a2, a3);
};
J.framebufferTexture2D$5$x = function(receiver, a0, a1, a2, a3, a4) {
  return J.getInterceptor$x(receiver).framebufferTexture2D$5(receiver, a0, a1, a2, a3, a4);
};
J.get$_key$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$_key(receiver);
};
J.get$a$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$a(receiver);
};
J.get$add$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$add(receiver);
};
J.get$alpha$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$alpha(receiver);
};
J.get$angle$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$angle(receiver);
};
J.get$animation$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$animation(receiver);
};
J.get$attributes$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$attributes(receiver);
};
J.get$blur$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$blur(receiver);
};
J.get$body$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$body(receiver);
};
J.get$bottom$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$bottom(receiver);
};
J.get$bound$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$bound(receiver);
};
J.get$buffer$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$buffer(receiver);
};
J.get$button$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$button(receiver);
};
J.get$canvas$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$canvas(receiver);
};
J.get$changedTouches$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$changedTouches(receiver);
};
J.get$charCode$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$charCode(receiver);
};
J.get$checked$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$checked(receiver);
};
J.get$children$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$children(receiver);
};
J.get$click$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$click(receiver);
};
J.get$contains$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$contains(receiver);
};
J.get$content$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$content(receiver);
};
J.get$context$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$context(receiver);
};
J.get$cursor$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$cursor(receiver);
};
J.get$data$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$data(receiver);
};
J.get$dataset$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$dataset(receiver);
};
J.get$defaultValue$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$defaultValue(receiver);
};
J.get$destination$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$destination(receiver);
};
J.get$disabled$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$disabled(receiver);
};
J.get$duration$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$duration(receiver);
};
J.get$dx$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$dx(receiver);
};
J.get$dy$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$dy(receiver);
};
J.get$error$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$error(receiver);
};
J.get$files$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$files(receiver);
};
J.get$fill$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$fill(receiver);
};
J.get$font$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$font(receiver);
};
J.get$force$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$force(receiver);
};
J.get$gain$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$gain(receiver);
};
J.get$globalAlpha$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$globalAlpha(receiver);
};
J.get$globalCompositeOperation$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$globalCompositeOperation(receiver);
};
J.get$grid$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$grid(receiver);
};
J.get$hashCode$ = function(receiver) {
  return J.getInterceptor(receiver).get$hashCode(receiver);
};
J.get$height$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$height(receiver);
};
J.get$id$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$id(receiver);
};
J.get$identifier$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$identifier(receiver);
};
J.get$index$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$index(receiver);
};
J.get$isEmpty$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
};
J.get$isNotEmpty$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
};
J.get$iterator$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$iterator(receiver);
};
J.get$key$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$key(receiver);
};
J.get$keys$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$keys(receiver);
};
J.get$last$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$last(receiver);
};
J.get$left$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$left(receiver);
};
J.get$length$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$length(receiver);
};
J.get$lineWidth$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$lineWidth(receiver);
};
J.get$load$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$load(receiver);
};
J.get$loop$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$loop(receiver);
};
J.get$mask$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$mask(receiver);
};
J.get$mode$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$mode(receiver);
};
J.get$name$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$name(receiver);
};
J.get$now$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$now(receiver);
};
J.get$offset$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$offset(receiver);
};
J.get$onAnimationStart$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onAnimationStart(receiver);
};
J.get$onDragStart$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onDragStart(receiver);
};
J.get$onError$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onError(receiver);
};
J.get$onLoad$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onLoad(receiver);
};
J.get$onPause$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onPause(receiver);
};
J.get$onTouchEnter$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onTouchEnter(receiver);
};
J.get$onTouchLeave$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onTouchLeave(receiver);
};
J.get$onWebGlContextLost$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onWebGlContextLost(receiver);
};
J.get$onWebGlContextRestored$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onWebGlContextRestored(receiver);
};
J.get$padding$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$padding(receiver);
};
J.get$parent$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$parent(receiver);
};
J.get$parentNode$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$parentNode(receiver);
};
J.get$paused$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$paused(receiver);
};
J.get$points$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$points(receiver);
};
J.get$position$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$position(receiver);
};
J.get$preload$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$preload(receiver);
};
J.get$r$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$r(receiver);
};
J.get$readyState$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$readyState(receiver);
};
J.get$resize$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$resize(receiver);
};
J.get$response$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$response(receiver);
};
J.get$responseText$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$responseText(receiver);
};
J.get$responseType$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$responseType(receiver);
};
J.get$responseXml$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$responseXml(receiver);
};
J.get$result$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$result(receiver);
};
J.get$reversed$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$reversed(receiver);
};
J.get$right$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$right(receiver);
};
J.get$scale$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$scale(receiver);
};
J.get$screenX$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$screenX(receiver);
};
J.get$screenY$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$screenY(receiver);
};
J.get$shadowBlur$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$shadowBlur(receiver);
};
J.get$shadowColor$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$shadowColor(receiver);
};
J.get$shadowOffsetX$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$shadowOffsetX(receiver);
};
J.get$shadowOffsetY$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$shadowOffsetY(receiver);
};
J.get$sign$n = function(receiver) {
  return J.getInterceptor$n(receiver).get$sign(receiver);
};
J.get$size$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$size(receiver);
};
J.get$source$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$source(receiver);
};
J.get$src$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$src(receiver);
};
J.get$start$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$start(receiver);
};
J.get$state$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$state(receiver);
};
J.get$status$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$status(receiver);
};
J.get$stop$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$stop(receiver);
};
J.get$stroke$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$stroke(receiver);
};
J.get$style$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$style(receiver);
};
J.get$target$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$target(receiver);
};
J.get$th$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$th(receiver);
};
J.get$top$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$top(receiver);
};
J.get$topLeft$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$topLeft(receiver);
};
J.get$total$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$total(receiver);
};
J.get$trim$s = function(receiver) {
  return J.getInterceptor$s(receiver).get$trim(receiver);
};
J.get$type$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$type(receiver);
};
J.get$url$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$url(receiver);
};
J.get$value$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$value(receiver);
};
J.get$values$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$values(receiver);
};
J.get$view$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$view(receiver);
};
J.get$volume$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$volume(receiver);
};
J.get$width$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$width(receiver);
};
J.get$wordWrap$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$wordWrap(receiver);
};
J.get$x$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$x(receiver);
};
J.get$y$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$y(receiver);
};
J.getAttribLocation$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).getAttribLocation$2(receiver, a0, a1);
};
J.getAttribute$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).getAttribute$1(receiver, a0);
};
J.getBoundingClientRect$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).getBoundingClientRect$0(receiver);
};
J.getContext$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).getContext$1(receiver, a0);
};
J.getContext$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).getContext$2(receiver, a0, a1);
};
J.getContext3d$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).getContext3d$0(receiver);
};
J.getImageData$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).getImageData$4(receiver, a0, a1, a2, a3);
};
J.getPropertyValue$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).getPropertyValue$1(receiver, a0);
};
J.getRange$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).getRange$2(receiver, a0, a1);
};
J.getUniformLocation$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).getUniformLocation$2(receiver, a0, a1);
};
J.indexOf$1$asx = function(receiver, a0) {
  return J.getInterceptor$asx(receiver).indexOf$1(receiver, a0);
};
J.indexOf$2$asx = function(receiver, a0, a1) {
  return J.getInterceptor$asx(receiver).indexOf$2(receiver, a0, a1);
};
J.insert$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).insert$1(receiver, a0);
};
J.insert$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).insert$2(receiver, a0, a1);
};
J.intersects$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).intersects$1(receiver, a0);
};
J.join$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).join$1(receiver, a0);
};
J.lineTo$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).lineTo$2(receiver, a0, a1);
};
J.load$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).load$0(receiver);
};
J.load$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).load$2(receiver, a0, a1);
};
J.map$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).map$1(receiver, a0);
};
J.measureText$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).measureText$1(receiver, a0);
};
J.moveTo$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).moveTo$2(receiver, a0, a1);
};
J.moveTo$5$finder$x = function(receiver, a0, a1, a2, a3, a4) {
  return J.getInterceptor$x(receiver).moveTo$5$finder(receiver, a0, a1, a2, a3, a4);
};
J.noSuchMethod$1 = function(receiver, a0) {
  return J.getInterceptor(receiver).noSuchMethod$1(receiver, a0);
};
J.on$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).on$2(receiver, a0, a1);
};
J.onResize$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).onResize$2(receiver, a0, a1);
};
J.open$3$async$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).open$3$async(receiver, a0, a1, a2);
};
J.overrideMimeType$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).overrideMimeType$1(receiver, a0);
};
J.padLeft$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).padLeft$2(receiver, a0, a1);
};
J.parseFromString$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).parseFromString$2(receiver, a0, a1);
};
J.pause$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).pause$0(receiver);
};
J.pixelStorei$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).pixelStorei$2(receiver, a0, a1);
};
J.play$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).play$0(receiver);
};
J.play$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).play$1(receiver, a0);
};
J.play$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).play$3(receiver, a0, a1, a2);
};
J.play$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).play$4(receiver, a0, a1, a2, a3);
};
J.preventDefault$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).preventDefault$0(receiver);
};
J.putImageData$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).putImageData$3(receiver, a0, a1, a2);
};
J.remove$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).remove$0(receiver);
};
J.remove$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).remove$1(receiver, a0);
};
J.removeAt$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).removeAt$1(receiver, a0);
};
J.removeEventListener$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).removeEventListener$2(receiver, a0, a1);
};
J.removeEventListener$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).removeEventListener$3(receiver, a0, a1, a2);
};
J.removeLast$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).removeLast$0(receiver);
};
J.removeRange$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).removeRange$2(receiver, a0, a1);
};
J.replace$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).replace$2(receiver, a0, a1);
};
J.replaceAll$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).replaceAll$2(receiver, a0, a1);
};
J.replaceFirst$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).replaceFirst$2(receiver, a0, a1);
};
J.replaceWith$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).replaceWith$1(receiver, a0);
};
J.requestFullscreen$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).requestFullscreen$0(receiver);
};
J.reset$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).reset$0(receiver);
};
J.reset$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).reset$1(receiver, a0);
};
J.reset$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).reset$4(receiver, a0, a1, a2, a3);
};
J.resize$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).resize$2(receiver, a0, a1);
};
J.restore$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).restore$0(receiver);
};
J.round$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).round$0(receiver);
};
J.save$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).save$0(receiver);
};
J.send$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).send$0(receiver);
};
J.send$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).send$1(receiver, a0);
};
J.set$a$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$a(receiver, value);
};
J.set$add$ax = function(receiver, value) {
  return J.getInterceptor$ax(receiver).set$add(receiver, value);
};
J.set$alpha$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$alpha(receiver, value);
};
J.set$angle$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$angle(receiver, value);
};
J.set$backgroundColor$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$backgroundColor(receiver, value);
};
J.set$blur$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$blur(receiver, value);
};
J.set$body$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$body(receiver, value);
};
J.set$checked$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$checked(receiver, value);
};
J.set$context$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$context(receiver, value);
};
J.set$crossOrigin$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$crossOrigin(receiver, value);
};
J.set$currentTime$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$currentTime(receiver, value);
};
J.set$cursor$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$cursor(receiver, value);
};
J.set$data$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$data(receiver, value);
};
J.set$display$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$display(receiver, value);
};
J.set$fill$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$fill(receiver, value);
};
J.set$fillStyle$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$fillStyle(receiver, value);
};
J.set$font$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$font(receiver, value);
};
J.set$globalAlpha$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$globalAlpha(receiver, value);
};
J.set$globalCompositeOperation$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$globalCompositeOperation(receiver, value);
};
J.set$height$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$height(receiver, value);
};
J.set$imageRendering$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$imageRendering(receiver, value);
};
J.set$imageSmoothingEnabled$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$imageSmoothingEnabled(receiver, value);
};
J.set$index$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$index(receiver, value);
};
J.set$key$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$key(receiver, value);
};
J.set$left$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$left(receiver, value);
};
J.set$length$asx = function(receiver, value) {
  return J.getInterceptor$asx(receiver).set$length(receiver, value);
};
J.set$lineCap$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$lineCap(receiver, value);
};
J.set$lineJoin$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$lineJoin(receiver, value);
};
J.set$lineWidth$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$lineWidth(receiver, value);
};
J.set$load$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$load(receiver, value);
};
J.set$loop$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$loop(receiver, value);
};
J.set$marginLeft$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$marginLeft(receiver, value);
};
J.set$marginTop$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$marginTop(receiver, value);
};
J.set$minHeight$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$minHeight(receiver, value);
};
J.set$mode$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$mode(receiver, value);
};
J.set$muted$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$muted(receiver, value);
};
J.set$offset$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$offset(receiver, value);
};
J.set$onAnimationStart$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$onAnimationStart(receiver, value);
};
J.set$onDragStart$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$onDragStart(receiver, value);
};
J.set$overflow$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$overflow(receiver, value);
};
J.set$parent$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$parent(receiver, value);
};
J.set$paused$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$paused(receiver, value);
};
J.set$position$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$position(receiver, value);
};
J.set$r$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$r(receiver, value);
};
J.set$responseType$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$responseType(receiver, value);
};
J.set$right$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$right(receiver, value);
};
J.set$scale$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$scale(receiver, value);
};
J.set$shadowBlur$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$shadowBlur(receiver, value);
};
J.set$shadowColor$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$shadowColor(receiver, value);
};
J.set$shadowOffsetX$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$shadowOffsetX(receiver, value);
};
J.set$shadowOffsetY$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$shadowOffsetY(receiver, value);
};
J.set$source$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$source(receiver, value);
};
J.set$src$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$src(receiver, value);
};
J.set$state$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$state(receiver, value);
};
J.set$stroke$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$stroke(receiver, value);
};
J.set$strokeStyle$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$strokeStyle(receiver, value);
};
J.set$tapHighlightColor$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$tapHighlightColor(receiver, value);
};
J.set$target$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$target(receiver, value);
};
J.set$textBaseline$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$textBaseline(receiver, value);
};
J.set$th$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$th(receiver, value);
};
J.set$touchAction$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$touchAction(receiver, value);
};
J.set$trim$s = function(receiver, value) {
  return J.getInterceptor$s(receiver).set$trim(receiver, value);
};
J.set$userSelect$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$userSelect(receiver, value);
};
J.set$volume$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$volume(receiver, value);
};
J.set$width$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$width(receiver, value);
};
J.set$wordWrap$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$wordWrap(receiver, value);
};
J.set$x$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$x(receiver, value);
};
J.set$x1$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$x1(receiver, value);
};
J.set$x2$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$x2(receiver, value);
};
J.set$y$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$y(receiver, value);
};
J.set$y1$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$y1(receiver, value);
};
J.set$y2$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$y2(receiver, value);
};
J.set$z$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$z(receiver, value);
};
J.setProperty$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).setProperty$3(receiver, a0, a1, a2);
};
J.setRange$4$ax = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$ax(receiver).setRange$4(receiver, a0, a1, a2, a3);
};
J.setTransform$6$x = function(receiver, a0, a1, a2, a3, a4, a5) {
  return J.getInterceptor$x(receiver).setTransform$6(receiver, a0, a1, a2, a3, a4, a5);
};
J.sort$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).sort$0(receiver);
};
J.sort$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).sort$1(receiver, a0);
};
J.split$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).split$1(receiver, a0);
};
J.start$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).start$0(receiver);
};
J.start$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).start$1(receiver, a0);
};
J.start$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).start$2(receiver, a0, a1);
};
J.start$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).start$3(receiver, a0, a1, a2);
};
J.startsWith$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).startsWith$1(receiver, a0);
};
J.step$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).step$1(receiver, a0);
};
J.stop$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).stop$0(receiver);
};
J.stop$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).stop$1(receiver, a0);
};
J.stroke$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).stroke$0(receiver);
};
J.strokeRect$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).strokeRect$4(receiver, a0, a1, a2, a3);
};
J.strokeText$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).strokeText$3(receiver, a0, a1, a2);
};
J.sublist$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).sublist$2(receiver, a0, a1);
};
J.substring$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).substring$1(receiver, a0);
};
J.substring$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
};
J.texImage2D$6$x = function(receiver, a0, a1, a2, a3, a4, a5) {
  return J.getInterceptor$x(receiver).texImage2D$6(receiver, a0, a1, a2, a3, a4, a5);
};
J.texImage2D$9$x = function(receiver, a0, a1, a2, a3, a4, a5, a6, a7, a8) {
  return J.getInterceptor$x(receiver).texImage2D$9(receiver, a0, a1, a2, a3, a4, a5, a6, a7, a8);
};
J.texParameteri$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).texParameteri$3(receiver, a0, a1, a2);
};
J.text$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).text$3(receiver, a0, a1, a2);
};
J.text$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).text$4(receiver, a0, a1, a2, a3);
};
J.toDataUrl$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).toDataUrl$0(receiver);
};
J.toDouble$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).toDouble$0(receiver);
};
J.toInt$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).toInt$0(receiver);
};
J.toList$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).toList$0(receiver);
};
J.toLowerCase$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).toLowerCase$0(receiver);
};
J.toRadixString$1$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).toRadixString$1(receiver, a0);
};
J.toString$0 = function(receiver) {
  return J.getInterceptor(receiver).toString$0(receiver);
};
J.toStringAsFixed$1$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).toStringAsFixed$1(receiver, a0);
};
J.toUpperCase$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).toUpperCase$0(receiver);
};
J.translate$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).translate$2(receiver, a0, a1);
};
J.trim$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).trim$0(receiver);
};
J.uniform1f$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).uniform1f$2(receiver, a0, a1);
};
J.uniform1i$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).uniform1i$2(receiver, a0, a1);
};
J.uniform2f$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).uniform2f$3(receiver, a0, a1, a2);
};
J.uniform3fv$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).uniform3fv$2(receiver, a0, a1);
};
J.uniformMatrix3fv$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).uniformMatrix3fv$3(receiver, a0, a1, a2);
};
J.upload$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).upload$0(receiver);
};
J.useProgram$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).useProgram$1(receiver, a0);
};
J.vertexAttribPointer$6$x = function(receiver, a0, a1, a2, a3, a4, a5) {
  return J.getInterceptor$x(receiver).vertexAttribPointer$6(receiver, a0, a1, a2, a3, a4, a5);
};
J.viewport$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).viewport$4(receiver, a0, a1, a2, a3);
};
J.where$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).where$1(receiver, a0);
};
Isolate.makeConstantList = function(list) {
  list.immutable$list = Array;
  list.fixed$length = Array;
  return list;
};
;
C.FileList_methods = W.FileList.prototype;
C.HtmlDocument_methods = W.HtmlDocument.prototype;
C.HttpRequest_methods = W.HttpRequest.prototype;
C.JSArray_methods = J.JSArray.prototype;
C.JSDouble_methods = J.JSDouble.prototype;
C.JSInt_methods = J.JSInt.prototype;
C.JSNull_methods = J.JSNull.prototype;
C.JSNumber_methods = J.JSNumber.prototype;
C.JSString_methods = J.JSString.prototype;
C.NativeUint8List_methods = H.NativeUint8List.prototype;
C.NodeList_methods = W.NodeList.prototype;
C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
C.Window_methods = W.Window.prototype;
C.AttackType_0 = new R.AttackType(0);
C.AttackType_1 = new R.AttackType(1);
C.AttackType_2 = new R.AttackType(2);
C.AttackType_3 = new R.AttackType(3);
C.AttackType_4 = new R.AttackType(4);
C.AttackType_5 = new R.AttackType(5);
C.BlendModes_0 = new M.BlendModes(0);
C.BlendModes_1 = new M.BlendModes(1);
C.BlendModes_10 = new M.BlendModes(10);
C.BlendModes_11 = new M.BlendModes(11);
C.BlendModes_12 = new M.BlendModes(12);
C.BlendModes_13 = new M.BlendModes(13);
C.BlendModes_14 = new M.BlendModes(14);
C.BlendModes_15 = new M.BlendModes(15);
C.BlendModes_16 = new M.BlendModes(16);
C.BlendModes_2 = new M.BlendModes(2);
C.BlendModes_3 = new M.BlendModes(3);
C.BlendModes_4 = new M.BlendModes(4);
C.BlendModes_5 = new M.BlendModes(5);
C.BlendModes_6 = new M.BlendModes(6);
C.BlendModes_7 = new M.BlendModes(7);
C.BlendModes_8 = new M.BlendModes(8);
C.BlendModes_9 = new M.BlendModes(9);
C.BlendModes_99999 = new M.BlendModes(99999);
C.C_DynamicRuntimeType = new H.DynamicRuntimeType();
C.C_OutOfMemoryError = new P.OutOfMemoryError();
C.C__DelayedDone = new P._DelayedDone();
C.C__JSRandom = new P._JSRandom();
C.C__RootZone = new P._RootZone();
C.CharType_0 = new R.CharType(0);
C.CharType_1 = new R.CharType(1);
C.Duration_0 = new P.Duration(0);
C.Duration_10000 = new P.Duration(10000);
C.EventStreamProvider_blur = H.setRuntimeTypeInfo(new W.EventStreamProvider("blur"), [W.Event]);
C.EventStreamProvider_canplaythrough = H.setRuntimeTypeInfo(new W.EventStreamProvider("canplaythrough"), [W.Event]);
C.EventStreamProvider_complete = H.setRuntimeTypeInfo(new W.EventStreamProvider("complete"), [W.Event]);
C.EventStreamProvider_dragstart = H.setRuntimeTypeInfo(new W.EventStreamProvider("dragstart"), [W.MouseEvent]);
C.EventStreamProvider_error = H.setRuntimeTypeInfo(new W.EventStreamProvider("error"), [W.Event]);
C.EventStreamProvider_error0 = H.setRuntimeTypeInfo(new W.EventStreamProvider("error"), [W.ProgressEvent]);
C.EventStreamProvider_focus = H.setRuntimeTypeInfo(new W.EventStreamProvider("focus"), [W.Event]);
C.EventStreamProvider_load = H.setRuntimeTypeInfo(new W.EventStreamProvider("load"), [W.Event]);
C.EventStreamProvider_load0 = H.setRuntimeTypeInfo(new W.EventStreamProvider("load"), [W.ProgressEvent]);
C.EventStreamProvider_loadend = H.setRuntimeTypeInfo(new W.EventStreamProvider("loadend"), [W.ProgressEvent]);
C.EventStreamProvider_loadstart = H.setRuntimeTypeInfo(new W.EventStreamProvider("loadstart"), [W.ProgressEvent]);
C.EventStreamProvider_loadstart0 = H.setRuntimeTypeInfo(new W.EventStreamProvider("loadstart"), [W.Event]);
C.EventStreamProvider_mousedown = H.setRuntimeTypeInfo(new W.EventStreamProvider("mousedown"), [W.MouseEvent]);
C.EventStreamProvider_mousemove = H.setRuntimeTypeInfo(new W.EventStreamProvider("mousemove"), [W.MouseEvent]);
C.EventStreamProvider_mouseout = H.setRuntimeTypeInfo(new W.EventStreamProvider("mouseout"), [W.MouseEvent]);
C.EventStreamProvider_mouseover = H.setRuntimeTypeInfo(new W.EventStreamProvider("mouseover"), [W.MouseEvent]);
C.EventStreamProvider_mouseup = H.setRuntimeTypeInfo(new W.EventStreamProvider("mouseup"), [W.MouseEvent]);
C.EventStreamProvider_mousewheel = H.setRuntimeTypeInfo(new W.EventStreamProvider("mousewheel"), [W.WheelEvent]);
C.EventStreamProvider_pagehide = H.setRuntimeTypeInfo(new W.EventStreamProvider("pagehide"), [W.Event]);
C.EventStreamProvider_pageshow = H.setRuntimeTypeInfo(new W.EventStreamProvider("pageshow"), [W.Event]);
C.EventStreamProvider_pause = H.setRuntimeTypeInfo(new W.EventStreamProvider("pause"), [W.Event]);
C.EventStreamProvider_play = H.setRuntimeTypeInfo(new W.EventStreamProvider("play"), [W.Event]);
C.EventStreamProvider_progress = H.setRuntimeTypeInfo(new W.EventStreamProvider("progress"), [W.ProgressEvent]);
C.EventStreamProvider_progress0 = H.setRuntimeTypeInfo(new W.EventStreamProvider("progress"), [W.Event]);
C.EventStreamProvider_readystatechange = H.setRuntimeTypeInfo(new W.EventStreamProvider("readystatechange"), [W.ProgressEvent]);
C.EventStreamProvider_resize = H.setRuntimeTypeInfo(new W.EventStreamProvider("resize"), [W.Event]);
C.EventStreamProvider_touchcancel = H.setRuntimeTypeInfo(new W.EventStreamProvider("touchcancel"), [W.TouchEvent]);
C.EventStreamProvider_touchend = H.setRuntimeTypeInfo(new W.EventStreamProvider("touchend"), [W.TouchEvent]);
C.EventStreamProvider_touchenter = H.setRuntimeTypeInfo(new W.EventStreamProvider("touchenter"), [W.TouchEvent]);
C.EventStreamProvider_touchleave = H.setRuntimeTypeInfo(new W.EventStreamProvider("touchleave"), [W.TouchEvent]);
C.EventStreamProvider_touchmove = H.setRuntimeTypeInfo(new W.EventStreamProvider("touchmove"), [W.TouchEvent]);
C.EventStreamProvider_touchstart = H.setRuntimeTypeInfo(new W.EventStreamProvider("touchstart"), [W.TouchEvent]);
C.EventStreamProvider_webglcontextlost = H.setRuntimeTypeInfo(new W.EventStreamProvider("webglcontextlost"), [P.ContextEvent]);
C.EventStreamProvider_webglcontextrestored = H.setRuntimeTypeInfo(new W.EventStreamProvider("webglcontextrestored"), [P.ContextEvent]);
C.EventStreamProvider_webkitAnimationStart = H.setRuntimeTypeInfo(new W.EventStreamProvider("webkitAnimationStart"), [W.AnimationEvent]);
C.JS_CONST_0 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
C.JS_CONST_4hp = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
C.JS_CONST_8ZY = function getTagFallback(o) {
  var constructor = o.constructor;
  if (typeof constructor == "function") {
    var name = constructor.name;
    if (typeof name == "string" &&
        name.length > 2 &&
        name !== "Object" &&
        name !== "Function.prototype") {
      return name;
    }
  }
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
C.JS_CONST_Fs4 = function(hooks) { return hooks; }
;
C.JS_CONST_QJm = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
C.JS_CONST_gkc = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
C.JS_CONST_oRe = function() {
  function typeNameInChrome(o) {
    var name = o.constructor.name;
    if (name) return name;
    var s = Object.prototype.toString.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = Object.prototype.toString.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: typeNameInChrome,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
C.JS_CONST_rr7 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
C.JS_CONST_s8I = function(_, letter) { return letter.toUpperCase(); };
C.JsonCodec_null_null = new P.JsonCodec(null, null);
C.JsonDecoder_null = new P.JsonDecoder(null);
C.List_0_0 = Isolate.makeConstantList([0, 0]);
C.List_127_2047_65535_1114111 = H.setRuntimeTypeInfo(Isolate.makeConstantList([127, 2047, 65535, 1114111]), [P.$int]);
C.List_2Vk = Isolate.makeConstantList([0, 0, 32776, 33792, 1, 10240, 0, 0]);
C.List_CVk = Isolate.makeConstantList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]);
C.List_JYB = Isolate.makeConstantList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]);
C.List_empty = Isolate.makeConstantList([]);
C.List_empty0 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.TypeVariableMirror]);
C.List_empty1 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.TypeMirror]);
C.List_empty2 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.$int]);
C.List_gRj = Isolate.makeConstantList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]);
C.List_nxB = Isolate.makeConstantList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]);
C.List_qNA = Isolate.makeConstantList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]);
C.List_qg4 = Isolate.makeConstantList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]);
C.List_qg40 = Isolate.makeConstantList([0, 0, 32722, 12287, 65535, 34815, 65534, 18431]);
C.List_F9d = Isolate.makeConstantList(["TEXTURE_ATLAS_JSON_ARRAY", "TEXTURE_ATLAS_JSON_HASH", "TEXTURE_ATLAS_XML_STARLING", "PHYSICS_LIME_CORONA_JSON", "PHYSICS_PHASER_JSON"]);
C.Map_F9OTV = new H.ConstantStringMap(5, {TEXTURE_ATLAS_JSON_ARRAY: 0, TEXTURE_ATLAS_JSON_HASH: 1, TEXTURE_ATLAS_XML_STARLING: 2, PHYSICS_LIME_CORONA_JSON: 3, PHYSICS_PHASER_JSON: 3}, C.List_F9d);
C.List_CSV_TILED_JSON = Isolate.makeConstantList(["CSV", "TILED_JSON"]);
C.Map_do86y = new H.ConstantStringMap(2, {CSV: 0, TILED_JSON: 1}, C.List_CSV_TILED_JSON);
C.Map_empty = new H.ConstantStringMap(0, {}, C.List_empty);
C.Symbol_0c4 = new H.Symbol("");
C.Symbol_call = new H.Symbol("call");
C.Symbol_dynamic = new H.Symbol("dynamic");
C.Symbol_void = new H.Symbol("void");
C.TileType_0 = new R.TileType(0);
C.TileType_1 = new R.TileType(1);
C.TileType_2 = new R.TileType(2);
C.TileType_3 = new R.TileType(3);
C.TileType_4 = new R.TileType(4);
C.TileType_5 = new R.TileType(5);
C.TileType_6 = new R.TileType(6);
C.Type_O1S = H.createRuntimeType('Sprite');
C.TypeVariable_0 = new H.TypeVariable(C.Type_O1S, "T", 4);
C.Type_9jE = H.createRuntimeType('Group');
C.TypeVariable_2Uu = new H.TypeVariable(C.Type_9jE, "T", 2);
C.Type_nZF = H.createRuntimeType('Signal');
C.TypeVariable_eTF = new H.TypeVariable(C.Type_nZF, "T", 0);
C.Type_1Od = H.createRuntimeType('Particle');
C.Type_6L0 = H.createRuntimeType('Uint8List');
C.Type_AGr = H.createRuntimeType('JsTypeVariableMirror');
C.Type_Art = H.createRuntimeType('Float32List');
C.Type_CAk = H.createRuntimeType('Uint16List');
C.Type_EjN = H.createRuntimeType('Function');
C.Type_Ejg = H.createRuntimeType('String');
C.Type_EsU = H.createRuntimeType('bool');
C.Type_QuW = H.createRuntimeType('Uint8ClampedList');
C.Type_SnA = H.createRuntimeType('$int');
C.Type_UoK = H.createRuntimeType('Int16List');
C.Type_XXD = H.createRuntimeType('JSObject');
C.Type_ckn = H.createRuntimeType('Float64List');
C.Type_dTZ = H.createRuntimeType('Int32List');
C.Type_dynamic = H.createRuntimeType('dynamic');
C.Type_eZO = H.createRuntimeType('Null');
C.Type_irB = H.createRuntimeType('Uint32List');
C.Type_mp3 = H.createRuntimeType('Int8List');
C.Type_oGP = H.createRuntimeType('ByteData');
C.Type_qq1 = H.createRuntimeType('$double');
C.Type_wAg = H.createRuntimeType('ByteBuffer');
C.Type_xM7 = H.createRuntimeType('num');
C.Utf8Codec_false = new P.Utf8Codec(false);
C._CustomEventStreamProvider__determineMouseWheelEventType = H.setRuntimeTypeInfo(new W._CustomEventStreamProvider(W.Element__determineMouseWheelEventType$closure()), [W.WheelEvent]);
C.scaleModes_0 = new M.scaleModes(0);
C.scaleModes_1 = new M.scaleModes(1);
C.scaleModes_2 = new M.scaleModes(2);
init.isHunkLoaded = function(hunkHash) {
  return !!$dart_deferred_initializers[hunkHash];
};
init.initializeLoadedHunk = function(hunkHash) {
  $dart_deferred_initializers[hunkHash](globalsHolder, $);
};
init.deferredLibraryUris = {};
init.deferredLibraryHashes = {};
$.Bone_yDown = true;
$.defaultRenderer = null;
$.blendModesWebGL = null;
$.blendModesCanvas = null;
$._UID = 0;
$.Graphics_POLY = 0;
$.Graphics_RECT = 1;
$.Graphics_CIRC = 2;
$.Graphics_ELIP = 3;
$.Graphics_RREC = 4;
$.CanvasTinter_cacheStepsPerColorChannel = 8;
$.CanvasTinter_convertTintToImage = false;
$.CanvasTinter_canvas = null;
$.WebGLGraphics_last = null;
$.BaseTextureCacheIdGenerator = 0;
$.TextureCacheIdGenerator = 0;
$.Group_RETURN_NONE = 0;
$.Group_RETURN_TOTAL = 1;
$.Group_RETURN_CHILD = 2;
$.Group_SORT_ASCENDING = -1;
$.Group_SORT_DESCENDING = 1;
$.RandomDataGenerator_UUID = 0;
$.Particles_ID = 0;
$.Device_LITTLE_ENDIAN = false;
$.IsolateNatives_enableSpawnWorker = null;
$.RawReceivePortImpl__nextFreeId = 1;
$.Primitives_mirrorFunctionCacheName = "$cachedFunction";
$.Primitives_mirrorInvokeCacheName = "$cachedInvocation";
$.Closure_functionCounter = 0;
$.BoundClosure_selfFieldNameCache = null;
$.BoundClosure_receiverFieldNameCache = null;
$.RuntimeFunctionType_inAssert = false;
$.deferredLoadHook = null;
$.getTagFunction = null;
$.alternateTagFunction = null;
$.prototypeForTagFunction = null;
$.dispatchRecordsForInstanceTags = null;
$.interceptorsForUncacheableTags = null;
$.initNativeDispatchFlag = null;
$.printToZone = null;
$.JsMirrorSystem__librariesByName = null;
$.JsMirrorSystem__hasInstalledDeferredLoadHook = false;
$.classMirrors = null;
$._nextCallback = null;
$._lastCallback = null;
$._lastPriorityCallback = null;
$._isInCallbackLoop = false;
$.Zone__current = C.C__RootZone;
$.Expando__keyCount = 0;
$.Device__isOpera = null;
$.Device__isIE = null;
$.Device__isFirefox = null;
$.Device__isWebKit = null;
$.Device__cachedCssPrefix = null;
$.ContactMaterial_idCounter = 0;
$.Material_idCounter = 0;
$.vec2_sub = A.vec2_subtract$closure();
$.Body__idCounter = 0;
$.Shape_idCounter = 0;
$.finder = null;
$.interceptedNames = ["$add", "$and", "$div", "$eq", "$ge", "$gt", "$index", "$indexSet", "$le", "$lt", "$mod", "$mul", "$negate", "$not", "$or", "$shl", "$shr", "$sub", "$tdiv", "$xor", "_addEventListener$3", "_checkIndex$2", "_checkSublistArguments$3", "_clearChildren$0", "_decodeAudioData$3", "_defaultSplit$1", "_ensureRequestAnimationFrame$0", "_getPropertyValueHelper$1", "_getUserMedia$3", "_invalidIndex$2", "_js$_checkIndex$1", "_rangeCheck$2", "_removeEventListener$3", "_replaceChild$2", "_requestAnimationFrame$1", "_setPropertyHelper$3", "_setRangeFast$4", "_shlPositive$1", "_shrOtherPositive$1", "_shrReceiverPositive$1", "_tdivFast$1", "abs$0", "activeTexture$1", "add$1", "add$2", "add$3", "add$4", "add$5", "addAll$1", "addEventListener$2", "addEventListener$3", "addKey$1", "allMatches$1", "allMatches$2", "angle$0", "angle$1", "angle$2", "any$1", "append$1", "arc$5", "arc$6", "arcTo$5", "attachShader$2", "audio$1", "audio$2", "audio$3", "audio$4", "beginPath$0", "bezierCurveTo$6", "bindBuffer$2", "bindFramebuffer$2", "bindRenderbuffer$2", "bindTexture$2", "blendFunc$2", "blur$0", "body$1", "body$2", "body$3", "bufferData$3", "bufferSubData$3", "button$0", "button$1", "button$2", "button$3", "button$4", "button$5", "button$6", "button$7", "button$8", "button$9", "capture$1", "ceil$0", "checkGrowable$1", "checkMutable$1", "clamp$2", "clear$0", "clear$1", "clearColor$4", "clearRect$4", "click$0", "clip$0", "clip$2", "clone$0", "clone$1", "close$0", "closePath$0", "codeUnitAt$1", "colorMask$4", "compareTo$1", "compileShader$1", "complete$0", "complete$1", "connectNode$1", "connectNode$3", "contains$1", "contains$2", "containsKey$1", "containsPoint$2", "createBuffer$0", "createBuffer$3", "createBufferSource$0", "createFramebuffer$0", "createGain$0", "createPattern$2", "createPatternFromImage$2", "createProgram$0", "createRenderbuffer$0", "createShader$1", "createTexture$0", "decodeAudioData$1", "defaultValue$1", "deleteBuffer$1", "deleteFramebuffer$1", "deleteProgram$1", "deleteTexture$1", "deltaX$0", "deltaY$0", "deltaZ$0", "disable$1", "disableVertexAttribArray$1", "dispatchEvent$1", "drawElements$4", "drawImage$3", "drawImageScaledFromSource$9", "elementAt$1", "enable$1", "enable$2", "enable$3", "enable$5", "enableVertexAttribArray$1", "endsWith$1", "fill$0", "fill$1", "fill$3", "fill$4", "fill$5", "fill$6", "fillRect$4", "fillText$3", "fillText$4", "filter$1", "filter$2", "firstWhere$1", "firstWhere$2$orElse", "floor$0", "flush$0", "fold$2", "forEach$1", "forEach$2", "forEach$5", "forEach$6", "framebufferRenderbuffer$4", "framebufferTexture2D$5", "get$LINEAR", "get$NEAREST", "get$NONE", "get$ONE", "get$TEXTURE", "get$VERSION", "get$ZERO", "get$_created", "get$_key", "get$a", "get$acceleration", "get$add", "get$alpha", "get$altKey", "get$angle", "get$animation", "get$any", "get$aspectRatio", "get$attributes", "get$autoplay", "get$backgroundColor", "get$blur", "get$body", "get$border", "get$bottom", "get$bottomLeft", "get$bottomRight", "get$bound", "get$buffer", "get$button", "get$canvas", "get$capture", "get$changedTouches", "get$charCode", "get$checked", "get$children", "get$clear", "get$click", "get$client", "get$clientLeft", "get$clientTop", "get$clip", "get$codeUnits", "get$color", "get$columnWidth", "get$columns", "get$complete", "get$content", "get$context", "get$crossOrigin", "get$ctrlKey", "get$currentTime", "get$cursor", "get$data", "get$dataset", "get$defaultValue", "get$deltaX", "get$deltaY", "get$deltaZ", "get$destination", "get$disabled", "get$draggable", "get$duration", "get$dx", "get$dy", "get$error", "get$files", "get$fill", "get$fillStyle", "get$filter", "get$first", "get$font", "get$fontSize", "get$fontWeight", "get$fonts", "get$force", "get$format", "get$gain", "get$getUserMedia", "get$globalAlpha", "get$globalCompositeOperation", "get$grid", "get$hashCode", "get$height", "get$host", "get$id", "get$identifier", "get$imageSmoothingEnabled", "get$index", "get$isEmpty", "get$isNaN", "get$isNegative", "get$isNotEmpty", "get$iterator", "get$key", "get$keyCode", "get$keys", "get$last", "get$layer", "get$left", "get$length", "get$lineCap", "get$lineHeight", "get$lineJoin", "get$lineWidth", "get$load", "get$loaded", "get$localStorage", "get$loop", "get$lowerBound", "get$map", "get$margin", "get$mask", "get$maskPosition", "get$maxHeight", "get$maxWidth", "get$minHeight", "get$minWidth", "get$mode", "get$movement", "get$muted", "get$name", "get$nodes", "get$now", "get$offset", "get$on", "get$onAnimationStart", "get$onBlur", "get$onComplete", "get$onDragStart", "get$onError", "get$onFocus", "get$onLoad", "get$onLoadStart", "get$onMouseDown", "get$onMouseMove", "get$onMouseOut", "get$onMouseOver", "get$onMouseUp", "get$onMouseWheel", "get$onPause", "get$onPlay", "get$onProgress", "get$onReadyStateChange", "get$onResize", "get$onTouchCancel", "get$onTouchEnd", "get$onTouchEnter", "get$onTouchLeave", "get$onTouchMove", "get$onTouchStart", "get$onWebGlContextLost", "get$onWebGlContextRestored", "get$options", "get$order", "get$orientation", "get$padding", "get$page", "get$parent", "get$parentNode", "get$paused", "get$points", "get$port", "get$position", "get$preload", "get$preventDefault", "get$r", "get$readyState", "get$requestFullscreen", "get$resize", "get$response", "get$responseText", "get$responseType", "get$responseXml", "get$result", "get$reversed", "get$right", "get$rotate", "get$rows", "get$runtimeType", "get$scale", "get$screen", "get$screenX", "get$screenY", "get$scrollX", "get$scrollY", "get$shadowBlur", "get$shadowColor", "get$shadowOffsetX", "get$shadowOffsetY", "get$shiftKey", "get$sign", "get$size", "get$source", "get$src", "get$start", "get$state", "get$status", "get$step", "get$stop", "get$stroke", "get$strokeStyle", "get$style", "get$target", "get$text", "get$textBaseline", "get$th", "get$top", "get$topLeft", "get$topRight", "get$total", "get$transform", "get$trim", "get$type", "get$upperBound", "get$url", "get$value", "get$values", "get$version", "get$view", "get$volume", "get$width", "get$wordWrap", "get$wrap", "get$x", "get$x1", "get$x2", "get$y", "get$y1", "get$y2", "get$z", "getAttribLocation$2", "getAttribute$1", "getBoundingClientRect$0", "getContext$1", "getContext$2", "getContext3d$0", "getContext3d$6$alpha$antialias$depth$premultipliedAlpha$preserveDrawingBuffer$stencil", "getElementsByTagName$1", "getImageData$4", "getProgramParameter$2", "getPropertyValue$1", "getRange$2", "getShaderInfoLog$1", "getShaderParameter$2", "getUniformLocation$2", "getUserMedia$0", "getUserMedia$2$audio$video", "hash$1", "indexOf$1", "indexOf$2", "insert$1", "insert$2", "intersection$1", "intersection$2", "intersects$1", "intersects$2", "intersects$3", "intersects$4", "join$1", "key$3", "key$4", "lineTo$2", "lineWidth$1", "linkProgram$1", "load$0", "load$1", "loop$0", "loop$3", "map$1", "matchAsPrefix$2", "measureText$1", "moveTo$2", "moveTo$5$finder", "moveTo$5$precomputed", "moveTo$6$finder$precomputed", "noSuchMethod$1", "now$0", "offset$2", "on$2", "onError$0", "onError$1", "onMouseDown$1", "onMouseMove$1", "onMouseOut$1", "onMouseOver$1", "onMouseUp$1", "onMouseWheel$1", "onResize$2", "onTouchCancel$1", "onTouchEnd$1", "onTouchEnter$1", "onTouchLeave$1", "onTouchMove$1", "onTouchStart$1", "open$3$async", "open$5$async$password$user", "order$0", "overrideMimeType$1", "padLeft$2", "parseFromString$2", "pause$0", "pause$1", "paused$0", "pixelStorei$2", "play$0", "play$1", "play$2", "play$3", "play$4", "play$5", "preload$0", "preventDefault$0", "putIfAbsent$2", "putImageData$3", "putImageData$7", "quadraticCurveTo$4", "rect$4", "rect$5", "reduce$1", "remainder$1", "remove$0", "remove$1", "remove$2", "remove$3", "removeAt$1", "removeEventListener$2", "removeEventListener$3", "removeLast$0", "removeRange$2", "renderbufferStorage$4", "repeat$1", "repeat$4", "replace$2", "replace$6", "replace$7", "replaceAll$2", "replaceFirst$2", "replaceFirst$3", "replaceWith$1", "requestAnimationFrame$1", "requestFullscreen$0", "requestPointerLock$0", "reset$0", "reset$1", "reset$2", "reset$3", "reset$4", "reset$5", "reset$6", "reset$7", "resize$0", "resize$2", "resize$3", "restore$0", "rotate$1", "rotate$3", "rotate$4", "rotate$5", "round$0", "roundToDouble$0", "save$0", "scale$2", "scrollTo$2", "scrollTo$3", "send$0", "send$1", "send$2", "set$LINEAR", "set$NEAREST", "set$NONE", "set$ONE", "set$TEXTURE", "set$VERSION", "set$ZERO", "set$_created", "set$_key", "set$a", "set$acceleration", "set$add", "set$alpha", "set$altKey", "set$angle", "set$animation", "set$any", "set$aspectRatio", "set$attributes", "set$autoplay", "set$backgroundColor", "set$blur", "set$body", "set$bottom", "set$bottomLeft", "set$bottomRight", "set$bound", "set$buffer", "set$button", "set$canvas", "set$capture", "set$changedTouches", "set$charCode", "set$checked", "set$children", "set$click", "set$color", "set$columnWidth", "set$columns", "set$complete", "set$content", "set$context", "set$crossOrigin", "set$ctrlKey", "set$currentTime", "set$cursor", "set$data", "set$defaultValue", "set$deltaZ", "set$destination", "set$disabled", "set$display", "set$draggable", "set$duration", "set$dx", "set$dy", "set$error", "set$files", "set$fill", "set$fillStyle", "set$font", "set$fontSize", "set$fontWeight", "set$fonts", "set$force", "set$format", "set$gain", "set$getUserMedia", "set$globalAlpha", "set$globalCompositeOperation", "set$grid", "set$height", "set$id", "set$identifier", "set$imageRendering", "set$imageSmoothingEnabled", "set$index", "set$key", "set$keyCode", "set$keys", "set$last", "set$layer", "set$left", "set$length", "set$lineCap", "set$lineHeight", "set$lineJoin", "set$lineWidth", "set$load", "set$loaded", "set$localStorage", "set$loop", "set$lowerBound", "set$map", "set$margin", "set$marginLeft", "set$marginTop", "set$mask", "set$maskPosition", "set$maxHeight", "set$maxWidth", "set$minHeight", "set$minWidth", "set$mode", "set$muted", "set$name", "set$nodes", "set$now", "set$offset", "set$on", "set$onAnimationStart", "set$onBlur", "set$onComplete", "set$onDragStart", "set$onFocus", "set$onLoadStart", "set$onPause", "set$onPlay", "set$onProgress", "set$onResize", "set$options", "set$orientation", "set$overflow", "set$padding", "set$page", "set$parent", "set$parentNode", "set$paused", "set$points", "set$position", "set$preload", "set$preventDefault", "set$r", "set$readyState", "set$requestFullscreen", "set$responseText", "set$responseType", "set$responseXml", "set$result", "set$reversed", "set$right", "set$rotate", "set$rows", "set$scale", "set$screen", "set$screenX", "set$screenY", "set$scrollX", "set$scrollY", "set$shadowBlur", "set$shadowColor", "set$shadowOffsetX", "set$shadowOffsetY", "set$shiftKey", "set$size", "set$source", "set$src", "set$start", "set$state", "set$status", "set$step", "set$stop", "set$stroke", "set$strokeStyle", "set$style", "set$tapHighlightColor", "set$target", "set$text", "set$textBaseline", "set$th", "set$top", "set$topLeft", "set$topRight", "set$total", "set$touchAction", "set$trim", "set$type", "set$upperBound", "set$url", "set$userSelect", "set$value", "set$values", "set$version", "set$view", "set$volume", "set$width", "set$wordWrap", "set$wrap", "set$x", "set$x1", "set$x2", "set$y", "set$y1", "set$y2", "set$z", "setProperty$3", "setRange$4", "setTransform$6", "shaderSource$2", "shuffle$4", "shuffle$5", "size$0", "size$1", "sort$0", "sort$1", "sort$2", "split$0", "split$1", "start$0", "start$1", "start$2", "start$3", "start$4", "start$5", "startsWith$1", "startsWith$2", "stencilFunc$3", "stencilOp$3", "step$0", "step$1", "step$2", "step$3", "stop$0", "stop$1", "stop$2", "stroke$0", "stroke$1", "strokeRect$4", "strokeText$3", "strokeText$4", "sublist$2", "substring$1", "substring$2", "take$1", "texImage2D$6", "texImage2D$9", "texImage2DTyped$9", "texParameteri$3", "text$2", "text$3", "text$4", "text$5", "toDataUrl$0", "toDataUrl$2", "toDouble$0", "toInt$0", "toList$0", "toList$1$growable", "toLowerCase$0", "toRadixString$1", "toString$0", "toStringAsFixed$1", "toUpperCase$0", "transform$6", "translate$2", "trim$0", "trim$1", "uniform1f$2", "uniform1i$2", "uniform2f$3", "uniform2fv$2", "uniform2i$3", "uniform3f$4", "uniform3fv$2", "uniform3i$4", "uniform4f$5", "uniform4fv$2", "uniform4i$5", "uniformMatrix2fv$3", "uniformMatrix3fv$3", "uniformMatrix4fv$3", "unlock$0", "upload$0", "useProgram$1", "vertexAttribPointer$6", "viewport$4", "where$1", "wordWrap$1", "wrap$1", "wrap$2", "wrap$3", "wrap$4", "wrap$5"];
Isolate.$lazy($, "IdentityMatrix", "IdentityMatrix", "get$IdentityMatrix", function() {
  return new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9)));
});
Isolate.$lazy($, "Matrix2", "Matrix2", "get$Matrix2", function() {
  return C.Type_Art;
});
Isolate.$lazy($, "EmptyRectangle", "EmptyRectangle", "get$EmptyRectangle", function() {
  return new M.Rectangle0(0, 0, 0, 0);
});
Isolate.$lazy($, "AnimCache", "AnimCache", "get$AnimCache", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "AttachmentType", "AttachmentType", "get$AttachmentType", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["region", 0], null, null);
});
Isolate.$lazy($, "Format", "Atlas_Format", "get$Atlas_Format", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["alpha", 0, "intensity", 1, "luminanceAlpha", 2, "rgb565", 3, "rgba4444", 4, "rgb888", 5, "rgba8888", 6], null, null);
});
Isolate.$lazy($, "TextureFilter", "Atlas_TextureFilter", "get$Atlas_TextureFilter", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["nearest", 0, "linear", 1, "mipMap", 2, "mipMapNearestNearest", 3, "mipMapLinearNearest", 4, "mipMapNearestLinear", 5, "mipMapLinearLinear", 6], null, null);
});
Isolate.$lazy($, "TextureWrap", "Atlas_TextureWrap", "get$Atlas_TextureWrap", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["mirroredRepeat", 0, "clampToEdge", 1, "repeat", 2], null, null);
});
Isolate.$lazy($, "splitReg", "AtlasReader_splitReg", "get$AtlasReader_splitReg", function() {
  return new H.JSSyntaxRegExp("\r\n|\r|\n", H.JSSyntaxRegExp_makeNative("\r\n|\r|\n", false, true, false), null, null);
});
Isolate.$lazy($, "replaceReg", "AtlasReader_replaceReg", "get$AtlasReader_replaceReg", function() {
  return new H.JSSyntaxRegExp("^s+|s+$", H.JSSyntaxRegExp_makeNative("^s+|s+$", true, true, false), null, null);
});
Isolate.$lazy($, "baseReg", "Loader_baseReg", "get$Loader_baseReg", function() {
  return new H.JSSyntaxRegExp("[^/]*$", H.JSSyntaxRegExp_makeNative("[^/]*$", false, true, false), null, null);
});
Isolate.$lazy($, "resultReg", "Loader_resultReg", "get$Loader_resultReg", function() {
  return new H.JSSyntaxRegExp("\r?\n", H.JSSyntaxRegExp_makeNative("\r?\n", false, true, false), null, null);
});
Isolate.$lazy($, "resultSplit", "Loader_resultSplit", "get$Loader_resultSplit", function() {
  return new H.JSSyntaxRegExp("^s+|s+$", H.JSSyntaxRegExp_makeNative("^s+|s+$", true, true, false), null, null);
});
Isolate.$lazy($, "requestAnimFrame", "requestAnimFrame", "get$requestAnimFrame", function() {
  return C.Window_methods.get$requestAnimationFrame(window);
});
Isolate.$lazy($, "canUseMultiply", "CanvasTinter_canUseMultiply", "get$CanvasTinter_canUseMultiply", function() {
  return M.canUseNewCanvasBlendModes();
});
Isolate.$lazy($, "tintMethod", "CanvasTinter_tintMethod", "get$CanvasTinter_tintMethod", function() {
  return $.get$CanvasTinter_canUseMultiply() != null ? M.CanvasTinter_tintWithMultiply$closure() : M.CanvasTinter_tintWithPerPixel$closure();
});
Isolate.$lazy($, "defaultVertexSrc", "PixiShader_defaultVertexSrc", "get$PixiShader_defaultVertexSrc", function() {
  return ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec2 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;", "   vColor = vec4(color * aColor.x, aColor.x);", "}"];
});
Isolate.$lazy($, "graphicsDataPool", "WebGLGraphics_graphicsDataPool", "get$WebGLGraphics_graphicsDataPool", function() {
  return [];
});
Isolate.$lazy($, "glContexts", "glContexts", "get$glContexts", function() {
  return P.LinkedHashSet_LinkedHashSet(null, null, null, null);
});
Isolate.$lazy($, "fonts", "BitmapText_fonts", "get$BitmapText_fonts", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_charCodeReg", "BitmapText__charCodeReg", "get$BitmapText__charCodeReg", function() {
  return new H.JSSyntaxRegExp("(?:\r\n|\r|\n)", H.JSSyntaxRegExp_makeNative("(?:\r\n|\r|\n)", false, true, false), null, null);
});
Isolate.$lazy($, "_numReg", "BitmapText__numReg", "get$BitmapText__numReg", function() {
  return new H.JSSyntaxRegExp("[a-zA-Z]", H.JSSyntaxRegExp_makeNative("[a-zA-Z]", false, true, false), null, null);
});
Isolate.$lazy($, "splitReg", "Text_splitReg", "get$Text_splitReg", function() {
  return new H.JSSyntaxRegExp("(?:\r\n|\r|\n)", H.JSSyntaxRegExp_makeNative("(?:\r\n|\r|\n)", false, true, false), null, null);
});
Isolate.$lazy($, "heightCache", "Text_heightCache", "get$Text_heightCache", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "BaseTextureCache", "BaseTextureCache", "get$BaseTextureCache", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "texturesToUpdate", "texturesToUpdate", "get$texturesToUpdate", function() {
  return [];
});
Isolate.$lazy($, "texturesToDestroy", "texturesToDestroy", "get$texturesToDestroy", function() {
  return [];
});
Isolate.$lazy($, "tempMatrix", "RenderTexture_tempMatrix", "get$RenderTexture_tempMatrix", function() {
  return new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(H._checkLength(9)));
});
Isolate.$lazy($, "TextureCache", "TextureCache", "get$TextureCache", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "FrameCache", "FrameCache", "get$FrameCache", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "frameUpdates", "Texture_frameUpdates", "get$Texture_frameUpdates", function() {
  return [];
});
Isolate.$lazy($, "linesReg", "Text_linesReg", "get$Text_linesReg", function() {
  return new H.JSSyntaxRegExp("(?:\r\n|\r|\n)", H.JSSyntaxRegExp_makeNative("(?:\r\n|\r|\n)", false, true, false), null, null);
});
Isolate.$lazy($, "random", "Math_random", "get$Math_random", function() {
  return C.C__JSRandom.get$nextDouble();
});
Isolate.$lazy($, "GAMES", "GAMES", "get$GAMES", function() {
  return [];
});
Isolate.$lazy($, "Default", "Easing_Default", "get$Easing_Default", function() {
  return $.get$Easing_Linear().get$None();
});
Isolate.$lazy($, "Linear", "Easing_Linear", "get$Easing_Linear", function() {
  return new R.Linears();
});
Isolate.$lazy($, "Quadratic", "Easing_Quadratic", "get$Easing_Quadratic", function() {
  return new R.Quads();
});
Isolate.$lazy($, "Cubic", "Easing_Cubic", "get$Easing_Cubic", function() {
  return new R.Cubics();
});
Isolate.$lazy($, "Quartic", "Easing_Quartic", "get$Easing_Quartic", function() {
  return new R.Quarts();
});
Isolate.$lazy($, "Circ", "Easing_Circ", "get$Easing_Circ", function() {
  return new R.Circs();
});
Isolate.$lazy($, "Quintic", "Easing_Quintic", "get$Easing_Quintic", function() {
  return new R.Quints();
});
Isolate.$lazy($, "Sinusoidal", "Easing_Sinusoidal", "get$Easing_Sinusoidal", function() {
  return new R.Sines();
});
Isolate.$lazy($, "Exponential", "Easing_Exponential", "get$Easing_Exponential", function() {
  return new R.Expos();
});
Isolate.$lazy($, "Back", "Easing_Back", "get$Easing_Back", function() {
  return new R.Backs();
});
Isolate.$lazy($, "Bounce", "Easing_Bounce", "get$Easing_Bounce", function() {
  return new R.Bounces();
});
Isolate.$lazy($, "Elastic", "Easing_Elastic", "get$Easing_Elastic", function() {
  return new R.Elastics();
});
Isolate.$lazy($, "ALL_TYPES", "Character_ALL_TYPES", "get$Character_ALL_TYPES", function() {
  return [C.AttackType_3, C.AttackType_1, C.AttackType_0, C.AttackType_2, C.AttackType_4, C.AttackType_5];
});
Isolate.$lazy($, "RNG", "RNG", "get$RNG", function() {
  return C.C__JSRandom;
});
Isolate.$lazy($, "thisScript", "IsolateNatives_thisScript", "get$IsolateNatives_thisScript", function() {
  return H.IsolateNatives_computeThisScript();
});
Isolate.$lazy($, "workerIds", "IsolateNatives_workerIds", "get$IsolateNatives_workerIds", function() {
  return H.setRuntimeTypeInfo(new P.Expando(null), [P.$int]);
});
Isolate.$lazy($, "noSuchMethodPattern", "TypeErrorDecoder_noSuchMethodPattern", "get$TypeErrorDecoder_noSuchMethodPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({toString: function() {
      return "$receiver$";
    }}));
});
Isolate.$lazy($, "notClosurePattern", "TypeErrorDecoder_notClosurePattern", "get$TypeErrorDecoder_notClosurePattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null, toString: function() {
      return "$receiver$";
    }}));
});
Isolate.$lazy($, "nullCallPattern", "TypeErrorDecoder_nullCallPattern", "get$TypeErrorDecoder_nullCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
});
Isolate.$lazy($, "nullLiteralCallPattern", "TypeErrorDecoder_nullLiteralCallPattern", "get$TypeErrorDecoder_nullLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      null.$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "undefinedCallPattern", "TypeErrorDecoder_undefinedCallPattern", "get$TypeErrorDecoder_undefinedCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralCallPattern", "TypeErrorDecoder_undefinedLiteralCallPattern", "get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      (void 0).$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "nullPropertyPattern", "TypeErrorDecoder_nullPropertyPattern", "get$TypeErrorDecoder_nullPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
});
Isolate.$lazy($, "nullLiteralPropertyPattern", "TypeErrorDecoder_nullLiteralPropertyPattern", "get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      null.$method$;
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "undefinedPropertyPattern", "TypeErrorDecoder_undefinedPropertyPattern", "get$TypeErrorDecoder_undefinedPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralPropertyPattern", "TypeErrorDecoder_undefinedLiteralPropertyPattern", "get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      (void 0).$method$;
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "publicSymbolPattern", "Symbol_publicSymbolPattern", "get$Symbol_publicSymbolPattern", function() {
  return new H.JSSyntaxRegExp("^(?:(?:[\\-+*/%&|^]|\\[\\]=?|==|~/?|<[<=]?|>[>=]?|unary-)$|(?!(?:assert|break|c(?:a(?:se|tch)|lass|on(?:st|tinue))|d(?:efault|o)|e(?:lse|num|xtends)|f(?:alse|inal(?:ly)?|or)|i[fns]|n(?:ew|ull)|ret(?:hrow|urn)|s(?:uper|witch)|t(?:h(?:is|row)|r(?:ue|y))|v(?:ar|oid)|w(?:hile|ith))\\b(?!\\$))[a-zA-Z$][\\w$]*(?:=?$|[.](?!$)))+?$", H.JSSyntaxRegExp_makeNative("^(?:(?:[\\-+*/%&|^]|\\[\\]=?|==|~/?|<[<=]?|>[>=]?|unary-)$|(?!(?:assert|break|c(?:a(?:se|tch)|lass|on(?:st|tinue))|d(?:efault|o)|e(?:lse|num|xtends)|f(?:alse|inal(?:ly)?|or)|i[fns]|n(?:ew|ull)|ret(?:hrow|urn)|s(?:uper|witch)|t(?:h(?:is|row)|r(?:ue|y))|v(?:ar|oid)|w(?:hile|ith))\\b(?!\\$))[a-zA-Z$][\\w$]*(?:=?$|[.](?!$)))+?$", false, true, false), null, null);
});
Isolate.$lazy($, "_dynamicType", "JsMirrorSystem__dynamicType", "get$JsMirrorSystem__dynamicType", function() {
  return new H.JsTypeMirror(C.Symbol_dynamic);
});
Isolate.$lazy($, "_voidType", "JsMirrorSystem__voidType", "get$JsMirrorSystem__voidType", function() {
  return new H.JsTypeMirror(C.Symbol_void);
});
Isolate.$lazy($, "currentJsMirrorSystem", "currentJsMirrorSystem", "get$currentJsMirrorSystem", function() {
  return new H.JsMirrorSystem(null, new H.JsIsolateMirror(init.globalState.currentContext));
});
Isolate.$lazy($, "mangledNames", "mangledNames", "get$mangledNames", function() {
  return H.computeMangledNames(init.mangledNames, false);
});
Isolate.$lazy($, "reflectiveNames", "reflectiveNames", "get$reflectiveNames", function() {
  return H.computeReflectiveNames($.get$mangledNames());
});
Isolate.$lazy($, "mangledGlobalNames", "mangledGlobalNames", "get$mangledGlobalNames", function() {
  return H.computeMangledNames(init.mangledGlobalNames, true);
});
Isolate.$lazy($, "scheduleImmediateClosure", "_AsyncRun_scheduleImmediateClosure", "get$_AsyncRun_scheduleImmediateClosure", function() {
  return P._AsyncRun__initializeScheduleImmediate();
});
Isolate.$lazy($, "_toStringVisiting", "IterableBase__toStringVisiting", "get$IterableBase__toStringVisiting", function() {
  return [];
});
Isolate.$lazy($, "webkitEvents", "ElementEvents_webkitEvents", "get$ElementEvents_webkitEvents", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["animationend", "webkitAnimationEnd", "animationiteration", "webkitAnimationIteration", "animationstart", "webkitAnimationStart", "fullscreenchange", "webkitfullscreenchange", "fullscreenerror", "webkitfullscreenerror", "keyadded", "webkitkeyadded", "keyerror", "webkitkeyerror", "keymessage", "webkitkeymessage", "needkey", "webkitneedkey", "pointerlockchange", "webkitpointerlockchange", "pointerlockerror", "webkitpointerlockerror", "resourcetimingbufferfull", "webkitresourcetimingbufferfull", "transitionend", "webkitTransitionEnd", "speechchange", "webkitSpeechChange"], null, null);
});
Isolate.$lazy($, "_DART_OBJECT_PROPERTY_NAME", "_DART_OBJECT_PROPERTY_NAME", "get$_DART_OBJECT_PROPERTY_NAME", function() {
  return H.getIsolateAffinityTag("_$dart_dartObject");
});
Isolate.$lazy($, "_DART_CLOSURE_PROPERTY_NAME", "_DART_CLOSURE_PROPERTY_NAME", "get$_DART_CLOSURE_PROPERTY_NAME", function() {
  return H.getIsolateAffinityTag("_$dart_dartClosure");
});
Isolate.$lazy($, "_dartProxyCtor", "_dartProxyCtor", "get$_dartProxyCtor", function() {
  return function DartObject(o) {
    this.o = o;
  };
});
Isolate.$lazy($, "tmp", "AABB_tmp", "get$AABB_tmp", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "dist", "Broadphase_dist", "get$Broadphase_dist", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "yAxis", "Narrowphase_yAxis", "get$Narrowphase_yAxis", function() {
  return A.vec2_fromValues(0, 1);
});
Isolate.$lazy($, "tmp1", "Narrowphase_tmp1", "get$Narrowphase_tmp1", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp2", "Narrowphase_tmp2", "get$Narrowphase_tmp2", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp3", "Narrowphase_tmp3", "get$Narrowphase_tmp3", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp4", "Narrowphase_tmp4", "get$Narrowphase_tmp4", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp5", "Narrowphase_tmp5", "get$Narrowphase_tmp5", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp6", "Narrowphase_tmp6", "get$Narrowphase_tmp6", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp7", "Narrowphase_tmp7", "get$Narrowphase_tmp7", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp8", "Narrowphase_tmp8", "get$Narrowphase_tmp8", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp9", "Narrowphase_tmp9", "get$Narrowphase_tmp9", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp10", "Narrowphase_tmp10", "get$Narrowphase_tmp10", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp11", "Narrowphase_tmp11", "get$Narrowphase_tmp11", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp12", "Narrowphase_tmp12", "get$Narrowphase_tmp12", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp13", "Narrowphase_tmp13", "get$Narrowphase_tmp13", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp14", "Narrowphase_tmp14", "get$Narrowphase_tmp14", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp15", "Narrowphase_tmp15", "get$Narrowphase_tmp15", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp16", "Narrowphase_tmp16", "get$Narrowphase_tmp16", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp17", "Narrowphase_tmp17", "get$Narrowphase_tmp17", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmp18", "Narrowphase_tmp18", "get$Narrowphase_tmp18", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "tmpArray", "Narrowphase_tmpArray", "get$Narrowphase_tmpArray", function() {
  return Array(2);
});
Isolate.$lazy($, "convexCapsule_tempRect", "Narrowphase_convexCapsule_tempRect", "get$Narrowphase_convexCapsule_tempRect", function() {
  return A.Rectangle$0(1, 1);
});
Isolate.$lazy($, "convexCapsule_tempVec", "Narrowphase_convexCapsule_tempVec", "get$Narrowphase_convexCapsule_tempVec", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "capsuleCapsule_tempVec1", "Narrowphase_capsuleCapsule_tempVec1", "get$Narrowphase_capsuleCapsule_tempVec1", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "capsuleCapsule_tempVec2", "Narrowphase_capsuleCapsule_tempVec2", "get$Narrowphase_capsuleCapsule_tempVec2", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "capsuleCapsule_tempRect1", "Narrowphase_capsuleCapsule_tempRect1", "get$Narrowphase_capsuleCapsule_tempRect1", function() {
  return A.Rectangle$0(1, 1);
});
Isolate.$lazy($, "pic_worldVertex0", "Narrowphase_pic_worldVertex0", "get$Narrowphase_pic_worldVertex0", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "pic_worldVertex1", "Narrowphase_pic_worldVertex1", "get$Narrowphase_pic_worldVertex1", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "pic_r0", "Narrowphase_pic_r0", "get$Narrowphase_pic_r0", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "pic_r1", "Narrowphase_pic_r1", "get$Narrowphase_pic_r1", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "planeCapsule_tmpCircle", "Narrowphase_planeCapsule_tmpCircle", "get$Narrowphase_planeCapsule_tmpCircle", function() {
  var t1 = new A.Circle2(1, null, null, null, null, null, null, null, null);
  t1.Shape$1(1);
  return t1;
});
Isolate.$lazy($, "planeCapsule_tmp1", "Narrowphase_planeCapsule_tmp1", "get$Narrowphase_planeCapsule_tmp1", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "planeCapsule_tmp2", "Narrowphase_planeCapsule_tmp2", "get$Narrowphase_planeCapsule_tmp2", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "planeCapsule_tmp3", "Narrowphase_planeCapsule_tmp3", "get$Narrowphase_planeCapsule_tmp3", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "pcoa_tmp1", "Narrowphase_pcoa_tmp1", "get$Narrowphase_pcoa_tmp1", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "fsa_tmp1", "Narrowphase_fsa_tmp1", "get$Narrowphase_fsa_tmp1", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "fsa_tmp2", "Narrowphase_fsa_tmp2", "get$Narrowphase_fsa_tmp2", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "fsa_tmp3", "Narrowphase_fsa_tmp3", "get$Narrowphase_fsa_tmp3", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "fsa_tmp4", "Narrowphase_fsa_tmp4", "get$Narrowphase_fsa_tmp4", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "fsa_tmp5", "Narrowphase_fsa_tmp5", "get$Narrowphase_fsa_tmp5", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "fsa_tmp6", "Narrowphase_fsa_tmp6", "get$Narrowphase_fsa_tmp6", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "gce_tmp1", "Narrowphase_gce_tmp1", "get$Narrowphase_gce_tmp1", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "gce_tmp2", "Narrowphase_gce_tmp2", "get$Narrowphase_gce_tmp2", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "gce_tmp3", "Narrowphase_gce_tmp3", "get$Narrowphase_gce_tmp3", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "circleHeightfield_candidate", "Narrowphase_circleHeightfield_candidate", "get$Narrowphase_circleHeightfield_candidate", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "circleHeightfield_dist", "Narrowphase_circleHeightfield_dist", "get$Narrowphase_circleHeightfield_dist", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "circleHeightfield_v0", "Narrowphase_circleHeightfield_v0", "get$Narrowphase_circleHeightfield_v0", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "circleHeightfield_v1", "Narrowphase_circleHeightfield_v1", "get$Narrowphase_circleHeightfield_v1", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "circleHeightfield_minCandidate", "Narrowphase_circleHeightfield_minCandidate", "get$Narrowphase_circleHeightfield_minCandidate", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "circleHeightfield_worldNormal", "Narrowphase_circleHeightfield_worldNormal", "get$Narrowphase_circleHeightfield_worldNormal", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "circleHeightfield_minCandidateNormal", "Narrowphase_circleHeightfield_minCandidateNormal", "get$Narrowphase_circleHeightfield_minCandidateNormal", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "convexHeightfield_v0", "Narrowphase_convexHeightfield_v0", "get$Narrowphase_convexHeightfield_v0", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "convexHeightfield_v1", "Narrowphase_convexHeightfield_v1", "get$Narrowphase_convexHeightfield_v1", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "convexHeightfield_tilePos", "Narrowphase_convexHeightfield_tilePos", "get$Narrowphase_convexHeightfield_tilePos", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "convexHeightfield_tempConvexShape", "Narrowphase_convexHeightfield_tempConvexShape", "get$Narrowphase_convexHeightfield_tempConvexShape", function() {
  var out, out0, out1, out2, t1, t2, out3;
  out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  out0 = new A.vec2(0, 0);
  out0.x = 0;
  out0.y = 0;
  out1 = new A.vec2(0, 0);
  out1.x = 0;
  out1.y = 0;
  out2 = new A.vec2(0, 0);
  out2.x = 0;
  out2.y = 0;
  t1 = H.setRuntimeTypeInfo([], [A.vec2]);
  t2 = H.setRuntimeTypeInfo([], [A.vec2]);
  out3 = new A.vec2(0, 0);
  out3.x = 0;
  out3.y = 0;
  out3 = new A.Convex(t1, t2, out3, [], null, null, null, null, null, null, null, null);
  out3.Shape$1(8);
  out3.init$2([out, out0, out1, out2], null);
  return out3;
});
Isolate.$lazy($, "qi", "Equation_qi", "get$Equation_qi", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "qj", "Equation_qj", "get$Equation_qj", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "iMfi", "Equation_iMfi", "get$Equation_iMfi", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "iMfj", "Equation_iMfj", "get$Equation_iMfj", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "addToWlambda_temp", "Equation_addToWlambda_temp", "get$Equation_addToWlambda_temp", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "addToWlambda_Gi", "Equation_addToWlambda_Gi", "get$Equation_addToWlambda_Gi", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "addToWlambda_Gj", "Equation_addToWlambda_Gj", "get$Equation_addToWlambda_Gj", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "addToWlambda_ri", "Equation_addToWlambda_ri", "get$Equation_addToWlambda_ri", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "addToWlambda_rj", "Equation_addToWlambda_rj", "get$Equation_addToWlambda_rj", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "addToWlambda_Mdiag", "Equation_addToWlambda_Mdiag", "get$Equation_addToWlambda_Mdiag", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "shapeAABB", "Body_shapeAABB", "get$Body_shapeAABB", function() {
  return A.AABB$(null, null);
});
Isolate.$lazy($, "tmp", "Body_tmp", "get$Body_tmp", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "sleepEvent", "Body_sleepEvent", "get$Body_sleepEvent", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["type", "sleep"], null, null);
});
Isolate.$lazy($, "wakeUpEvent", "Body_wakeUpEvent", "get$Body_wakeUpEvent", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["type", "wakeup"], null, null);
});
Isolate.$lazy($, "updateCenterOfMass_centroid", "Convex_updateCenterOfMass_centroid", "get$Convex_updateCenterOfMass_centroid", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "updateCenterOfMass_centroid_times_mass", "Convex_updateCenterOfMass_centroid_times_mass", "get$Convex_updateCenterOfMass_centroid_times_mass", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "updateCenterOfMass_a", "Convex_updateCenterOfMass_a", "get$Convex_updateCenterOfMass_a", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "updateCenterOfMass_b", "Convex_updateCenterOfMass_b", "get$Convex_updateCenterOfMass_b", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "updateCenterOfMass_c", "Convex_updateCenterOfMass_c", "get$Convex_updateCenterOfMass_c", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "updateCenterOfMass_ac", "Convex_updateCenterOfMass_ac", "get$Convex_updateCenterOfMass_ac", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "updateCenterOfMass_ca", "Convex_updateCenterOfMass_ca", "get$Convex_updateCenterOfMass_ca", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "updateCenterOfMass_cb", "Convex_updateCenterOfMass_cb", "get$Convex_updateCenterOfMass_cb", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "updateCenterOfMass_n", "Convex_updateCenterOfMass_n", "get$Convex_updateCenterOfMass_n", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "step_fhMinv", "World_step_fhMinv", "get$World_step_fhMinv", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "step_velodt", "World_step_velodt", "get$World_step_velodt", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "step_mg", "World_step_mg", "get$World_step_mg", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "xiw", "World_xiw", "get$World_xiw", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "xjw", "World_xjw", "get$World_xjw", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "interpvelo", "World_interpvelo", "get$World_interpvelo", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "endOverlaps", "World_endOverlaps", "get$World_endOverlaps", function() {
  return H.setRuntimeTypeInfo([], [A.OverlapKeeperRecord]);
});
Isolate.$lazy($, "ib_fhMinv", "World_ib_fhMinv", "get$World_ib_fhMinv", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "ib_velodt", "World_ib_velodt", "get$World_ib_velodt", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "hitTest_tmp1", "World_hitTest_tmp1", "get$World_hitTest_tmp1", function() {
  var out = new A.vec2(0, 0);
  out.x = 0;
  out.y = 0;
  return out;
});
Isolate.$lazy($, "hitTest_zero", "World_hitTest_zero", "get$World_hitTest_zero", function() {
  return A.vec2_fromValues(0, 0);
});
Isolate.$lazy($, "hitTest_tmp2", "World_hitTest_tmp2", "get$World_hitTest_tmp2", function() {
  return A.vec2_fromValues(0, 0);
});

// Native classes

init.metadata = [P.Function,
C.TypeVariable_eTF,
R.GameObject,
C.TypeVariable_2Uu,
R.Body,
C.TypeVariable_0,
{func: "void__num", void: true, args: [P.num]},
"angle",
{func: "void__num_num", void: true, args: [P.num, P.num]},
"x",
"y",
{func: "void___Path2D", void: true, opt: [W.Path2D]},
,
"path",
{func: "void___String", void: true, opt: [P.String]},
"nonzero",
"winding",
{func: "void_", void: true},
{func: "Future___dynamic_dynamic", ret: [P.Future, W.MediaStream], named: {audio: null, video: null}},
false,
{func: "bool__Node", ret: P.bool, args: [W.Node0]},
{func: "double_", ret: P.$double},
{func: "void__HtmlElement_int", void: true, args: [W.HtmlElement, P.$int]},
"element",
"before",
{func: "int__RequestAnimationFrameCallback", ret: P.$int, args: [{func: "void__num", void: true, args: [P.num]}]},
"callback",
{func: "void__num__num_num", void: true, args: [P.num], opt: [P.num, P.num]},
"when",
"grainOffset",
"grainDuration",
"width",
{func: "void__UniformLocation_num", void: true, args: [P.UniformLocation, P.num]},
"location",
{func: "void__UniformLocation_int", void: true, args: [P.UniformLocation, P.$int]},
{func: "void__UniformLocation_num_num", void: true, args: [P.UniformLocation, P.num, P.num]},
{func: "void__UniformLocation_Float32List", void: true, args: [P.UniformLocation, P.Float32List]},
"v",
{func: "void__UniformLocation_int_int", void: true, args: [P.UniformLocation, P.$int, P.$int]},
{func: "void__UniformLocation_num_num_num", void: true, args: [P.UniformLocation, P.num, P.num, P.num]},
"z",
{func: "void__UniformLocation_int_int_int", void: true, args: [P.UniformLocation, P.$int, P.$int, P.$int]},
{func: "void__UniformLocation_num_num_num_num", void: true, args: [P.UniformLocation, P.num, P.num, P.num, P.num]},
"w",
{func: "void__UniformLocation_int_int_int_int", void: true, args: [P.UniformLocation, P.$int, P.$int, P.$int, P.$int]},
{func: "void__UniformLocation_bool_Float32List", void: true, args: [P.UniformLocation, P.bool, P.Float32List]},
"transpose",
"array",
{func: "dynamic___num_num_num", opt: [P.num, P.num, P.num]},
0,
"radius",
{func: "dynamic___num_num_num_num", opt: [P.num, P.num, P.num, P.num]},
"height",
{func: "Type_", ret: P.Type},
{func: "args0"},
{func: "dynamic__List", args: [P.List]},
{func: "dynamic___num_num", opt: [P.num, P.num]},
"points",
{func: "Shape_", ret: M.Shape},
{func: "DisplayInterface_", ret: M.DisplayInterface},
{func: "DisplayObject_", ret: M.DisplayObject},
{func: "DisplayObjectContainer_", ret: M.DisplayObjectContainer},
{func: "dynamic__List0", args: [[P.List, M.Texture]]},
"textures",
{func: "MovieClip__List", ret: M.MovieClip, args: [[P.List, P.String]]},
"frames",
"images",
{func: "dynamic__Texture", args: [M.Texture]},
"texture",
{func: "Sprite__String", ret: M.Sprite0, args: [P.String]},
"frameId",
{func: "Sprite__String__bool_scaleModes", ret: M.Sprite0, args: [P.String], opt: [P.bool, M.scaleModes]},
"imageId",
"crossorigin",
"scaleMode",
{func: "dynamic___RenderTexture", opt: [M.RenderTexture0]},
"textureThing",
{func: "dynamic___int_bool", opt: [P.$int, P.bool]},
true,
"backgroundColor",
"interactive",
{func: "dynamic__Texture_List", args: [M.Texture, P.List]},
{func: "dynamic__String_BoneData", args: [P.String, M.BoneData]},
"name",
"parent",
"boneData",
{func: "dynamic__BoneData_Bone", args: [M.BoneData, M.Bone]},
"data",
{func: "dynamic__SlotData_Skeleton_Bone", args: [M.SlotData, M.Skeleton, M.Bone]},
"skeleton",
"bone",
{func: "dynamic__String", args: [P.String]},
{func: "dynamic__String_List_num", args: [P.String, [P.List, M.Timeline], P.num]},
"timelines",
"duration",
{func: "int__List_num_int", ret: P.$int, args: [[P.List, P.num], P.num, P.$int]},
"values",
"target",
"step",
{func: "dynamic__int", args: [P.$int]},
"frameCount",
{func: "Timeline_", ret: M.Timeline},
{func: "args1", args: [null]},
{func: "dynamic__SkeletonData", args: [M.SkeletonData]},
"skeletonData",
{func: "Attachment_", ret: M.Attachment},
{func: "dynamic___String", opt: [P.String]},
{func: "Entry_", ret: M.Entry},
{func: "dynamic__AnimationStateData", args: [M.AnimationStateData]},
"stateData",
{func: "dynamic___AtlasAttachmentLoader", opt: [M.AtlasAttachmentLoader]},
"attachmentLoader",
{func: "dynamic__Timeline_int_Map", args: [M.Timeline, P.$int, P.Map]},
"timeline",
"frameIndex",
"valueMap",
{func: "dynamic__String_int", args: [P.String, P.$int]},
"hexString",
"colorIndex",
{func: "dynamic__String_dynamic", args: [P.String, null]},
"atlasText",
"textureLoader",
{func: "AtlasPage_", ret: M.AtlasPage},
{func: "AtlasRegion_", ret: M.AtlasRegion},
"text",
{func: "dynamic__Atlas", args: [M.Atlas]},
"atlas",
"url",
{func: "dynamic__Texture__num_num", args: [M.Texture], opt: [P.num, P.num]},
100,
{func: "InteractionData_", ret: M.InteractionData},
{func: "dynamic__Stage", args: [M.Stage0]},
"stage",
{func: "dynamic__List__bool", args: [[P.List, P.String]], opt: [P.bool]},
"assetURLs",
{func: "dynamic__String_bool", args: [P.String, P.bool]},
{func: "Loader__String_String_bool", ret: M.Loader0, args: [P.String, P.String, P.bool]},
"type",
"value",
{func: "GraphicsData_", ret: M.GraphicsData},
{func: "dynamic__Graphics_CanvasRenderingContext2D", args: [M.Graphics0, W.CanvasRenderingContext2D]},
"graphics",
"context",
{func: "dynamic___num_num_CanvasElement_bool_bool", opt: [P.num, P.num, W.CanvasElement, P.bool, P.bool]},
800,
600,
"view",
"transparent",
"antialias",
{func: "dynamic__num_num", args: [P.num, P.num]},
{func: "CanvasImageSource__Sprite_int", ret: W.CanvasImageSource, args: [M.Sprite0, P.$int]},
"sprite",
"color",
{func: "dynamic__Texture_int_CanvasElement", args: [M.Texture, P.$int, W.CanvasElement]},
"canvas",
{func: "args3", args: [null, null, null]},
{func: "int__dynamic", ret: P.$int, args: [null]},
{func: "MaskManager_", ret: M.MaskManager},
{func: "RenderSession_", ret: M.RenderSession},
{func: "dynamic__RenderingContext", args: [P.RenderingContext]},
"gl",
{func: "Shader_", ret: M.Shader},
{func: "dynamic__RenderingContext_int_int__dynamic", args: [P.RenderingContext, P.$int, P.$int], opt: [null]},
C.scaleModes_0,
{func: "dynamic__RenderingContext_bool", args: [P.RenderingContext, P.bool]},
{func: "dynamic__Graphics_RenderSession", args: [M.Graphics0, M.RenderSession]},
"renderSession",
{func: "dynamic__Graphics_RenderingContext", args: [M.Graphics0, P.RenderingContext]},
{func: "WebGLGraphicsData__WebGLGraphicsData_int", ret: M.WebGLGraphicsData, args: [M.WebGLGraphicsData, P.$int]},
"webGL",
{func: "dynamic__GraphicsData_WebGLGraphicsData", args: [M.GraphicsData, M.WebGLGraphicsData]},
"graphicsData",
"webGLData",
{func: "List__num_num_num_num_num_num", ret: [P.List, P.num], args: [P.num, P.num, P.num, P.num, P.num, P.num]},
"fromX",
"fromY",
"cpX",
"cpY",
"toX",
"toY",
{func: "dynamic__RenderingContext_List", args: [P.RenderingContext, [P.List, P.String]]},
"shaderSrc",
{func: "dynamic__RenderingContext_List_int", args: [P.RenderingContext, [P.List, P.String], P.$int]},
"shaderType",
{func: "dynamic__RenderingContext_List_List", args: [P.RenderingContext, [P.List, P.String], [P.List, P.String]]},
"vertexSrc",
"fragmentSrc",
{func: "dynamic___num_num_CanvasElement_bool_bool_bool", opt: [P.num, P.num, W.CanvasElement, P.bool, P.bool, P.bool]},
"preserveDrawingBuffer",
{func: "void__RenderingContext", void: true, args: [P.RenderingContext]},
{func: "dynamic__BaseTexture_RenderingContext", args: [M.BaseTexture, P.RenderingContext]},
{func: "ChartData_", ret: M.ChartData},
{func: "Char_", ret: M.Char},
{func: "dynamic__String__TextStyle", args: [P.String], opt: [M.TextStyle0]},
"style",
{func: "dynamic___String_String_String_String_num_num", named: {align: P.String, fill: P.String, font: P.String, stroke: P.String, strokeThickness: P.num, tint: P.num}},
"black",
"bold 20pt Arial",
"left",
16777215,
"fill",
"font",
"align",
"stroke",
"strokeThickness",
"tint",
{func: "dynamic__String_TextStyle", args: [P.String, M.TextStyle0]},
{func: "dynamic___dynamic_scaleModes", opt: [null, M.scaleModes]},
"source",
{func: "BaseTexture__String_bool_scaleModes", ret: M.BaseTexture, args: [P.String, P.bool, M.scaleModes]},
"imageUrl",
{func: "BaseTexture__CanvasElement_scaleModes", ret: M.BaseTexture, args: [W.CanvasElement, M.scaleModes]},
{func: "dynamic___num_num_Renderer_scaleModes", opt: [P.num, P.num, M.Renderer, M.scaleModes]},
"renderer",
{func: "dynamic__BaseTexture__Rectangle", args: [M.BaseTexture], opt: [M.Rectangle0]},
"baseTexture",
"frame",
{func: "Texture__String__bool_scaleModes", ret: M.Texture, args: [P.String], opt: [P.bool, M.scaleModes]},
{func: "Texture__String", ret: M.Texture, args: [P.String]},
{func: "Texture__CanvasElement__scaleModes", ret: M.Texture, args: [W.CanvasElement], opt: [M.scaleModes]},
{func: "void__dynamic_dynamic", void: true, args: [null, null]},
"id",
{func: "Texture__dynamic", ret: M.Texture, args: [null]},
{func: "TextureUvs_", ret: M.TextureUvs},
{func: "Renderer___num_num_dynamic_dynamic_dynamic", ret: M.Renderer, opt: [P.num, P.num, null, null, null]},
{func: "dynamic___dynamic_dynamic_String", named: {content: null, loader: null, type: P.String}},
"content",
"loader",
{func: "EventTarget_", ret: M.EventTarget0},
{func: "List__dynamic", ret: [P.List, P.num], args: [null]},
"p",
{func: "bool__dynamic_dynamic_dynamic_dynamic_dynamic_dynamic_dynamic_dynamic", ret: P.bool, args: [null, null, null, null, null, null, null, null]},
"px",
"py",
"ax",
"ay",
"bx",
"by",
"cx",
"cy",
{func: "bool__num_num_num_num_num_num_bool", ret: P.bool, args: [P.num, P.num, P.num, P.num, P.num, P.num, P.bool]},
"sign",
{func: "List__int", ret: [P.List, P.num], args: [P.$int]},
"hex",
{func: "int__List", ret: P.$int, args: [[P.List, P.num]]},
"rgb",
{func: "HttpRequest_", ret: W.HttpRequest},
{func: "bool_", ret: P.bool},
{func: "int__int", ret: P.$int, args: [P.$int]},
"number",
{func: "dynamic__Game_Sprite_String_FrameData__List_num_bool", args: [R.Game, R.Sprite, P.String, R.FrameData], opt: [[P.List, P.num], P.num, P.bool]},
60,
"game",
"_parent",
"_frameData",
"_frames",
"frameRate",
"loop",
{func: "List___String_int_int_String_dynamic", ret: [P.List, P.String], opt: [P.String, P.$int, P.$int, P.String, null]},
"",
"prefix",
"start",
"stop",
"suffix",
"zeroPad",
{func: "dynamic__AnimationInterface", args: [R.AnimationInterface]},
{func: "AnimationParser_", ret: R.AnimationParser},
{func: "FrameData__Game_String_num_num__int_num_num", ret: R.FrameData, args: [R.Game, P.String, P.num, P.num], opt: [P.$int, P.num, P.num]},
-1,
"key",
"frameWidth",
"frameHeight",
"frameMax",
"margin",
"spacing",
{func: "FrameData__dynamic_dynamic_dynamic", ret: R.FrameData, args: [null, null, null]},
"json",
"cacheKey",
{func: "FrameData__Game_Document_String", ret: R.FrameData, args: [R.Game, W.Document, P.String]},
"xml",
{func: "dynamic__int_num_num_num_num_String_String", args: [P.$int, P.num, P.num, P.num, P.num, P.String, P.String]},
"index",
"uuid",
{func: "AtLimit_", ret: R.AtLimit},
{func: "dynamic__Game_dynamic_dynamic_dynamic_dynamic_dynamic", args: [R.Game, null, null, null, null, null]},
{func: "dynamic__Game__Map_List", args: [R.Game], opt: [P.Map, [P.List, P.String]]},
"uniforms",
{func: "dynamic__ScaleManager_num_num", args: [R.ScaleManager, P.num, P.num]},
"manager",
{func: "dynamic__FlexGrid_Point_Rectangle_Point", args: [R.FlexGrid, R.Point, R.Rectangle1, R.Point]},
"position",
"bounds",
"scale",
{func: "dynamic___num_num_int_String_State_bool_bool_Map", opt: [P.num, P.num, P.$int, P.String, R.State, P.bool, P.bool, P.Map]},
"state",
"physicsConfig",
{func: "dynamic__Game__Group_String_bool_bool_num", args: [R.Game], opt: [R.Group, P.String, P.bool, P.bool, P.num]},
"group",
"addToStage",
"enableBody",
"physicsBodyType",
{func: "dynamic__Game_PluginManager", args: [R.Game, R.PluginManager]},
{func: "dynamic__Game", args: [R.Game]},
{func: "dynamic__Game_num_num", args: [R.Game, P.num, P.num]},
{func: "dynamic__Signal_Function__bool_int", args: [R.Signal, P.Function], opt: [P.bool, P.$int]},
"_signal",
"_listener",
"_isOnce",
"_priority",
{func: "dynamic__Game__State", args: [R.Game], opt: [R.State]},
"pendingState",
{func: "dynamic__Game_String_int_int", args: [R.Game, P.String, P.$int, P.$int]},
{func: "dynamic__dynamic__num_num_String_String_int", args: [null], opt: [P.num, P.num, P.String, P.String, P.$int]},
32,
"size",
{func: "dynamic__Game__num_num_String_Function_dynamic_dynamic_dynamic_dynamic", args: [R.Game], opt: [P.num, P.num, P.String, P.Function, null, null, null, null]},
"overFrame",
"outFrame",
"downFrame",
"upFrame",
{func: "dynamic__GameObject", args: [R.GameObject]},
{func: "CoreInterfact_", ret: R.CoreInterfact},
{func: "SpriteInterface_", ret: R.SpriteInterface},
{func: "AnimationInterface_", ret: R.AnimationInterface},
{func: "GameObject_", ret: R.GameObject},
{func: "dynamic__Game__num_num", args: [R.Game], opt: [P.num, P.num]},
{func: "dynamic__Game__int_int_dynamic_dynamic", args: [R.Game], opt: [P.$int, P.$int, null, null]},
{func: "dynamic__Game_num_num_String_num", args: [R.Game, P.num, P.num, P.String, P.num]},
{func: "dynamic__Game_num_num__String_scaleModes", args: [R.Game, P.num, P.num], opt: [P.String, M.scaleModes]},
{func: "dynamic__Game_String_num_num_String__num_int_int_int_int", args: [R.Game, P.String, P.num, P.num, P.String], opt: [P.num, P.$int, P.$int, P.$int, P.$int]},
"characterWidth",
"characterHeight",
"chars",
"charsPerRow",
"xSpacing",
"ySpacing",
"xOffset",
"yOffset",
{func: "dynamic__Game__num_num_dynamic_dynamic_List", args: [R.Game], opt: [P.num, P.num, null, null, P.List]},
{func: "dynamic__Game_dynamic_dynamic_dynamic", args: [R.Game, null, null, null]},
{func: "dynamic__Game__num_num_String_TextStyle", args: [R.Game], opt: [P.num, P.num, P.String, R.TextStyle]},
{func: "dynamic__Game__num_num_num_num_dynamic_dynamic", args: [R.Game], opt: [P.num, P.num, P.num, P.num, null, null]},
256,
"_diameter",
{func: "bool__Circle_Rectangle", ret: P.bool, args: [R.Circle0, R.Rectangle1]},
"c",
"r",
{func: "bool__Circle_Circle", ret: P.bool, args: [R.Circle0, R.Circle0]},
"a",
"b",
{func: "dynamic__num_num_num_num", args: [P.num, P.num, P.num, P.num]},
"x1",
"y1",
"x2",
"y2",
{func: "Point__Point_Point_Point_Point__bool_Point", ret: R.Point, args: [R.Point, R.Point, R.Point, R.Point], opt: [P.bool, R.Point]},
"e",
"f",
"asSegment",
"result",
{func: "Point__Point_Point_num__Point", ret: R.Point, args: [R.Point, R.Point, P.num], opt: [R.Point]},
"out",
{func: "Point__Point_Point__Point", ret: R.Point, args: [R.Point, R.Point], opt: [R.Point]},
{func: "Point__List__Point", ret: R.Point, args: [[P.List, R.Point]], opt: [R.Point]},
{func: "dynamic__List1", args: [[P.List, R.Point]]},
"_points",
{func: "Rectangle__dynamic", ret: R.Rectangle1, args: [null]},
{func: "dynamic__Game_int", args: [R.Game, P.$int]},
"keycode",
{func: "CursorKeys_", ret: R.CursorKeys},
{func: "LoaderParser_", ret: R.LoaderParser},
{func: "dynamic__Game_Document_String_int_int", args: [R.Game, W.Document, P.String, P.$int, P.$int]},
{func: "SinCosTable_", ret: R.SinCosTable},
{func: "num__num_num", ret: P.num, args: [P.num, P.num]},
"th",
"exp",
{func: "num__num", ret: P.num, args: [P.num]},
"val",
{func: "bool__num_num__num", ret: P.bool, args: [P.num, P.num], opt: [P.num]},
0.0001,
"epsilon",
{func: "int__num__num", ret: P.$int, args: [P.num], opt: [P.num]},
{func: "double__List", ret: P.$double, args: [[P.List, P.num]]},
"args",
{func: "int__num", ret: P.$int, args: [P.num]},
"n",
{func: "int__num_num__num", ret: P.$int, args: [P.num, P.num], opt: [P.num]},
"input",
"gap",
{func: "num__num_List__dynamic", ret: P.num, args: [P.num, [P.List, P.num]], opt: [null]},
"arr",
"sort",
{func: "int__num__int_int", ret: P.$int, args: [P.num], opt: [P.$int, P.$int]},
10,
"place",
"base",
{func: "num__num_num_num", ret: P.num, args: [P.num, P.num, P.num]},
"weight",
{func: "num__num_num_num_num", ret: P.num, args: [P.num, P.num, P.num, P.num]},
{func: "num__Point_Point", ret: P.num, args: [R.Point, R.Point]},
"point1",
"point2",
"angleRad",
"lat",
"lng",
{func: "bool___num", ret: P.bool, opt: [P.num]},
50,
"chance",
{func: "List__int_int", ret: [P.List, P.$int], args: [P.$int, P.$int]},
"min",
"max",
"amount",
{func: "int_", ret: P.$int},
{func: "bool__int", ret: P.bool, args: [P.$int]},
{func: "num__Iterable", ret: P.num, args: [[P.Iterable, P.num]]},
{func: "num__Iterable_args1", ret: P.num, args: [P.Iterable, {func: "args1", args: [null]}]},
"prop",
{func: "num__num__bool", ret: P.num, args: [P.num], opt: [P.bool]},
"radians",
{func: "num__List_num", ret: P.num, args: [[P.List, P.num], P.num]},
"k",
"p0",
"p1",
"t",
"i",
{func: "num__num_num_num_num_num", ret: P.num, args: [P.num, P.num, P.num, P.num, P.num]},
"p2",
"p3",
{func: "Object__List__int_int", ret: P.Object, args: [P.List], opt: [P.$int, P.$int]},
"objects",
"startIndex",
"length",
{func: "dynamic__int__num_num_num", args: [P.$int], opt: [P.num, P.num, P.num]},
1,
"sinAmplitude",
"cosAmplitude",
"frequency",
{func: "Object__DoubleLinkedQueue", ret: P.Object, args: [P.DoubleLinkedQueue]},
"stack",
{func: "List__List", ret: P.List, args: [P.List]},
{func: "num__num_num_num_num__num", ret: P.num, args: [P.num, P.num, P.num, P.num], opt: [P.num]},
2,
"power",
{func: "bool__num_num_num", ret: P.bool, args: [P.num, P.num, P.num]},
"tolerance",
"a1",
"a2",
"b1",
"b2",
{func: "num__num_num__num", ret: P.num, args: [P.num, P.num], opt: [P.num]},
"degrees",
{func: "Bounds_", ret: R.Bounds},
{func: "dynamic__num_num_num_num__int_int_int", args: [P.num, P.num, P.num, P.num], opt: [P.$int, P.$int, P.$int]},
"maxObjects",
"maxLevels",
"level",
"seeds",
{func: "dynamic__Game__num_num_int", args: [R.Game], opt: [P.num, P.num, P.$int]},
"maxParticles",
{func: "dynamic___bool_bool_bool_bool", named: {down: P.bool, left: P.bool, right: P.bool, up: P.bool}},
"up",
"down",
"right",
{func: "Body_", ret: R.Body},
{func: "dynamic__dynamic__Map", args: [null], opt: [P.Map]},
C.Map_empty,
"config",
{func: "dynamic__Game_String", args: [R.Game, P.String]},
{func: "Marker_", ret: R.Marker},
{func: "dynamic__Game_String__num_bool_bool", args: [R.Game, P.String], opt: [P.num, P.bool, P.bool]},
"volume",
"connect",
{func: "Canvas_", ret: R.Canvas},
{func: "CanvasElement___num_num_String", ret: W.CanvasElement, opt: [P.num, P.num, P.String]},
{func: "Point__CanvasElement__Point", ret: R.Point, args: [W.CanvasElement], opt: [R.Point]},
"point",
{func: "num__CanvasElement", ret: P.num, args: [W.CanvasElement]},
{func: "CanvasElement__CanvasElement__String", ret: W.CanvasElement, args: [W.CanvasElement], opt: [P.String]},
"rgb(0,0,0)",
"none",
{func: "CanvasElement__CanvasElement__dynamic_bool", ret: W.CanvasElement, args: [W.CanvasElement], opt: [null, P.bool]},
"overflowHidden",
{func: "CanvasRenderingContext2D__CanvasRenderingContext2D_num_num_num_num_num_num", ret: W.CanvasRenderingContext2D, args: [W.CanvasRenderingContext2D, P.num, P.num, P.num, P.num, P.num, P.num]},
"translateX",
"translateY",
"scaleX",
"scaleY",
"skewX",
"skewY",
{func: "CanvasRenderingContext2D__CanvasRenderingContext2D__bool", ret: W.CanvasRenderingContext2D, args: [W.CanvasRenderingContext2D], opt: [P.bool]},
{func: "CanvasElement__CanvasElement", ret: W.CanvasElement, args: [W.CanvasElement]},
{func: "dynamic__CanvasElement", args: [W.CanvasElement]},
{func: "dynamic__Game__bool", args: [R.Game], opt: [P.bool]},
"forceSetTimeOut",
{func: "dynamic__TilemapLayerData_int_num_num_num_num", args: [R.TilemapLayerData, P.$int, P.num, P.num, P.num, P.num]},
"layer",
{func: "TilemapData_", ret: R.TilemapData},
{func: "dynamic__Game__String_num_num_num_num", args: [R.Game], opt: [P.String, P.num, P.num, P.num, P.num]},
"tileWidth",
"tileHeight",
{func: "MapCache_", ret: R.MapCache},
{func: "TilemapLayerData_", ret: R.TilemapLayerData},
{func: "dynamic__Game__Tilemap_int_num_num", args: [R.Game], opt: [R.Tilemap, P.$int, P.num, P.num]},
"tilemap",
{func: "TilemapImageData_", ret: R.TilemapImageData},
{func: "TilemapParser_", ret: R.TilemapParser},
{func: "TilemapData__Game__String_num_num_num_num", ret: R.TilemapData, args: [R.Game], opt: [P.String, P.num, P.num, P.num, P.num]},
{func: "TilemapData__String_String__num_num", ret: R.TilemapData, args: [P.String, P.String], opt: [P.num, P.num]},
{func: "TilemapData___num_num_num_num", ret: R.TilemapData, opt: [P.num, P.num, P.num, P.num]},
{func: "TilemapData__Map", ret: R.TilemapData, args: [P.Map]},
{func: "dynamic__String_int__num_num_num_num_Map", args: [P.String, P.$int], opt: [P.num, P.num, P.num, P.num, P.Map]},
"firstgid",
"properties",
"autoDestroy",
{func: "dynamic__Timer_num_num_int_bool_Function_List", args: [R.Timer, P.num, P.num, P.$int, P.bool, P.Function, P.List]},
"timer",
"delay",
"tick",
"repeatCount",
{func: "Linears_", ret: R.Linears},
{func: "Quads_", ret: R.Quads},
{func: "Cubics_", ret: R.Cubics},
{func: "Quarts_", ret: R.Quarts},
{func: "Circs_", ret: R.Circs},
{func: "Sines_", ret: R.Sines},
{func: "Expos_", ret: R.Expos},
{func: "Backs_", ret: R.Backs},
{func: "Bounces_", ret: R.Bounces},
{func: "Elastics_", ret: R.Elastics},
{func: "Quints_", ret: R.Quints},
{func: "Easing_", ret: R.Easing},
{func: "dynamic__dynamic_Game__TweenManager", args: [null, R.Game], opt: [R.TweenManager]},
"_object",
"_manager",
{func: "Color_", ret: R.Color},
{func: "int__int_int_int_int", ret: P.$int, args: [P.$int, P.$int, P.$int, P.$int]},
"g",
{func: "Color__int__Color_bool_bool", ret: R.Color, args: [P.$int], opt: [R.Color, P.bool, P.bool]},
"rgba",
"hsl",
"hsv",
{func: "Color__int_Color", ret: R.Color, args: [P.$int, R.Color]},
{func: "Color__int_int_int__Color", ret: R.Color, args: [P.$int, P.$int, P.$int], opt: [R.Color]},
{func: "Color__double_double_double__Color", ret: R.Color, args: [P.$double, P.$double, P.$double], opt: [R.Color]},
"h",
"s",
"l",
{func: "Color__int_int_int_Color", ret: R.Color, args: [P.$int, P.$int, P.$int, R.Color]},
{func: "double__double_double_double", ret: P.$double, args: [P.$double, P.$double, P.$double]},
"q",
{func: "Color___int_int_int_int_double_double_double_double", ret: R.Color, opt: [P.$int, P.$int, P.$int, P.$int, P.$double, P.$double, P.$double, P.$double]},
255,
{func: "Color__Color", ret: R.Color, args: [R.Color]},
{func: "int__dynamic_dynamic_dynamic_dynamic", ret: P.$int, args: [null, null, null, null]},
{func: "int__dynamic_dynamic_dynamic", ret: P.$int, args: [null, null, null]},
{func: "String__int_int_int__int_String", ret: P.String, args: [P.$int, P.$int, P.$int], opt: [P.$int, P.String]},
"#",
{func: "int__String", ret: P.$int, args: [P.String]},
{func: "Color__String__Color", ret: R.Color, args: [P.String], opt: [R.Color]},
{func: "String__int", ret: P.String, args: [P.$int]},
{func: "List___double_double", ret: P.List, opt: [P.$double, P.$double]},
0.5,
{func: "int__dynamic_dynamic_dynamic_dynamic__int", ret: P.$int, args: [null, null, null, null], opt: [P.$int]},
"color1",
"color2",
"steps",
"currentStep",
"alpha",
{func: "num__dynamic_dynamic_dynamic_dynamic_dynamic_dynamic", ret: P.num, args: [null, null, null, null, null, null]},
{func: "num__dynamic_dynamic_dynamic_dynamic_dynamic_dynamic_dynamic_dynamic", ret: P.num, args: [null, null, null, null, null, null, null, null]},
"r1",
"g1",
"r2",
"g2",
{func: "int___int_int_int", ret: P.$int, opt: [P.$int, P.$int, P.$int]},
{func: "Color__int", ret: R.Color, args: [P.$int]},
{func: "String__dynamic", ret: P.String, args: [null]},
{func: "double__int", ret: P.$double, args: [P.$int]},
{func: "List__List0", ret: [P.List, P.List], args: [[P.List, P.List]]},
{func: "List__List_dynamic", ret: [P.List, P.List], args: [[P.List, P.List], null]},
"matrix",
"direction",
{func: "num__dynamic_num", ret: P.num, args: [null, P.num]},
"dimension",
"object",
"sender",
"closure",
"isolate",
"numberOfArguments",
"arg1",
"arg2",
"arg3",
"arg4",
{func: "InstanceMirror__Object", ret: P.InstanceMirror, args: [P.Object]},
"reflectee",
{func: "void__void_", void: true, args: [{func: "void_", void: true}]},
{func: "void__dynamic", void: true, args: [null]},
{func: "void__dynamic__StackTrace", void: true, args: [null], opt: [P.StackTrace]},
"error",
"stackTrace",
{func: "bool__dynamic_dynamic", ret: P.bool, args: [null, null]},
{func: "int__Comparable_Comparable", ret: P.$int, args: [P.Comparable, P.Comparable]},
{func: "bool__Object_Object", ret: P.bool, args: [P.Object, P.Object]},
{func: "int__Object", ret: P.$int, args: [P.Object]},
{func: "String__EventTarget", ret: P.String, args: [W.EventTarget]},
"captureThis",
"self",
"arguments",
"o",
{func: "Object__dynamic", ret: P.Object, args: [null]},
{func: "vec2__vec2_num_num", ret: A.vec2, args: [A.vec2, P.num, P.num]},
{func: "vec2__vec2_vec2_vec2", ret: A.vec2, args: [A.vec2, A.vec2, A.vec2]},
{func: "dynamic__Sprite", args: [R.Sprite]},
R.Game,
P.$int,
R.Point,
P.num,
P.bool,
R.CollisionInfo,
{func: "num_", ret: P.num},
{func: "dynamic__num", args: [P.num]},
{func: "dynamic__dynamic__String_bool", args: [null], opt: [P.String, P.bool]},
"rgba(0,255,0,0.4)",
"filled",
"speed",
{func: "dynamic__num_num__num_num", args: [P.num, P.num], opt: [P.num, P.num]},
"offsetX",
"offsetY",
{func: "dynamic__num_num__bool_bool", args: [P.num, P.num], opt: [P.bool, P.bool]},
{func: "dynamic__num_num_AABB", args: [P.num, P.num, E.AABB]},
"obj",
{func: "dynamic__num_num_AABB_Tile", args: [P.num, P.num, E.AABB, E.Tile1]},
{func: "dynamic__CanvasRenderingContext2D_num_num_String_bool", args: [W.CanvasRenderingContext2D, P.num, P.num, P.String, P.bool]},
{func: "dynamic__CanvasRenderingContext2D__String_bool", args: [W.CanvasRenderingContext2D], opt: [P.String, P.bool]},
{func: "dynamic__num_num_num_num_Circle_Tile", args: [P.num, P.num, P.num, P.num, E.Circle1, E.Tile1]},
"oH",
"oV",
{func: "dynamic__SpriteInterface__int_int_num", args: [R.SpriteInterface], opt: [P.$int, P.$int, P.num]},
L.InversePointProxy,
{func: "dynamic__bool", args: [P.bool]},
{func: "dynamic__dynamic__Function_Shape", args: [null], opt: [P.Function, A.Shape0]},
"resetDamping",
"resetMass",
{func: "dynamic__CollisionGroup", args: [L.CollisionGroup]},
P.String,
P.List,
{func: "GameObject_", ret: R.GameObject, typedef: R.Creator},
[P.List, 3],
R.Events,
R.Rectangle1,
[R.Signal, {func: "dynamic__bool_bool", args: [P.bool, P.bool], typedef: R.DestroyGroup}],
[P.List, M.DisplayInterface],
M.Point0,
M.Shape,
M.DisplayInterface,
{func: "void__InteractionData", void: true, args: [M.InteractionData], typedef: M.InteractionHandler},
[P.Map, P.$int, M.InteractionData],
M.Stage0,
M.Matrix,
M.Rectangle0,
M.Graphics0,
M.Sprite0,
M.FilterBlock,
[P.List, M.AbstractFilter],
{func: "dynamic__Sprite_bool", args: [R.Sprite, P.bool]},
{func: "dynamic__Map", args: [P.Map]},
"event",
{func: "Circle_", ret: M.Circle},
{func: "bool__num_num", ret: P.bool, args: [P.num, P.num]},
{func: "Rectangle_", ret: M.Rectangle0},
{func: "Ellipse_", ret: M.Ellipse},
P.$double,
P.Float32List,
{func: "Float32List__bool", ret: P.Float32List, args: [P.bool]},
P.Object,
[P.List, M.Point0],
{func: "Stage_", ret: M.Stage0},
{func: "Matrix_", ret: M.Matrix},
{func: "Graphics_", ret: M.Graphics0},
{func: "dynamic__Graphics", args: [M.Graphics0]},
{func: "List_", ret: [P.List, M.AbstractFilter]},
{func: "dynamic__List2", args: [[P.List, M.AbstractFilter]]},
{func: "Rectangle___Matrix", ret: M.Rectangle0, opt: [M.Matrix]},
{func: "RenderTexture__Renderer", ret: M.RenderTexture0, args: [M.Renderer]},
{func: "dynamic__RenderSession", args: [M.RenderSession]},
{func: "void__RenderSession", void: true, args: [M.RenderSession]},
{func: "DisplayInterface__DisplayInterface", ret: M.DisplayInterface, args: [M.DisplayInterface]},
"child",
{func: "DisplayInterface__DisplayInterface_int", ret: M.DisplayInterface, args: [M.DisplayInterface, P.$int]},
{func: "bool__DisplayInterface_DisplayInterface", ret: P.bool, args: [M.DisplayInterface, M.DisplayInterface]},
"child2",
{func: "DisplayInterface__int", ret: M.DisplayInterface, args: [P.$int]},
{func: "List___int_int", ret: [P.List, M.DisplayInterface], opt: [P.$int, P.$int]},
"begin",
"end",
{func: "void__Stage", void: true, args: [M.Stage0]},
M.DisplayObject,
[P.List, M.Texture],
M.Texture,
M.TextureUvs,
W.CanvasImageSource,
M.CanvasBuffer,
M.BlendModes,
"frameNumber",
{func: "void__Texture", void: true, args: [M.Texture]},
{func: "dynamic__PixiEvent", args: [M.PixiEvent]},
M.DisplayObjectContainer,
M.RenderTexture0,
M.WebGLFastSpriteBatch,
[P.List, P.num],
M.InteractionManager,
"domElement",
{func: "void__int", void: true, args: [P.$int]},
{func: "Point_", ret: M.Point0},
P.Uint16List,
P.Buffer,
M.Strip,
M.BoneData,
M.Bone,
{func: "dynamic__bool_bool", args: [P.bool, P.bool]},
"flipX",
"flipY",
M.SlotData,
M.Skeleton,
[P.Map, P.String, M.Sprite0],
M.Attachment,
"attachment",
"time",
[P.Map, P.String, M.Attachment],
{func: "dynamic__int_String_dynamic", args: [P.$int, P.String, null]},
"slotIndex",
{func: "dynamic__int_String", args: [P.$int, P.String]},
{func: "dynamic__Skeleton_Skin", args: [M.Skeleton, M.Skin]},
"oldSkin",
[P.List, M.Timeline],
{func: "dynamic__Skeleton_num_bool", args: [M.Skeleton, P.num, P.bool]},
{func: "dynamic__Skeleton_num_bool_num", args: [M.Skeleton, P.num, P.bool, P.num]},
{func: "dynamic__int_num_num_num_num", args: [P.$int, P.num, P.num, P.num, P.num]},
"cx1",
"cy1",
"cx2",
"cy2",
{func: "num__int_num", ret: P.num, args: [P.$int, P.num]},
"percent",
M.Curves,
[P.List, P.$int],
{func: "dynamic__int_num_num__dynamic_dynamic_dynamic", args: [P.$int, P.num, P.num], opt: [null, null, null]},
{func: "dynamic__Skeleton_num_num", args: [M.Skeleton, P.num, P.num]},
M.Timeline,
{func: "dynamic__int_dynamic_dynamic__dynamic_dynamic_dynamic", args: [P.$int, null, null], opt: [null, null, null]},
{func: "dynamic__int_dynamic_String__dynamic_dynamic_dynamic", args: [P.$int, null, P.String], opt: [null, null, null]},
"attachmentName",
[P.List, M.BoneData],
[P.List, M.SlotData],
[P.List, M.Animation0],
M.Skin,
{func: "BoneData__String", ret: M.BoneData, args: [P.String]},
"boneName",
{func: "SlotData__String", ret: M.SlotData, args: [P.String]},
"slotName",
{func: "Skin__String", ret: M.Skin, args: [P.String]},
"skinName",
{func: "Animation__String", ret: M.Animation0, args: [P.String]},
"animationName",
M.SkeletonData,
[P.List, M.Bone],
[P.List, M.Slot],
{func: "Bone_", ret: M.Bone},
{func: "Bone__String", ret: M.Bone, args: [P.String]},
{func: "Slot__String", ret: M.Slot, args: [P.String]},
{func: "dynamic__Skin", args: [M.Skin]},
"newSkin",
{func: "dynamic__String_String", args: [P.String, P.String]},
{func: "dynamic__int_dynamic", args: [P.$int, null]},
"delta",
M.AtlasRegion,
{func: "dynamic__num_num_num_num_bool", args: [P.num, P.num, P.num, P.num, P.bool]},
"u",
"u2",
"v2",
"rotate",
{func: "dynamic__num_num_Bone_dynamic", args: [P.num, P.num, M.Bone, null]},
"vertices",
P.Map,
{func: "dynamic__String_String_num", args: [P.String, P.String, P.num]},
"fromName",
"toName",
{func: "dynamic__Animation_Animation_num", args: [M.Animation0, M.Animation0, P.num]},
"from",
"to",
{func: "dynamic__Animation_Animation", args: [M.Animation0, M.Animation0]},
M.Animation0,
M.AnimationStateData,
[P.List, M.Entry],
{func: "dynamic__Skeleton", args: [M.Skeleton]},
{func: "dynamic__Animation__bool", args: [M.Animation0], opt: [P.bool]},
"animation",
{func: "dynamic__String__bool_num", args: [P.String], opt: [P.bool, P.num]},
{func: "dynamic__Animation__bool_num", args: [M.Animation0], opt: [P.bool, P.num]},
M.AtlasAttachmentLoader,
"root",
{func: "dynamic__Skin_String_Map", args: [M.Skin, P.String, P.Map]},
"skin",
"map",
{func: "dynamic__String_Map_SkeletonData", args: [P.String, P.Map, M.SkeletonData]},
[P.List, M.AtlasPage],
[P.List, M.AtlasRegion],
{func: "dynamic__AtlasPage", args: [M.AtlasPage]},
"page",
M.AtlasPage,
{func: "String_", ret: P.String},
{func: "int__List0", ret: P.$int, args: [P.List]},
"tuple",
P.RegExp,
M.Atlas,
{func: "dynamic__Skin_String_String", args: [M.Skin, P.String, P.String]},
M.AnimationState,
[P.List, M.DisplayObjectContainer],
P.DateTime,
{func: "Sprite__Slot_AtlasRegion", ret: M.Sprite0, args: [M.Slot, M.AtlasRegion]},
"slot",
"descriptor",
W.CanvasPattern,
"forcePowerOfTwo",
{func: "Texture_", ret: M.Texture},
M.AbstractFilter,
M.BlurXFilter,
M.BlurYFilter,
{func: "List_0", ret: [P.List, P.num]},
{func: "dynamic__Point", args: [M.Point0]},
M.FilterTexture,
W.Event,
{func: "Point__DisplayObject", ret: M.Point0, args: [M.DisplayObject]},
"displayObject",
M.InteractionData,
[P.List, M.InteractionData],
W.CanvasElement,
M.Renderer,
{func: "void__DisplayObjectContainer_DisplayObjectContainer", void: true, args: [M.DisplayObjectContainer, M.DisplayObjectContainer]},
"iParent",
{func: "void__Renderer", void: true, args: [M.Renderer]},
{func: "void__Element", void: true, args: [W.Element]},
{func: "dynamic__MouseEvent", args: [W.MouseEvent]},
{func: "void__MouseEvent", void: true, args: [W.MouseEvent]},
{func: "bool__DisplayObjectContainer_InteractionData", ret: P.bool, args: [M.DisplayObjectContainer, M.InteractionData]},
"item",
"interactionData",
[P.List, P.String],
[P.Map, P.String, [P.List, {func: "void__PixiEvent", void: true, args: [M.PixiEvent], typedef: M.EventFunc}]],
"str",
M.EventTarget0,
"evt",
W.HttpRequest,
M.BaseTexture,
M.Loader0,
"textureName",
[P.List, M.GraphicsData],
M.GraphicsData,
[P.Map, P.RenderingContext, M.WebGLGraphicsData],
{func: "Graphics___num_num_num", ret: M.Graphics0, opt: [P.num, P.num, P.num]},
"lineWidth",
{func: "Graphics__num_num", ret: M.Graphics0, args: [P.num, P.num]},
{func: "Graphics__num_num_num_num", ret: M.Graphics0, args: [P.num, P.num, P.num, P.num]},
{func: "Graphics__num_num_num_num_num_num", ret: M.Graphics0, args: [P.num, P.num, P.num, P.num, P.num, P.num]},
"cpX2",
"cpY2",
{func: "Graphics__num_num_num_num_num", ret: M.Graphics0, args: [P.num, P.num, P.num, P.num, P.num]},
{func: "Graphics__num_num_num_num_num__bool", ret: M.Graphics0, args: [P.num, P.num, P.num, P.num, P.num], opt: [P.bool]},
"startAngle",
"endAngle",
"anticlockwise",
{func: "Graphics__List", ret: M.Graphics0, args: [[P.List, P.num]]},
{func: "Graphics___num_num", ret: M.Graphics0, opt: [P.num, P.num]},
{func: "Graphics__num_num_num", ret: M.Graphics0, args: [P.num, P.num, P.num]},
{func: "Graphics__dynamic_dynamic_dynamic_dynamic", ret: M.Graphics0, args: [null, null, null, null]},
{func: "Texture___Renderer", ret: M.Texture, opt: [M.Renderer]},
W.CanvasRenderingContext2D,
P.RenderingContext,
M.WebGLShaderManager,
M.WebGLSpriteBatch,
M.MaskManager,
M.WebGLFilterManager,
M.WebGLStencilManager,
M.WebGLBlendModeManager,
M.RenderSession,
{func: "dynamic__DisplayInterface__CanvasRenderingContext2D_dynamic", args: [M.DisplayInterface], opt: [W.CanvasRenderingContext2D, null]},
"buffer",
"strip",
{func: "dynamic__dynamic__dynamic", args: [null], opt: [null]},
"maskData",
{func: "dynamic__dynamic__RenderSession", args: [null], opt: [M.RenderSession]},
M.scaleModes,
P.Program,
P.UniformLocation,
M.Shader,
"uniform",
P.Framebuffer,
P.Renderbuffer,
{func: "bool__BlendModes", ret: P.bool, args: [M.BlendModes]},
"blendMode",
{func: "dynamic__SpriteBatch_RenderSession", args: [M.SpriteBatch0, M.RenderSession]},
"spriteBatch",
{func: "dynamic__SpriteBatch", args: [M.SpriteBatch0]},
{func: "dynamic__Sprite0", args: [M.Sprite0]},
{func: "dynamic__BlendModes", args: [M.BlendModes]},
[P.List, M.FilterBlock],
[P.List, M.FilterTexture],
M.PixiShader,
{func: "dynamic__RenderSession_Framebuffer", args: [M.RenderSession, P.Framebuffer]},
{func: "dynamic__FilterBlock", args: [M.FilterBlock]},
"filterBlock",
{func: "dynamic__AbstractFilter_Rectangle_num_num", args: [M.AbstractFilter, M.Rectangle0, P.num, P.num]},
"filter",
"filterArea",
[P.List, M.WebGLGraphicsData],
"n1",
"n2",
"perc",
{func: "dynamic__Graphics__RenderSession", args: [M.Graphics0], opt: [M.RenderSession]},
[P.Map, P.$int, P.bool],
M.PrimitiveShader,
M.PixiFastShader,
M.ComplexPrimitiveShader,
M.StripShader,
{func: "dynamic__List3", args: [[P.List, P.$int]]},
"attribs",
"shader",
[P.List, M.BaseTexture],
[P.List, M.BlendModes],
{func: "dynamic__TilingSprite", args: [M.TilingSprite]},
"tilingSprite",
{func: "dynamic__BaseTexture_int_int", args: [M.BaseTexture, P.$int, P.$int]},
{func: "dynamic__Graphics_WebGLGraphicsData_RenderSession", args: [M.Graphics0, M.WebGLGraphicsData, M.RenderSession]},
{func: "dynamic__DisplayInterface__Point_dynamic", args: [M.DisplayInterface], opt: [M.Point0, null]},
"projection",
M.TextStyle0,
{func: "TextStyle_", ret: M.TextStyle0},
{func: "dynamic__TextStyle", args: [M.TextStyle0]},
{func: "CanvasElement_", ret: W.CanvasElement},
{func: "CanvasRenderingContext2D_", ret: W.CanvasRenderingContext2D},
{func: "dynamic__Object", args: [P.Object]},
{func: "num__String", ret: P.num, args: [P.String]},
"fontStyle",
{func: "String__String", ret: P.String, args: [P.String]},
{func: "dynamic___dynamic", opt: [null]},
"destroyBaseTexture",
[P.Map, P.String, P.$int],
[P.Map, P.RenderingContext, null],
{func: "void__PixiEvent", void: true, args: [M.PixiEvent], typedef: M.EventFunc},
"newSrc",
{func: "void__DisplayInterface_Point__bool", void: true, args: [M.DisplayInterface, M.Point0], opt: [P.bool], typedef: M.Render},
{func: "dynamic__num_num__bool", args: [P.num, P.num], opt: [P.bool]},
"updateBase",
{func: "dynamic__DisplayObjectContainer_Point__bool", args: [M.DisplayObjectContainer, M.Point0], opt: [P.bool]},
"clear",
{func: "void__DisplayObjectContainer_Point__bool", void: true, args: [M.DisplayObjectContainer, M.Point0], opt: [P.bool]},
{func: "dynamic___bool", opt: [P.bool]},
"destroyBase",
{func: "dynamic__Rectangle", args: [M.Rectangle0]},
{func: "args2", args: [null, null]},
"listener",
R.Sprite,
R.FrameData,
R.Frame,
[R.Signal, {func: "void__GameObject_Animation", void: true, args: [R.GameObject, R.Animation], typedef: R.AnimationFunc}],
[R.Signal, {func: "dynamic__Animation_Frame", args: [R.Animation, R.Frame], typedef: R.AnimationUpdateFunc}],
{func: "dynamic___num_bool_bool", opt: [P.num, P.bool, P.bool]},
"killOnComplete",
{func: "dynamic__dynamic__bool", args: [null], opt: [P.bool]},
"useLocalFrameIndex",
{func: "dynamic___bool_bool", opt: [P.bool, P.bool]},
"resetFrame",
"dispatchComplete",
{func: "dynamic___int", opt: [P.$int]},
"quantity",
{func: "dynamic__FrameData", args: [R.FrameData]},
"frameData",
R.AnimationInterface,
R.Animation,
[P.Map, P.String, R.Animation],
{func: "FrameData_", ret: R.FrameData},
{func: "bool___FrameData_dynamic", ret: P.bool, opt: [R.FrameData, null]},
{func: "dynamic__FrameData_dynamic", args: [R.FrameData, null]},
{func: "Animation__String__List_num_bool_bool", ret: R.Animation, args: [P.String], opt: [P.List, P.num, P.bool, P.bool]},
"useNumericIndex",
{func: "bool__List__bool", ret: P.bool, args: [P.List], opt: [P.bool]},
{func: "dynamic__dynamic__num_bool_bool", args: [null], opt: [P.num, P.bool, P.bool]},
{func: "dynamic___dynamic_dynamic", opt: [null, null]},
{func: "Animation__String0", ret: R.Animation, args: [P.String]},
{func: "dynamic__bool_num_num_num_num_num_num", args: [P.bool, P.num, P.num, P.num, P.num, P.num, P.num]},
"trimmed",
"actualWidth",
"actualHeight",
"destX",
"destY",
"destWidth",
"destHeight",
{func: "Rectangle___Rectangle", ret: R.Rectangle1, opt: [R.Rectangle1]},
{func: "Frame___Frame", ret: R.Frame, opt: [R.Frame]},
"output",
[P.List, R.Frame],
{func: "Frame__dynamic", ret: R.Frame, args: [null]},
{func: "Frame__int", ret: R.Frame, args: [P.$int]},
{func: "Frame__String", ret: R.Frame, args: [P.String]},
{func: "bool__dynamic", ret: P.bool, args: [null]},
{func: "List__int_int__List", ret: [P.List, R.Frame], args: [P.$int, P.$int], opt: [[P.List, R.Frame]]},
{func: "List___List_bool_List", ret: [P.List, R.Frame], opt: [P.List, P.bool, [P.List, R.Frame]]},
{func: "List___List_bool_List0", ret: [P.List, P.$int], opt: [P.List, P.bool, [P.List, P.$int]]},
R.World,
R.AtLimit,
{func: "Point_0", ret: R.Point},
{func: "dynamic__Point0", args: [R.Point]},
{func: "dynamic__dynamic__int", args: [null], opt: [P.$int]},
[P.List, R.SignalBinding],
"fnName",
"isOnce",
"priority",
{func: "dynamic__SignalBinding", args: [R.SignalBinding]},
"binding",
[P.List, R.Filter],
{func: "dynamic___Pointer", opt: [R.Pointer]},
"pointer",
R.ScaleManager,
[P.List, R.FlexLayer],
{func: "FlexLayer__num_num_List__bool", ret: R.FlexLayer, args: [P.num, P.num, P.List], opt: [P.bool]},
"children",
"addToWorld",
{func: "dynamic__List__bool0", args: [P.List], opt: [P.bool]},
R.FlexGrid,
R.Group,
R.StateManager,
R.RequestAnimationFrame,
R.GameObjectFactory,
R.GameObjectCreator,
R.Cache,
R.Input,
R.Loader,
R.Net,
R.SoundManager,
R.PluginManager,
R.Stage,
R.Time,
R.Physics,
R.TweenManager,
R.RandomDataGenerator,
R.Device,
R.Camera,
R.Debug,
R.Particles,
[R.Signal, {func: "void_", void: true, typedef: R.GameFunc}],
"silent",
"predicate",
"checkExists",
"exists",
{func: "dynamic__int__dynamic_dynamic_bool", args: [P.$int], opt: [null, null, P.bool]},
"child1",
{func: "dynamic__int_num_num", args: [P.$int, P.num, P.num]},
"oldChild",
"newChild",
{func: "dynamic__Function__bool", args: [P.Function], opt: [P.bool]},
{func: "dynamic__Function", args: [P.Function]},
{func: "dynamic___String_int", opt: [P.String, P.$int]},
"order",
"sortHandler",
{func: "int__GameObject_GameObject", ret: P.$int, args: [R.GameObject, R.GameObject]},
"where",
"destroy",
{func: "dynamic__int__int_bool_bool", args: [P.$int], opt: [P.$int, P.bool, P.bool]},
"endIndex",
"destroyChildren",
"soft",
{func: "Rectangle___Matrix0", ret: R.Rectangle1, opt: [M.Matrix]},
[P.List, R.Plugin],
{func: "Plugin__Plugin__List", ret: R.Plugin, args: [R.Plugin], opt: [P.List]},
"plugin",
{func: "dynamic__Plugin", args: [R.Plugin]},
[R.Signal, {func: "void__int_bool_bool", void: true, args: [P.$int, P.bool, P.bool], typedef: R.ScreenFunc}],
W.Element,
P.Timer0,
"minWidth",
"minHeight",
"maxWidth",
"maxHeight",
"resize",
"forceLandscape",
"forcePortrait",
"force",
"clearWorld",
R.Signal,
"params",
P.Type,
[P.List, R.GameObject],
{func: "GameObject___GameObject", ret: R.GameObject, opt: [R.GameObject]},
R.Math,
[P.Map, P.String, R.State],
R.State,
{func: "dynamic__String_State__bool", args: [P.String, R.State], opt: [P.bool]},
"autoStart",
{func: "dynamic__String__bool_bool_List", args: [P.String], opt: [P.bool, P.bool, P.List]},
"clearCache",
{func: "dynamic___bool_bool_List", opt: [P.bool, P.bool, P.List]},
{func: "dynamic__GameObject__num_bool_bool_bool", args: [R.GameObject], opt: [P.num, P.bool, P.bool, P.bool]},
"padding",
"useBounds",
"horizontal",
"vertical",
W.ImageData,
P.Uint32List,
{func: "dynamic__int_int_int__double", args: [P.$int, P.$int, P.$int], opt: [P.$double]},
{func: "dynamic___int_int_int_int", opt: [P.$int, P.$int, P.$int, P.$int]},
{func: "dynamic__Function__int_int_int_int", args: [P.Function], opt: [P.$int, P.$int, P.$int, P.$int]},
{func: "args5", args: [null, null, null, null, null]},
{func: "dynamic__int_int_int_int_int_int_int_int__Rectangle", args: [P.$int, P.$int, P.$int, P.$int, P.$int, P.$int, P.$int, P.$int], opt: [R.Rectangle1]},
"region",
{func: "dynamic___double_double_double_Rectangle", opt: [P.$double, P.$double, P.$double, R.Rectangle1]},
{func: "dynamic__int_int_int_int_int_int__bool", args: [P.$int, P.$int, P.$int, P.$int, P.$int, P.$int], opt: [P.bool]},
"red",
"green",
"blue",
"immediate",
{func: "dynamic__int_int_int_int_int__bool", args: [P.$int, P.$int, P.$int, P.$int, P.$int], opt: [P.bool]},
{func: "Color__int_int_Color", ret: R.Color, args: [P.$int, P.$int, R.Color]},
{func: "int__int_int", ret: P.$int, args: [P.$int, P.$int]},
{func: "Color__int_int__Color_bool_bool", ret: R.Color, args: [P.$int, P.$int], opt: [R.Color, P.bool, P.bool]},
{func: "ImageData__Rectangle", ret: W.ImageData, args: [R.Rectangle1]},
"rect",
{func: "GameObject___int_int", ret: R.GameObject, opt: [P.$int, P.$int]},
{func: "dynamic__dynamic_Rectangle_int_int", args: [null, R.Rectangle1, P.$int, P.$int]},
"area",
{func: "dynamic__dynamic__num_num_num_num", args: [null], opt: [P.num, P.num, P.num, P.num]},
{func: "dynamic__dynamic__int_int", args: [null], opt: [P.$int, P.$int]},
{func: "dynamic__dynamic_dynamic__Rectangle_Rectangle", args: [null, null], opt: [R.Rectangle1, R.Rectangle1]},
"mask",
"sourceRect",
"maskRect",
{func: "BitmapData__BitmapData_int_int_int__int_bool_int_int_int", ret: R.BitmapData, args: [R.BitmapData, P.$int, P.$int, P.$int], opt: [P.$int, P.bool, P.$int, P.$int, P.$int]},
"destination",
{func: "dynamic__int_int_int_int__String", args: [P.$int, P.$int, P.$int, P.$int], opt: [P.String]},
"fillStyle",
{func: "dynamic__int_int_num__String", args: [P.$int, P.$int, P.num], opt: [P.String]},
"pixel",
R.InputHandler,
{func: "dynamic___TextStyle", opt: [M.TextStyle0]},
M.BitmapText,
R.Sound,
[R.Signal, {func: "void__GameObject_Pointer", void: true, args: [R.GameObject, R.Pointer], typedef: R.InputFunc}],
[R.Signal, {func: "void__GameObject_Pointer_bool", void: true, args: [R.GameObject, R.Pointer, P.bool], typedef: R.InputUpFunc}],
R.AnimationManager,
{func: "args4", args: [null, null, null, null]},
{func: "dynamic___Sound_String_Sound_String_Sound_String_Sound_String", opt: [R.Sound, P.String, R.Sound, P.String, R.Sound, P.String, R.Sound, P.String]},
"overSound",
"overMarker",
"downSound",
"downMarker",
"outSound",
"outMarker",
"upSound",
"upMarker",
{func: "dynamic___Sound_String", opt: [R.Sound, P.String]},
"sound",
"marker",
{func: "dynamic__Button_Pointer", args: [R.Button, R.Pointer]},
{func: "dynamic__Button_Pointer_bool", args: [R.Button, R.Pointer, P.bool]},
"isOver",
"newState",
R.Image,
[R.Signal, {func: "void__GameObject_Group", void: true, args: [R.GameObject, R.Group], typedef: R.GroupFunc}],
[R.Signal, {func: "void__GameObject", void: true, args: [R.GameObject], typedef: R.GameObjectFunc}],
R.CoreInterfact,
R.SpriteInterface,
{func: "Image__num_num_dynamic__dynamic", ret: R.Image, args: [P.num, P.num, null], opt: [null]},
{func: "Sprite__num_num__Object_Object", ret: R.Sprite, args: [P.num, P.num], opt: [P.Object, P.Object]},
{func: "Tween__dynamic", ret: R.Tween, args: [null]},
{func: "Group___String_bool_bool_num", ret: R.Group, opt: [P.String, P.bool, P.bool, P.num]},
{func: "Group__Group__String_bool", ret: R.Group, args: [R.Group], opt: [P.String, P.bool]},
{func: "Sound__String__num_bool_bool", ret: R.Sound, args: [P.String], opt: [P.num, P.bool, P.bool]},
{func: "TileSprite__num_num_num_num_dynamic_dynamic", ret: R.TileSprite, args: [P.num, P.num, P.num, P.num, null, null]},
{func: "Rope__num_num_dynamic_dynamic_List", ret: R.Rope0, args: [P.num, P.num, null, null, P.List]},
{func: "Text__num_num_String_TextStyle", ret: R.Text, args: [P.num, P.num, P.String, R.TextStyle]},
{func: "Button___num_num_String_Function_dynamic_dynamic_dynamic_dynamic", ret: R.Button, opt: [P.num, P.num, P.String, P.Function, null, null, null, null]},
{func: "Graphics___num_num0", ret: R.Graphics, opt: [P.num, P.num]},
{func: "Emitter___num_num_num", ret: R.Emitter, opt: [P.num, P.num, P.num]},
{func: "RetroFont__String_num_num_String_num__num_num_num_num", ret: R.RetroFont, args: [P.String, P.num, P.num, P.String, P.num], opt: [P.num, P.num, P.num, P.num]},
{func: "BitmapText__num_num_String__String_num", ret: R.BitmapText0, args: [P.num, P.num, P.String], opt: [P.String, P.num]},
{func: "Tilemap__String__num_num_num_num", ret: R.Tilemap, args: [P.String], opt: [P.num, P.num, P.num, P.num]},
{func: "RenderTexture___int_int_String_bool", ret: R.RenderTexture, opt: [P.$int, P.$int, P.String, P.bool]},
"addToCache",
{func: "BitmapData___int_int_String_bool", ret: R.BitmapData, opt: [P.$int, P.$int, P.String, P.bool]},
{func: "Filter__dynamic", ret: R.Filter, args: [null]},
{func: "GameObject__num_num_dynamic__dynamic_Group", ret: R.GameObject, args: [P.num, P.num, null], opt: [null, R.Group]},
{func: "Sprite__num_num__Object_Object_Group", ret: R.Sprite, args: [P.num, P.num], opt: [P.Object, P.Object, R.Group]},
{func: "Tween__Object", ret: R.Tween, args: [P.Object]},
{func: "Group___Group_String_bool_bool_int", ret: R.Group, opt: [R.Group, P.String, P.bool, P.bool, P.$int]},
{func: "dynamic___int_Group_String_bool", opt: [P.$int, R.Group, P.String, P.bool]},
{func: "Group___Group_String_bool", ret: R.Group, opt: [R.Group, P.String, P.bool]},
{func: "Sound__String__double_bool_bool", ret: R.Sound, args: [P.String], opt: [P.$double, P.bool, P.bool]},
{func: "TileSprite__int_int_int_int_String__dynamic_Group", ret: R.TileSprite, args: [P.$int, P.$int, P.$int, P.$int, P.String], opt: [null, R.Group]},
{func: "Rope__num_num_dynamic_dynamic_List__Group", ret: R.Rope0, args: [P.num, P.num, null, null, P.List], opt: [R.Group]},
{func: "Text__int_int_String_TextStyle__Group", ret: R.Text, args: [P.$int, P.$int, P.String, R.TextStyle], opt: [R.Group]},
{func: "Button___num_num_String_Function_dynamic_dynamic_dynamic_dynamic_Group", ret: R.Button, opt: [P.num, P.num, P.String, P.Function, null, null, null, null, R.Group]},
{func: "Graphics___int_int_Group", ret: R.Graphics, opt: [P.$int, P.$int, R.Group]},
{func: "Emitter___int_int_int", ret: R.Emitter, opt: [P.$int, P.$int, P.$int]},
{func: "RetroFont__String_int_int_String_int__int_int_int_int", ret: R.RetroFont, args: [P.String, P.$int, P.$int, P.String, P.$int], opt: [P.$int, P.$int, P.$int, P.$int]},
{func: "BitmapText__int_int_String__String_int_Group", ret: R.BitmapText0, args: [P.$int, P.$int, P.String], opt: [P.String, P.$int, R.Group]},
{func: "Tilemap___String_int_int_int_int", ret: R.Tilemap, opt: [P.String, P.$int, P.$int, P.$int, P.$int]},
{func: "Filter__Type__List", ret: R.Filter, args: [P.Type], opt: [P.List]},
"filterType",
{func: "Plugin__Plugin", ret: R.Plugin, args: [R.Plugin]},
{func: "dynamic__Polygon", args: [R.Polygon0]},
"poly",
{func: "dynamic__List__bool1", args: [[P.List, R.Point]], opt: [P.bool]},
"cull",
{func: "dynamic__dynamic__List_bool", args: [null], opt: [[P.List, P.$int], P.bool]},
"indices",
{func: "dynamic__Frame", args: [R.Frame]},
{func: "dynamic__Rectangle__bool", args: [R.Rectangle1], opt: [P.bool]},
"copy",
{func: "dynamic___GameObject", opt: [R.GameObject]},
[P.List, [P.Map, P.String, P.num]],
5,
{func: "dynamic__List4", args: [[P.List, [P.Map, P.String, P.num]]]},
{func: "Particle__num_num__num", ret: R.Particle, args: [P.num, P.num], opt: [P.num]},
"health",
{func: "dynamic__DisplayObject_dynamic_dynamic_dynamic", args: [M.DisplayObject, null, null, null]},
W.ImageElement,
{func: "dynamic__num__String", args: [P.num], opt: [P.String]},
"lineAlignment",
{func: "dynamic__String__bool_num_int_String_bool", args: [P.String], opt: [P.bool, P.num, P.$int, P.String, P.bool]},
"multiLine",
"characterSpacing",
"lineSpacing",
"allowLowerCase",
{func: "dynamic__String_num_num_num", args: [P.String, P.num, P.num, P.num]},
"line",
"customSpacingX",
{func: "String__bool", ret: P.String, args: [P.bool]},
"stripCR",
R.RenderTexture,
{func: "Function_", ret: P.Function},
{func: "List_1", ret: [P.List, R.Rectangle1]},
M.Rope,
{func: "dynamic__dynamic__dynamic_bool", args: [null], opt: [null, P.bool]},
"stopAnimation",
{func: "dynamic___Rectangle_bool", opt: [R.Rectangle1, P.bool]},
{func: "Sprite__num_num__num", ret: R.Sprite, args: [P.num, P.num], opt: [P.num]},
{func: "dynamic__String__num_bool_bool", args: [P.String], opt: [P.num, P.bool, P.bool]},
{func: "bool__GameObject", ret: P.bool, args: [R.GameObject]},
R.TextStyle,
{func: "dynamic___num_num_String_num", opt: [P.num, P.num, P.String, P.num]},
"rgba(0,0,0,0)",
"blur",
{func: "dynamic__TextStyle0", args: [R.TextStyle]},
{func: "dynamic__String_num_num", args: [P.String, P.num, P.num]},
M.Text0,
{func: "Animation__String_num__bool_bool", ret: R.Animation, args: [P.String, P.num], opt: [P.bool, P.bool]},
M.TilingSprite,
{func: "Circle__num_num_num", ret: R.Circle0, args: [P.num, P.num, P.num]},
"diameter",
{func: "Circle__Circle", ret: R.Circle0, args: [R.Circle0]},
"dest",
"round",
{func: "Circle___Circle", ret: R.Circle0, opt: [R.Circle0]},
{func: "Point__dynamic__dynamic_dynamic", ret: R.Point, args: [null], opt: [null, null]},
"asDegrees",
{func: "Circle__num_num", ret: R.Circle0, args: [P.num, P.num]},
"dx",
"dy",
{func: "Circle__Point", ret: R.Circle0, args: [R.Point]},
M.Circle,
{func: "Ellipse__num_num_num_num", ret: R.Ellipse0, args: [P.num, P.num, P.num, P.num]},
{func: "Ellipse__Ellipse", ret: R.Ellipse0, args: [R.Ellipse0]},
{func: "Ellipse___Ellipse", ret: R.Ellipse0, opt: [R.Ellipse0]},
{func: "Rectangle_0", ret: R.Rectangle1},
M.Ellipse,
{func: "Line__Sprite_Sprite__bool", ret: R.Line, args: [R.Sprite, R.Sprite], opt: [P.bool]},
"startSprite",
"endSprite",
"useCenter",
{func: "Line__Line", ret: R.Line, args: [R.Line]},
{func: "Point__Line__bool_Point", ret: R.Point, args: [R.Line], opt: [P.bool, R.Point]},
{func: "dynamic__int_int", args: [P.$int, P.$int]},
{func: "List___int_List", ret: [P.List, [P.List, P.num]], opt: [P.$int, [P.List, [P.List, P.num]]]},
"stepRate",
"results",
{func: "Point__dynamic", ret: R.Point, args: [null]},
{func: "Point___num_num", ret: R.Point, opt: [P.num, P.num]},
{func: "Point__num_num", ret: R.Point, args: [P.num, P.num]},
{func: "Point___Point", ret: R.Point, opt: [R.Point]},
{func: "num__Point__bool", ret: P.num, args: [R.Point], opt: [P.bool]},
{func: "bool__Point", ret: P.bool, args: [R.Point]},
{func: "num__Point__dynamic", ret: P.num, args: [R.Point], opt: [null]},
{func: "num__Point", ret: P.num, args: [R.Point]},
{func: "Point__num_num_num__bool_num", ret: R.Point, args: [P.num, P.num, P.num], opt: [P.bool, P.num]},
"distance",
{func: "Point__num", ret: R.Point, args: [P.num]},
"magnitude",
{func: "Point__dynamic__String_String", ret: R.Point, args: [null], opt: [P.String, P.String]},
"xProp",
"yProp",
[P.List, R.Point],
{func: "List_2", ret: [P.List, R.Point]},
{func: "Polygon__Polygon", ret: R.Polygon0, args: [R.Polygon0]},
{func: "Rectangle__num_num", ret: R.Rectangle1, args: [P.num, P.num]},
{func: "Rectangle__Point", ret: R.Rectangle1, args: [R.Point]},
{func: "Rectangle__num_num_num_num", ret: R.Rectangle1, args: [P.num, P.num, P.num, P.num]},
{func: "dynamic__Rectangle0", args: [R.Rectangle1]},
{func: "bool__Rectangle", ret: P.bool, args: [R.Rectangle1]},
{func: "Rectangle__Rectangle__Rectangle", ret: R.Rectangle1, args: [R.Rectangle1], opt: [R.Rectangle1]},
{func: "bool__Rectangle__num", ret: P.bool, args: [R.Rectangle1], opt: [P.num]},
{func: "bool__num_num_num_num__num", ret: P.bool, args: [P.num, P.num, P.num, P.num], opt: [P.num]},
"top",
"bottom",
{func: "Rectangle__Rectangle_Rectangle", ret: R.Rectangle1, args: [R.Rectangle1, R.Rectangle1]},
{func: "Rectangle__List_Rectangle", ret: R.Rectangle1, args: [[P.List, R.Point], R.Rectangle1]},
R.Circle0,
[P.List, R.Pointer],
R.Pointer,
R.Mouse,
R.Keyboard,
R.Touch,
[R.Signal, {func: "void__Pointer_dynamic", void: true, args: [R.Pointer, null], typedef: R.PointerFunc}],
[P.List, R.InputHandler],
{func: "int__MoveFunc", ret: P.$int, args: [{func: "void__num_num_bool", void: true, args: [P.num, P.num, P.bool], typedef: R.MoveFunc}]},
{func: "Pointer_", ret: R.Pointer},
"hard",
{func: "Pointer__dynamic", ret: R.Pointer, args: [null]},
{func: "Pointer___bool", ret: R.Pointer, opt: [P.bool]},
{func: "Pointer__int", ret: R.Pointer, args: [P.$int]},
"identifier",
"pointerId",
{func: "Point__dynamic_Pointer_Point", ret: R.Point, args: [null, R.Pointer, R.Point]},
{func: "bool__GameObject_Pointer_Point", ret: P.bool, args: [R.GameObject, R.Pointer, R.Point]},
"localPoint",
{func: "GameObject___int_bool", ret: R.GameObject, opt: [P.$int, P.bool]},
"useHandCursor",
{func: "dynamic__GameObject_Group", args: [R.GameObject, R.Group]},
{func: "bool__int_int__bool", ret: P.bool, args: [P.$int, P.$int], opt: [P.bool]},
"highestID",
"highestRenderID",
"includePixelPerfect",
{func: "num___int", ret: P.num, opt: [P.$int]},
{func: "bool___int", ret: P.bool, opt: [P.$int]},
{func: "double___int", ret: P.$double, opt: [P.$int]},
{func: "bool__Pointer__bool", ret: P.bool, args: [R.Pointer], opt: [P.bool]},
"fastTest",
{func: "bool__num_num__Pointer", ret: P.bool, args: [P.num, P.num], opt: [R.Pointer]},
{func: "bool__Pointer", ret: P.bool, args: [R.Pointer]},
{func: "dynamic__Pointer", args: [R.Pointer]},
{func: "bool___int_int", ret: P.bool, opt: [P.$int, P.$int]},
500,
{func: "dynamic___bool_bool_bool_int_Rectangle_Sprite", opt: [P.bool, P.bool, P.bool, P.$int, R.Rectangle1, R.Sprite]},
"lockCenter",
"bringToTop",
"pixelPerfect",
"alphaThreshold",
"boundsRect",
"boundsSprite",
"allowHorizontal",
"allowVertical",
{func: "dynamic__num_num__bool_bool_num_num", args: [P.num, P.num], opt: [P.bool, P.bool, P.num, P.num]},
"snapX",
"snapY",
"onDrag",
"onRelease",
"snapOffsetX",
"snapOffsetY",
[R.Signal, {func: "void__Key", void: true, args: [R.Key], typedef: R.KeyFunc}],
{func: "dynamic__KeyboardEvent", args: [W.KeyboardEvent]},
R.Key,
[P.Map, P.$int, R.Key],
{func: "Key_", ret: R.Key},
{func: "dynamic__dynamic__Function_Function_Function", args: [null], opt: [P.Function, P.Function, P.Function]},
"onDown",
"onUp",
"onPress",
{func: "Key__int", ret: R.Key, args: [P.$int]},
{func: "bool__dynamic__int", ret: P.bool, args: [null], opt: [P.$int]},
{func: "dynamic__int__int", args: [P.$int], opt: [P.$int]},
W.MouseEvent,
{func: "dynamic__WheelEvent", args: [W.WheelEvent]},
{func: "Pointer__dynamic__bool", ret: R.Pointer, args: [null], opt: [P.bool]},
"fromClick",
{func: "bool___bool", ret: P.bool, opt: [P.bool]},
{func: "dynamic__InputHandler", args: [R.InputHandler]},
"currentNode",
W.TouchEvent,
P.StreamSubscription,
{func: "dynamic__TouchEvent", args: [W.TouchEvent]},
[R.Signal, {func: "void__Sound", void: true, args: [R.Sound], typedef: R.SoundFunc}],
{func: "dynamic__String_CanvasElement_CanvasRenderingContext2D", args: [P.String, W.CanvasElement, W.CanvasRenderingContext2D]},
"binaryData",
{func: "BitmapData__String_BitmapData__FrameData", ret: R.BitmapData, args: [P.String, R.BitmapData], opt: [R.FrameData]},
"bitmapData",
{func: "dynamic__String_RenderTexture", args: [P.String, R.RenderTexture]},
{func: "dynamic__String_String_dynamic_int_int__int_int_int", args: [P.String, P.String, null, P.$int, P.$int], opt: [P.$int, P.$int, P.$int]},
{func: "dynamic__String_String_dynamic_int", args: [P.String, P.String, null, P.$int]},
"mapData",
"format",
{func: "dynamic__String_String_dynamic_dynamic_int", args: [P.String, P.String, null, null, P.$int]},
"atlasData",
{func: "dynamic__String_String_dynamic_dynamic__int_int", args: [P.String, P.String, null, null], opt: [P.$int, P.$int]},
"xmlData",
"JSONData",
{func: "dynamic__String_String_dynamic", args: [P.String, P.String, null]},
{func: "dynamic__String_String_dynamic__bool_bool", args: [P.String, P.String, null], opt: [P.bool, P.bool]},
"webAudio",
"audioTag",
"property",
{func: "BitmapData__String", ret: R.BitmapData, args: [P.String]},
{func: "Map__String", ret: P.Map, args: [P.String]},
{func: "dynamic__String__String_String", args: [P.String], opt: [P.String, P.String]},
"fixtureKey",
{func: "bool__int_String", ret: P.bool, args: [P.$int, P.String]},
{func: "bool__String", ret: P.bool, args: [P.String]},
{func: "ImageElement__String", ret: W.ImageElement, args: [P.String]},
{func: "FrameData__String__int", ret: R.FrameData, args: [P.String], opt: [P.$int]},
{func: "dynamic__String_FrameData", args: [P.String, R.FrameData]},
{func: "Frame__String_Frame", ret: R.Frame, args: [P.String, R.Frame]},
{func: "RenderTexture__String", ret: R.RenderTexture, args: [P.String]},
{func: "Object__String", ret: P.Object, args: [P.String]},
{func: "List__int0", ret: [P.List, P.String], args: [P.$int]},
{func: "dynamic__String__bool", args: [P.String], opt: [P.bool]},
"removeFromPixi",
[R.Signal, {func: "void__int", void: true, args: [P.$int], typedef: R.LoaderStartFunc}],
[R.Signal, {func: "void__int_String_String", void: true, args: [P.$int, P.String, P.String], typedef: R.FileStartFunc}],
[R.Signal, {func: "void__int_String_bool_int_int", void: true, args: [P.$int, P.String, P.bool, P.$int, P.$int], typedef: R.FileCompleteFunc}],
[R.Signal, {func: "void__dynamic_Map", void: true, args: [null, P.Map], typedef: R.FileError0}],
[R.Signal, {func: "void__dynamic_bool_int_int", void: true, args: [null, P.bool, P.$int, P.$int], typedef: R.PackCompleteFunc}],
[P.List, P.Map],
{func: "bool__String_String", ret: P.bool, args: [P.String, P.String]},
{func: "int__String_String", ret: P.$int, args: [P.String, P.String]},
{func: "Map__dynamic_dynamic", ret: P.Map, args: [null, null]},
{func: "dynamic__String_String_dynamic__Map", args: [P.String, P.String, null], opt: [P.Map]},
{func: "dynamic__String_String_String__Map", args: [P.String, P.String, P.String], opt: [P.Map]},
{func: "Loader__String__String_dynamic", ret: R.Loader, args: [P.String], opt: [P.String, null]},
{func: "Loader__String_String__bool", ret: R.Loader, args: [P.String, P.String], opt: [P.bool]},
"overwrite",
{func: "Loader__String_String__Function", ret: R.Loader, args: [P.String, P.String], opt: [P.Function]},
{func: "Loader__String_String_int__int_int_int_int", ret: R.Loader, args: [P.String, P.String, P.$int], opt: [P.$int, P.$int, P.$int, P.$int]},
{func: "Loader__String_dynamic__bool", ret: R.Loader, args: [P.String, null], opt: [P.bool]},
"autoDecode",
{func: "Loader__String_dynamic_String", ret: R.Loader, args: [P.String, null, P.String]},
"urls",
"atlasURL",
{func: "Loader__String__String_dynamic_int", ret: R.Loader, args: [P.String], opt: [P.String, null, P.$int]},
{func: "Loader__String_String__String_dynamic_int_int", ret: R.Loader, args: [P.String, P.String], opt: [P.String, null, P.$int, P.$int]},
"textureURL",
"xmlURL",
{func: "Loader__String_String__String_dynamic", ret: R.Loader, args: [P.String, P.String], opt: [P.String, null]},
{func: "Loader__String_String__String_dynamic_int", ret: R.Loader, args: [P.String, P.String], opt: [P.String, null, P.$int]},
{func: "dynamic__int__bool", args: [P.$int], opt: [P.bool]},
"parse",
{func: "dynamic__int_bool", args: [P.$int, P.bool]},
"success",
{func: "dynamic__int_String_String_Function_Function", args: [P.$int, P.String, P.String, P.Function, P.Function]},
"onLoad",
"onError",
"previousIndex",
{func: "dynamic__AudioBuffer", args: [P.AudioBuffer]},
[P.DoubleLinkedQueue, P.num],
{func: "List___num_num_num", ret: P.List, opt: [P.num, P.num, P.num]},
{func: "double_", ret: P.$double, typedef: R.doubleFunc},
R.Bounds,
[P.List, R.Body],
[P.List, R.QuadTree],
{func: "dynamic__int_int_int_int__int_int_int", args: [P.$int, P.$int, P.$int, P.$int], opt: [P.$int, P.$int, P.$int]},
{func: "dynamic__Group", args: [R.Group]},
{func: "dynamic__Body", args: [R.Body]},
"body",
{func: "List__dynamic0", ret: P.List, args: [null]},
{func: "int__num_num", ret: P.$int, args: [P.num, P.num]},
"ary",
{func: "num___num_num", ret: P.num, opt: [P.num, P.num]},
946684800000,
1577862000000,
"domain",
{func: "String__String_String_bool_String", ret: P.String, args: [P.String, P.String, P.bool, P.String]},
"redirect",
"parameter",
{func: "dynamic__dynamic__dynamic_int_bool_bool", args: [null], opt: [null, P.$int, P.bool, P.bool]},
"keys",
"collide",
"collideWorldBounds",
"lifespan",
{func: "dynamic___bool_num_num_int_bool", opt: [P.bool, P.num, P.num, P.$int, P.bool]},
250,
"explode",
"forceQuantity",
{func: "dynamic___num_num_num_EasingFunction_bool", opt: [P.num, P.num, P.num, {func: "double__double", ret: P.$double, args: [P.$double], typedef: R.EasingFunction}, P.bool]},
"rate",
"ease",
"yoyo",
{func: "dynamic___num_num_num_num_num_EasingFunction_bool", opt: [P.num, P.num, P.num, P.num, P.num, {func: "double__double", ret: P.$double, args: [P.$double], typedef: R.EasingFunction}, P.bool]},
"minX",
"maxX",
"minY",
"maxY",
[P.Map, P.String, R.Emitter],
{func: "Emitter__Emitter", ret: R.Emitter, args: [R.Emitter]},
"emitter",
O.Arcade0,
E.Ninja,
L.P2,
{func: "dynamic__int__Broadphase_bool_bool_List_bool_Solver", args: [P.$int], named: {broadphase: A.Broadphase, doProfiling: P.bool, fake: P.bool, gravity: P.List, islandSplit: P.bool, solver: A.Solver}},
C.List_0_0,
"system",
"solver",
"gravity",
"doProfiling",
"broadphase",
"islandSplit",
"fake",
{func: "dynamic__dynamic__int_bool", args: [null], opt: [P.$int, P.bool]},
"debug",
[P.Map, P.String, R.Sound],
{func: "dynamic___String_num", opt: [P.String, P.num]},
[P.Map, P.String, R.Marker],
P.AudioContext,
P.AudioNode,
P.GainNode,
{func: "dynamic__String_num_num__num_bool", args: [P.String, P.num, P.num], opt: [P.num, P.bool]},
{func: "Sound___String_int_num_bool_bool", ret: R.Sound, opt: [P.String, P.$int, P.num, P.bool, P.bool]},
"forceRestart",
{func: "dynamic___String_int_double_bool", opt: [P.String, P.$int, P.$double, P.bool]},
{func: "dynamic___num_bool", opt: [P.num, P.bool]},
1000,
{func: "dynamic___num", opt: [P.num]},
{func: "dynamic__Sound", args: [R.Sound]},
"remove",
[P.List, R.Sound],
P.AudioBufferSourceNode,
{func: "dynamic__double", args: [P.$double]},
{func: "dynamic__String__Sound", args: [P.String], opt: [R.Sound]},
{func: "dynamic__String__num_bool_dynamic", args: [P.String], opt: [P.num, P.bool, null]},
{func: "bool__Sound", ret: P.bool, args: [R.Sound]},
{func: "Sound__String__num_bool", ret: R.Sound, args: [P.String], opt: [P.num, P.bool]},
R.TilemapLayerData,
[P.Map, P.String, P.String],
{func: "dynamic__bool_bool_bool_bool", args: [P.bool, P.bool, P.bool, P.bool]},
{func: "bool__bool_bool", ret: P.bool, args: [P.bool, P.bool]},
"collides",
"faces",
{func: "dynamic__Tile", args: [R.Tile0]},
"tile",
[P.Map, P.String, P.List],
[P.List, R.TilemapImageData],
[P.List, R.TilemapLayerData],
[P.List, R.Tileset],
[P.List, [P.List, P.$int]],
[P.Map, R.Tile0, P.String],
{func: "TilemapLayer__String_num_num_num_num__Group", ret: R.TilemapLayer, args: [P.String, P.num, P.num, P.num, P.num], opt: [R.Group]},
{func: "Tileset__dynamic__String_num_num_num_num_int", ret: R.Tileset, args: [null], opt: [P.String, P.num, P.num, P.num, P.num, P.$int]},
"tileset",
"tileMargin",
"tileSpacing",
"gid",
{func: "dynamic__String_num_String__dynamic_bool_bool_Group_Type_bool", args: [P.String, P.num, P.String], opt: [null, P.bool, P.bool, R.Group, P.Type, P.bool]},
"autoCull",
"CustomClass",
"adjustY",
{func: "TilemapLayer__dynamic__num_num_Group", ret: R.TilemapLayer, args: [null], opt: [P.num, P.num, R.Group]},
{func: "int__List_String", ret: P.$int, args: [P.List, P.String]},
{func: "dynamic__dynamic_Function__dynamic", args: [null, P.Function], opt: [null]},
"indexes",
{func: "dynamic__num_num_num_num_Function__dynamic", args: [P.num, P.num, P.num, P.num, P.Function], opt: [null]},
{func: "dynamic__dynamic__bool_dynamic_bool", args: [null], opt: [P.bool, null, P.bool]},
"recalculate",
{func: "dynamic__num_num__bool_dynamic_bool", args: [P.num, P.num], opt: [P.bool, null, P.bool]},
{func: "dynamic__List__bool_dynamic_bool", args: [[P.List, P.$int]], opt: [P.bool, null, P.bool]},
{func: "dynamic__int__bool_dynamic_bool", args: [P.$int], opt: [P.bool, null, P.bool]},
{func: "int___dynamic", ret: P.$int, opt: [null]},
{func: "Tile__int_num_num", ret: R.Tile0, args: [P.$int, P.num, P.num]},
{func: "bool__num_num_dynamic", ret: P.bool, args: [P.num, P.num, null]},
{func: "Tile__num_num_dynamic", ret: R.Tile0, args: [P.num, P.num, null]},
{func: "Tile__num_num_num_num_dynamic", ret: R.Tile0, args: [P.num, P.num, P.num, P.num, null]},
{func: "Tile__dynamic_num_num__dynamic", ret: R.Tile0, args: [null, P.num, P.num], opt: [null]},
{func: "Tile__dynamic_num_num_num_num__dynamic", ret: R.Tile0, args: [null, P.num, P.num, P.num, P.num], opt: [null]},
{func: "Tile__int__int_bool_dynamic", ret: R.Tile0, args: [P.$int], opt: [P.$int, P.bool, null]},
"skip",
"reverse",
{func: "Tile__num_num__dynamic_bool", ret: R.Tile0, args: [P.num, P.num], opt: [null, P.bool]},
"nonNull",
{func: "Tile__num_num__num_num_dynamic", ret: R.Tile0, args: [P.num, P.num], opt: [P.num, P.num, null]},
{func: "List__num_num_num_num__dynamic", ret: [P.List, R.Tile0], args: [P.num, P.num, P.num, P.num], opt: [null]},
{func: "dynamic___num_num_List_dynamic", opt: [P.num, P.num, P.List, null]},
"tileblock",
{func: "dynamic__int_int_num_num_num_num__dynamic", args: [P.$int, P.$int, P.num, P.num, P.num, P.num], opt: [null]},
"tileA",
"tileB",
{func: "dynamic__Function_num_num_num_num__dynamic", args: [P.Function, P.num, P.num, P.num, P.num], opt: [null]},
{func: "dynamic__num_num_num_num__dynamic", args: [P.num, P.num, P.num, P.num], opt: [null]},
{func: "dynamic__int_num_num_num_num__dynamic", args: [P.$int, P.num, P.num, P.num, P.num], opt: [null]},
[P.List, P.Function],
[P.List, [P.List, R.Tile0]],
R.Tilemap,
R.MapCache,
[P.List, R.Tile0],
{func: "Point__dynamic_dynamic_Point", ret: R.Point, args: [null, null, R.Point]},
{func: "List__Line__num_bool_bool", ret: [P.List, R.Tile0], args: [R.Line], opt: [P.num, P.bool, P.bool]},
"interestingFace",
{func: "List__num_num_num_num__bool_bool", ret: [P.List, R.Tile0], args: [P.num, P.num, P.num, P.num], opt: [P.bool, P.bool]},
{func: "Map__Map_List", ret: P.Map, args: [P.Map, P.List]},
"fields",
[P.List, P.List],
{func: "dynamic__CanvasRenderingContext2D_num_num_int", args: [W.CanvasRenderingContext2D, P.num, P.num, P.$int]},
"image",
R.Timer,
[P.List, R.Timer],
{func: "dynamic__Timer", args: [R.Timer]},
{func: "Timer___bool", ret: R.Timer, opt: [P.bool]},
"since",
[P.List, R.TimerEvent],
[R.Signal, {func: "void__Timer", void: true, args: [R.Timer], typedef: R.TimerFunc}],
{func: "TimerEvent__num_bool_int_Function_dynamic", ret: R.TimerEvent, args: [P.num, P.bool, P.$int, P.Function, null]},
{func: "TimerEvent__num_Function__List", ret: R.TimerEvent, args: [P.num, P.Function], opt: [P.List]},
{func: "TimerEvent__num_int_Function_List", ret: R.TimerEvent, args: [P.num, P.$int, P.Function, P.List]},
{func: "TimerEvent__num_Function_List", ret: R.TimerEvent, args: [P.num, P.Function, P.List]},
"clearEvents",
{func: "dynamic__TimerEvent", args: [R.TimerEvent]},
"events",
{func: "bool__num", ret: P.bool, args: [P.num]},
"baseTime",
{func: "EasingFunction_", ret: {func: "double__double", ret: P.$double, args: [P.$double], typedef: R.EasingFunction}},
{func: "double__double", ret: P.$double, args: [P.$double], typedef: R.EasingFunction},
R.Linears,
R.Quads,
R.Cubics,
R.Quarts,
R.Circs,
R.Quints,
R.Sines,
R.Expos,
R.Backs,
R.Bounces,
R.Elastics,
[P.List, R.Tween],
[R.Signal, {func: "void__Object", void: true, args: [P.Object], typedef: R.ObjectFunc}],
R.Tween,
{func: "Tween__Map__int_EasingFunction_bool_num_int_bool", ret: R.Tween, args: [[P.Map, P.String, P.num]], opt: [P.$int, {func: "double__double", ret: P.$double, args: [P.$double], typedef: R.EasingFunction}, P.bool, P.num, P.$int, P.bool]},
"repeat",
{func: "Tween__Map__int_EasingFunction_bool_double_int_bool", ret: R.Tween, args: [P.Map], opt: [P.$int, {func: "double__double", ret: P.$double, args: [P.$double], typedef: R.EasingFunction}, P.bool, P.$double, P.$int, P.bool]},
{func: "List___int_List0", ret: P.List, opt: [P.$int, P.List]},
"times",
"easing",
"interpolation",
{func: "Tween__List", ret: R.Tween, args: [[P.List, R.Tween]]},
"tweens",
{func: "Tween__Tween", ret: R.Tween, args: [R.Tween]},
"tween",
"callbackContext",
{func: "dynamic__Tween", args: [R.Tween]},
"rgb(255,255,255)",
"columnWidth",
"strs",
{func: "dynamic__Sound_num_num__String", args: [R.Sound, P.num, P.num], opt: [P.String]},
{func: "dynamic__Camera_num_num__String", args: [R.Camera, P.num, P.num], opt: [P.String]},
"camera",
{func: "dynamic__Timer_num_num__String", args: [R.Timer, P.num, P.num], opt: [P.String]},
{func: "dynamic__Rope__String_bool", args: [R.Rope0], opt: [P.String, P.bool]},
"rope",
{func: "dynamic__Pointer__bool_String_String_String", args: [R.Pointer], opt: [P.bool, P.String, P.String, P.String]},
"rgba(0,255,0,0.5)",
"rgba(255,0,0,0.5)",
"hideIfUp",
"downColor",
"upColor",
{func: "dynamic__dynamic_num_num__String", args: [null, P.num, P.num], opt: [P.String]},
{func: "dynamic__Key_num_num__String", args: [R.Key, P.num, P.num], opt: [P.String]},
{func: "dynamic__num_num__String", args: [P.num, P.num], opt: [P.String]},
"rgba(255,255,255,0.2)",
{func: "dynamic__Sprite_num_num__String", args: [R.Sprite, P.num, P.num], opt: [P.String]},
{func: "dynamic__Line_num_num__String", args: [R.Line, P.num, P.num], opt: [P.String]},
{func: "dynamic__num_num__String_int", args: [P.num, P.num], opt: [P.String, P.$int]},
{func: "dynamic__dynamic__String_bool_int", args: [null], opt: [P.String, P.bool, P.$int]},
"forceType",
{func: "dynamic__Rectangle__String_bool", args: [R.Rectangle1], opt: [P.String, P.bool]},
"rgba(0, 255, 0, 0.4)",
{func: "dynamic__String_num_num__String_String", args: [P.String, P.num, P.num], opt: [P.String, P.String]},
"16px Courier",
{func: "dynamic__QuadTree__String", args: [R.QuadTree], opt: [P.String]},
"rgba(255,0,0,0.3)",
"quadtree",
{func: "dynamic__Sprite__String_bool", args: [R.Sprite], opt: [P.String, P.bool]},
{func: "dynamic__Sprite_num_num_String", args: [R.Sprite, P.num, P.num, P.String]},
"segment",
{func: "dynamic__AttackType", args: [R.AttackType]},
"_",
{func: "bool__Mover_int_int", ret: P.bool, args: [R.Mover, P.$int, P.$int]},
{func: "dynamic__TileType_Tile", args: [R.TileType, R.Tile]},
{func: "dynamic__TileType", args: [R.TileType]},
{func: "dynamic__Character", args: [R.Character]},
{func: "bool__int_int", ret: P.bool, args: [P.$int, P.$int]},
"invocation",
{func: "bool__Object", ret: P.bool, args: [P.Object]},
{func: "bool__Pattern__int", ret: P.bool, args: [P.Pattern], opt: [P.$int]},
H.TearOffClosure,
{func: "dynamic__dynamic_String", args: [null, P.String]},
{func: "dynamic__Symbol_dynamic", args: [P.Symbol0, null]},
{func: "TypeMirror__int", ret: P.TypeMirror, args: [P.$int]},
{func: "dynamic__void_", args: [{func: "void_", void: true}]},
{func: "void__Object__StackTrace", void: true, args: [P.Object], opt: [P.StackTrace]},
{func: "void___dynamic", void: true, opt: [null]},
"ignored",
{func: "Future__Object", ret: [P.Future, P.bool], args: [P.Object]},
"st",
{func: "void__Function", void: true, args: [P.Function]},
{func: "void___DelayedEvent", void: true, args: [P._DelayedEvent]},
{func: "dynamic__dynamic_StackTrace", args: [null, P.StackTrace]},
{func: "void__dynamic_StackTrace", void: true, args: [null, P.StackTrace]},
"arg",
"each",
{func: "int__dynamic_int", ret: P.$int, args: [null, P.$int]},
{func: "void__int_int", void: true, args: [P.$int, P.$int]},
{func: "DateTime__Duration", ret: P.DateTime, args: [P.Duration]},
"other",
{func: "dynamic__Invocation", args: [P.Invocation]},
{func: "int__dynamic_dynamic", ret: P.$int, args: [null, null]},
{func: "void__String", void: true, args: [P.String]},
"byteString",
{func: "void__String__dynamic", void: true, args: [P.String], opt: [null]},
{func: "Element__Element", ret: W.Element, args: [W.Element]},
"stream",
{func: "void__Node", void: true, args: [W.Node0]},
{func: "num__Body_Shape_vec2_num_Body_Line_vec2_num_bool", ret: P.num, args: [A.Body3, A.Shape0, A.vec2, P.num, A.Body3, A.Line0, A.vec2, P.num, P.bool]},
"convexBody",
"convexShape",
"convexOffset",
"convexAngle",
"lineBody",
"lineShape",
"lineOffset",
"lineAngle",
"justTest",
{func: "num__Body_Line_vec2_num_Body_Rectangle_vec2_num_bool", ret: P.num, args: [A.Body3, A.Line0, A.vec2, P.num, A.Body3, A.Rectangle2, A.vec2, P.num, P.bool]},
"rectangleBody",
"rectangleShape",
"rectangleOffset",
"rectangleAngle",
{func: "num__Body_Convex_vec2_num_Body_Capsule_vec2_num_bool", ret: P.num, args: [A.Body3, A.Convex, A.vec2, P.num, A.Body3, A.Capsule, A.vec2, P.num, P.bool]},
"convexPosition",
"capsuleBody",
"capsuleShape",
"capsulePosition",
"capsuleAngle",
{func: "num__Body_Capsule_vec2_num_Body_Capsule_vec2_num_bool", ret: P.num, args: [A.Body3, A.Capsule, A.vec2, P.num, A.Body3, A.Capsule, A.vec2, P.num, P.bool]},
"bi",
"si",
"xi",
"ai",
"bj",
"sj",
"xj",
"aj",
{func: "num__Body_Line_vec2_num_Body_Line_vec2_num_bool", ret: P.num, args: [A.Body3, A.Line0, A.vec2, P.num, A.Body3, A.Line0, A.vec2, P.num, P.bool]},
"bodyA",
"shapeA",
"positionA",
"angleA",
"bodyB",
"shapeB",
"positionB",
"angleB",
{func: "dynamic__Body_Plane_vec2_num_Body_Line_vec2_num_bool", args: [A.Body3, A.Plane, A.vec2, P.num, A.Body3, A.Line0, A.vec2, P.num, P.bool]},
"planeBody",
"planeShape",
"planeOffset",
"planeAngle",
{func: "num__Body_Particle_vec2_num_Body_Capsule_vec2_num_bool", ret: P.num, args: [A.Body3, A.Particle0, A.vec2, P.num, A.Body3, A.Capsule, A.vec2, P.num, P.bool]},
"particleBody",
"particleShape",
"particlePosition",
"particleAngle",
{func: "num__Body_Shape_vec2_num_Body_dynamic_vec2_num_bool__num_num", ret: P.num, args: [A.Body3, A.Shape0, A.vec2, P.num, A.Body3, null, A.vec2, P.num, P.bool], opt: [P.num, P.num]},
"circleBody",
"circleShape",
"circleOffset",
"circleAngle",
"lineRadius",
"circleRadius",
{func: "num__dynamic_dynamic_dynamic_dynamic_dynamic_dynamic_dynamic_dynamic_dynamic", ret: P.num, args: [null, null, null, null, null, null, null, null, null]},
{func: "num__Body_dynamic_vec2_num_Body_dynamic_vec2_num_bool__num", ret: P.num, args: [A.Body3, null, A.vec2, P.num, A.Body3, null, A.vec2, P.num, P.bool], opt: [P.num]},
{func: "num__dynamic_dynamic_vec2_dynamic_dynamic_dynamic_vec2_dynamic_dynamic", ret: P.num, args: [null, null, A.vec2, null, null, null, A.vec2, null, null]},
"particleOffset",
{func: "num__Body_Shape_vec2_num_Body_Shape_vec2_num_bool__num_num", ret: P.num, args: [A.Body3, A.Shape0, A.vec2, P.num, A.Body3, A.Shape0, A.vec2, P.num, P.bool], opt: [P.num, P.num]},
"offsetA",
"offsetB",
"radiusA",
"radiusB",
"capsuleOffset",
{func: "num__dynamic_dynamic_vec2_dynamic_dynamic_dynamic_vec2_dynamic_dynamic__num", ret: P.num, args: [null, null, A.vec2, null, null, null, A.vec2, null, null], opt: [P.num]},
"precision",
{func: "num__Body_Circle_vec2_dynamic_Body_Heightfield_vec2_num_bool__num", ret: P.num, args: [A.Body3, A.Circle2, A.vec2, null, A.Body3, A.Heightfield, A.vec2, P.num, P.bool], opt: [P.num]},
"circlePos",
"hfBody",
"hfShape",
"hfPos",
"hfAngle",
{func: "num__Body_Convex_vec2_num_Body_Heightfield_vec2_num_bool", ret: P.num, args: [A.Body3, A.Convex, A.vec2, P.num, A.Body3, A.Heightfield, A.vec2, P.num, P.bool]},
"convexPos",
{func: "EventEmitter__String_EventFunc", ret: A.EventEmitter, args: [P.String, {func: "dynamic__Map", args: [P.Map]}]},
{func: "dynamic__List_List", args: [[P.List, A.vec2], [P.List, A.vec2]]},
"axes",
{func: "dynamic__num__num_num", args: [P.num], opt: [P.num, P.num]},
{func: "void__Sprite_Pointer", void: true, args: [R.Sprite, R.Pointer]},
{func: "dynamic__AttackType_Sprite", args: [R.AttackType, R.Sprite]},
{func: "dynamic__AttackType_Text", args: [R.AttackType, R.Text]},
{func: "dynamic__AttackType_int", args: [R.AttackType, P.$int]},
{func: "dynamic__AttackType_AttackType", args: [R.AttackType, R.AttackType]},
[P.List, R.Game],
[P.Map, P.String, M.BaseTexture],
P.Set,
{func: "void__InteractionData", void: true, args: [M.InteractionData]},
{func: "void__PixiEvent", void: true, args: [M.PixiEvent]},
{func: "void__DisplayInterface_Point__bool", void: true, args: [M.DisplayInterface, M.Point0], opt: [P.bool]},
{func: "dynamic__Animation_Frame", args: [R.Animation, R.Frame]},
{func: "void__int_bool_bool", void: true, args: [P.$int, P.bool, P.bool]},
{func: "void__GameObject", void: true, args: [R.GameObject]},
{func: "void__GameObject_Pointer", void: true, args: [R.GameObject, R.Pointer]},
{func: "void__GameObject_Pointer_bool", void: true, args: [R.GameObject, R.Pointer, P.bool]},
{func: "void__GameObject_Group", void: true, args: [R.GameObject, R.Group]},
{func: "void__GameObject_Animation", void: true, args: [R.GameObject, R.Animation]},
{func: "void__Pointer_dynamic", void: true, args: [R.Pointer, null]},
{func: "void__num_num_bool", void: true, args: [P.num, P.num, P.bool]},
{func: "void__Key", void: true, args: [R.Key]},
{func: "void__int_String_String", void: true, args: [P.$int, P.String, P.String]},
{func: "void__int_String_bool_int_int", void: true, args: [P.$int, P.String, P.bool, P.$int, P.$int]},
{func: "void__dynamic_Map", void: true, args: [null, P.Map]},
{func: "void__dynamic_bool_int_int", void: true, args: [null, P.bool, P.$int, P.$int]},
{func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]},
{func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]},
{func: "void__Sound", void: true, args: [R.Sound]},
{func: "void__Timer", void: true, args: [R.Timer]},
{func: "double__double", ret: P.$double, args: [P.$double]},
{func: "void__Object", void: true, args: [P.Object]},
];
$ = null;
Isolate = Isolate.$finishIsolateConstructor(Isolate);
$ = new Isolate();
function convertToFastObject(properties) {
  function MyClass() {
  }
  MyClass.prototype = properties;
  new MyClass();
  return properties;
}
;
A = convertToFastObject(A);
B = convertToFastObject(B);
C = convertToFastObject(C);
D = convertToFastObject(D);
E = convertToFastObject(E);
F = convertToFastObject(F);
G = convertToFastObject(G);
H = convertToFastObject(H);
J = convertToFastObject(J);
K = convertToFastObject(K);
L = convertToFastObject(L);
M = convertToFastObject(M);
N = convertToFastObject(N);
O = convertToFastObject(O);
P = convertToFastObject(P);
Q = convertToFastObject(Q);
R = convertToFastObject(R);
S = convertToFastObject(S);
T = convertToFastObject(T);
U = convertToFastObject(U);
V = convertToFastObject(V);
W = convertToFastObject(W);
X = convertToFastObject(X);
Y = convertToFastObject(Y);
Z = convertToFastObject(Z);
function init() {
  Isolate.$isolateProperties = Object.create(null);
  function generateAccessor(fieldDescriptor, accessors, cls) {
    var fieldInformation = fieldDescriptor.split("-");
    var field = fieldInformation[0];
    var len = field.length;
    var code = field.charCodeAt(len - 1);
    var reflectable;
    if (fieldInformation.length > 1)
      reflectable = true;
    else
      reflectable = false;
    code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
    if (code) {
      var getterCode = code & 3;
      var setterCode = code >> 2;
      var accessorName = field = field.substring(0, len - 1);
      var divider = field.indexOf(":");
      if (divider > 0) {
        accessorName = field.substring(0, divider);
        field = field.substring(divider + 1);
      }
      if (getterCode) {
        var args = getterCode & 2 ? "receiver" : "";
        var receiver = getterCode & 1 ? "this" : "receiver";
        var body = "return " + receiver + "." + field;
        var property = cls + ".prototype.get$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
      if (setterCode) {
        var args = setterCode & 2 ? "receiver, value" : "value";
        var receiver = setterCode & 1 ? "this" : "receiver";
        var body = receiver + "." + field + " = value";
        var property = cls + ".prototype.set$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
    }
    return field;
  }
  Isolate.$isolateProperties.$generateAccessor = generateAccessor;
  function defineClass(name, cls, fields) {
    var accessors = [];
    var str = "function " + cls + "(";
    var body = "";
    for (var i = 0; i < fields.length; i++) {
      if (i != 0)
        str += ", ";
      var field = generateAccessor(fields[i], accessors, cls);
      var parameter = "parameter_" + field;
      str += parameter;
      body += "this." + field + " = " + parameter + ";\n";
    }
    str += ") {\n" + body + "}\n";
    str += cls + ".builtin$cls=\"" + name + "\";\n";
    str += "$desc=$collectedClasses." + cls + ";\n";
    str += "if($desc instanceof Array) $desc = $desc[1];\n";
    str += cls + ".prototype = $desc;\n";
    if (typeof defineClass.name != "string") {
      str += cls + ".name=\"" + cls + "\";\n";
    }
    str += accessors.join("");
    return str;
  }
  var inheritFrom = function() {
    function tmp() {
    }
    function tmp() {
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    return function(constructor, superConstructor) {
      tmp.prototype = superConstructor.prototype;
      var object = new tmp();
      var properties = constructor.prototype;
      for (var member in properties) {
        if (hasOwnProperty.call(properties, member)) {
          object[member] = properties[member];
        }
      }
      object.constructor = constructor;
      constructor.prototype = object;
      return object;
    };
  }();
  Isolate.$finishClasses = function(collectedClasses, isolateProperties, existingIsolateProperties) {
    var pendingClasses = Object.create(null);
    var allClasses = init.allClasses;
    var constructors;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    if (typeof dart_precompiled == "function") {
      constructors = dart_precompiled(collectedClasses);
    } else {
      var combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
      var constructorsList = [];
    }
    for (var cls in collectedClasses) {
      var desc = collectedClasses[cls];
      if (desc instanceof Array)
        desc = desc[1];
      var classData = desc["^"], supr, name = cls, fields = classData;
      if (typeof classData == "object" && classData instanceof Array) {
        classData = fields = classData[0];
      }
      if (typeof classData == "string") {
        var split = classData.split("/");
        if (split.length == 2) {
          name = split[0];
          fields = split[1];
        }
      }
      var s = fields.split(";");
      fields = s[1] == "" ? [] : s[1].split(",");
      supr = s[0];
      split = supr.split(":");
      if (split.length == 2) {
        supr = split[0];
        var functionSignature = split[1];
        if (functionSignature)
          desc.$signature = function(s) {
            return function() {
              return init.metadata[s];
            };
          }(functionSignature);
      }
      if (supr && supr.indexOf("+") > 0) {
        s = supr.split("+");
        supr = s[0];
        var mixin = collectedClasses[s[1]];
        if (mixin instanceof Array)
          mixin = mixin[1];
        for (var d in mixin) {
          if (hasOwnProperty.call(mixin, d) && !hasOwnProperty.call(desc, d))
            desc[d] = mixin[d];
        }
      }
      if (typeof dart_precompiled != "function") {
        combinedConstructorFunction += defineClass(name, cls, fields);
        constructorsList.push(cls);
      }
      if (supr)
        pendingClasses[cls] = supr;
    }
    if (typeof dart_precompiled != "function") {
      combinedConstructorFunction += "return [\n  " + constructorsList.join(",\n  ") + "\n]";
      var constructors = new Function("$collectedClasses", combinedConstructorFunction)(collectedClasses);
      combinedConstructorFunction = null;
    }
    for (var i = 0; i < constructors.length; i++) {
      var constructor = constructors[i];
      var cls = constructor.name;
      var desc = collectedClasses[cls];
      var globalObject = isolateProperties;
      if (desc instanceof Array) {
        globalObject = desc[0] || isolateProperties;
        desc = desc[1];
      }
      constructor["@"] = desc;
      allClasses[cls] = constructor;
      globalObject[cls] = constructor;
    }
    constructors = null;
    var finishedClasses = init.finishedClasses;
    function finishClass(cls) {
      if (finishedClasses[cls])
        return;
      finishedClasses[cls] = true;
      var superclass = pendingClasses[cls];
      if (!superclass || typeof superclass != "string")
        return;
      finishClass(superclass);
      var constructor = allClasses[cls];
      var superConstructor = allClasses[superclass];
      if (!superConstructor)
        superConstructor = existingIsolateProperties[superclass];
      var prototype = inheritFrom(constructor, superConstructor);
      if (Object.prototype.hasOwnProperty.call(prototype, "%")) {
        var nativeSpec = prototype["%"].split(";");
        if (nativeSpec[0]) {
          var tags = nativeSpec[0].split("|");
          for (var i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = true;
          }
        }
        if (nativeSpec[1]) {
          tags = nativeSpec[1].split("|");
          if (nativeSpec[2]) {
            var subclasses = nativeSpec[2].split("|");
            for (var i = 0; i < subclasses.length; i++) {
              var subclass = allClasses[subclasses[i]];
              subclass.$nativeSuperclassTag = tags[0];
            }
          }
          for (i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = false;
          }
        }
      }
    }
    for (var cls in pendingClasses)
      finishClass(cls);
  };
  (function() {
    init.allClasses = Object.create(null);
    init.interceptorsByTag = Object.create(null);
    init.leafTags = Object.create(null);
    init.finishedClasses = Object.create(null);
  })();
  Isolate.$lazy = function(prototype, staticName, fieldName, getterName, lazyValue) {
    if (!init.lazies)
      init.lazies = Object.create(null);
    init.lazies[fieldName] = getterName;
    var sentinelUndefined = {};
    var sentinelInProgress = {};
    prototype[fieldName] = sentinelUndefined;
    prototype[getterName] = function() {
      var result = $[fieldName];
      try {
        if (result === sentinelUndefined) {
          $[fieldName] = sentinelInProgress;
          try {
            result = $[fieldName] = lazyValue();
          } finally {
            if (result === sentinelUndefined)
              $[fieldName] = null;
          }
        } else {
          if (result === sentinelInProgress)
            H.throwCyclicInit(staticName);
        }
        return result;
      } finally {
        $[getterName] = function() {
          return this[fieldName];
        };
      }
    };
  };
  Isolate.$finishIsolateConstructor = function(oldIsolate) {
    var isolateProperties = oldIsolate.$isolateProperties;
    function Isolate() {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      for (var staticName in isolateProperties)
        if (hasOwnProperty.call(isolateProperties, staticName))
          this[staticName] = isolateProperties[staticName];
      var lazies = init.lazies;
      for (var lazyInit in lazies) {
        this[lazies[lazyInit]] = null;
      }
      function ForceEfficientMap() {
      }
      ForceEfficientMap.prototype = this;
      new ForceEfficientMap();
      for (var lazyInit in lazies) {
        var lazyInitName = lazies[lazyInit];
        this[lazyInitName] = isolateProperties[lazyInitName];
      }
    }
    Isolate.prototype = oldIsolate.prototype;
    Isolate.prototype.constructor = Isolate;
    Isolate.$isolateProperties = isolateProperties;
    Isolate.$finishClasses = oldIsolate.$finishClasses;
    Isolate.makeConstantList = oldIsolate.makeConstantList;
    return Isolate;
  };
}
!function() {
  function intern(s) {
    var o = {};
    o[s] = 1;
    return Object.keys(convertToFastObject(o))[0];
  }
  init.getIsolateTag = function(name) {
    return intern("___dart_" + name + init.isolateTag);
  };
  var tableProperty = "___dart_isolate_tags_";
  var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
  var rootProperty = "_ZxYxX";
  for (var i = 0;; i++) {
    var property = intern(rootProperty + "_" + i + "_");
    if (!(property in usedProperties)) {
      usedProperties[property] = 1;
      init.isolateTag = property;
      break;
    }
  }
}();
init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
// BEGIN invoke [main].
;(function(callback) {
  if (typeof document === "undefined") {
    callback(null);
    return;
  }
  if (document.currentScript) {
    callback(document.currentScript);
    return;
  }
  var scripts = document.scripts;
  function onLoad(event) {
    for (var i = 0; i < scripts.length; ++i) {
      scripts[i].removeEventListener("load", onLoad, false);
    }
    callback(event.target);
  }
  for (var i = 0; i < scripts.length; ++i) {
    scripts[i].addEventListener("load", onLoad, false);
  }
})(function(currentScript) {
  init.currentScript = currentScript;
  if (typeof dartMainRunner === "function") {
    dartMainRunner(function(a) {
      H.startRootIsolate(L.main$closure(), a);
    }, []);
  } else {
    (function(a) {
      H.startRootIsolate(L.main$closure(), a);
    })([]);
  }
});
;
// END invoke [main].
})()

//# sourceMappingURL=textfueledcombat.dart.js.map
